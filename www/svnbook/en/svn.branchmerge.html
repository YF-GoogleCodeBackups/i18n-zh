<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Chapter 4. Branching and Merging</title>
<link rel="stylesheet" href="styles.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="index.html" title="Version Control with Subversion">
<link rel="up" href="index.html" title="Version Control with Subversion">
<link rel="prev" href="svn.advanced.html" title="Chapter 3. Advanced Topics">
<link rel="next" href="svn.reposadmin.html" title="Chapter 5. Repository Administration">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Chapter 4. Branching and Merging</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="svn.advanced.html">Prev</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a accesskey="n" href="svn.reposadmin.html">Next</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="chapter" lang="en">
<div class="titlepage"><div><div><h2 class="title">
<a name="svn.branchmerge"></a>Chapter 4. Branching and Merging</h2></div></div></div>
<div class="toc">
<p><b>Table of Contents</b></p>
<dl>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.whatis">4.1. What's a Branch?</a></span></dt>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.using">4.2. Using Branches</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.using.create">4.2.1. Creating a Branch</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.using.work">4.2.2. Working with Your Branch</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.using.concepts">4.2.3. The Key Concepts Behind Branching</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.basicmerging">4.3. Basic Merging</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.changesets">4.3.1. Changesets</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchemerge.basicmerging.stayinsync">4.3.2. Keeping a Branch in Sync</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.basicmerging.mergeinfo">4.3.3. Mergeinfo and Previews</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.basicmerging.undo">4.3.4. Undoing Changes</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.basicmerging.resurrect">4.3.5. Resurrecting Deleted Items</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.advanced">4.4. Advanced Merging</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.cherrypicking">4.4.1. Cherrypicking</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.advancedsyntax">4.4.2. Merge Syntax:  Full Disclosure</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.nomergedata">4.4.3. Merges Without Mergeinfo</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.mergeconflicts">4.4.4. More on Merge Conflicts</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.blockchanges">4.4.5. Blocking Changes</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.logblame">4.4.6. Merge-Sensitive Logs and Annotations</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.ancestry">4.4.7. Noticing or Ignoring Ancestry</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.moves">4.4.8. Merges and Moves</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.pre1.5clients">4.4.9. Blocking Merge-Unaware Clients</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.finalword">4.4.10. The Final Word on Merge Tracking</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.switchwc">4.5. Traversing Branches</a></span></dt>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.tags">4.6. Tags</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.tags.mksimple">4.6.1. Creating a Simple Tag</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.tags.mkcomplex">4.6.2. Creating a Complex Tag</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.maint">4.7. Branch Maintenance</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.maint.layout">4.7.1. Repository Layout</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.maint.lifetime">4.7.2. Data Lifetimes</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.commonpatterns">4.8. Common Branching Patterns</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.commonpatterns.release">4.8.1. Release Branches</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.commonpatterns.feature">4.8.2. Feature Branches</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.advanced.vendorbr">4.9. Vendor Branches</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.advanced.vendorbr.general">4.9.1. General Vendor Branch Management Procedure</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.advanced.vendorbr.svn_load_dirs">4.9.2. svn_load_dirs.pl</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.summary">4.10. Summary</a></span></dt>
</dl>
</div>
<div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote">
<tr>
<td width="10%" valign="top"> </td>
<td width="80%" valign="top"><p>&#8220;<span class="quote">&#21531;&#23376;&#21153;&#26412;
      (It is upon the Trunk that a gentleman works.)</span>&#8221;</p></td>
<td width="10%" valign="top"> </td>
</tr>
<tr>
<td width="10%" valign="top"> </td>
<td colspan="2" align="right" valign="top">--<span class="attribution">Confucius</span>
</td>
</tr>
</table></div>
<p>Branching, tagging, and merging are concepts common to
    almost all version control systems.  If you're not familiar with
    these ideas, we provide a good introduction in this chapter.  If
    you are familiar, hopefully you'll find it interesting to
    see how Subversion implements them.</p>
<p>Branching is a fundamental part of version control.  If
    you're going to allow Subversion to manage your data, this
    is a feature you'll eventually come to depend on.  This chapter
    assumes that you're already familiar with Subversion's basic
    concepts (<a class="xref" href="svn.basic.html" title="Chapter 1. Fundamental Concepts">Chapter 1, <i>Fundamental Concepts</i></a>).</p>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.whatis"></a>4.1. What's a Branch?</h2></div></div></div>
<p>Suppose it's your job to maintain a document for a division
      in your company&#8212;a handbook of some sort.  One day a different
      division asks you for the same handbook, but with a few parts
      &#8220;<span class="quote">tweaked</span>&#8221; for them, since they do things slightly
      differently.</p>
<p>What do you do in this situation?  You do the obvious: make
      a second copy of your document and begin maintaining the two
      copies separately.  As each department asks you to make small
      changes, you incorporate them into one copy or the other.</p>
<p>You often want to make the same change to both copies.  For
      example, if you discover a typo in the first copy, it's very
      likely that the same typo exists in the second copy.  The two
      documents are almost the same, after all; they differ only in
      small, specific ways.</p>
<p>This is the basic concept of a
      <em class="firstterm">branch</em>&#8212;namely, a line of
      development that exists independently of another line, yet still
      shares a common history if you look far enough back in time.  A
      branch always begins life as a copy of something, and moves on
      from there, generating its own history (see <a class="xref" href="svn.branchmerge.html#svn.branchmerge.whatis.dia-1" title="Figure 4.1. Branches of development">Figure 4.1, &#8220;Branches of development&#8221;</a>).</p>
<div class="figure">
<a name="svn.branchmerge.whatis.dia-1"></a><p class="title"><b>Figure 4.1. Branches of development</b></p>
<div class="figure-contents"><div><img src="images/ch04dia1.png" alt="Branches of development"></div></div>
</div>
<br class="figure-break"><p>Subversion has commands to help you maintain parallel
      branches of your files and directories.  It allows you to create
      branches by copying your data, and remembers that the copies are
      related to one another.  It also helps you duplicate changes
      from one branch to another.  Finally, it can make portions of
      your working copy reflect different branches so that you can
      &#8220;<span class="quote">mix and match</span>&#8221; different lines of development in
      your daily work.</p>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.using"></a>4.2. Using Branches</h2></div></div></div>
<p>At this point, you should understand how each commit creates
      an entirely new filesystem tree (called a &#8220;<span class="quote">revision</span>&#8221;)
      in the repository.  If you don't, go back and read about revisions in
      <a class="xref" href="svn.basic.html#svn.basic.in-action.revs" title="1.3.3. Revisions">Section 1.3.3, &#8220;Revisions&#8221;</a>.</p>
<p>For this chapter, we'll go back to the same example from
      <a class="xref" href="svn.basic.html" title="Chapter 1. Fundamental Concepts">Chapter 1, <i>Fundamental Concepts</i></a>.  Remember that you and your
      collaborator, Sally, are sharing a repository that contains two
      projects, <code class="filename">paint</code> and
      <code class="filename">calc</code>.  Notice that in <a class="xref" href="svn.branchmerge.html#svn.branchmerge.using.dia-1" title="Figure 4.2. Starting repository layout">Figure 4.2, &#8220;Starting repository layout&#8221;</a>, however, each project
      directory now contains subdirectories named
      <code class="filename">trunk</code> and <code class="filename">branches</code>.
      The reason for this will soon become clear.</p>
<div class="figure">
<a name="svn.branchmerge.using.dia-1"></a><p class="title"><b>Figure 4.2. Starting repository layout</b></p>
<div class="figure-contents"><div><img src="images/ch04dia2.png" alt="Starting repository layout"></div></div>
</div>
<br class="figure-break"><p>As before, assume that Sally and you both have working
      copies of the &#8220;<span class="quote">calc</span>&#8221; project.  Specifically, you
      each have a working copy of <code class="filename">/calc/trunk</code>.
      All the files for the project are in this subdirectory rather
      than in <code class="filename">/calc</code> itself, because your team has
      decided that <code class="filename">/calc/trunk</code> is where the
      &#8220;<span class="quote">main line</span>&#8221; of development is going to take
      place.</p>
<p>Let's say that you've been given the task of implementing a
      large software feature.  It will take a long time to write, and
      will affect all the files in the project.  The immediate problem
      is that you don't want to interfere with Sally, who is in the
      process of fixing small bugs here and there.  She's depending on
      the fact that the latest version of the project (in
      <code class="filename">/calc/trunk</code>) is always usable.  If you
      start committing your changes bit by bit, you'll surely break
      things for Sally (and other team members as well).</p>
<p>One strategy is to crawl into a hole: you and Sally can stop
      sharing information for a week or two.  That is, start gutting
      and reorganizing all the files in your working copy, but don't
      commit or update until you're completely finished with the task.
      There are a number of problems with this, though.  First, it's
      not very safe.  Most people like to save their work to the
      repository frequently, should something bad accidentally happen
      to their working copy.  Second, it's not very flexible.  If you
      do your work on different computers (perhaps you have a working
      copy of <code class="filename">/calc/trunk</code> on two different
      machines), you'll need to manually copy your changes back and
      forth or just do all the work on a single computer.  By that
      same token, it's difficult to share your changes in progress
      with anyone else.  A common software development &#8220;<span class="quote">best
      practice</span>&#8221; is to allow your peers to review your work as
      you go.  If nobody sees your intermediate commits, you lose
      potential feedback and may end up going down the wrong path for
      weeks before another person on your team notices.  Finally, when
      you're finished with all your changes, you might find it very
      difficult to remerge your final work with the rest of the
      company's main body of code.  Sally (or others) may have made
      many other changes in the repository that are difficult to
      incorporate into your working copy&#8212;especially if you
      run <span class="command"><strong>svn update</strong></span> after weeks of
      isolation.</p>
<p>The better solution is to create your own branch, or line of
      development, in the repository.  This allows you to save your
      half-broken work frequently without interfering with others, yet
      you can still selectively share information with your
      collaborators.  You'll see exactly how this works as we go.
      </p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.using.create"></a>4.2.1. Creating a Branch</h3></div></div></div>
<p>Creating a branch is very simple&#8212;you make a copy of
        the project in the repository using the <span class="command"><strong>svn
        copy</strong></span> command.  Subversion is able to copy not only 
        single files, but whole directories as well.  In this case,
        you want to make a copy of the
        <code class="filename">/calc/trunk</code> directory.  Where should the
        new copy live?  Wherever you wish&#8212;it's a matter of
        project policy.  Let's say that your team has a policy of
        creating branches in the <code class="filename">/calc/branches</code>
        area of the repository, and you want to name your branch
        <code class="literal">my-calc-branch</code>.  You'll want to create a
        new directory,
        <code class="filename">/calc/branches/my-calc-branch</code>, which
        begins its life as a copy of
        <code class="filename">/calc/trunk</code>.</p>
<p>You may already have seen <span class="command"><strong>svn copy</strong></span> used
        to copy one file to another within a working copy.  But it can
        also be used to do a &#8220;<span class="quote">remote</span>&#8221; copy entirely
        within the repository.  Just copy one URL to another:</p>
<pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/my-calc-branch \
      -m "Creating a private branch of /calc/trunk."

Committed revision 341.
</pre>
<p>This command causes a near-instantaneous commit in the
        repository, creating a new directory in revision 341.  The new
        directory is a copy of <code class="filename">/calc/trunk</code>.  This
        is shown in
        <a class="xref" href="svn.branchmerge.html#svn.branchmerge.using.create.dia-1" title="Figure 4.3. Repository with new copy">Figure 4.3, &#8220;Repository with new copy&#8221;</a>.
        <sup>[<a name="id494002" href="#ftn.id494002" class="footnote">20</a>]</sup>

        While it's also possible to create a branch by
        using <span class="command"><strong>svn copy</strong></span> to duplicate a directory
        within the working copy, this technique isn't recommended.  It
        can be quite slow, in fact!  Copying a directory on the
        client side is a linear-time operation, in that it actually
        has to duplicate every file and subdirectory on the local disk.
        Copying a directory on the server, however, is a constant-time
        operation, and it's the way most people create
        branches.</p>
<div class="figure">
<a name="svn.branchmerge.using.create.dia-1"></a><p class="title"><b>Figure 4.3. Repository with new copy</b></p>
<div class="figure-contents"><div><img src="images/ch04dia3.png" alt="Repository with new copy"></div></div>
</div>
<br class="figure-break"><div class="sidebar">
<p class="title"><b>Cheap Copies</b></p>
<p>Subversion's repository has a special design.  When you
          copy a directory, you don't need to worry about the
          repository growing huge&#8212;Subversion doesn't actually
          duplicate any data.  Instead, it creates a new directory
          entry that points to an <span class="emphasis"><em>existing</em></span> tree.
          If you're an experienced Unix user, you'll recognize this as
          the same concept behind a hard link.  As further changes are
          made to files and directories beneath the copied directory,
          Subversion continues to employ this hard link concept where
          it can.  It duplicates data only when it is necessary to
          disambiguate different versions of objects.</p>
<p>This is why you'll often hear Subversion users talk
          about &#8220;<span class="quote">cheap copies.</span>&#8221;  It doesn't matter how
          large the directory is&#8212;it takes a very tiny, constant
          amount of time and space to make a copy of it.  In fact,
          this feature is the basis of how commits work in Subversion:
          each revision is a &#8220;<span class="quote">cheap copy</span>&#8221; of the previous
          revision, with a few items lazily changed within.  (To read
          more about this, visit Subversion's web site and read about
          the &#8220;<span class="quote">bubble up</span>&#8221; method in Subversion's design
          documents.)</p>
<p>Of course, these internal mechanics of copying and
          sharing data are hidden from the user, who simply sees
          copies of trees.  The main point here is that copies are
          cheap, both in time and in space.  If you create a branch
          entirely within the repository (by running <strong class="userinput"><code>svn copy
          <em class="replaceable"><code>URL1</code></em> <em class="replaceable"><code>URL2</code></em></code></strong>), it's a quick, constant-time operation.
          Make branches as often as you want.</p>
</div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.using.work"></a>4.2.2. Working with Your Branch</h3></div></div></div>
<p>Now that you've created a branch of the project, you can
        check out a new working copy to start using it:</p>
<pre class="screen">
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A  my-calc-branch/Makefile
A  my-calc-branch/integer.c
A  my-calc-branch/button.c
Checked out revision 341.
</pre>
<p>There's nothing special about this working copy; it simply
        mirrors a different directory in the repository.  When you
        commit changes, however, Sally won't see them when she
        updates, because her working copy is of
        <code class="filename">/calc/trunk</code>.  (Be sure to read <a class="xref" href="svn.branchmerge.html#svn.branchmerge.switchwc" title="4.5. Traversing Branches">Section 4.5, &#8220;Traversing Branches&#8221;</a> later in this chapter: the
        <span class="command"><strong>svn switch</strong></span> command is an alternative way of
        creating a working copy of a branch.)</p>
<p>Let's pretend that a week goes by, and the following
        commits happen:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>
          You make a change to
          <code class="filename">/calc/branches/my-calc-branch/button.c</code>,
          which creates revision 342.</p></li>
<li><p>
          You make a change to
          <code class="filename">/calc/branches/my-calc-branch/integer.c</code>,
          which creates revision 343.</p></li>
<li><p>
          Sally makes a change to
          <code class="filename">/calc/trunk/integer.c</code>, which creates
          revision 344.</p></li>
</ul></div>
<p>Now two independent lines of development (shown
        in <a class="xref" href="svn.branchmerge.html#svn.branchmerge.using.work.dia-1" title="Figure 4.4. The branching of one file's history">Figure 4.4, &#8220;The branching of one file's history&#8221;</a>) are happening on
        <code class="filename">integer.c</code>.</p>
<div class="figure">
<a name="svn.branchmerge.using.work.dia-1"></a><p class="title"><b>Figure 4.4. The branching of one file's history</b></p>
<div class="figure-contents"><div><img src="images/ch04dia4.png" alt="The branching of one file's history"></div></div>
</div>
<br class="figure-break"><p>Things get interesting when you look at the history of
        changes made to your copy of
        <code class="filename">integer.c</code>:</p>
<pre class="screen">
$ pwd
/home/user/my-calc-branch

$ svn log -v integer.c
------------------------------------------------------------------------
r343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/branches/my-calc-branch/integer.c

* integer.c:  frozzled the wazjub.

------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   A /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</pre>
<p>Notice that Subversion is tracing the history of your
        branch's <code class="filename">integer.c</code> all the way back
        through time, even traversing the point where it was copied.
        It shows the creation of the branch as an event in the
        history, because <code class="filename">integer.c</code> was implicitly
        copied when all of <code class="filename">/calc/trunk/</code> was
        copied.  Now look at what happens when Sally runs the same
        command on her copy of the file:</p>
<pre class="screen">
$ pwd
/home/sally/calc

$ svn log -v integer.c
------------------------------------------------------------------------
r344 | sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  fix a bunch of spelling errors.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   A /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</pre>
<p>Sally sees her own revision 344 change, but not the change
        you made in revision 343.  As far as Subversion is concerned,
        these two commits affected different files in different
        repository locations.  However, Subversion
        <span class="emphasis"><em>does</em></span> show that the two files share a
        common history.  Before the branch copy was made in revision
        341, the files used to be the same file.  That's why you and
        Sally both see the changes made in revisions 303 and
        98.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.using.concepts"></a>4.2.3. The Key Concepts Behind Branching</h3></div></div></div>
<p>You should remember two important lessons
        from this section.  First, Subversion has no internal concept
        of a branch&#8212;it knows only how to make copies.  When you
        copy a directory, the resultant directory is only
        a &#8220;<span class="quote">branch</span>&#8221; because <span class="emphasis"><em>you</em></span>
        attach that meaning to it.  You may think of the directory
        differently, or treat it differently, but to Subversion it's
        just an ordinary directory that happens to carry some extra
        historical information.</p>
<p>Second, because of this copy mechanism, Subversion's
        branches exist as <span class="emphasis"><em>normal filesystem
        directories</em></span> in the repository.  This is different
        from other version control systems, where branches are
        typically defined by adding
        extra-dimensional &#8220;<span class="quote">labels</span>&#8221; to collections of
        files.  The location of your branch directory doesn't matter
        to Subversion.  Most teams follow a convention of putting all
        branches into a <code class="filename">/branches</code> directory, but
        you're free to invent any policy you wish.</p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.basicmerging"></a>4.3. Basic Merging</h2></div></div></div>
<p>Now you and Sally are working on parallel branches of the
      project: you're working on a private branch, and Sally is
      working on the <em class="firstterm">trunk</em>, or main line of
      development.</p>
<p>For projects that have a large number of contributors, it's
      common for most people to have working copies of the trunk.
      Whenever someone needs to make a long-running change that is
      likely to disrupt the trunk, a standard procedure is to create a
      private branch and commit changes there until all the work is
      complete.</p>
<p>So, the good news is that you and Sally aren't interfering
      with each other.  The bad news is that it's very easy to drift
      <span class="emphasis"><em>too</em></span> far apart.  Remember that one of the
      problems with the &#8220;<span class="quote">crawl in a hole</span>&#8221; strategy is
      that by the time you're finished with your branch, it may be
      near-impossible to merge your changes back into the trunk
      without a huge number of conflicts.</p>
<p>Instead, you and Sally might continue to share changes as
      you work.  It's up to you to decide which changes are worth
      sharing; Subversion gives you the ability to selectively
      &#8220;<span class="quote">copy</span>&#8221; changes between branches.  And when you're
      completely finished with your branch, your entire set of branch
      changes can be copied back into the trunk.  In Subversion
      terminology, the general act of replicating changes from one
      branch to another is called <em class="firstterm">merging</em>, and
      it is performed using various invocations of the <span class="command"><strong>svn
      merge</strong></span> command.</p>
<p>In the examples that follow, we're assuming that both your
      Subversion client and server are running Subversion 1.5 (or
      later).  If either client or server is older than version 1.5,
      things are more complicated: the system won't track changes
      automatically, and you'll have to use painful manual methods to
      achieve similar results.  That is, you'll always need to use the
      detailed merge syntax to specify specific ranges of revisions to
      replicate (see
      <a class="xref" href="svn.branchmerge.html#svn.branchmerge.advanced.advancedsyntax" title="4.4.2. Merge Syntax: Full Disclosure">Section 4.4.2, &#8220;Merge Syntax:  Full Disclosure&#8221;</a> later
      in this chapter), and take special care to keep track of what's
      already been merged and what hasn't.  For this reason,
      we <span class="emphasis"><em>strongly</em></span> recommend that you make sure your
      client and server are at least at version 1.5.</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.changesets"></a>4.3.1. Changesets</h3></div></div></div>
<p>Before we proceed further, we should warn you that there's
        going to be a lot of discussion of &#8220;<span class="quote">changes</span>&#8221; in
        the pages ahead.  A lot of people experienced with version
        control systems use the terms &#8220;<span class="quote">change</span>&#8221;
        and &#8220;<span class="quote">changeset</span>&#8221; interchangeably, and we should
        clarify what Subversion understands as
        a <em class="firstterm">changeset</em>.</p>
<p>Everyone seems to have a slightly different definition
        of changeset, or at least a different
        expectation of what it means for a version control system to
        have one.  For our purposes, let's say that a changeset is just
        a collection of changes with a unique name.  The changes might
        include textual edits to file contents, modifications to tree
        structure, or tweaks to metadata.  In more common speak, a
        changeset is just a patch with a name you can refer to.</p>
<p>In Subversion, a global revision number N names a tree in
        the repository: it's the way the repository looked after the
        Nth commit.  It's also the name of an implicit changeset: if
        you compare tree N with tree N&#8722;1, you can derive the exact
        patch that was committed.  For this reason, it's easy to think
        of revision N as not just a tree, but a changeset as well.  If
        you use an issue tracker to manage bugs, you can use the
        revision numbers to refer to particular patches that fix
        bugs&#8212;for example,
        &#8220;<span class="quote">this issue was fixed by r9238.</span>&#8221; Somebody
        can then run <strong class="userinput"><code>svn log -r 9238</code></strong> to read about
        the exact changeset that fixed the bug, and run
        <strong class="userinput"><code>svn diff -c 9238</code></strong> to see the patch itself.
        And (as you'll see shortly)
        Subversion's <span class="command"><strong>svn merge</strong></span> command is able to use
        revision numbers.  You can merge specific changesets from one
        branch to another by naming them in the merge
        arguments: passing <strong class="userinput"><code>-c 9238</code></strong> to <span class="command"><strong>svn merge</strong></span> would merge
        changeset r9238 into your working copy.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchemerge.basicmerging.stayinsync"></a>4.3.2. Keeping a Branch in Sync</h3></div></div></div>
<p>Continuing with our running example, let's suppose that a
        week has passed since you started working on your private
        branch.  Your new feature isn't finished yet, but at the same
        time you know that other people on your team have continued to
        make important changes in the
        project's <code class="filename">/trunk</code>.  It's in your best
        interest to replicate those changes to your own branch, just
        to make sure they mesh well with your changes.  In fact, this
        is a best practice: frequently keeping your branch in sync
        with the main development line helps
        prevent &#8220;<span class="quote">surprise</span>&#8221; conflicts when it comes time
        for you to fold your changes back into the trunk.</p>
<p>Subversion is aware of the history of your branch and
        knows when it divided away from the trunk.  To replicate the
        latest, greatest trunk changes to your branch, first make sure
        your working copy of the branch
        is &#8220;<span class="quote">clean</span>&#8221;&#8212;that it has no local
        modifications reported by <span class="command"><strong>svn status</strong></span>.  Then
        simply run:</p>
<pre class="screen">
$ pwd
/home/user/my-calc-branch

$ svn merge ^/trunk
--- Merging r345 through r356 into '.':
U    button.c
U    integer.c
</pre>
<p>This basic syntax&#8212;<strong class="userinput"><code>svn merge
        <em class="replaceable"><code>URL</code></em></code></strong>&#8212;tells
        Subversion to merge all recent changes from the URL to the
        current working directory (which is typically the root of your
        working copy).  Also notice that we're using the caret
        (<code class="literal">^</code>) syntax<sup>[<a name="id494562" href="#ftn.id494562" class="footnote">21</a>]</sup> to avoid having to
        type out the entire <code class="filename">/trunk</code> URL.</p>
<p>After running the prior example, your branch working copy
        now contains new local modifications, and these edits are
        duplications of all of the changes that have happened on the
        trunk since you first created your branch:</p>
<pre class="screen">
$ svn status
 M     .
M      button.c
M      integer.c
</pre>
<p>At this point, the wise thing to do is look at the changes
        carefully with <span class="command"><strong>svn diff</strong></span>, and then build and
        test your branch.  Notice that the current working directory
        (&#8220;<span class="quote"><code class="filename">.</code></span>&#8221;) has also been
        modified; the <span class="command"><strong>svn diff</strong></span> will show that
        its <code class="literal">svn:mergeinfo</code> property has been either
        created or modified.  This is important merge-related metadata
        that you should <span class="emphasis"><em>not</em></span> touch, since it will
        be needed by future <span class="command"><strong>svn merge</strong></span> commands.
        (We'll learn more about this metadata later in the
        chapter.)</p>
<p>After performing the merge, you might also need to resolve
        some conflicts (just as you do with <span class="command"><strong>svn
        update</strong></span>) or possibly make some small edits to get
        things working properly.  (Remember, just because there are
        no <span class="emphasis"><em>syntactic</em></span> conflicts doesn't mean there
        aren't any <span class="emphasis"><em>semantic</em></span> conflicts!)  If you
        encounter serious problems, you can always abort the local
        changes by running <strong class="userinput"><code>svn revert . -R</code></strong> (which
        will undo all local modifications) and start a
        long &#8220;<span class="quote">what's going on?</span>&#8221; discussion with your
        collaborators.  If things look good, however, you can
        submit these changes into the repository:</p>
<pre class="screen">
$ svn commit -m "Merged latest trunk changes to my-calc-branch."
Sending        .
Sending        button.c
Sending        integer.c
Transmitting file data ..
Committed revision 357.
</pre>
<p>At this point, your private branch is now &#8220;<span class="quote">in
          sync</span>&#8221; with the trunk, so you can rest easier knowing
          that as you continue to work in isolation, you're not
          drifting too far away from what everyone else is
          doing.</p>
<div class="sidebar">
<p class="title"><b>Why Not Use Patches Instead?</b></p>
<p>A question may be on your mind, especially if you're a
          Unix user: why bother to use <span class="command"><strong>svn merge</strong></span> at
          all?  Why not simply use the operating system's
          <span class="command"><strong>patch</strong></span> command to accomplish the same job?
          For example:</p>
<pre class="screen">
$ cd my-calc-branch
$ svn diff -r 341:HEAD ^/trunk &gt; patchfile
$ patch -p0  &lt; patchfile
Patching file integer.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
</pre>
<p>In this particular example, there really isn't much
          difference.  But <span class="command"><strong>svn merge</strong></span> has special
          abilities that surpass the <span class="command"><strong>patch</strong></span> program.
          The file format used by <span class="command"><strong>patch</strong></span> is quite
          limited; it's able to tweak file contents only.  There's no
          way to represent changes to <span class="emphasis"><em>trees</em></span>, such
          as the addition, removal, or renaming of files and
          directories.  Nor can the <span class="command"><strong>patch</strong></span> program
          notice changes to properties.  If Sally's change had,
          say, added a new directory, the output of <span class="command"><strong>svn
          diff</strong></span> wouldn't have mentioned it at
          all.  <span class="command"><strong>svn diff</strong></span> outputs only the limited
          patch format, so there are some ideas it simply can't
          express.</p>
<p>The <span class="command"><strong>svn merge</strong></span> command, however, can
          express changes in tree structure and properties by directly
          applying them to your working copy.  Even more important,
          this command records the changes that have been duplicated
          to your branch so that Subversion is aware of exactly which
          changes exist in each location (see
          <a class="xref" href="svn.branchmerge.html#svn.branchmerge.basicmerging.mergeinfo" title="4.3.3. Mergeinfo and Previews">Section 4.3.3, &#8220;Mergeinfo and Previews&#8221;</a>.)
          This is a critical feature that makes branch management
          usable; without it, users would have to manually keep notes
          on which sets of changes have or haven't been merged
          yet.</p>
</div>
<p>Suppose that another week has passed.  You've committed
        more changes to your branch, and your comrades have continued
        to improve the trunk as well.  Once again, you'd like to
        replicate the latest trunk changes to your branch and bring
        yourself in sync.  Just run the same merge command
        again!</p>
<pre class="screen">
$ svn merge ^/trunk
--- Merging r357 through r380 into '.':
U    integer.c
U    Makefile
A    README
</pre>
<p>Subversion knows which trunk changes you've already
        replicated to your branch, so it carefully replicates only
        those changes you don't yet have.  Once again, you'll have to
        build, test, and <span class="command"><strong>svn commit</strong></span> the local
        modifications to your branch.</p>
<p>What happens when you finally finish your work, though?
        Your new feature is done, and you're ready to merge your
        branch changes back to the trunk (so your team can enjoy the
        bounty of your labor).  The process is simple.  First, bring
        your branch in sync with the trunk again, just as you've been
        doing all along:</p>
<pre class="screen">
$ svn merge ^/trunk
--- Merging r381 through r385 into '.':
U    button.c
U    README

$ # build, test, ...

$ svn commit -m "Final merge of trunk changes to my-calc-branch."
Sending        .
Sending        button.c
Sending        README
Transmitting file data ..
Committed revision 390.
</pre>
<p>Now, you use <span class="command"><strong>svn merge</strong></span> to replicate
        your branch changes back into the trunk.  You'll need an
        up-to-date working copy of <code class="filename">/trunk</code>.  You
        can do this by either doing an <span class="command"><strong>svn
        checkout</strong></span>, dredging up an old trunk working copy from
        somewhere on your disk, or using <span class="command"><strong>svn 
        switch</strong></span> (see
        <a class="xref" href="svn.branchmerge.html#svn.branchmerge.switchwc" title="4.5. Traversing Branches">Section 4.5, &#8220;Traversing Branches&#8221;</a>.) However you get a
        trunk working copy, remember that it's a best practice to do
        your merge into a working copy that
        has <span class="emphasis"><em>no</em></span> local edits and has been recently
        updated (i.e., is not a mixture of local revisions).  If your
        working copy isn't &#8220;<span class="quote">clean</span>&#8221; in these ways, you can
        run into some unnecessary conflict-related headaches
        and <span class="command"><strong>svn merge</strong></span> will likely return an
        error.</p>
<p>Once you have a clean working copy of the trunk, you're
        ready to merge your branch back into it:</p>
<pre class="screen">
$ pwd
/home/user/calc-trunk

$ svn update  # (make sure the working copy is up to date)
At revision 390.

$ svn merge --reintegrate ^/branches/my-calc-branch
--- Merging differences between repository URLs into '.':
U    button.c
U    integer.c
U    Makefile
 U   .

$ # build, test, verify, ...

$ svn commit -m "Merge my-calc-branch back into trunk!"
Sending        .
Sending        button.c
Sending        integer.c
Sending        Makefile
Transmitting file data ..
Committed revision 391.
</pre>
<p>Congratulations, your branch has now been remerged back
        into the main line of development.  Notice our use of
        the <code class="option">--reintegrate</code> option this time around.
        The option is critical for reintegrating changes from a branch
        back into its original line of development&#8212;don't forget
        it!  It's needed because this sort of &#8220;<span class="quote">merge
        back</span>&#8221; is a different sort of work than what you've been
        doing up until now.  Previously, we had been
        asking <span class="command"><strong>svn merge</strong></span> to grab the &#8220;<span class="quote">next
        set</span>&#8221; of changes from one line of development (the
        trunk) and duplicate them to another (your branch).  This is
        fairly straightforward, and each time Subversion knows how to
        pick up where it left off.  In our prior examples, you can see
        that first it merges the ranges 345:356 from trunk to branch;
        later on, it continues by merging the next contiguously
        available range, 356:380.  When doing the final sync, it
        merges the range 380:385.</p>
<p>When merging your branch back to the trunk, however, the
        underlying mathematics is quite different.  Your feature
        branch is now a mishmosh of both duplicated trunk changes and
        private branch changes, so there's no simple contiguous range
        of revisions to copy over.  By specifying
        the <code class="option">--reintegrate</code> option, you're asking
        Subversion to carefully replicate <span class="emphasis"><em>only</em></span>
        those changes unique to your branch.  (And in fact, it does
        this by comparing the latest trunk tree with the latest branch
        tree:  the resulting difference is exactly your branch
        changes!)</p>
<p>Now that your private branch is merged to trunk, you may
        wish to remove it from the repository:</p>
<pre class="screen">
$ svn delete ^/branches/my-calc-branch \
      -m "Remove my-calc-branch."
Committed revision 392.
</pre>
<p>But wait!  Isn't the history of that branch valuable?
        What if somebody wants to audit the evolution of your feature
        someday and look at all of your branch changes?  No need to
        worry.  Remember that even though your branch is no longer
        visible in the <code class="filename">/branches</code> directory, its
        existence is still an immutable part of the repository's
        history.  A simple <span class="command"><strong>svn log</strong></span> command on
        the <code class="filename">/branches</code> URL will show the entire
        history of your branch.  Your branch can even be resurrected
        at some point, should you desire (see
        <a class="xref" href="svn.branchmerge.html#svn.branchmerge.basicmerging.resurrect" title="4.3.5. Resurrecting Deleted Items">Section 4.3.5, &#8220;Resurrecting Deleted Items&#8221;</a>).</p>
<p>In Subversion 1.5, once
        a <code class="option">--reintegrate</code> merge is done from branch to trunk,
        the branch is no longer usable for further work.  It's not
        able to correctly absorb new trunk changes, nor can it be
        properly reintegrated to trunk again.  For this reason, if you
        want to keep working on your feature branch, we recommend
        destroying it and then re-creating it from the trunk:</p>
<pre class="screen">
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
      -m "Remove my-calc-branch."
Committed revision 392.

$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/new-branch
      -m "Create a new branch from trunk."
Committed revision 393.

$ cd my-calc-branch

$ svn switch ^/branches/new-branch
Updated to revision 393.
</pre>
<p>The final command in the prior example&#8212;<span class="command"><strong>svn
        switch</strong></span>&#8212;is a way of updating an existing working
        copy to reflect a different repository directory.  We'll discuss
        this more in <a class="xref" href="svn.branchmerge.html#svn.branchmerge.switchwc" title="4.5. Traversing Branches">Section 4.5, &#8220;Traversing Branches&#8221;</a>.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.basicmerging.mergeinfo"></a>4.3.3. Mergeinfo and Previews</h3></div></div></div>
<p>The basic mechanism Subversion uses to track
        changesets&#8212;that is, which changes have been merged to
        which branches&#8212;is by recording data in properties.
        Specifically, merge data is tracked in
        the <code class="literal">svn:mergeinfo</code> property attached to
        files and directories.  (If you're not familiar with
        Subversion properties, now is the time to skim
        <a class="xref" href="svn.advanced.html#svn.advanced.props" title="3.2. Properties">Section 3.2, &#8220;Properties&#8221;</a>.)</p>
<p>You can examine the property, just like any
        other:</p>
<pre class="screen">
$ cd my-calc-branch
$ svn propget svn:mergeinfo .
/trunk:341-390
</pre>
<p>It is <span class="emphasis"><em>not</em></span> recommended that you change
        the value of this property yourself, unless you really know
        what you're doing.  This property is automatically maintained
        by Subversion whenever you run <span class="command"><strong>svn merge</strong></span>.
        Its value indicates which changes (at a given path) have been
        replicated into the directory in question.  In this case, the
        path is <code class="filename">/trunk</code> and the directory which
        has received the specific changes
        is <code class="filename">/branches/my-calc-branch</code>.</p>
<p>There's also a subcommand, <span class="command"><strong>svn
        mergeinfo</strong></span>, which can be helpful in seeing not only
        which changesets a directory has absorbed, but also which
        changesets it's still eligible to receive.  This gives a sort
        of preview of the next set of changes that <span class="command"><strong>svn
        merge</strong></span> will replicate to your branch.</p>
<pre class="screen">
$ cd my-calc-branch

# Which changes have already been merged from trunk to branch?
$ svn mergeinfo ^/trunk
r341
r342
r343
&#8230;
r388
r389
r390

# Which changes are still eligible to merge from trunk to branch?
$ svn mergeinfo ^/trunk --show-revs eligible
r391
r392
r393
r394
r395
</pre>
<p>The <span class="command"><strong>svn mergeinfo</strong></span> command requires
        a &#8220;<span class="quote">source</span>&#8221; URL (where the changes would be coming
        from), and takes an optional &#8220;<span class="quote">target</span>&#8221; URL (where
        the changes would be merged to).  If no target URL is given,
        it assumes that the current working directory is the
        target.  In the prior example, because we're querying our
        branch working copy, the command assumes we're interested in
        receiving changes to <code class="filename">/branches/mybranch</code>
        from the specified trunk URL.</p>
<p>Another way to get a more precise preview of a merge
        operation is to use the <code class="option">--dry-run</code>
        option:</p>
<pre class="screen">
$ svn merge ^/trunk --dry-run
U    integer.c

$ svn status
#  nothing printed, working copy is still unchanged.
</pre>
<p>The <code class="option">--dry-run</code> option doesn't actually
        apply any local changes to the working copy.  It shows only
        status codes that <span class="emphasis"><em>would</em></span> be printed in a
        real merge.  It's useful for getting a &#8220;<span class="quote">high-level</span>&#8221;
        preview of the potential merge, for those times
        when running <span class="command"><strong>svn diff</strong></span> gives too much
        detail.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>After performing a merge operation, but before committing
          the results of the merge, you can use <strong class="userinput"><code>svn diff
          --depth=empty <em class="replaceable"><code>/path/to/merge/target</code></em></code></strong> to see only
          the changes to the immediate target of your merge.  If your
          merge target was a directory, only property differences will
          be displayed.  This is a handy way to see the changes to the
          <code class="literal">svn:mergeinfo</code> property recorded by the
          merge operation, which will remind you about what you've
          just merged.</p></td></tr>
</table></div>
<p>Of course, the best way to preview a merge operation is to
        just do it!  Remember, running <span class="command"><strong>svn merge</strong></span>
        isn't an inherently risky thing (unless you've made local
        modifications to your working copy&#8212;but we've already
        stressed that you shouldn't be merging into such an
        environment).  If you don't like the results of the merge,
        simply run <strong class="userinput"><code>svn revert . -R</code></strong> to revert the changes from
        your working copy and retry the command with different
        options.  The merge isn't final until you
        actually <span class="command"><strong>svn commit</strong></span> the results.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>While it's perfectly fine to experiment with merges by
          running <span class="command"><strong>svn merge</strong></span> and <span class="command"><strong>svn
          revert</strong></span> over and over, you may run into some
          annoying (but easily bypassed) roadblocks.  For example, if
          the merge operation adds a new file (i.e., schedules it for
          addition), <span class="command"><strong>svn revert</strong></span> won't actually
          remove the file; it simply unschedules the addition.  You're
          left with an unversioned file.  If you then attempt to run
          the merge again, you may get conflicts due to the
          unversioned file &#8220;<span class="quote">being in the way.</span>&#8221; Solution?
          After performing a revert, be sure to clean up the working
          copy and remove unversioned files and directories.  The
          output of <span class="command"><strong>svn status</strong></span> should be as clean
          as possible, ideally showing no output.</p></td></tr>
</table></div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.basicmerging.undo"></a>4.3.4. Undoing Changes</h3></div></div></div>
<p>An extremely common use for <span class="command"><strong>svn merge</strong></span>
        is to roll back a change that has already been committed.
        Suppose you're working away happily on a working copy of
        <code class="filename">/calc/trunk</code>, and you discover that the
        change made way back in revision 303, which changed
        <code class="filename">integer.c</code>, is completely wrong.  It never
        should have been committed.  You can use <span class="command"><strong>svn
        merge</strong></span> to &#8220;<span class="quote">undo</span>&#8221; the change in your
        working copy, and then commit the local modification to the
        repository.  All you need to do is to specify a
        <span class="emphasis"><em>reverse</em></span> difference.  (You can do this by
        specifying <code class="option">--revision 303:302</code>, or by an
        equivalent <code class="option">--change -303</code>.)</p>
<pre class="screen">
$ svn merge -c -303 ^/trunk
--- Reverse-merging r303 into 'integer.c':
U    integer.c

$ svn status
 M     .
M      integer.c

$ svn diff
&#8230;
# verify that the change is removed
&#8230;

$ svn commit -m "Undoing change committed in r303."
Sending        integer.c
Transmitting file data .
Committed revision 350.
</pre>
<p>As we mentioned earlier, one way to think about a
        repository revision is as a specific changeset.  By using the
        <code class="option">-r</code> option, you can ask <span class="command"><strong>svn
        merge</strong></span> to apply a changeset, or a whole range of
        changesets, to your working copy.  In our case of undoing a
        change, we're asking <span class="command"><strong>svn merge</strong></span> to apply
        changeset #303 to our working copy
        <span class="emphasis"><em>backward</em></span>.</p>
<p>Keep in mind that rolling back a change like this is just
        like any other <span class="command"><strong>svn merge</strong></span> operation, so you
        should use <span class="command"><strong>svn status</strong></span> and <span class="command"><strong>svn
        diff</strong></span> to confirm that your work is in the state you
        want it to be in, and then use <span class="command"><strong>svn commit</strong></span>
        to send the final version to the repository.  After
        committing, this particular changeset is no longer reflected
        in the <code class="literal">HEAD</code> revision.</p>
<p>Again, you may be thinking: well, that really didn't undo
        the commit, did it?  The change still exists in revision 303.
        If somebody checks out a version of the
        <code class="filename">calc</code> project between revisions 303 and
        349, she'll still see the bad change, right?</p>
<p>Yes, that's true.  When we talk about
        &#8220;<span class="quote">removing</span>&#8221; a change, we're really talking about
        removing it from the <code class="literal">HEAD</code> revision.  The
        original change still exists in the repository's history.  For
        most situations, this is good enough.  Most people are only
        interested in tracking the <code class="literal">HEAD</code> of a
        project anyway.  There are special cases, however, where you
        really might want to destroy all evidence of the commit.
        (Perhaps somebody accidentally committed a confidential
        document.)  This isn't so easy, it turns out, because
        Subversion was deliberately designed to never lose
        information.  Revisions are immutable trees that build upon
        one another.  Removing a revision from history would cause a
        domino effect, creating chaos in all subsequent revisions and
        possibly invalidating all working copies.
        <sup>[<a name="id495357" href="#ftn.id495357" class="footnote">22</a>]</sup>
      </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.basicmerging.resurrect"></a>4.3.5. Resurrecting Deleted Items</h3></div></div></div>
<p>The great thing about version control systems is that
        information is never lost.  Even when you delete a file or
        directory, it may be gone from the <code class="literal">HEAD</code>
        revision, but the object still exists in earlier revisions.
        One of the most common questions new users ask is, &#8220;<span class="quote">How
        do I get my old file or directory back?</span>&#8221;</p>
<p>The first step is to define
        exactly <span class="emphasis"><em>which</em></span> item you're
        trying to resurrect.  Here's a useful metaphor: you can think
        of every object in the repository as existing in a sort of
        two-dimensional coordinate system.  The first coordinate is a
        particular revision tree, and the second coordinate is a path
        within that tree.  So every version of your file or directory
        can be defined by a specific coordinate pair.  (Remember the
        &#8220;<span class="quote">peg revision</span>&#8221;
        syntax&#8212;foo.c@224&#8212;mentioned back in
        <a class="xref" href="svn.advanced.html#svn.advanced.pegrevs" title="3.9. Peg and Operative Revisions">Section 3.9, &#8220;Peg and Operative Revisions&#8221;</a>.) </p>
<p>First, you might need to use <span class="command"><strong>svn log</strong></span> to
        discover the exact coordinate pair you wish to resurrect.  A
        good strategy is to run <strong class="userinput"><code>svn log --verbose</code></strong>
        in a directory that used to contain your deleted item.  The
        <code class="option">--verbose</code> (<code class="option">-v</code>) option shows
        a list of all changed items in each revision; all you need to
        do is find the revision in which you deleted the file or
        directory.  You can do this visually, or by using another tool
        to examine the log output (via <span class="command"><strong>grep</strong></span>, or
        perhaps via an incremental search in an editor).</p>
<pre class="screen">
$ cd parent-dir
$ svn log -v
&#8230;
------------------------------------------------------------------------
r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines
Changed paths:
   D /calc/trunk/real.c
   M /calc/trunk/integer.c

Added fast fourier transform functions to integer.c.
Removed real.c because code now in double.c.
&#8230;
</pre>
<p>In the example, we're assuming that you're looking for a
        deleted file <code class="filename">real.c</code>.  By looking through
        the logs of a parent directory, you've spotted that this file
        was deleted in revision 808.  Therefore, the last version of
        the file to exist was in the revision right before that.
        Conclusion: you want to resurrect the path
        <code class="filename">/calc/trunk/real.c</code> from revision
        807.</p>
<p>That was the hard part&#8212;the research.  Now that you
        know what you want to restore, you have two different
        choices.</p>
<p>One option is to use <span class="command"><strong>svn merge</strong></span> to apply
        revision 808 &#8220;<span class="quote">in reverse.</span>&#8221; (We already
        discussed how to undo changes in
        <a class="xref" href="svn.branchmerge.html#svn.branchmerge.basicmerging.undo" title="4.3.4. Undoing Changes">Section 4.3.4, &#8220;Undoing Changes&#8221;</a>.)  This
        would have the effect of re-adding <code class="filename">real.c</code>
        as a local modification.  The file would be scheduled for
        addition, and after a commit, the file would again exist
        in <code class="literal">HEAD</code>.</p>
<p>In this particular example, however, this is probably not
        the best strategy.  Reverse-applying revision 808 would not
        only schedule <code class="filename">real.c</code> for addition, but
        the log message indicates that it would also undo certain
        changes to <code class="filename">integer.c</code>, which you don't
        want.  Certainly, you could reverse-merge revision 808 and
        then <span class="command"><strong>svn revert</strong></span> the local modifications to
        <code class="filename">integer.c</code>, but this technique doesn't
        scale well.  What if 90 files were changed in revision
        808?</p>
<p>A second, more targeted strategy is not to use
        <span class="command"><strong>svn merge</strong></span> at all, but rather to use the
        <span class="command"><strong>svn copy</strong></span> command.  Simply copy the exact
        revision and path &#8220;<span class="quote">coordinate pair</span>&#8221; from the
        repository to your working copy:</p>
<pre class="screen">
$ svn copy ^/trunk/real.c@807 ./real.c

$ svn status
A  +   real.c

$ svn commit -m "Resurrected real.c from revision 807, /calc/trunk/real.c."
Adding         real.c
Transmitting file data .
Committed revision 1390.
</pre>
<p>The plus sign in the status output indicates that the item
        isn't merely scheduled for addition, but scheduled for
        addition &#8220;<span class="quote">with history.</span>&#8221;  Subversion remembers
        where it was copied from.  In the future, running <span class="command"><strong>svn
        log</strong></span> on this file will traverse back through the
        file's resurrection and through all the history it had prior
        to revision 807.  In other words, this new
        <code class="filename">real.c</code> isn't really new; it's a direct
        descendant of the original, deleted file.  This is usually
        considered a good and useful thing.  If, however, you wanted
        to resurrect the file <span class="emphasis"><em>without</em></span>
        maintaining a historical link to the old file, this technique
        works just as well:</p>
<pre class="screen">
$ svn cat ^/trunk/real.c@807 &gt; ./real.c

$ svn add real.c
A         real.c

$ svn commit -m "Re-created real.c from revision 807."
Adding         real.c
Transmitting file data .
Committed revision 1390.
</pre>
<p>Although our example shows us resurrecting a file, note
        that these same techniques work just as well for resurrecting
        deleted directories.  Also note that a resurrection doesn't
        have to happen in your working copy&#8212;it can happen
        entirely in the repository:</p>
<pre class="screen">
$ svn copy ^/trunk/real.c@807 ^/trunk/ \
      -m "Resurrect real.c from revision 807."
Committed revision 1390.

$ svn update
A    real.c
Updated to revision 1390.
</pre>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.advanced"></a>4.4. Advanced Merging</h2></div></div></div>
<p>Here ends the automated magic.  Sooner or later, once you
      get the hang of branching and merging, you're going to have to
      ask Subversion to merge <span class="emphasis"><em>specific</em></span> changes
      from one place to another.  To do this, you're going to
      have to start passing more complicated arguments to <span class="command"><strong>svn
      merge</strong></span>.  The next section describes the fully expanded
      syntax of the command and discusses a number of common
      scenarios that require it.</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.cherrypicking"></a>4.4.1. Cherrypicking</h3></div></div></div>
<p>Just as the term &#8220;<span class="quote">changeset</span>&#8221; is often used in
        version control systems, so is the term
        <em class="firstterm">cherrypicking</em>.  This word refers to
        the act of choosing <span class="emphasis"><em>one</em></span> specific
        changeset from a branch and replicating it to another.
        Cherrypicking may also refer to the act of duplicating a
        particular set of (not necessarily contiguous!) changesets
        from one branch to another.  This is in contrast to more
        typical merging scenarios, where the &#8220;<span class="quote">next</span>&#8221;
        contiguous range of revisions is duplicated
        automatically.</p>
<p>Why would people want to replicate just a single change?
        It comes up more often than you'd think.  For example, let's
        go back in time and imagine that you haven't yet merged your
        private feature branch back to the trunk.  At the
        water cooler, you get word that Sally made an interesting
        change to <code class="filename">integer.c</code> on the trunk.
        Looking over the history of commits to the trunk, you see that
        in revision 355 she fixed a critical bug that directly
        impacts the feature you're working on.  You might not be ready
        to merge all the trunk changes to your branch just yet, but
        you certainly need that particular bug fix in order to continue
        your work.</p>
<pre class="screen">
$ svn diff -c 355 ^/trunk

Index: integer.c
===================================================================
--- integer.c	(revision 354)
+++ integer.c	(revision 355)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info-&gt;operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info-&gt;operating_system, "Macintosh"); break;
     case 8:  sprintf(info-&gt;operating_system, "Z-System"); break;
-    case 9:  sprintf(info-&gt;operating_system, "CP/MM");
+    case 9:  sprintf(info-&gt;operating_system, "CP/M"); break;
     case 10:  sprintf(info-&gt;operating_system, "TOPS-20"); break;
     case 11:  sprintf(info-&gt;operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info-&gt;operating_system, "QDOS"); break;
</pre>
<p>Just as you used <span class="command"><strong>svn diff</strong></span> in the prior
        example to examine revision 355, you can pass the same option
        to <span class="command"><strong>svn merge</strong></span>:</p>
<pre class="screen">
$ svn merge -c 355 ^/trunk
U    integer.c

$ svn status
M      integer.c
</pre>
<p>You can now go through the usual testing procedures before
        committing this change to your branch.  After the commit,
        Subversion marks r355 as having been merged to the branch so
        that future &#8220;<span class="quote">magic</span>&#8221; merges that synchronize your
        branch with the trunk know to skip over r355.  (Merging the
        same change to the same branch almost always results in a
        conflict!)</p>
<pre class="screen">
$ cd my-calc-branch

$ svn propget svn:mergeinfo .
/trunk:341-349,355

# Notice that r355 isn't listed as "eligible" to merge, because
# it's already been merged.
$ svn mergeinfo ^/trunk --show-revs eligible
r350
r351
r352
r353
r354
r356
r357
r358
r359
r360

$ svn merge ^/trunk
--- Merging r350 through r354 into '.':
 U   .
U    integer.c
U    Makefile
--- Merging r356 through r360 into '.':
 U   .
U    integer.c
U    button.c
</pre>
<p>This use case of replicating
        (or <em class="firstterm">backporting</em>) bug fixes from one
        branch to another is perhaps the most popular reason for
        cherrypicking changes; it comes up all the time, for example,
        when a team is maintaining a &#8220;<span class="quote">release branch</span>&#8221; of
        software.  (We discuss this pattern in
        <a class="xref" href="svn.branchmerge.html#svn.branchmerge.commonpatterns.release" title="4.8.1. Release Branches">Section 4.8.1, &#8220;Release Branches&#8221;</a>.)</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>Did you notice how, in the last example, the merge
          invocation caused two distinct ranges of merges to be
          applied?  The <span class="command"><strong>svn merge</strong></span> command applied
          two independent patches to your working copy to
          skip over changeset 355, which your branch already
          contained.  There's nothing inherently wrong with this,
          except that it has the potential to make conflict resolution
          trickier.  If the first range of changes creates
          conflicts, you <span class="emphasis"><em>must</em></span> resolve them
          interactively for the merge process to continue and
          apply the second range of changes.  If you postpone a
          conflict from the first wave of changes, the whole merge
          command will bail out with an error message.
          <sup>[<a name="id495776" href="#ftn.id495776" class="footnote">23</a>]</sup> 
        </p></td></tr>
</table></div>
<p>A word of warning: while <span class="command"><strong>svn diff</strong></span> and
        <span class="command"><strong>svn merge</strong></span> are very similar in concept, they
        do have different syntax in many cases.  Be sure to read about
        them in <a class="xref" href="svn.ref.html" title="Chapter 9. Subversion Complete Reference">Chapter 9, <i>Subversion Complete Reference</i></a> for details, or ask
        <span class="command"><strong>svn help</strong></span>.  For example, <span class="command"><strong>svn
        merge</strong></span> requires a working copy path as a target, that is,
        a place where it should apply the generated patch.  If the
        target isn't specified, it assumes you are trying to perform
        one of the following common operations:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>You want to merge directory changes into your current
            working directory.</p></li>
<li><p>You want to merge the changes in a specific file into
            a file by the same name that exists in your current working
            directory.</p></li>
</ul></div>
<p>If you are merging a directory and haven't specified a
        target path, <span class="command"><strong>svn merge</strong></span> assumes the first
        case and tries to apply the changes into your current
        directory.  If you are merging a file, and that file (or a
        file by the same name) exists in your current working
        directory,
        <span class="command"><strong>svn merge</strong></span> assumes the second case and tries
        to apply the changes to a local file with the same name.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.advancedsyntax"></a>4.4.2. Merge Syntax:  Full Disclosure</h3></div></div></div>
<p>You've now seen some examples of the <span class="command"><strong>svn
        merge</strong></span> command, and you're about to see several more.
        If you're feeling confused about exactly how merging works,
        you're not alone.  Many users (especially those new to version
        control) are initially perplexed about the proper syntax of
        the command and about how and when the feature should be
        used.  But fear not, this command is actually much simpler
        than you think!  There's a very easy technique for
        understanding exactly how <span class="command"><strong>svn merge</strong></span>
        behaves.</p>
<p>The main source of confusion is the
        <span class="emphasis"><em>name</em></span> of the command.  The term
        &#8220;<span class="quote">merge</span>&#8221; somehow denotes that branches are
        combined together, or that some sort of mysterious
        blending of data is going on.  That's not the case.  A better
        name for the command might have been <span class="command"><strong>svn
        diff-and-apply</strong></span>, because that's all that happens:
        two repository trees are compared, and the differences are
        applied to a working copy.</p>
<p>If you're using <span class="command"><strong>svn merge</strong></span> to do basic
        copying of changes between branches, it will generally do the
        right thing automatically.  For example, a command such as the
        following:</p>
<pre class="screen">
$ svn merge ^/branches/some-branch
</pre>
<p>will attempt to duplicate any changes made
        on <code class="filename">some-branch</code> into your current working
        directory, which is presumably a working copy that shares some
        historical connection to the branch.  The command is smart
        enough to only duplicate changes that your working copy
        doesn't yet have.  If you repeat this command once a week, it
        will only duplicate the &#8220;<span class="quote">newest</span>&#8221; branch changes
        that happened since you last merged.</p>
<p>If you choose to use the <span class="command"><strong>svn merge</strong></span>
        command in all its full glory by giving it specific revision
        ranges to duplicate, the command takes three main
        arguments:</p>
<div class="orderedlist"><ol type="1">
<li><p>An initial repository tree (often called the
        <em class="firstterm">left side</em> of the
        comparison)</p></li>
<li><p>A final repository tree (often called the
        <em class="firstterm">right side</em> of the
        comparison)</p></li>
<li><p>A working copy to accept the differences as
        local changes (often called the <em class="firstterm">target</em>
        of the merge)</p></li>
</ol></div>
<p>Once these three arguments are specified, the two trees
        are compared, and the differences are applied to the
        target working copy as local modifications.  When the command
        is done, the results are no different than if you had
        hand-edited the files or run various <span class="command"><strong>svn
        add</strong></span> or <span class="command"><strong>svn delete</strong></span> commands
        yourself.  If you like the results, you can commit them.  If
        you don't like the results, you can simply <span class="command"><strong>svn
        revert</strong></span> all of the changes.</p>
<p>The syntax of <span class="command"><strong>svn merge</strong></span> allows you to
        specify the three necessary arguments rather flexibly.  Here
        are some examples:</p>
<pre class="screen">
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
</pre>
<p>The first syntax lays out all three arguments explicitly,
        naming each tree in the form <span class="emphasis"><em>URL@REV</em></span> and
        naming the working copy target.  The second syntax can be used
        as a shorthand for situations when you're comparing two
        different revisions of the same URL.  The last syntax shows
        how the working copy argument is optional; if omitted, it
        defaults to the current directory.</p>
<p>While the first example shows the &#8220;<span class="quote">full</span>&#8221;
        syntax of <span class="command"><strong>svn merge</strong></span>, it needs to be used
        very carefully;  it can result in merges which do not record
        any <code class="literal">svn:mergeinfo</code> metadata at all.  The
        next section talks a bit more about this.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.nomergedata"></a>4.4.3. Merges Without Mergeinfo</h3></div></div></div>
<p>Subversion tries to generate merge metadata whenever it
        can, to make future invocations of <span class="command"><strong>svn
        merge</strong></span> smarter.  There are still situations, however,
        where <code class="literal">svn:mergeinfo</code> data is not created or
        changed.  Remember to be a bit wary of these scenarios:</p>
<div class="variablelist"><dl>
<dt><span class="term">Merging unrelated sources</span></dt>
<dd><p>If you
            ask <span class="command"><strong>svn merge</strong></span> to compare two URLs that
            aren't related to each other, a patch will still be
            generated and applied to your working copy, but no merging
            metadata will be created.  There's no common history
            between the two sources, and future &#8220;<span class="quote">smart</span>&#8221;
            merges depend on that common history.</p></dd>
<dt><span class="term">Merging from foreign repositories</span></dt>
<dd><p>While it's possible to run a
            command such as <strong class="userinput"><code>svn merge -r 100:200
            <em class="replaceable"><code>http://svn.foreignproject.com/repos/trunk</code></em></code></strong>, the
            resultant patch will also lack any historical merge
            metadata.  At time of this writing, Subversion has no way of
            representing different repository URLs within
            the <code class="literal">svn:mergeinfo</code> property.</p></dd>
<dt><span class="term">Using <code class="option">--ignore-ancestry</code></span></dt>
<dd><p>If this option is passed to <span class="command"><strong>svn
            merge</strong></span>, it causes the merging logic to mindlessly
            generate differences the same way that <span class="command"><strong>svn
            diff</strong></span> does, ignoring any historical
            relationships.  We discuss this later in the chapter in
            <a class="xref" href="svn.branchmerge.html#svn.branchmerge.advanced.ancestry" title="4.4.7. Noticing or Ignoring Ancestry">Section 4.4.7, &#8220;Noticing or Ignoring Ancestry&#8221;</a>.</p></dd>
<dt><span class="term">Applying reverse merges to a target's natural history</span></dt>
<dd><p>Earlier in this chapter 
                (<a class="xref" href="svn.branchmerge.html#svn.branchmerge.basicmerging.undo" title="4.3.4. Undoing Changes">Section 4.3.4, &#8220;Undoing Changes&#8221;</a>)
                we discussed how to use <span class="command"><strong>svn merge</strong></span>
                to apply a &#8220;<span class="quote">reverse patch</span>&#8221; as a way of
                rolling back changes.  If this technique is used to
                undo a change to an object's personal history (e.g.,
                commit r5 to the trunk, then immediately roll back r5
                using <strong class="userinput"><code>svn merge . -c -5</code></strong>), this
                sort of merge doesn't affect the recorded mergeinfo.
            <sup>[<a name="id496182" href="#ftn.id496182" class="footnote">24</a>]</sup>
            </p></dd>
</dl></div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.mergeconflicts"></a>4.4.4. More on Merge Conflicts</h3></div></div></div>
<p>Just like the <span class="command"><strong>svn update</strong></span> command,
        <span class="command"><strong>svn merge</strong></span> applies changes to your working
        copy.  And therefore it's also capable of creating
        conflicts.  The conflicts produced by <span class="command"><strong>svn
          merge</strong></span>, however, are sometimes different, and this
        section explains those differences.</p>
<p>To begin with, assume that your working copy has no
        local edits.  When you <span class="command"><strong>svn update</strong></span> to a
        particular revision, the changes sent by the server will
        always apply &#8220;<span class="quote">cleanly</span>&#8221; to your working copy.
        The server produces the delta by comparing two trees: a
        virtual snapshot of your working copy, and the revision tree
        you're interested in.  Because the left hand side of the
        comparison is exactly equal to what you already have, the
        delta is guaranteed to correctly convert your working copy
        into the right hand tree.</p>
<p>But <span class="command"><strong>svn merge</strong></span> has no such guarantees
        and can be much more chaotic: the advanced user can ask the
        server to compare <span class="emphasis"><em>any</em></span> two trees at all,
        even ones that are unrelated to the working copy!  This means
        there's large potential for human error.  Users will sometimes
        compare the wrong two trees, creating a delta that doesn't
        apply cleanly.  <span class="command"><strong>svn merge</strong></span> will do its best
        to apply as much of the delta as possible, but some parts may
        be impossible.  Just as the Unix
        <span class="command"><strong>patch</strong></span> command sometimes complains about
        &#8220;<span class="quote">failed hunks,</span>&#8221; <span class="command"><strong>svn merge</strong></span> will
        similarly complain about &#8220;<span class="quote">skipped
        targets</span>&#8221;:</p>
<pre class="screen">
$ svn merge -r 1288:1351 ^/branches/mybranch
U    foo.c
U    bar.c
Skipped missing target: 'baz.c'
U    glub.c
U    sputter.h

Conflict discovered in 'glorb.h'.
Select: (p) postpone, (df) diff-full, (e) edit,
        (h) help for more options:
</pre>
<p>In the previous example, it might be the case that
        <code class="filename">baz.c</code> exists in both snapshots of the
        branch being compared, and the resultant delta wants to
        change the file's contents, but the file doesn't exist in
        the working copy.  Whatever the case, the
        &#8220;<span class="quote">skipped</span>&#8221; message means that the user is most
        likely comparing the wrong two trees; it's the classic
        sign of user error.  When this happens, it's easy to
        recursively revert all the changes created by the merge
        (<strong class="userinput"><code>svn revert . --recursive</code></strong>), delete any
        unversioned files or directories left behind after the
        revert, and rerun <span class="command"><strong>svn merge</strong></span> with
        different arguments.</p>
<p>Also notice that the preceding example shows a conflict
        happening on <code class="filename">glorb.h</code>.  We already
        stated that the working copy has no local edits: how can a
        conflict possibly happen?  Again, because the user can use
        <span class="command"><strong>svn merge</strong></span> to define and apply any old
        delta to the working copy, that delta may contain textual
        changes that don't cleanly apply to a working file, even if
        the file has no local modifications.</p>
<p>Another small difference between <span class="command"><strong>svn
          update</strong></span> and <span class="command"><strong>svn merge</strong></span> is the
        names of the full-text files created when a conflict
        happens.  In <a class="xref" href="svn.tour.html#svn.tour.cycle.resolve" title="2.4.5. Resolve Conflicts (Merging Others' Changes)">Section 2.4.5, &#8220;Resolve Conflicts (Merging Others' Changes)&#8221;</a>, we saw
        that an update produces files named
        <code class="filename">filename.mine</code>,
        <code class="filename">filename.rOLDREV</code>, and
        <code class="filename">filename.rNEWREV</code>.  When <span class="command"><strong>svn
          merge</strong></span> produces a conflict, though, it creates
        three files named <code class="filename">filename.working</code>,
        <code class="filename">filename.left</code>, and
        <code class="filename">filename.right</code>.  In this case, the
        terms &#8220;<span class="quote">left</span>&#8221; and &#8220;<span class="quote">right</span>&#8221; are
        describing which side of the double-tree comparison the file
        came from.  In any case, these differing names will help you
        distinguish between conflicts that happened as a result of an
        update and ones that happened as a result of a
        merge.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.blockchanges"></a>4.4.5. Blocking Changes</h3></div></div></div>
<p>Sometimes there's a particular changeset that you don't
        want to be automatically merged.  For example, perhaps your
        team's policy is to do new development work on
        <code class="filename">/trunk</code>, but to be more conservative about
        backporting changes to a stable branch you use for releasing
        to the public.  On one extreme, you can manually cherrypick
        single changesets from the trunk to the branch&#8212;just the
        changes that are stable enough to pass muster.  Maybe things
        aren't quite that strict, though; perhaps most of the time
        you'd like to just let <span class="command"><strong>svn merge</strong></span>
        automatically merge most changes from trunk to branch.  In
        this case, you'd like a way to mask a few specific changes
        out, that is, prevent them from ever being automatically
        merged.</p>
<p>In Subversion 1.5, the only way to block a changeset is to
        make the system believe that the change has
        <span class="emphasis"><em>already</em></span> been merged.  To do this, one can
        invoke a merge command with the <code class="option">--record-only</code>
        option:</p>
<pre class="screen">
$ cd my-calc-branch

$ svn propget svn:mergeinfo .
/trunk:1680-3305

# Let's make the metadata list r3328 as already merged.
$ svn merge -c 3328 --record-only ^/trunk

$ svn status
M     .

$ svn propget svn:mergeinfo .
/trunk:1680-3305,3328

$ svn commit -m "Block r3328 from being merged to the branch."
&#8230;
</pre>
<p>This technique works, but it's also a little bit
        dangerous.  The main problem is that we're not clearly
        differentiating between the ideas of &#8220;<span class="quote">I already have this
        change</span>&#8221; and &#8220;<span class="quote">I don't have this change.</span>&#8221;
        We're effectively lying to the system, making it think that
        the change was previously merged.  This puts the
        responsibility on you&#8212;the user&#8212;to remember that
        the change wasn't actually merged, it just wasn't wanted.
        There's no way to ask Subversion for a list of &#8220;<span class="quote">blocked
        changelists.</span>&#8221; If you want to track them (so that you
        can unblock them someday). you'll need to record them in a
        text file somewhere, or perhaps in an invented property.  In
        Subversion 1.5, unfortunately, this is the only way to manage
        blocked revisions; the plans are to make a better interface
        for this in future versions.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.logblame"></a>4.4.6. Merge-Sensitive Logs and Annotations</h3></div></div></div>
<p>One of the main features of any version control system is
        to keep track of who changed what, and when they did it.
        The <span class="command"><strong>svn log</strong></span> and <span class="command"><strong>svn
        blame</strong></span> commands are just the tools for this: when
        invoked on individual files, they show not only the history of
        changesets that affected the file, but also exactly which user
        wrote which line of code, and when she did it.</p>
<p>When changes start getting replicated between branches,
        however, things start to get complicated.  For example, if you
        were to ask <span class="command"><strong>svn log</strong></span> about the history of
        your feature branch, it would show exactly every revision that ever
        affected the branch:</p>
<pre class="screen">
$ cd my-calc-branch
$ svn log -q
------------------------------------------------------------------------
r390 | user | 2002-11-22 11:01:57 -0600 (Fri, 22 Nov 2002) | 1 line
------------------------------------------------------------------------
r388 | user | 2002-11-21 05:20:00 -0600 (Thu, 21 Nov 2002) | 2 lines
------------------------------------------------------------------------
r381 | user | 2002-11-20 15:07:06 -0600 (Wed, 20 Nov 2002) | 2 lines
------------------------------------------------------------------------
r359 | user | 2002-11-19 19:19:20 -0600 (Tue, 19 Nov 2002) | 2 lines
------------------------------------------------------------------------
r357 | user | 2002-11-15 14:29:52 -0600 (Fri, 15 Nov 2002) | 2 lines
------------------------------------------------------------------------
r343 | user | 2002-11-07 13:50:10 -0600 (Thu, 07 Nov 2002) | 2 lines
------------------------------------------------------------------------
r341 | user | 2002-11-03 07:17:16 -0600 (Sun, 03 Nov 2002) | 2 lines
------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
------------------------------------------------------------------------
</pre>
<p>But is this really an accurate picture of all the changes
        that happened on the branch?  What's being left out here is
        the fact that revisions 390, 381, and 357 were actually the
        results of merging changes from the trunk.  If you look at one
        of these logs in detail, the multiple trunk changesets that
        comprised the branch change are nowhere to be seen:</p>
<pre class="screen">
$ svn log -v -r 390
------------------------------------------------------------------------
r390 | user | 2002-11-22 11:01:57 -0600 (Fri, 22 Nov 2002) | 1 line
Changed paths:
   M /branches/my-calc-branch/button.c
   M /branches/my-calc-branch/README

Final merge of trunk changes to my-calc-branch.
</pre>
<p>We happen to know that this merge to the branch was
        nothing but a merge of trunk changes.  How can we see those
        trunk changes as well?  The answer is to use the
        <code class="option">--use-merge-history</code> (<code class="option">-g</code>)
        option.  This option expands those &#8220;<span class="quote">child</span>&#8221;
        changes that were part of the merge.</p>
<pre class="screen">
$ svn log -v -r 390 -g
------------------------------------------------------------------------
r390 | user | 2002-11-22 11:01:57 -0600 (Fri, 22 Nov 2002) | 1 line
Changed paths:
   M /branches/my-calc-branch/button.c
   M /branches/my-calc-branch/README

Final merge of trunk changes to my-calc-branch.
------------------------------------------------------------------------
r383 | sally | 2002-11-21 03:19:00 -0600 (Thu, 21 Nov 2002) | 2 lines
Changed paths:
   M /branches/my-calc-branch/button.c
Merged via: r390

Fix inverse graphic error on button.
------------------------------------------------------------------------
r382 | sally | 2002-11-20 16:57:06 -0600 (Wed, 20 Nov 2002) | 2 lines
Changed paths:
   M /branches/my-calc-branch/README
Merged via: r390

Document my last fix in README.
</pre>
<p>By making the log operation use merge history, we see not
        just the revision we queried (r390), but also the two revisions
        that came along on the ride with it&#8212;a couple of changes
        made by Sally to the trunk.  This is a much more complete
        picture of history!</p>
<p>The <span class="command"><strong>svn blame</strong></span> command also takes the
        <code class="option">--use-merge-history</code> (<code class="option">-g</code>)
        option.  If this option is neglected, somebody looking at
        a line-by-line annotation of <code class="filename">button.c</code> may
        get the mistaken impression that you were responsible for the
        lines that fixed a certain error:</p>
<pre class="screen">
$ svn blame button.c
&#8230;
   390    user    retval = inverse_func(button, path);
   390    user    return retval;
   390    user    }
&#8230;
</pre>
<p>And while it's true that you did actually commit those
        three lines in revision 390, two of them were actually written
        by Sally back in revision 383:</p>
<pre class="screen">
$ svn blame button.c -g
&#8230;
G    383    sally   retval = inverse_func(button, path);
G    383    sally   return retval;
     390    user    }
&#8230;
</pre>
<p>Now we know who to <span class="emphasis"><em>really</em></span> blame for
        those two lines of code!</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.ancestry"></a>4.4.7. Noticing or Ignoring Ancestry</h3></div></div></div>
<p>When conversing with a Subversion developer, you might
        very likely hear reference to the term
        <em class="firstterm">ancestry</em>.  This word is used to
        describe the relationship between two objects in a
        repository: if they're related to each other, one
        object is said to be an ancestor of the other.</p>
<p>For example, suppose you commit revision 100, which
        includes a change to a file <code class="filename">foo.c</code>.
        Then <code class="filename">foo.c@99</code> is an
        &#8220;<span class="quote">ancestor</span>&#8221; of <code class="filename">foo.c@100</code>.
        On the other hand, suppose you commit the deletion of
        <code class="filename">foo.c</code> in revision 101, and then add a
        new file by the same name in revision 102.  In this case,
        <code class="filename">foo.c@99</code> and
        <code class="filename">foo.c@102</code> may appear to be related
        (they have the same path), but in fact are completely
        different objects in the repository.  They share no history
        or &#8220;<span class="quote">ancestry.</span>&#8221;</p>
<p>The reason for bringing this up is to point out an
        important difference between <span class="command"><strong>svn diff</strong></span> and
        <span class="command"><strong>svn merge</strong></span>.  The former command ignores
        ancestry, while the latter command is quite sensitive to it.
        For example, if you asked <span class="command"><strong>svn diff</strong></span> to
        compare revisions 99 and 102 of <code class="filename">foo.c</code>,
        you would see line-based diffs; the <span class="command"><strong>diff</strong></span>
        command is blindly comparing two paths.  But if you asked
        <span class="command"><strong>svn merge</strong></span> to compare the same two objects,
        it would notice that they're unrelated and first attempt to
        delete the old file, then add the new file;  the output would
        indicate a deletion followed by an add:</p>
<pre class="screen">
D    foo.c
A    foo.c
      </pre>
<p>Most merges involve comparing trees that are ancestrally
        related to one another; therefore, <span class="command"><strong>svn
        merge</strong></span> defaults to this behavior.  Occasionally,
        however, you may want the <span class="command"><strong>merge</strong></span> command to
        compare two unrelated trees.  For example, you may have
        imported two source-code trees representing different vendor
        releases of a software project (see
        <a class="xref" href="svn.branchmerge.html#svn.advanced.vendorbr" title="4.9. Vendor Branches">Section 4.9, &#8220;Vendor Branches&#8221;</a>).  If you ask
        <span class="command"><strong>svn merge</strong></span> to compare the two trees, you'd
        see the entire first tree being deleted, followed by an add
        of the entire second tree!  In these situations, you'll want
        <span class="command"><strong>svn merge</strong></span> to do a path-based comparison
        only, ignoring any relations between files and directories.
        Add the <code class="option">--ignore-ancestry</code> option to your
        <span class="command"><strong>merge</strong></span> command, and it will behave just
          like <span class="command"><strong>svn diff</strong></span>.  (And conversely, the
        <code class="option">--notice-ancestry</code> option will cause
        <span class="command"><strong>svn diff</strong></span> to behave like the
        <span class="command"><strong>svn merge</strong></span> command.)</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.moves"></a>4.4.8. Merges and Moves</h3></div></div></div>
<p>A common desire is to refactor source code, especially
        in Java-based software projects.  Files and directories are
        shuffled around and renamed, often causing great disruption
        to everyone working on the project.  Sounds like a perfect
        case to use a branch, doesn't it?  Just create a branch,
        shuffle things around, and then merge the branch back to the
        trunk, right?</p>
<p>Alas, this scenario doesn't work so well right now and
        is considered one of Subversion's current weak spots.  The
        problem is that Subversion's <span class="command"><strong>svn update</strong></span>
        command isn't as robust as it should be, particularly when
        dealing with copy and move operations.</p>
<p>When you use <span class="command"><strong>svn copy</strong></span> to duplicate a
        file, the repository remembers where the new file came from,
        but it fails to transmit that information to the client which
        is running <span class="command"><strong>svn update</strong></span> or <span class="command"><strong>svn
        merge</strong></span>.  Instead of telling the client, &#8220;<span class="quote">Copy
        that file you already have to this new location,</span>&#8221; it
        sends down an entirely new file.  This can lead to
        problems, especially because the same thing happens with
        renamed files.  A lesser-known fact about Subversion is that
        it lacks &#8220;<span class="quote">true renames</span>&#8221;&#8212;the <span class="command"><strong>svn
        move</strong></span> command is nothing more than an aggregation
        of <span class="command"><strong>svn copy</strong></span> and <span class="command"><strong>svn
        delete</strong></span>.</p>
<p>For example, suppose that while working on your private
        branch, you rename <code class="filename">integer.c</code>
        to <code class="filename">whole.c</code>.  Effectively you've created
        a new file in your branch that is a copy of the original
        file, and deleted the original file.  Meanwhile, back
        on <code class="filename">trunk</code>, Sally has committed some
        improvements to <code class="filename">integer.c</code>.  Now you
        decide to merge your branch to the trunk:</p>
<pre class="screen">
$ cd calc/trunk

$ svn merge --reintegrate ^/branches/my-calc-branch
--- Merging differences between repository URLs into '.':
D   integer.c
A   whole.c
U   .
      </pre>
<p>This doesn't look so bad at first glance, but it's also
        probably not what you or Sally expected.  The merge operation
        has deleted the latest version of
        the <code class="filename">integer.c</code> file (the one containing
        Sally's latest changes), and blindly added your
        new <code class="filename">whole.c</code> file&#8212;which is a
        duplicate of the <span class="emphasis"><em>older</em></span> version
        of <code class="filename">integer.c</code>.  The net effect is that
        merging your &#8220;<span class="quote">rename</span>&#8221; to the branch has removed
        Sally's recent changes from the latest revision!</p>
<p>This isn't true data loss.  Sally's changes are still in
        the repository's history, but it may not be immediately
        obvious that this has happened.  The moral of this story is
        that until Subversion improves, be very careful about
        merging copies and renames from one branch to
        another.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.pre1.5clients"></a>4.4.9. Blocking Merge-Unaware Clients</h3></div></div></div>
<p>If you've just upgraded your server to Subversion 1.5 or
        later, there's a significant risk that pre-1.5 Subversion
        clients can mess up your automated merge tracking.  Why is
        this?  When a pre-1.5 Subversion client performs <span class="command"><strong>svn
        merge</strong></span>, it doesn't modify the value of
        the <code class="literal">svn:mergeinfo</code> property at all.  So the
        subsequent commit, despite being the result of a merge,
        doesn't tell the repository about the duplicated
        changes&#8212;that information is lost.  Later on,
        when &#8220;<span class="quote">merge-aware</span>&#8221; clients attempt automatic
        merging, they're likely to run into all sorts of conflicts
        resulting from repeated merges.</p>
<p>If you and your team are relying on the merge-tracking
        features of Subversion, you may want to configure your
        repository to prevent older clients from committing changes.
        The easy way to do this is by inspecting
        the &#8220;<span class="quote">capabilities</span>&#8221; parameter in
        the <code class="literal">start-commit</code> hook script.  If the
        client reports itself as having <code class="literal">mergeinfo</code>
        capabilities, the hook script can allow the commit to start.
        If the client doesn't report that capability, have the hook
        deny the commit.  We'll learn more about hook scripts in the
        next chapter; see
        <a class="xref" href="svn.reposadmin.html#svn.reposadmin.create.hooks" title="5.3.2. Implementing Repository Hooks">Section 5.3.2, &#8220;Implementing Repository Hooks&#8221;</a> and
        <a class="xref" href="svn.ref.reposhooks.start-commit.html" title="start-commit">start-commit</a> for
        details.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.finalword"></a>4.4.10. The Final Word on Merge Tracking</h3></div></div></div>
<p>The bottom line is that Subversion's merge-tracking
        feature has an extremely complex internal implementation, and
        the <code class="literal">svn:mergeinfo</code> property is the only
        window the user has into the machinery.  Because the feature
        is relatively new, a numbers of edge cases and
        possible unexpected behaviors may pop up.</p>
<p>For example, sometimes mergeinfo will be generated when
        running a simple <span class="command"><strong>svn copy</strong></span> or <span class="command"><strong>svn
        move</strong></span> command.  Sometimes mergeinfo will appear on
        files that you didn't expect to be touched by an operation.
        Sometimes mergeinfo won't be generated at all, when you expect
        it to.  Furthermore, the management of mergeinfo metadata has
        a whole set of taxonomies and behaviors around it, such
        as &#8220;<span class="quote">explicit</span>&#8221; versus &#8220;<span class="quote">implicit</span>&#8221;
        mergeinfo, &#8220;<span class="quote">operative</span>&#8221;
        versus &#8220;<span class="quote">inoperative</span>&#8221; revisions, specific
        mechanisms of mergeinfo &#8220;<span class="quote">elision,</span>&#8221; and
        even &#8220;<span class="quote">inheritance</span>&#8221; from parent to child
        directories.</p>
<p>We've chosen not to cover these detailed topics in this
        book for a couple of reasons.  First, the level of detail is
        absolutely overwhelming for a typical user.  Second, as
        Subversion continues to improve, we feel that a typical user
        <span class="emphasis"><em>shouldn't</em></span> have to understand these
        concepts; they'll eventually fade into the background as pesky
        implementation details.  All that said, if you enjoy this sort
        of thing, you can get a fantastic overview in a paper posted
        at CollabNet's website: <a class="ulink" href="http://www.collab.net/community/subversion/articles/merge-info.html" target="_top">http://www.collab.net/community/subversion/articles/merge-info.html</a>.</p>
<p>For now, if you want to steer clear of bugs and odd
        behaviors in automatic merging, the CollabNet article
        recommends that you stick to these simple best practices:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>For short-term feature branches, follow the simple
            procedure described throughout
            <a class="xref" href="svn.branchmerge.html#svn.branchmerge.basicmerging" title="4.3. Basic Merging">Section 4.3, &#8220;Basic Merging&#8221;</a>.</p></li>
<li><p>For long-lived release branches (as described in
            <a class="xref" href="svn.branchmerge.html#svn.branchmerge.commonpatterns" title="4.8. Common Branching Patterns">Section 4.8, &#8220;Common Branching Patterns&#8221;</a>),
            perform merges only on the root of the branch, not on
            subdirectories.</p></li>
<li><p>Never merge into working copies with a mixture of
            working revision numbers, or with
            &#8220;<span class="quote">switched</span>&#8221; subdirectories (as described next
            in <a class="xref" href="svn.branchmerge.html#svn.branchmerge.switchwc" title="4.5. Traversing Branches">Section 4.5, &#8220;Traversing Branches&#8221;</a>).  A merge
            target should be a working copy which represents
            a <span class="emphasis"><em>single</em></span> location in the repository
            at a single point in time.</p></li>
<li><p>Don't ever edit the <code class="literal">svn:mergeinfo</code>
            property directly; use <span class="command"><strong>svn
            merge</strong></span> with the <code class="option">--record-only</code> option to effect a desired change
            to the metadata (as demonstrated in
            <a class="xref" href="svn.branchmerge.html#svn.branchmerge.advanced.blockchanges" title="4.4.5. Blocking Changes">Section 4.4.5, &#8220;Blocking Changes&#8221;</a>).</p></li>
<li><p>Always make sure you have complete read access to
            all of your merge sources, and that your target working
            copy has no sparse directories.</p></li>
</ul></div>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.switchwc"></a>4.5. Traversing Branches</h2></div></div></div>
<p>The <span class="command"><strong>svn switch</strong></span> command transforms an
      existing working copy to reflect a different branch.  While this
      command isn't strictly necessary for working with branches, it
      provides a nice shortcut.  In our earlier example,
      after creating your private branch, you checked out a fresh
      working copy of the new repository directory.  Instead, you can
      simply ask Subversion to change your working copy of
      <code class="filename">/calc/trunk</code> to mirror the new branch
      location:</p>
<pre class="screen">
$ cd calc

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/trunk

$ svn switch ^/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile
Updated to revision 341.

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/branches/my-calc-branch
</pre>
<p>&#8220;<span class="quote">Switching</span>&#8221; a working copy that has no local
      modifications to a different branch results in the working copy
      looking just as it would if you'd done a fresh checkout of the
      directory.  It's usually more efficient to
      use this command, because often branches differ by only a small
      degree.  The server sends only the minimal set of changes
      necessary to make your working copy reflect the branch
      directory.</p>
<p>The <span class="command"><strong>svn switch</strong></span> command also takes a
      <code class="option">--revision</code> (<code class="option">-r</code>) option, so you
      need not always move your working copy to the
      <code class="literal">HEAD</code> of the branch.</p>
<p>Of course, most projects are more complicated than our
      <code class="filename">calc</code> example, and contain multiple
      subdirectories.  Subversion users often follow a specific
      algorithm when using branches:</p>
<div class="orderedlist"><ol type="1">
<li><p>Copy the project's entire &#8220;<span class="quote">trunk</span>&#8221; to a
            new branch directory.</p></li>
<li><p>Switch only <span class="emphasis"><em>part</em></span> of the trunk
            working copy to mirror the branch.</p></li>
</ol></div>
<p>In other words, if a user knows that the branch work needs
      to happen on only a specific subdirectory, she uses
      <span class="command"><strong>svn switch</strong></span> to move only that subdirectory to
      the branch.  (Or sometimes users will switch just a single
      working file to the branch!)  That way, the user can continue to
      receive normal &#8220;<span class="quote">trunk</span>&#8221; updates to most of her
      working copy, but the switched portions will remain immune
      (unless someone commits a change to her branch).  This feature
      adds a whole new dimension to the concept of a &#8220;<span class="quote">mixed
      working copy</span>&#8221;&#8212;not only can working copies contain a
      mixture of working revisions, but they can also contain a
      mixture of repository locations as well.</p>
<p>If your working copy contains a number of switched subtrees
      from different repository locations, it continues to function as
      normal.  When you update, you'll receive patches to each subtree
      as appropriate.  When you commit, your local changes will still
      be applied as a single, atomic change to the repository.</p>
<p>Note that while it's okay for your working copy to reflect a
      mixture of repository locations, these locations must all be
      within the <span class="emphasis"><em>same</em></span> repository.  Subversion
      repositories aren't yet able to communicate with one another;
      that feature is planned for the future.
      <sup>[<a name="id497335" href="#ftn.id497335" class="footnote">25</a>]</sup>
    </p>
<div class="sidebar">
<p class="title"><b>Switches and Updates</b></p>
<p>Have you noticed that the output of <span class="command"><strong>svn
        switch</strong></span> and <span class="command"><strong>svn update</strong></span> looks the
        same?  The switch command is actually a superset of the update
        command.</p>
<p>When you run <span class="command"><strong>svn update</strong></span>, you're asking
        the repository to compare two trees.  The repository does so,
        and then sends a description of the differences back to the
        client.  The only difference between <span class="command"><strong>svn
        switch</strong></span> and <span class="command"><strong>svn update</strong></span> is that the
        latter command always compares two identical repository
        paths.</p>
<p>That is, if your working copy is a mirror of
        <code class="filename">/calc/trunk</code>, <span class="command"><strong>svn
        update</strong></span> will automatically compare your working copy
        of <code class="filename">/calc/trunk</code> to
        <code class="filename">/calc/trunk</code> in the
        <code class="literal">HEAD</code> revision.  If you're switching your
        working copy to a branch, <span class="command"><strong>svn switch</strong></span>
        will compare your working copy of
        <code class="filename">/calc/trunk</code> to some
        <span class="emphasis"><em>other</em></span> branch directory in the
        <code class="literal">HEAD</code> revision.</p>
<p>In other words, an update moves your working copy through
        time.  A switch moves your working copy through time
        <span class="emphasis"><em>and</em></span> space.</p>
</div>
<p>Because <span class="command"><strong>svn switch</strong></span> is essentially a
      variant of <span class="command"><strong>svn update</strong></span>, it shares the same
      behaviors; any local modifications in your working copy are
      preserved when new data arrives from the repository.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top">
<p>Have you ever found yourself making some complex edits
          (in your <code class="filename">/trunk</code> working copy) and
          suddenly realized, &#8220;<span class="quote">Hey, these changes ought to be in
          their own branch?</span>&#8221;  A great technique to do this can
          be summarized in two steps:</p>
<pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/newbranch \
      -m "Create branch 'newbranch'."
Committed revision 353.
$ svn switch ^/branches/newbranch
At revision 353.
</pre>
<p>The <span class="command"><strong>svn switch</strong></span> command, like
          <span class="command"><strong>svn update</strong></span>, preserves your local edits.
          At this point, your working copy is now a reflection of the
          newly created branch, and your next <span class="command"><strong>svn
          commit</strong></span> invocation will send your changes
          there.</p>
</td></tr>
</table></div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.tags"></a>4.6. Tags</h2></div></div></div>
<p>Another common version control concept is a
      <em class="firstterm">tag</em>.  A tag is just a
      &#8220;<span class="quote">snapshot</span>&#8221; of a project in time.  In Subversion,
      this idea already seems to be everywhere.  Each repository
      revision is exactly that&#8212;a snapshot of the filesystem
      after each commit.</p>
<p>However, people often want to give more human-friendly names
      to tags, such as <code class="literal">release-1.0</code>.  And they want
      to make snapshots of smaller subdirectories of the filesystem.
      After all, it's not so easy to remember that release 1.0 of a
      piece of software is a particular subdirectory of revision
      4822.</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.tags.mksimple"></a>4.6.1. Creating a Simple Tag</h3></div></div></div>
<p>Once again, <span class="command"><strong>svn copy</strong></span> comes to the
        rescue.  If you want to create a snapshot of
        <code class="filename">/calc/trunk</code> exactly as it looks in the
        <code class="literal">HEAD</code> revision, make a copy of it:</p>
<pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/release-1.0 \
      -m "Tagging the 1.0 release of the 'calc' project."

Committed revision 902.
</pre>
<p>This example assumes that a
        <code class="filename">/calc/tags</code> directory already exists.  (If
        it doesn't, you can create it using <span class="command"><strong>svn
        mkdir</strong></span>.)  After the copy completes, the new
        <code class="filename">release-1.0</code> directory is forever a
        snapshot of how the <code class="filename">/trunk</code> directory
        looked in the <code class="literal">HEAD</code> revision at the time you
        made the copy.  Of course, you might want to be more precise
        about exactly which revision you copy, in case somebody else
        may have committed changes to the project when you weren't
        looking.  So if you know that revision 901 of
        <code class="filename">/calc/trunk</code> is exactly the snapshot you
        want, you can specify it by passing <code class="option">-r 901</code> to
        the <span class="command"><strong>svn copy</strong></span> command.</p>
<p>But wait a moment: isn't this tag creation procedure the
        same procedure we used to create a branch?  Yes, in fact, it
        is.  In Subversion, there's no difference between a tag and a
        branch.  Both are just ordinary directories that are created
        by copying.  Just as with branches, the only reason a copied
        directory is a &#8220;<span class="quote">tag</span>&#8221; is because
        <span class="emphasis"><em>humans</em></span> have decided to treat it that way:
        as long as nobody ever commits to the directory, it forever
        remains a snapshot.  If people start committing to it, it
        becomes a branch.</p>
<p>If you are administering a repository, there are two
        approaches you can take to managing tags.  The first approach
        is &#8220;<span class="quote">hands off</span>&#8221;: as a matter of project policy,
        decide where your tags will live, and make sure all users know
        how to treat the directories they copy.  (That is, make sure
        they know not to commit to them.)  The second approach is more
        paranoid: you can use one of the access control scripts
        provided with Subversion to prevent anyone from doing anything
        but creating new copies in the tags area (see
        <a class="xref" href="svn.serverconfig.html" title="Chapter 6. Server Configuration">Chapter 6, <i>Server Configuration</i></a>).  The paranoid approach,
        however, isn't usually necessary.  If a user accidentally
        commits a change to a tag directory, you can simply undo the
        change as discussed in the previous section.  This is version
        control, after all!</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.tags.mkcomplex"></a>4.6.2. Creating a Complex Tag</h3></div></div></div>
<p>Sometimes you may want your &#8220;<span class="quote">snapshot</span>&#8221; to be
        more complicated than a single directory at a single
        revision.</p>
<p>For example, pretend your project is much larger than our
        <code class="filename">calc</code> example: suppose it contains a
        number of subdirectories and many more files.  In the course
        of your work, you may decide that you need to create a working
        copy that is designed to have specific features and bug fixes.
        You can accomplish this by selectively backdating files or
        directories to particular revisions (using <span class="command"><strong>svn update</strong></span>
        with the <code class="option">-r</code> option liberally), by switching files and directories to
        particular branches (making use of <span class="command"><strong>svn
        switch</strong></span>), or even just by making a bunch of local
        changes.  When you're done, your working copy is a hodgepodge
        of repository locations from different revisions.  But after
        testing, you know it's the precise combination of data you
        need to tag.</p>
<p>Time to make a snapshot.  Copying one URL to another won't
        work here.  In this case, you want to make a snapshot of your
        exact working copy arrangement and store it in the repository.
        Luckily, <span class="command"><strong>svn copy</strong></span> actually has four
        different uses (which you can read about in <a class="xref" href="svn.ref.html" title="Chapter 9. Subversion Complete Reference">Chapter 9, <i>Subversion Complete Reference</i></a>), including the ability to copy a
        working copy tree to the repository:</p>
<pre class="screen">
$ ls
my-working-copy/

$ svn copy my-working-copy \
           http://svn.example.com/repos/calc/tags/mytag \
           -m "Tag my existing working copy state."

Committed revision 940.
</pre>
<p>Now there is a new directory in the repository,
        <code class="filename">/calc/tags/mytag</code>, which is an exact
        snapshot of your working copy&#8212;mixed revisions, URLs,
        local changes, and all.</p>
<p>Other users have found interesting uses for this feature.
        Sometimes there are situations where you have a bunch of local
        changes made to your working copy, and you'd like a
        collaborator to see them.  Instead of running <span class="command"><strong>svn
        diff</strong></span> and sending a patch file (which won't capture
        directory, symlink, or property changes), you can
        use <span class="command"><strong>svn copy</strong></span> to &#8220;<span class="quote">upload</span>&#8221; your
        working copy to a private area of the repository.  Your
        collaborator can then either check out a verbatim copy of your
        working copy or use <span class="command"><strong>svn merge</strong></span> to receive
        your exact changes.</p>
<p>While this is a nice method for uploading a quick snapshot
        of your working copy, note that this is <span class="emphasis"><em>not</em></span>
        a good way to initially create a branch.  Branch creation should
        be an event unto itself, and this method conflates the creation
        of a branch with extra changes to files, all within a single revision.
        This makes it very difficult (later on) to identify a single
        revision number as a branch point.</p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.maint"></a>4.7. Branch Maintenance</h2></div></div></div>
<p>You may have noticed by now that Subversion is extremely
      flexible.  Because it implements branches and tags with the same
      underlying mechanism (directory copies), and because branches
      and tags appear in normal filesystem space, many people find
      Subversion intimidating.  It's almost <span class="emphasis"><em>too</em></span>
      flexible.  In this section, we'll offer some suggestions for
      arranging and managing your data over time.</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.maint.layout"></a>4.7.1. Repository Layout</h3></div></div></div>
<p>There are some standard, recommended ways to organize a
        repository.  Most people create a <code class="filename">trunk</code>
        directory to hold the &#8220;<span class="quote">main line</span>&#8221; of development,
        a <code class="filename">branches</code> directory to contain branch
        copies, and a <code class="filename">tags</code> directory to contain
        tag copies.  If a repository holds only one project,
        often people create these top-level directories:</p>
<pre class="screen">
/trunk
/branches
/tags
</pre>
<p>If a repository contains multiple projects, admins
        typically index their layout by project (see <a class="xref" href="svn.reposadmin.html#svn.reposadmin.projects.chooselayout" title="5.2.1. Planning Your Repository Organization">Section 5.2.1, &#8220;Planning Your Repository Organization&#8221;</a> to read more about
        &#8220;<span class="quote">project roots</span>&#8221;):</p>
<pre class="screen">
/paint/trunk
/paint/branches
/paint/tags
/calc/trunk
/calc/branches
/calc/tags
</pre>
<p>Of course, you're free to ignore these common layouts.
        You can create any sort of variation, whatever works best for
        you or your team.  Remember that whatever you choose, it's not
        a permanent commitment.  You can reorganize your repository at
        any time.  Because branches and tags are ordinary directories,
        the <span class="command"><strong>svn move</strong></span> command can move or rename
        them however you wish.  Switching from one layout to another
        is just a matter of issuing a series of server-side moves; if
        you don't like the way things are organized in the repository,
        just juggle the directories around.</p>
<p>Remember, though, that while moving directories may be
        easy to do, you need to be considerate of your users as well.
        Your juggling can be disorienting to users with existing
        working copies.  If a user has a working copy of a particular
        repository directory, your <span class="command"><strong>svn move</strong></span>
        operation might remove the path from the latest revision.
        When the user next runs <span class="command"><strong>svn update</strong></span>, she will
        be told that her working copy represents a path that no
        longer exists, and the user will be forced to <span class="command"><strong>svn
        switch</strong></span> to the new location.
        </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.maint.lifetime"></a>4.7.2. Data Lifetimes</h3></div></div></div>
<p>Another nice feature of Subversion's model is that
        branches and tags can have finite lifetimes, just like any
        other versioned item.  For example, suppose you eventually
        finish all your work on your personal branch of the
        <code class="filename">calc</code> project.  After merging all of your
        changes back into <code class="filename">/calc/trunk</code>, there's
        no need for your private branch directory to stick around
        anymore:</p>
<pre class="screen">
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m "Removing obsolete branch of calc project."

Committed revision 375.
</pre>
<p>And now your branch is gone.  Of course, it's not really
        gone: the directory is simply missing from the
        <code class="literal">HEAD</code> revision, no longer distracting
        anyone.  If you use <span class="command"><strong>svn checkout</strong></span>,
        <span class="command"><strong>svn switch</strong></span>, or <span class="command"><strong>svn list</strong></span>
        to examine an earlier revision, you'll still be able to see
        your old branch.</p>
<p>If browsing your deleted directory isn't enough, you can
        always bring it back.  Resurrecting data is very easy in
        Subversion.  If there's a deleted directory (or file) that
        you'd like to bring back into <code class="literal">HEAD</code>, simply
        use <span class="command"><strong>svn copy</strong></span> to copy it from the old
        revision:</p>
<pre class="screen">
$ svn copy http://svn.example.com/repos/calc/branches/my-calc-branch@374 \
           http://svn.example.com/repos/calc/branches/my-calc-branch \
           -m "Restore my-calc-branch."

Committed revision 376.
</pre>
<p>In our example, your personal branch had a relatively
        short lifetime: you may have created it to fix a bug or
        implement a new feature.  When your task is done, so is the
        branch.  In software development, though, it's also common to
        have two &#8220;<span class="quote">main</span>&#8221; branches running side by side for
        very long periods.  For example, suppose it's time to release
        a stable version of the <code class="filename">calc</code> project to the
        public, and you know it's going to take a couple of months to
        shake bugs out of the software.  You don't want people to add
        new features to the project, but you don't want to tell all
        developers to stop programming either.  So instead, you create
        a &#8220;<span class="quote">stable</span>&#8221; branch of the software that won't
        change much:</p>
<pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/stable-1.0 \
           -m "Creating stable branch of calc project."

Committed revision 377.
</pre>
<p>And now developers are free to continue adding
        cutting-edge (or experimental) features to
        <code class="filename">/calc/trunk</code>, and you can declare a
        project policy that only bug fixes are to be committed to
        <code class="filename">/calc/branches/stable-1.0</code>.  That is, as
        people continue to work on the trunk, a human selectively
        ports bug fixes over to the stable branch.  Even after the
        stable branch has shipped, you'll probably continue to
        maintain the branch for a long time&#8212;that is, as long
        as you continue to support that release for customers.  We'll
        discuss this more in the next section.</p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.commonpatterns"></a>4.8. Common Branching Patterns</h2></div></div></div>
<p>There are many different uses for branching and <span class="command"><strong>svn
        merge</strong></span>, and this section describes the most
        common.</p>
<p>Version control is most often used for software
      development, so here's a quick peek at two of the most common
      branching/merging patterns used by teams of programmers.  If
      you're not using Subversion for software development, feel
      free to skip this section.  If you're a software developer
      using version control for the first time, pay close attention,
      as these patterns are often considered best practices by
      experienced folk.  These processes aren't specific to
      Subversion; they're applicable to any version control system.
      Still, it may help to see them described in Subversion
      terms.</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.commonpatterns.release"></a>4.8.1. Release Branches</h3></div></div></div>
<p>Most software has a typical life cycle: code, test,
        release, repeat.  There are two problems with this process.
        First, developers need to keep writing new features while
        quality assurance teams take time to test supposedly stable
        versions of the software.  New work cannot halt while the
        software is tested.  Second, the team almost always needs to
        support older, released versions of software; if a bug is
        discovered in the latest code, it most likely exists in
        released versions as well, and customers will want to get
        that bug fix without having to wait for a major new
        release.</p>
<p>Here's where version control can help.  The typical
        procedure looks like this:</p>
<div class="orderedlist"><ol type="1">
<li><p><span class="emphasis"><em>Developers commit all new work to the
              trunk.</em></span>

            Day-to-day changes are committed to
            <code class="filename">/trunk</code>: new features, bug fixes, and
            so on.</p></li>
<li><p><span class="emphasis"><em>The trunk is copied to a
              &#8220;<span class="quote">release</span>&#8221; branch.</em></span>

            When the team thinks the software is ready for release
            (say, a 1.0 release), <code class="filename">/trunk</code>
            might be copied to
            <code class="filename">/branches/1.0</code>.</p></li>
<li><p><span class="emphasis"><em>Teams continue to work in parallel.</em></span>

            One team begins rigorous testing of the release branch,
            while another team continues new work (say, for version
            2.0) on <code class="filename">/trunk</code>.  If bugs are
            discovered in either location, fixes are ported back and
            forth as necessary.  At some point, however, even that
            process stops.  The branch is &#8220;<span class="quote">frozen</span>&#8221; for
            final testing right before a release.</p></li>
<li><p><span class="emphasis"><em>The branch is tagged and released.</em></span>

            When testing is complete,
            <code class="filename">/branches/1.0</code> is copied to
            <code class="filename">/tags/1.0.0</code> as a reference
            snapshot.  The tag is packaged and released to
            customers.</p></li>
<li><p><span class="emphasis"><em>The branch is maintained over time.</em></span>

            While work continues on <code class="filename">/trunk</code> for
            version 2.0, bug fixes continue to be ported from
            <code class="filename">/trunk</code> to
            <code class="filename">/branches/1.0</code>.  When enough
            bug fixes have accumulated, management may decide to do a
            1.0.1 release: <code class="filename">/branches/1.0</code> is
            copied to <code class="filename">/tags/1.0.1</code>, and the tag
            is packaged and released.</p></li>
</ol></div>
<p>This entire process repeats as the software matures:
        when the 2.0 work is complete, a new 2.0 release branch is
        created, tested, tagged, and eventually released.  After
        some years, the repository ends up with a number of release
        branches in &#8220;<span class="quote">maintenance</span>&#8221; mode, and a number
        of tags representing final shipped versions.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.commonpatterns.feature"></a>4.8.2. Feature Branches</h3></div></div></div>
<p>A <em class="firstterm">feature branch</em> is the sort of
        branch that's been the dominant example in this chapter (the
        one you've been working on while Sally continues to work on
        <code class="filename">/trunk</code>).  It's a temporary branch created
        to work on a complex change without interfering with the
        stability of <code class="filename">/trunk</code>.  Unlike release
        branches (which may need to be supported forever), feature
        branches are born, used for a while, merged back to the trunk,
        and then ultimately deleted.  They have a finite span of
        usefulness.</p>
<p>Again, project policies vary widely concerning exactly
        when it's appropriate to create a feature branch.  Some
        projects never use feature branches at all: commits to
        <code class="filename">/trunk</code> are a free-for-all.  The
        advantage to this system is that it's simple&#8212;nobody
        needs to learn about branching or merging.  The disadvantage
        is that the trunk code is often unstable or unusable.  Other
        projects use branches to an extreme: no change is
        <span class="emphasis"><em>ever</em></span> committed to the trunk directly.
        Even the most trivial changes are created on a short-lived
        branch, carefully reviewed, and merged to the trunk.  Then
        the branch is deleted.  This system guarantees an
        exceptionally stable and usable trunk at all times, but at
        the cost of tremendous process overhead.</p>
<p>Most projects take a middle-of-the-road approach.  They
        commonly insist that <code class="filename">/trunk</code> compile and
        pass regression tests at all times.  A feature branch is
        required only when a change requires a large number of
        destabilizing commits.  A good rule of thumb is to ask this
        question: if the developer worked for days in isolation and
        then committed the large change all at once (so that
        <code class="filename">/trunk</code> were never destabilized), would it
        be too large a change to review?  If the answer to that
        question is &#8220;<span class="quote">yes,</span>&#8221; the change should be
        developed on a feature branch.  As the developer commits
        incremental changes to the branch, they can be easily reviewed
        by peers.</p>
<p>Finally, there's the issue of how to best keep a feature
        branch in &#8220;<span class="quote">sync</span>&#8221; with the trunk as work
        progresses.  As we mentioned earlier, there's a great risk to
        working on a branch for weeks or months; trunk changes may
        continue to pour in, to the point where the two lines of
        development differ so greatly that it may become a nightmare
        trying to merge the branch back to the trunk.</p>
<p>This situation is best avoided by regularly merging trunk
        changes to the branch.  Make up a policy: once a week, merge
        the last week's worth of trunk changes to the branch.</p>
<p>At some point, you'll be ready to merge the
        &#8220;<span class="quote">synchronized</span>&#8221; feature branch back to the trunk.
        To do this, begin by doing a final merge of the latest trunk
        changes to the branch.  When that's done, the latest versions
        of branch and trunk will be absolutely identical except for
        your branch changes.  You would then merge back with
        the <code class="option">--reintegrate</code> option:</p>
<pre class="screen">
$ cd trunk-working-copy

$ svn update
At revision 1910.

$ svn merge --reintegrate ^/branches/mybranch
--- Merging differences between repository URLs into '.':
U    real.c
U    integer.c
A    newdirectory
A    newdirectory/newfile
 U   .
&#8230;
</pre>
<p>Another way of thinking about this pattern is that your
        weekly sync of trunk to branch is analogous to running
        <span class="command"><strong>svn update</strong></span> in a working copy, while the
        final merge step is analogous to running <span class="command"><strong>svn
          commit</strong></span> from a working copy.  After all, what else
        <span class="emphasis"><em>is</em></span> a working copy but a very shallow
        private branch?  It's a branch that's capable of
        storing only one change at a time.</p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.advanced.vendorbr"></a>4.9. Vendor Branches</h2></div></div></div>
<p>As is especially the case when developing software, the data
      that you maintain under version control is often closely related
      to, or perhaps dependent upon, someone else's data.  Generally,
      the needs of your project will dictate that you stay as
      up to date as possible with the data provided by that external
      entity without sacrificing the stability of your own project.
      This scenario plays itself out all the time&#8212;anywhere that
      the information generated by one group of people has a direct
      effect on that which is generated by another group.</p>
<p>For example, software developers might be working on an
      application that makes use of a third-party library.  Subversion
      has just such a relationship with the Apache Portable Runtime (APR)
      library (see <a class="xref" href="svn.developer.html#svn.developer.usingapi.apr" title="8.3.1. The Apache Portable Runtime Library">Section 8.3.1, &#8220;The Apache Portable Runtime Library&#8221;</a>).
      The Subversion source code depends on the APR library for all
      its portability needs.  In earlier stages of Subversion's
      development, the project closely tracked APR's changing API,
      always sticking to the &#8220;<span class="quote">bleeding edge</span>&#8221; of the
      library's code churn.  Now that both APR and Subversion have
      matured, Subversion attempts to synchronize with APR's library
      API only at well-tested, stable release points.</p>
<p>Now, if your project depends on someone else's information,
      you could attempt to synchronize that information with your own
      in several ways.  Most painfully, you could issue oral or
      written instructions to all the contributors of your project,
      telling them to make sure they have the specific versions
      of that third-party information that your project needs.  If the
      third-party information is maintained in a Subversion
      repository, you could also use Subversion's externals
      definitions to effectively &#8220;<span class="quote">pin down</span>&#8221; specific
      versions of that information to some location in your own
      working copy directory (see
      <a class="xref" href="svn.advanced.html#svn.advanced.externals" title="3.8. Externals Definitions">Section 3.8, &#8220;Externals Definitions&#8221;</a>).</p>
<p>But sometimes you want to maintain custom modifications to
      third-party code in your own version control system.  Returning
      to the software development example, programmers might need to
      make modifications to that third-party library for their own
      purposes.  These modifications might include new functionality
      or bug fixes, maintained internally only until they become part
      of an official release of the third-party library.  Or the
      changes might never be relayed back to the library maintainers,
      existing solely as custom tweaks to make the library further
      suit the needs of the software developers.</p>
<p>Now you face an interesting situation.  Your project could
      house its custom modifications to the third-party data in some
      disjointed fashion, such as using patch files or full-fledged
      alternative versions of files and directories.  But these quickly
      become maintenance headaches, requiring some mechanism by which
      to apply your custom changes to the third-party code and
      necessitating regeneration of those changes with each successive
      version of the third-party code that you track.</p>
<p>The solution to this problem is to use <em class="firstterm">vendor
      branches</em>.  A vendor branch is a directory tree in
      your own version control system that contains information
      provided by a third-party entity, or vendor.  Each version of
      the vendor's data that you decide to absorb into your project is
      called a <em class="firstterm">vendor drop</em>.</p>
<p>Vendor branches provide two benefits.  First, by storing
      the currently supported vendor drop in your own version control
      system, you ensure that the members of your project never need to question
      whether they have the right version of the vendor's data.  They
      simply receive that correct version as part of their regular
      working copy updates.  Second, because the data lives in your
      own Subversion repository, you can store your custom changes to
      it in-place&#8212;you have no more need of an automated (or
      worse, manual) method for swapping in your customizations.</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.advanced.vendorbr.general"></a>4.9.1. General Vendor Branch Management Procedure</h3></div></div></div>
<p>Managing vendor branches generally works like this: first,
        you create a top-level directory (such as
        <code class="filename">/vendor</code>) to hold the vendor branches.
        Then you import the third-party code into a subdirectory of
        that top-level directory.  You then copy that subdirectory
        into your main development branch (e.g.,
        <code class="filename">/trunk</code>) at the appropriate location.  You
        always make your local changes in the main development branch.
        With each new release of the code you are tracking, you bring
        it into the vendor branch and merge the changes into
        <code class="filename">/trunk</code>, resolving whatever conflicts
        occur between your local changes and the upstream
        changes.</p>
<p>An example will help to clarify this algorithm.  We'll use
        a scenario where your development team is creating a
        calculator program that links against a third-party complex
        number arithmetic library, libcomplex.  We'll begin with the
        initial creation of the vendor branch and the import of the
        first vendor drop.  We'll call our vendor branch directory
        <code class="filename">libcomplex</code>, and our code drops will go
        into a subdirectory of our vendor branch called
        <code class="filename">current</code>.  And since <span class="command"><strong>svn
        import</strong></span> creates all the intermediate parent
        directories it needs, we can actually accomplish both of these
        steps with a single command:</p>
<pre class="screen">
$ svn import /path/to/libcomplex-1.0 \
             http://svn.example.com/repos/vendor/libcomplex/current \
             -m 'importing initial 1.0 vendor drop'
&#8230;
</pre>
<p>We now have the current version of the libcomplex source
        code in <code class="filename">/vendor/libcomplex/current</code>.  Now,
        we tag that version (see <a class="xref" href="svn.branchmerge.html#svn.branchmerge.tags" title="4.6. Tags">Section 4.6, &#8220;Tags&#8221;</a>)
        and then copy it into the main development branch.  Our copy
        will create a new directory called
        <code class="filename">libcomplex</code> in our existing
        <code class="filename">calc</code> project directory.  It is in this
        copied version of the vendor data that we will make our
        customizations:</p>
<pre class="screen">
$ svn copy http://svn.example.com/repos/vendor/libcomplex/current  \
           http://svn.example.com/repos/vendor/libcomplex/1.0      \
           -m 'tagging libcomplex-1.0'
&#8230;
$ svn copy http://svn.example.com/repos/vendor/libcomplex/1.0  \
           http://svn.example.com/repos/calc/libcomplex        \
           -m 'bringing libcomplex-1.0 into the main branch'
&#8230;
</pre>
<p>We check out our project's main branch&#8212;which now
        includes a copy of the first vendor drop&#8212;and we get to
        work customizing the libcomplex code.  Before we know it, our
        modified version of libcomplex is now completely integrated
        into our calculator program.
        <sup>[<a name="id498721" href="#ftn.id498721" class="footnote">26</a>]</sup>
      </p>
<p>A few weeks later, the developers of libcomplex release a
        new version of their library&#8212;version 1.1&#8212;which
        contains some features and functionality that we really want.
        We'd like to upgrade to this new version, but without losing
        the customizations we made to the existing version.  What we
        essentially would like to do is to replace our current
        baseline version of libcomplex 1.0 with a copy of libcomplex
        1.1, and then re-apply the custom modifications we previously
        made to that library to the new version.  But we actually
        approach the problem from the other direction, applying the
        changes made to libcomplex between versions 1.0 and 1.1 to our
        modified copy of it.</p>
<p>To perform this upgrade, we check out a copy of our vendor
        branch and replace the code in the
        <code class="filename">current</code> directory with the new libcomplex
        1.1 source code.  We quite literally copy new files on top of
        existing files, perhaps exploding the libcomplex 1.1 release
        tarball atop our existing files and directories.  The goal
        here is to make our <code class="filename">current</code> directory
        contain only the libcomplex 1.1 code and to ensure that all
        that code is under version control.  Oh, and we want to do
        this with as little version control history disturbance as
        possible.</p>
<p>After replacing the 1.0 code with 1.1 code, <span class="command"><strong>svn
        status</strong></span> will show files with local modifications as
        well as, perhaps, some unversioned files.  If we did what we
        were supposed to do, the unversioned files are only those new
        files introduced in the 1.1 release of libcomplex&#8212;we
        run <span class="command"><strong>svn add</strong></span> on those to get them under
        version control.  If the 1.1 code no longer has certain files
        that were in the 1.0 tree, it may be hard to notice them;
        you'd have to compare the two trees with some external tool
        and then <span class="command"><strong>svn delete</strong></span> any files present in
        1.0 but not in 1.1.  (Although it might also be just fine to
        let these same files live on in unused obscurity!)  Finally,
        once our <code class="filename">current</code> working copy contains
        only the libcomplex 1.1 code, we commit the changes we made to
        get it looking that way.</p>
<p>Our <code class="filename">current</code> branch now contains the
        new vendor drop.  We tag the new version as 1.1 (in the same
        way we previously tagged the version 1.0 vendor drop), and
        then merge the differences between the tag of the previous
        version and the new current version into our main development
        branch:</p>
<pre class="screen">
$ cd working-copies/calc
$ svn merge ^/vendor/libcomplex/1.0      \
            ^/vendor/libcomplex/current  \
            libcomplex
&#8230; # resolve all the conflicts between their changes and our changes
$ svn commit -m 'merging libcomplex-1.1 into the main branch'
&#8230;
</pre>
<p>In the trivial use case, the new version of our
        third-party tool would look, from a files-and-directories
        point of view, just like the previous version.  None of the
        libcomplex source files would have been deleted, renamed, or
        moved to different locations&#8212;the new version would
        contain only textual modifications against the previous one.
        In a perfect world, our modifications would apply cleanly to
        the new version of the library, with absolutely no
        complications or conflicts.</p>
<p>But things aren't always that simple, and in fact it is
        quite common for source files to get moved around between
        releases of software.  This complicates the process of
        ensuring that our modifications are still valid for the new
        version of code, and things can quickly degrade into a
        situation where we have to manually re-create our
        customizations in the new version.  Once Subversion knows
        about the history of a given source file&#8212;including all
        its previous locations&#8212;the process of merging in the new
        version of the library is pretty simple.  But we are
        responsible for telling Subversion how the source file layout
        changed from vendor drop to vendor drop.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.advanced.vendorbr.svn_load_dirs"></a>4.9.2. svn_load_dirs.pl</h3></div></div></div>
<p>Vendor drops that contain more than a few deletes,
        additions, and moves complicate the process of upgrading to
        each successive version of the third-party data.  So
        Subversion supplies the <span class="command"><strong>svn_load_dirs.pl</strong></span>
        script to assist with this process.  This script automates the
        importing steps we mentioned in the general vendor branch
        management procedure to make sure mistakes are minimized.
        You will still be responsible for using the merge commands to
        merge the new versions of the third-party data into your main
        development branch, but <span class="command"><strong>svn_load_dirs.pl</strong></span>
        can help you more quickly and easily arrive at that
        stage.</p>
<p>In short, <span class="command"><strong>svn_load_dirs.pl</strong></span> is an
        enhancement to <span class="command"><strong>svn import</strong></span> that has several
        important characteristics:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>It can be run at any point in time to bring an existing
            directory in the repository to exactly match an external
            directory, performing all the necessary adds and deletes,
            and optionally performing moves, too.</p></li>
<li><p>It takes care of complicated series of operations between
            which Subversion requires an intermediate commit&#8212;such
            as before renaming a file or directory twice.</p></li>
<li><p>It will optionally tag the newly imported directory.</p></li>
<li><p>It will optionally add arbitrary properties to files and
            directories that match a regular expression.</p></li>
</ul></div>
<p><span class="command"><strong>svn_load_dirs.pl</strong></span> takes three mandatory
        arguments.  The first argument is the URL to the base
        Subversion directory to work in.  This argument is followed by
        the URL&#8212;relative to the first argument&#8212;into which the
        current vendor drop will be imported.  Finally, the third
        argument is the local directory to import.  Using our previous
        example, a typical run of <span class="command"><strong>svn_load_dirs.pl</strong></span>
        might look like this:</p>
<pre class="screen">
$ svn_load_dirs.pl http://svn.example.com/repos/vendor/libcomplex \
                   current                                        \
                   /path/to/libcomplex-1.1
&#8230;
</pre>
<p>You can indicate that you'd like
        <span class="command"><strong>svn_load_dirs.pl</strong></span> to tag the new vendor drop
        by passing the <code class="option">-t</code> command-line option and
        specifying a tag name.  This tag is another URL relative to
        the first program argument.</p>
<pre class="screen">
$ svn_load_dirs.pl -t libcomplex-1.1                              \
                   http://svn.example.com/repos/vendor/libcomplex \
                   current                                        \
                   /path/to/libcomplex-1.1
&#8230;
</pre>
<p>When you run <span class="command"><strong>svn_load_dirs.pl</strong></span>, it
        examines the contents of your existing &#8220;<span class="quote">current</span>&#8221;
        vendor drop and compares them with the proposed new vendor
        drop.  In the trivial case, no files will be in
        one version and not the other, and the script will perform the
        new import without incident.  If, however, there are
        discrepancies in the file layouts between versions,
        <span class="command"><strong>svn_load_dirs.pl</strong></span> will ask you how
        to resolve those differences.  For example, you
        will have the opportunity to tell the script that you know
        that the file <code class="filename">math.c</code> in version 1.0 of
        libcomplex was renamed to <code class="filename">arithmetic.c</code> in
        libcomplex 1.1.  Any discrepancies not explained by moves
        are treated as regular additions and deletions.</p>
<p>The script also accepts a separate configuration file for
        setting properties on files and directories matching a regular
        expression that are <span class="emphasis"><em>added</em></span> to the
        repository.  This configuration file is specified to
        <span class="command"><strong>svn_load_dirs.pl</strong></span> using the
        <code class="option">-p</code> command-line option.  Each line of the
        configuration file is a whitespace-delimited set of two or
        four values: a Perl-style regular expression against which to match the
        added path, a control keyword (either
        <code class="literal">break</code> or <code class="literal">cont</code>), and then
        optionally a property name and value.</p>
<pre class="screen">
\.png$              break   svn:mime-type   image/png
\.jpe?g$            break   svn:mime-type   image/jpeg
\.m3u$              cont    svn:mime-type   audio/x-mpegurl
\.m3u$              break   svn:eol-style   LF
.*                  break   svn:eol-style   native
</pre>
<p>For each added path, the configured property changes whose
        regular expression matches the path are applied in order,
        unless the control specification is <code class="literal">break</code>
        (which means that no more property changes should be applied
        to that path).  If the control specification is
        <code class="literal">cont</code>&#8212;an abbreviation for
        <code class="literal">continue</code>&#8212;matching will continue
        with the next line of the configuration file.</p>
<p>Any whitespace in the regular expression, property name,
        or property value must be surrounded by either single or
        double quotes.  You can escape quotes that
        are not used for wrapping whitespace by preceding them with a
        backslash (<code class="literal">\</code>) character.  The backslash
        escapes only quotes when parsing the configuration file, so do
        not protect any other characters beyond what is necessary for
        the regular expression.</p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.summary"></a>4.10. Summary</h2></div></div></div>
<p>We covered a lot of ground in this chapter.  We
      discussed the concepts of tags and branches and demonstrated
      how Subversion implements these concepts by copying directories
      with the <span class="command"><strong>svn copy</strong></span> command.  We showed how
      to use <span class="command"><strong>svn merge</strong></span> to copy changes from one
      branch to another or roll back bad changes.  We went over
      the use of <span class="command"><strong>svn switch</strong></span> to create
      mixed-location working copies.  And we talked about how one
      might manage the organization and lifetimes of branches in a
      repository.</p>
<p>Remember the Subversion mantra: branches and tags are cheap.
      So don't be afraid to use them when needed!</p>
<p>As a helpful reminder of all the operations we discussed,
      here is handy reference table you can consult as
      you begin to make use of branches.</p>
<div class="table">
<a name="svn.branchemerge.summary.tbl-1"></a><p class="title"><b>Table 4.1. Branching and merging commands</b></p>
<div class="table-contents"><table summary="Branching and merging commands" border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>Action</th>
<th>Command</th>
</tr></thead>
<tbody>
<tr>
<td>Create a branch or tag</td>
<td><strong class="userinput"><code>svn copy <em class="replaceable"><code>URL1</code></em> <em class="replaceable"><code>URL2</code></em></code></strong></td>
</tr>
<tr>
<td>Switch a working copy to a branch or tag</td>
<td><strong class="userinput"><code>svn switch <em class="replaceable"><code>URL</code></em></code></strong></td>
</tr>
<tr>
<td>Synchronize a branch with trunk</td>
<td><strong class="userinput"><code>svn merge <em class="replaceable"><code>trunkURL</code></em>; svn commit</code></strong></td>
</tr>
<tr>
<td>See merge history or eligible changesets</td>
<td><strong class="userinput"><code>svn mergeinfo target --from-source=<em class="replaceable"><code>URL</code></em></code></strong></td>
</tr>
<tr>
<td>Merge a branch back into trunk</td>
<td><strong class="userinput"><code>svn merge --reintegrate <em class="replaceable"><code>branchURL</code></em>; svn commit</code></strong></td>
</tr>
<tr>
<td>Merge one specific change</td>
<td><strong class="userinput"><code>svn merge -c <em class="replaceable"><code>REV</code></em> <em class="replaceable"><code>URL</code></em>; svn commit</code></strong></td>
</tr>
<tr>
<td>Merge a range of changes</td>
<td><strong class="userinput"><code>svn merge -r <em class="replaceable"><code>REV1</code></em>:<em class="replaceable"><code>REV2</code></em> <em class="replaceable"><code>URL</code></em>; svn commit</code></strong></td>
</tr>
<tr>
<td>Block a change from automatic merging</td>
<td><strong class="userinput"><code>svn merge -c <em class="replaceable"><code>REV</code></em> --record-only <em class="replaceable"><code>URL</code></em>; svn commit</code></strong></td>
</tr>
<tr>
<td>Preview a merge</td>
<td><strong class="userinput"><code>svn merge <em class="replaceable"><code>URL</code></em> --dry-run</code></strong></td>
</tr>
<tr>
<td>Abandon merge results</td>
<td><strong class="userinput"><code>svn revert -R .</code></strong></td>
</tr>
<tr>
<td>Resurrect something from history</td>
<td><strong class="userinput"><code>svn copy <em class="replaceable"><code>URL</code></em>@<em class="replaceable"><code>REV</code></em> <em class="replaceable"><code>localPATH</code></em></code></strong></td>
</tr>
<tr>
<td>Undo a committed change</td>
<td><strong class="userinput"><code>svn merge -c -<em class="replaceable"><code>REV</code></em> <em class="replaceable"><code>URL</code></em>; svn commit</code></strong></td>
</tr>
<tr>
<td>Examine merge-sensitive history</td>
<td><strong class="userinput"><code>svn log -g; svn blame -g</code></strong></td>
</tr>
<tr>
<td>Create a tag from a working copy</td>
<td><strong class="userinput"><code>svn copy . <em class="replaceable"><code>tagURL</code></em></code></strong></td>
</tr>
<tr>
<td>Rearrange a branch or tag</td>
<td><strong class="userinput"><code>svn mv <em class="replaceable"><code>URL1</code></em> <em class="replaceable"><code>URL2</code></em></code></strong></td>
</tr>
<tr>
<td>Remove a branch or tag</td>
<td><strong class="userinput"><code>svn rm <em class="replaceable"><code>URL</code></em></code></strong></td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.id494002" href="#id494002" class="para">20</a>] </sup>Subversion does not support copying between different
        repositories.  When using URLs with <span class="command"><strong>svn
        copy</strong></span> or <span class="command"><strong>svn move</strong></span>, you can only
        copy items within the same repository.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id494562" href="#id494562" class="para">21</a>] </sup>This was
        introduced in svn 1.6.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id495357" href="#id495357" class="para">22</a>] </sup>The Subversion project has plans, however, to someday
            implement a command that would accomplish the task of
            permanently deleting information.  In the meantime, see
            <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.tk.svndumpfilter" title="5.4.1.3. svndumpfilter">Section 5.4.1.3, &#8220;svndumpfilter&#8221;</a>
            for a possible workaround.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id495776" href="#id495776" class="para">23</a>] </sup>At least, this is true in Subversion 1.5 at the time
              of this writing.  This behavior may improve in future
              versions of Subversion.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id496182" href="#id496182" class="para">24</a>] </sup>Interestingly, after rolling back a
                revision like this, we wouldn't be able to reapply
                the revision using <strong class="userinput"><code>svn merge . -c 5</code></strong>,
                since the mergeinfo would already list r5 as being
                applied.  We would have to use
                the <code class="option">--ignore-ancestry</code> option to make
                the merge command ignore the existing
                mergeinfo!</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id497335" href="#id497335" class="para">25</a>] </sup>You <span class="emphasis"><em>can</em></span>, however, use <span class="command"><strong>svn
          switch</strong></span> with the <code class="option">--relocate</code> option
          if the URL of your server changes and you don't want to
          abandon an existing working copy.  See <a class="xref" href="svn.ref.svn.c.switch.html" title="svn switch">svn switch</a> for more information and an
          example.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id498721" href="#id498721" class="para">26</a>] </sup>And is entirely bug-free, of course!</p></div>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="svn.advanced.html">Prev</a> </td>
<td width="20%" align="center"> </td>
<td width="40%" align="right"> <a accesskey="n" href="svn.reposadmin.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Chapter 3. Advanced Topics </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> Chapter 5. Repository Administration</td>
</tr>
</table>
</div>
</body>
</html>
