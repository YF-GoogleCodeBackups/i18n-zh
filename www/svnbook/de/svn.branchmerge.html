<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Kapitel 4. Verzweigen und Zusammenführen</title>
<link rel="stylesheet" href="styles.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="index.html" title="Versionskontrolle mit Subversion">
<link rel="up" href="index.html" title="Versionskontrolle mit Subversion">
<link rel="prev" href="svn.advanced.html" title="Kapitel 3. Advanced Topics">
<link rel="next" href="svn.reposadmin.html" title="Kapitel 5. Verwaltung des Repositorys">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Kapitel 4. Verzweigen und Zusammenführen</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="svn.advanced.html">Zurück</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a accesskey="n" href="svn.reposadmin.html">Weiter</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="chapter" lang="de">
<div class="titlepage"><div><div><h2 class="title">
<a name="svn.branchmerge"></a>Kapitel 4. Verzweigen und Zusammenführen</h2></div></div></div>
<div class="toc">
<p><b>Inhaltsverzeichnis</b></p>
<dl>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.whatis">4.1. Was ist ein Zweig?</a></span></dt>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.using">4.2. Verwenden von Zweigen</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.using.create">4.2.1. Erzeugen eines Zweiges</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.using.work">4.2.2. Arbeiten mit Ihrem Zweig</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.using.concepts">4.2.3. Die Schlüsselkonzepte des Verzweigens</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.basicmerging">4.3. Grundlegendes Zusammenführen</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.changesets">4.3.1. Änderungsmengen</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchemerge.basicmerging.stayinsync">4.3.2. Einen Zweig synchron halten</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.basicmerging.mergeinfo">4.3.3. Mergeinfo und Vorschauen</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.basicmerging.undo">4.3.4. Änderungen rückgängig machen</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.basicmerging.resurrect">4.3.5. Zurückholen gelöschter Objekte</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.advanced">4.4. Fortgeschrittenes Zusammenführen</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.cherrypicking">4.4.1. Die Rosinen herauspicken</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.advancedsyntax">4.4.2. Merge-Syntax: Die vollständige Enthüllung</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.nomergedata">4.4.3. Zusammenführen ohne Mergeinfo</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.mergeconflicts">4.4.4. Mehr über Konflikte beim Zusammenführen</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.blockchanges">4.4.5. Änderungen blockieren</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.logblame">4.4.6. Protokolle und Anmerkungen, die Zusammenführungen anzeigen</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.ancestry">4.4.7. Die Abstammung berücksichtigen oder ignorieren</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.moves">4.4.8. Zusammenführen und Verschieben</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.pre1.5clients">4.4.9. Abblocken von Clients, die Zusammenführungen nicht
        ausreichend unterstützen</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.advanced.finalword">4.4.10. Das abschließende Wort zur Zusammenführungs-Verfolgung</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.switchwc">4.5. Zweige durchlaufen</a></span></dt>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.tags">4.6. Tags</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.tags.mksimple">4.6.1. Erzeugen eines einfachen Tags</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.tags.mkcomplex">4.6.2. Erzeugen eines komplexen Tags</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.maint">4.7. Verwaltung von Zweigen</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.maint.layout">4.7.1. Aufbau des Repositorys</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.maint.lifetime">4.7.2. Lebensdauer von Daten</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.commonpatterns">4.8. Verbreitete Verzweigungsmuster</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.commonpatterns.release">4.8.1. Release-Zweige</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.branchmerge.commonpatterns.feature">4.8.2. Funktions-Zweige</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.advanced.vendorbr">4.9. Lieferanten-Zweige</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.advanced.vendorbr.general">4.9.1. Allgemeines Vorgehen für die Verwaltung von Lieferanten-Zweigen</a></span></dt>
<dt><span class="sect2"><a href="svn.branchmerge.html#svn.advanced.vendorbr.svn_load_dirs">4.9.2. svn_load_dirs.pl</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.branchmerge.html#svn.branchmerge.summary">4.10. Zusammenfassung</a></span></dt>
</dl>
</div>
<div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote">
<tr>
<td width="10%" valign="top"> </td>
<td width="80%" valign="top"><p>&#8222;<span class="quote">&#21531;&#23376;&#21153;&#26412;
      (Der Edle pflegt die Wurzel)</span>&#8220;</p></td>
<td width="10%" valign="top"> </td>
</tr>
<tr>
<td width="10%" valign="top"> </td>
<td colspan="2" align="right" valign="top">--<span class="attribution">Konfuzius</span>
</td>
</tr>
</table></div>
<p>Verzweigen (Branching), Etikettieren (Tagging) und
    Zusammenführen (Merging) sind Konzepte, die fast allen
    Versionskontrollsystemen gemein sind. Falls Sie mit diesen
    Begriffen nicht vertraut sein sollten, geben wir in diesem Kapitel
    eine gute Einführung. Falls Sie damit vertraut sind, werden Sie es
    hoffentlich interessant finden, zu sehen, wie Subversion diese
    Konzepte implementiert.</p>
<p>Verzweigen ist ein grundlegender Teil der
    Versionskontrolle. Falls Sie Subversion erlauben wollen, Ihre
    Daten zu verwalten, ist dies eine Fähigkeit, von der Sie
    letztendlich abhängig sein werden. Dieses Kapitel geht davon aus,
    dass Sie mit den grundlegenden Konzepten von Subversion vertraut
    sind (<a class="xref" href="svn.basic.html" title="Kapitel 1. Grundlegende Konzepte">Kapitel 1, <i>Grundlegende Konzepte</i></a>).</p>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.whatis"></a>4.1. Was ist ein Zweig?</h2></div></div></div>
<p>Angenommen, Ihre Aufgabe ist es, ein Dokument für eine
      Abteilung Ihrer Firma zu pflegen &#8211; eine Art
      Handbuch. Eines Tages fragt eine andere Abteilung nach dem
      gleichen Handbuch, jedoch an einigen Stellen für ihre
      Bedürfnisse &#8222;<span class="quote">abgewandelt</span>&#8220;, da sie auf etwas andere
      Weise arbeiten.</p>
<p>Was machen Sie in dieser Situation? Sie machen das
      Offensichtliche: Sie erstellen eine Kopie Ihres Dokumentes und
      beginnen, die beiden Kopien getrennt zu pflegen. Sobald Sie
      irgendeine Abteilung auffordert, kleine Änderungen vorzunehmen,
      pflegen Sie diese in die eine oder andere Kopie ein.</p>
<p>Oftmals möchten Sie die selbe Änderung in beiden Kopien
      machen. Wenn Sie zum Beispiel einen Schreibfehler in der ersten
      Kopie entdecken, ist es sehr wahrscheinlich, dass dieser Fehler
      auch in der zweiten Kopie vorliegt. Schließlich sind die beiden
      Dokumente fast gleich; sie unterscheiden sich nur in kleinen
      Dingen.</p>
<p>Das ist das Grundkonzept eines <em class="firstterm">Zweigs</em>
      (Branch) &#8211; nämlich eine Entwicklungslinie, die unabhängig
      von einer anderen existiert, jedoch über eine gemeinsame
      Geschichte verfügt, wenn lang genug in der Zeit zurück gegangen
      wird. Ein Zweig beginnt sein Leben stets als eine Kopie von
      etwas und läuft von da an weiter, wobei er seine eigene
      Geschichte erzeugt (siehe <a class="xref" href="svn.branchmerge.html#svn.branchmerge.whatis.dia-1" title="Abbildung 4.1. Entwicklungszweige">Abbildung 4.1, &#8222;Entwicklungszweige&#8220;</a>).</p>
<div class="figure">
<a name="svn.branchmerge.whatis.dia-1"></a><p class="title"><b>Abbildung 4.1. Entwicklungszweige</b></p>
<div class="figure-contents"><div><img src="images/ch04dia1.png" alt="Entwicklungszweige"></div></div>
</div>
<br class="figure-break"><p>Subversion verfügt über Befehle, die Ihnen helfen, parallele
      Zweige Ihrer Dateien und Verzeichnisse zu verwalten. Es erlaubt
      Ihnen, durch das Kopieren Ihrer Daten, Zweige zu erstellen und
      merkt sich, dass die Zweige untereinander in Beziehung
      stehen. Es hilft Ihnen auch, Änderungen von einem Zweig auf den
      anderen zu duplizieren. Schließlich ermöglicht es, dass Teile
      Ihrer Arbeitskopie verschiedene Zweige repräsentieren können,
      was Ihnen während Ihrer täglichen Arbeit erlaubt, verschiedene
      Entwicklungslinien zu &#8222;<span class="quote">mischen und
      gegenüberzustellen</span>&#8220;.</p>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.using"></a>4.2. Verwenden von Zweigen</h2></div></div></div>
<p>An dieser Stelle sollten Sie verstehen, wie jede Übergabe an
      das Repository dort einen völlig neuen Dateibaum
      (&#8222;<span class="quote">Revision</span>&#8220; genannt) erzeugt. Wenn nicht, blättern
      Sie zurück und lesen Sie in <a class="xref" href="svn.basic.html#svn.basic.in-action.revs" title="1.3.3. Revisionen">Abschnitt 1.3.3, &#8222;Revisionen&#8220;</a> über Revisionen
      nach.</p>
<p>Für dieses Kapitel verwenden wir das Beispiel aus <a class="xref" href="svn.basic.html" title="Kapitel 1. Grundlegende Konzepte">Kapitel 1, <i>Grundlegende Konzepte</i></a>. Erinnern Sie sich, dass Sie und Ihre
      Mitarbeiterin Sally sich ein Repository teilen, das zwei
      Projekte beinhaltet: <code class="filename">paint</code> und
      <code class="filename">calc</code>. Beachten Sie, dass in <a class="xref" href="svn.branchmerge.html#svn.branchmerge.using.dia-1" title="Abbildung 4.2. Repository-Struktur zu Beginn">Abbildung 4.2, &#8222;Repository-Struktur zu Beginn&#8220;</a> dieses Mal jedoch jedes
      Projektverzeichnis Unterverzeichnisse namens
      <code class="filename">trunk</code> und <code class="filename">branches</code>
      beinhaltet.  Der Grund hierfür wird bald klar sein.</p>
<div class="figure">
<a name="svn.branchmerge.using.dia-1"></a><p class="title"><b>Abbildung 4.2. Repository-Struktur zu Beginn</b></p>
<div class="figure-contents"><div><img src="images/ch04dia2.png" alt="Repository-Struktur zu Beginn"></div></div>
</div>
<br class="figure-break"><p>Wie vorher sei hier angenommen, dass sowohl Sally als auch
      Sie Arbeitskopien des &#8222;<span class="quote">calc</span>&#8220; Projektes
      besitzen. Ausdrücklich hat jeder von Ihnen eine Arbeitskopie von
      <code class="filename">/calc/trunk</code>. Alle Dateien des Projektes
      befinden sich in diesem Unterverzeichnis statt in
      <code class="filename">/calc</code> selber, da Ihr Team entschieden hat,
      dass in <code class="filename">/calc/trunk</code> die
      &#8222;<span class="quote">Hauptlinie</span>&#8220; der Entwicklung stattfindet.</p>
<p>Sagen wir mal, dass Sie die Aufgabe bekommen haben, ein
      großes Stück Software umzusetzen. Die Erstellung benötigt eine
      lange Zeit und berührt alle Dateien im Projekt. Das Problem,
      dass sofort auftaucht ist, dass Sie nicht Sally in die Quere
      kommen möchten, die gerade hier und da kleinere Fehler
      beseitigt. Sie ist abhängig von der Tatsache, dass die letzte
      Version des Projektes (in <code class="filename">/calc/trunk</code>)
      stets benutzbar ist. Wenn Sie nun damit beginnen, Stück für
      Stück Ihre Änderungen zu übergeben, werden Sie gewiss die Dinge
      für Sally (und auch für andere Teammitglieder) in Unordnung
      bringen.</p>
<p>Eine Strategie ist, sich in ein Loch zu verkriechen: Sie und
      Sally können für eine Woche oder zwei den Informationsaustausch
      einstellen. Das heißt, Sie fangen damit an, die Dateien Ihrer
      Arbeitskopie auszuräumen und umzuorganisieren, ohne Änderungen
      zu übergeben oder die Arbeitskopie zu aktualisieren, bevor Sie
      mit Ihrer Arbeit vollständig fertig sind. Das wirft allerdings
      einige Probleme auf. Erstens ist das nicht sehr sicher. Viele
      Leute möchten Ihre Arbeit regelmäßig ins Repository sichern, für
      den Fall, dass etwas Schlimmes mit der Arbeitskopie passieren
      könnte. Zweitens ist das nicht sehr flexibel. Falls Sie Ihre
      Arbeit an mehreren Rechnern verrichten (vielleicht haben Sie
      eine Arbeitskopie von <code class="filename">/calc/trunk</code> auf zwei
      unterschiedlichen Maschinen), müssten Sie entweder alle
      Änderungen manuell hin und her kopieren oder die gesamte Arbeit
      an nur einem Rechner erledigen. Ebenso schwierig wäre es, Ihre
      Änderungen mit anderen zu teilen. Eine weit verbreitete
      &#8222;<span class="quote">beste Vorgehensweise</span>&#8220; ist es, Ihren Mitarbeitern
      zu erlauben, während Sie mit Ihrer Arbeit fortfahren, Ihre
      bisherigen Ergebnisse zu überprüfen. Wenn niemand Ihre
      unmittelbaren Änderungen sieht, haben Sie keine möglichen
      Rückmeldungen und es könnte sein, dass Sie für Wochen einen
      falschen Weg einschlagen, bevor es jemand aus Ihrem Team
      bemerkt. Schließlich könnte es am Ende, wenn Sie mit Ihren
      Änderungen fertig sind, sehr schwierig sein, Ihr Arbeitsergebnis
      wieder mit dem Hauptteil der Quelltexte Ihrer Firma
      zusammenzuführen. Sally (und andere) hätten viele andere
      Änderungen ins Repository übergeben haben können, die sich
      schwer in Ihre Arbeitskopie einarbeiten ließen &#8211;
      besonders, falls Sie <span class="command"><strong>svn update</strong></span> nach Wochen
      der Isolierung ausführen.</p>
<p>Die bessere Lösung ist, Ihren eigenen Zweig oder Ihre eigene
      Entwicklungslinie im Repository zu erzeugen. Dies erlaubt Ihnen,
      Ihre halbfertigen Arbeitsergebnisse regelmäßig zu sichern, ohne
      andere zu stören; dennoch können Sie selektiv Informationen mit
      Ihren Kollegen teilen. Im Weiteren werden Sie sehen, wie das
      funktioniert.</p>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.using.create"></a>4.2.1. Erzeugen eines Zweiges</h3></div></div></div>
<p>Es ist sehr einfach, einen Zweig zu erzeugen &#8211; Sie
        erstellen mit dem Befehl <span class="command"><strong>svn copy</strong></span> eine
        Kopie des Projektes im Repository. Subversion kann nicht nur
        Dateien, sondern auch komplette Verzeichnisse kopieren.  In
        diesem Fall möchten Sie eine Kopie des Verzeichnisses
        <code class="filename">/calc/trunk</code> machen. Wo soll die neue
        Kopie angelegt werden? Wo Sie wünschen &#8211; es ist eine
        Frage der Projektkonventionen. Sagen wir mal, dass Ihr Team
        die Konvention vereinbart hat, Zweige im Bereich
        <code class="filename">/calc/branches</code> des Repositorys anzulegen,
        und Sie Ihren Zweig <code class="literal">my-calc-branch</code> nennen
        möchten. Sie werden ein neues Verzeichnis
        <code class="filename">/calc/branches/my-calc-branch</code> anlegen,
        das als Kopie von <code class="filename">/calc/trunk</code>
        beginnt.</p>
<p>Sie haben vielleicht schon gesehen, wie mit <span class="command"><strong>svn
        copy</strong></span> in einer Arbeitskopie eine Datei auf eine
        andere kopiert wird. Es kann allerdings auch verwendet werden,
        um eine &#8222;<span class="quote">entfernte</span>&#8220; Kopie innerhalb des
        Repositorys durchzuführen. Kopieren Sie einfach einen URL auf
        einen anderen:</p>
<pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/my-calc-branch \
      -m "Privaten Zweig von /calc/trunk angelegt."

Revision 341 übertragen.
</pre>
<p>Dieser Befehl bewirkt eine fast sofortige Übergabe im
        Repository, wobei in Revision 341 ein neues Verzeichnis
        erzeugt wird. Das neue Verzeichnis ist eine Kopie von
        <code class="filename">/calc/trunk</code>. Dies wird in <a class="xref" href="svn.branchmerge.html#svn.branchmerge.using.create.dia-1" title="Abbildung 4.3. Repository mit neuer Kopie">Abbildung 4.3, &#8222;Repository mit neuer Kopie&#8220;</a> gezeigt.
        <sup>[<a name="id384682" href="#ftn.id384682" class="footnote">20</a>]</sup>

        Obwohl es auch möglich ist, einen Zweig zu erzeugen, indem
        <span class="command"><strong>svn copy</strong></span> verwendet wird, um ein Verzeichnis
        innerhalb der Arbeitskopie zu duplizieren, wird dieses
        Vorgehen nicht empfohlen. Es kann in der Tat sehr langsam
        sein! Das client-seitige Kopieren eines Verzeichnisses besitzt
        einen linearen Zeitaufwand, da wirklich jede Datei und jedes
        Verzeichnis auf der lokalen Platte dupliziert werden muss. Das
        Kopieren eines Verzeichnisses auf dem Server jedoch besitzt
        einen konstanten Zeitaufwand und ist die Art und Weise, auf
        die die meisten Leute Zweige erstellen.</p>
<div class="figure">
<a name="svn.branchmerge.using.create.dia-1"></a><p class="title"><b>Abbildung 4.3. Repository mit neuer Kopie</b></p>
<div class="figure-contents"><div><img src="images/ch04dia3.png" alt="Repository mit neuer Kopie"></div></div>
</div>
<br class="figure-break"><div class="sidebar">
<p class="title"><b>Billige Kopien</b></p>
<p>Das Repository von Subversion ist auf eine besondere
          Weise konstruiert. Wenn Sie ein Verzeichnis kopieren,
          brauchen Sie sich keine Gedanken darüber zu machen, dass das
          Repository riesengroß wird &#8211; Subversion dupliziert
          tatsächlich überhaupt keine Daten. Stattdessen erzeugt es
          einen neuen Verzeichniseintrag, der auf einen
          <span class="emphasis"><em>bestehenden</em></span> Baum verweist. Falls Sie
          ein erfahrener Unix-Benutzer sind, werden Sie erkennen, dass
          es sich um dasselbe Konzept handelt wie bei einem
          Hardlink. Während weitere Änderungen an den Dateien und
          Verzeichnissen unterhalb des kopierten Verzeichnisses
          gemacht werden, fährt Subversion fort, dieses Konzept
          anzuwenden wo es geht. Es dupliziert Daten nur dann, wenn es
          notwendig wird, verschiedene Versionen von Objekten
          auseinanderzuhalten.</p>
<p>Deshalb hören Sie Subversion-Benutzer oft von
          &#8222;<span class="quote">billigen Kopien</span>&#8220; sprechen. Es spielt keine
          Rolle, wie umfangreich das Verzeichnis ist &#8211; es bedarf
          lediglich eines kleinen, konstanten Zeitaufwands und
          Speicherplatzes, um eine Kopie davon zu erstellen. Diese
          Fähigkeit ist tatsächlich die Grundlage für die Umsetzung
          von Übergaben in Subversion: Jede Revision ist eine
          &#8222;<span class="quote">billige Kopie</span>&#8220; der vorhergehenden Revision mit
          ein paar Dingen, die sich im Innern geändert haben. (Um mehr
          hierüber zu lesen, gehen Sie auf die Website von Subversion
          und lesen Sie in den Subversion-Design-Dokumenten über die
          &#8222;<span class="quote">bubble-up</span>&#8220;-Methode.)</p>
<p>Natürlich sind diese internen Mechanismen des Kopierens
          und Teilens vor dem Benutzer verborgen, der lediglich Kopien
          von Bäumen sieht. Die Hauptsache hierbei ist, das Kopien
          billig sind, sowohl was die Zeit als auch den Speicherplatz
          angeht. Wenn Sie einen Zweig komplett im Repository anlegen
          (durch den Aufruf von <strong class="userinput"><code>svn copy
          <em class="replaceable"><code>URL1</code></em>
          <em class="replaceable"><code>URL2</code></em></code></strong>), handelt es
          sich um eine schnelle Operation mit konstanter
          Zeitdauer. Erstellen Sie Zweige so oft Sie wollen.</p>
</div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.using.work"></a>4.2.2. Arbeiten mit Ihrem Zweig</h3></div></div></div>
<p>Da Sie nun einen Zweig des Projektes erzeugt haben, können
        Sie eine neue Arbeitskopie auschecken, um ihn zu
        benutzen:</p>
<pre class="screen">
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A  my-calc-branch/Makefile
A  my-calc-branch/integer.c
A  my-calc-branch/button.c
Ausgecheckt, Revision 341.
</pre>
<p>An dieser Arbeitskopie ist nichts besonders; sie spiegelt
        bloß ein anderes Verzeichnis im Repository wieder. Wenn Sie
        Änderungen übergeben, wird sie Sally jedoch nicht sehen, wenn
        sie aktualisiert, da sie eine Arbeitskopie von
        <code class="filename">/calc/trunk</code> hat. (Stellen Sie sicher,
        dass Sie <a class="xref" href="svn.branchmerge.html#svn.branchmerge.switchwc" title="4.5. Zweige durchlaufen">Abschnitt 4.5, &#8222;Zweige durchlaufen&#8220;</a> weiter
        unten in diesem Kapitel lesen: Der Befehl <span class="command"><strong>svn
        switch</strong></span> ist eine Alternative für die Bereitstellung
        einer Arbeitskopie eines Zweiges.)</p>
<p>Tun wir mal so, als ob eine Woche ins Land geht und die
        folgenden Übergaben stattfinden:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>

          Sie machen eine Änderung an
          <code class="filename">/calc/branches/my-calc-branch/button.c</code>,
          die die Revision 342 erzeugt.</p></li>
<li><p>

          Sie machen eine Änderung an
          <code class="filename">/calc/branches/my-calc-branch/integer.c</code>,
          die die Revision 343 erzeugt.</p></li>
<li><p>

          Sally macht eine Änderung an
          <code class="filename">/calc/trunk/integer.c</code>, die die Revision
          344 erzeugt.</p></li>
</ul></div>
<p>Nun finden zwei unabhängige Entwicklungslinien (siehe
        <a class="xref" href="svn.branchmerge.html#svn.branchmerge.using.work.dia-1" title="Abbildung 4.4. Die Verzweigung der Geschichte einer Datei">Abbildung 4.4, &#8222;Die Verzweigung der Geschichte einer Datei&#8220;</a>) auf
        <code class="filename">integer.c</code> statt.</p>
<div class="figure">
<a name="svn.branchmerge.using.work.dia-1"></a><p class="title"><b>Abbildung 4.4. Die Verzweigung der Geschichte einer Datei</b></p>
<div class="figure-contents"><div><img src="images/ch04dia4.png" alt="Die Verzweigung der Geschichte einer Datei"></div></div>
</div>
<br class="figure-break"><p>Es wird interessant, wenn Sie die Geschichte der
        Änderungen an Ihrer Kopie von <code class="filename">integer.c</code>
        betrachten:</p>
<pre class="screen">
$ pwd
/home/user/my-calc-branch

$ svn log -v integer.c
------------------------------------------------------------------------
r343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Geänderte Pfade:
   M /calc/branches/my-calc-branch/integer.c

* integer.c:  Wazjub gefrozzelt.

------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Geänderte Pfade:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Privaten Zweig von /calc/trunk angelegt.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Geänderte Pfade:
   M /calc/trunk/integer.c

* integer.c:  Einen Docstring geändert.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Geänderte Pfade:
   A /calc/trunk/integer.c

* integer.c:  Diese Datei dem Projekt hinzugefügt.

------------------------------------------------------------------------
</pre>
<p>Beachten Sie, dass Subversion die Geschichte von
        <code class="filename">integer.c</code> auf Ihrem Zweig über die
        gesamte Zeit zurück verfolgt, und dabei sogar über den Punkt
        hinweg geht, an dem es kopiert wurde. Es zeigt die Erzeugung
        des Zweigs als ein Ereignis in der Geschichte, da
        <code class="filename">integer.c</code> implizit kopiert wurde, als
        alles andere in <code class="filename">/calc/trunk/</code> kopiert
        wurde. Sehen Sie nun, was passiert, wenn Sally den gleichen
        Befehl auf Ihre Arbeitskopie der Datei anwendet:</p>
<pre class="screen">
$ pwd
/home/sally/calc

$ svn log -v integer.c
------------------------------------------------------------------------
r344 | sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  fix a bunch of spelling errors.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   A /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</pre>
<p>Sally sieht ihre eigene Änderung in Revision 344, aber
        nicht die Änderung, die Sie in Revision 343 gemacht haben. Was
        Subversion angeht, hatten diese beiden Übergaben Auswirkungen
        auf unterschiedliche Dateien an unterschiedlichen
        Repository-Orten. Dennoch zeigt Subversion
        <span class="emphasis"><em>doch</em></span>, dass die beiden Dateien einen Teil
        der Geschichte gemeinsam haben. Bevor die Kopie des Zweiges in
        Revision 341 gemacht wurde, waren die Dateien dieselbe
        Datei. Deshalb sehen sowohl Sie als auch Sally die Änderungen,
        die in den Revisionen 303 und 98 gemacht wurden.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.using.concepts"></a>4.2.3. Die Schlüsselkonzepte des Verzweigens</h3></div></div></div>
<p>Sie sollten sich zwei Lektionen aus diesem Abschnitt
        merken. Erstens besitzt Subversion kein internes Konzept für
        einen Zweig &#8211; es weiß lediglich, wie Kopien angelegt
        werden. Wenn Sie ein Verzeichnis kopieren, ist das entstehende
        Verzeichnis bloß ein &#8222;<span class="quote">Zweig</span>&#8220;, weil
        <span class="emphasis"><em>Sie</em></span> ihm diese Bedeutung geben. Sie mögen
        über das Verzeichnis anders denken oder es anders behandeln,
        doch für Subversion ist es einfach ein gewöhnliches
        Verzeichnis, das nebenbei mit einigen zusätzlichen
        historischen Informationen ausgestattet ist.</p>
<p>Zweitens bestehen die Zweige von Subversion, bedingt durch
        den Kopiermechanismus, als <span class="emphasis"><em>normale
        Dateisystemverzeichnisse</em></span> im Repository. Das ist ein
        Unterschied zu anderen Versionskontrollsystemen, bei denen
        Zweige typischerweise definiert werden, indem auf einer
        eigenen Ebene den Dateisammlungen &#8222;<span class="quote">Etiketten</span>&#8220; 
        hinzugefügt werden. Der Ort Ihres Zweig-Verzeichnisses spielt
        für Subversion keine Rolle. Die meisten Teams folgen der
        Konvention, alle Zweige in einem Verzeichnis namens
        <code class="filename">/branches</code> abzulegen, jedoch steht es
        Ihnen frei, eine Vorgehensweise nach Ihren Wünschen zu
        erfinden.</p>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.basicmerging"></a>4.3. Grundlegendes Zusammenführen</h2></div></div></div>
<p>Nun arbeiten Sie und Sally auf parallelen Zweigen des
      Projektes: Sie arbeiten auf einem privaten Zweig, und Sally
      arbeitet auf dem <em class="firstterm">Stamm</em> oder dem
      Hauptzweig der Entwicklung.</p>
<p>Bei Projekten mit einer großen Zahl von Mitarbeitern haben
      die meisten gewöhnlich Arbeitskopien vom Stamm. Sobald jemand
      eine langwierige Änderung machen muss, die wahrscheinlich den
      Stamm stören würde, ist die Standardvorgehensweise, einen Zweig
      zu erzeugen und die Änderungen bis zum Abschluss der Arbeiten
      nach dorthin zu übergeben.</p>
<p>Die gute Nachricht ist also, dass Sie und Sally sich nicht
      in die Quere kommen. Die schlechte Nachricht ist, dass es sehr
      leicht ist, <span class="emphasis"><em>zu</em></span> weit auseinander zu treiben.
      Erinnern Sie sich, dass eins der Probleme bei der Strategie
      &#8222;<span class="quote">sich in ein Loch zu verkriechen</span>&#8220; war, dass es zu
      dem Zeitpunkt, an dem Sie mit dem Zweig fertig sind, fast
      unmöglich sein kann, Ihre Änderungen ohne eine riesige Zahl an
      Konflikten auf den Stamm zurückzuführen.</p>
<p>Stattdessen könnten Sie und Sally fortfahren, während der
      Arbeit Änderungen gemeinsam zu verwenden. Es liegt an Ihnen, zu
      entscheiden, welche Änderungen teilenswert sind; Subversion
      bietet Ihnen die Fähigkeit, Änderungen selektiv zwischen Zweigen
      zu &#8222;<span class="quote">kopieren</span>&#8220;. Und wenn Sie mit Ihrem Zweig
      vollständig fertig sind, kann die gesamte Menge Ihrer Änderungen
      vom Zweig auf den Stamm zurück kopiert werden. In der
      Terminologie von Subversion heißt der allgemeine Vorgang,
      Änderungen von einem Zweig auf einen anderen zu übertragen
      <em class="firstterm">Zusammenführen</em> (Merging) und wird durch
      verschiedene Aufrufe des Befehls <span class="command"><strong>svn merge</strong></span>
      durchgeführt.</p>
<p>In den folgenden Beispielen gehen wir davon aus, dass sowohl
      auf Ihrem Subversion-Client als auch auf dem Server Subversion
      1.5 (oder neuer) läuft. Falls einer von beiden älter als Version
      1.5 ist, wird es komplizierter: Das System wird Änderungen nicht
      automatisch mitverfolgen, so dass Sie schmerzhafte manuelle
      Methoden anwenden müssen, um ähnliche Resultate zu
      erzielen. Dass heißt, dass Sie stets die detaillierte Syntax
      beim Zusammenführen verwenden müssen, um bestimmte
      Revisionsintervalle zu übertragen (siehe <a class="xref" href="svn.branchmerge.html#svn.branchmerge.advanced.advancedsyntax" title="4.4.2. Merge-Syntax: Die vollständige Enthüllung">Abschnitt 4.4.2, &#8222;Merge-Syntax: Die vollständige Enthüllung&#8220;</a> weiter unten
      in diesem Kapitel), und besonders sorgfältig verfolgen müssen,
      was bereits zusammengeführt ist und was nicht. Aus diesem Grund
      empfehlen wir Ihnen <span class="emphasis"><em>dringend</em></span>,
      sicherzustellen, dass Ihr Client und Server mindestens die
      Version 1.5 haben.</p>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.changesets"></a>4.3.1. Änderungsmengen</h3></div></div></div>
<p>Bevor wir weitermachen, sollten wir Sie warnen, dass Sie
        auf den kommenden Seiten viele Erörterungen zum Thema
        &#8222;<span class="quote">Änderungen</span>&#8220; erwarten. Viele mit
        Versionskontrollsystemen erfahrene Leute benutzen die Begriffe
        &#8222;<span class="quote">Änderung</span>&#8220; und &#8222;<span class="quote">Änderungsmenge</span>&#8220;
        (Changeset) austauschbar, so dass wir klären sollten, was
        Subversion unter einer <em class="firstterm">Änderungsmenge</em>
        versteht.</p>
<p>Jeder scheint eine etwas unterschiedliche Definition für
        den Begriff Änderungsmenge zu haben oder zumindest eine
        unterschiedliche Erwartung darüber, was es für ein
        Versionskontrollsystem bedeutet, so etwas zu besitzen. Für
        unsere Zwecke reicht es aus, zu sagen, dass eine
        Änderungsmenge lediglich eine Sammlung von Änderungen mit
        einem eindeutigen Namen ist. Die Änderungen können aus der
        Bearbeitung an Textdateien, Modifizierungen an der
        Baumstruktur oder Justierungen an Metadaten bestehen. In
        einfachen Worten ist eine Änderungsmenge einfach ein Patch mit
        einem Namen, auf den Sie sich beziehen können.</p>
<p>In Subversion bezeichnet eine globale Revisionsnummer N
        einen Baum im Repository: Sie beschreibt das Aussehen des
        Repositorys nach der N-ten Übergabe. Sie ist auch der Name
        einer impliziten Änderungsmenge: Wenn Sie den Baum N mit dem
        Baum N&#8722;1 vergleichen, können Sie genau den Patch
        ableiten, der übergeben wurde. Daher ist es einfach, sich
        Revision N nicht nur als Baum sondern auch als Änderungsmenge
        vorzustellen. Falls Sie ein Fehlerverwaltungssystem verwenden,
        können Sie die Revisionsnummern benutzen, um auf bestimmte
        Patches zu verweisen, die Fehler beheben &#8211; zum Beispiel:
        &#8222;<span class="quote">Dieser Fehler wurde durch r9238 behoben</span>&#8220;. Dann
        kann jemand <strong class="userinput"><code>svn log -r 9238</code></strong> aufrufen,
        um den Protokolleintrag zu genau der Änderungsmenge zu lesen,
        die den Fehler behoben hat, und sich mit <strong class="userinput"><code>svn diff
        -c 9238</code></strong> den eigentlichen Patch ansehen.  Und auch
        (wie Sie bald sehen werden) der Subversion Befehl <span class="command"><strong>svn
        merge</strong></span> kann Revisionsnummern verwenden. Sie können
        bestimmte Änderungsmengen von einem Zweig mit einem anderen
        zusammenführen, indem sie in den Argumenten zum entsprechenden
        Kommando benannt werden: Die Übergabe von <strong class="userinput"><code>-c
        9238</code></strong> an <span class="command"><strong>svn merge</strong></span> würde das
        Änderungsmenge r9238 mit Ihrer Arbeitskopie
        zusammenführen.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchemerge.basicmerging.stayinsync"></a>4.3.2. Einen Zweig synchron halten</h3></div></div></div>
<p>Machen wir mit unserem Beispiel weiter und nehmen an, dass
        eine Woche vergangen ist seitdem Sie begonnen haben, auf
        Ihrem privaten Zweig zu arbeiten. Ihre Arbeit ist noch nicht
        beendet, jedoch wissen Sie, dass gleichzeitig andere Leute in
        Ihrem Team weiterhin wichtige Änderungen im
        <code class="filename">/trunk</code> des Projektes gemacht haben. Es
        ist in Ihrem Interesse, diese Änderungen in Ihren Zweig zu
        übernehmen, um sicherzustellen, dass sie sich gut mit Ihren
        Änderungen vertragen. Dies ist tatsächlich eine der besten
        Vorgehensweisen: Ihren Zweig regelmäßig mit der
        Hauptentwicklungslinie zu synchronisieren hilft,
        &#8222;<span class="quote">überraschende</span>&#8220; Konflikte zu vermeiden, wenn es
        an der Zeit ist, Ihre Änderungen zurück auf den Stamm zu
        bringen.</p>
<p>Subversion kennt die Geschichte Ihres Zweigs und weiß,
        wann Sie ihn vom Stamm abgezweigt haben. Um die letzten,
        aktuellsten Änderungen vom Stamm auf Ihren Zweig zu bringen,
        sollten Sie zunächst sicherstellen, dass die Arbeitskopie des
        Zweigs &#8222;<span class="quote">sauber</span>&#8220; ist &#8211; dass sie keine
        lokalen Änderungen hat, die durch <span class="command"><strong>svn
        status</strong></span> angezeigt werden. Dann rufen Sie einfach die
        folgenden Befehle auf:</p>
<pre class="screen">
$ pwd
/home/user/my-calc-branch

$ svn merge http://svn.example.com/repos/calc/trunk
--- Zusammenführen von r345 bis r356 in ».«:
U    button.c
U    integer.c
</pre>
<p>Diese einfache Syntax &#8211; <strong class="userinput"><code>svn merge
        <em class="replaceable"><code>URL</code></em></code></strong> &#8211; fordert
        Subversion auf, alle neuen Änderungen von dem URL mit dem
        aktuellen Arbeitsverzeichnis (welches typischerweise das
        Wurzelverzeichnis Ihrer Arbeitskopie ist)
        zusammenzuführen. Nach dem Ausführen des vorangegangenen
        Beispiels enthält Ihre Arbeitskopie nun neue lokale
        Änderungen, die Nachbildungen all der Änderungen auf dem Stamm
        seit der Erstellung Ihres Zweiges sind:</p>
<pre class="screen">
$ svn status
 M     .
M      button.c
M      integer.c
</pre>
<p>Zu diesem Zeitpunkt ist es weise, sich die Änderungen
        mithilfe von <span class="command"><strong>svn diff</strong></span> sorgfältig anzusehen,
        und anschließend die Software von Ihrem Zweig zu bauen und zu
        testen. Beachten Sie, dass auch das aktuelle
        Arbeitsverzeichnis (&#8222;<span class="quote"><code class="filename">.</code></span>&#8220;)
        verändert wurde; <span class="command"><strong>svn diff</strong></span> zeigt an, dass
        seine Eigenschaft <code class="literal">svn:mergeinfo</code> entweder
        angelegt oder modifiziert wurde. Das ist ein wichtiges
        Metadatum in Zusammenhang mit Zusammenführungen, das Sie
        <span class="emphasis"><em>nicht</em></span> anfassen sollten, da es von
        künftigen <span class="command"><strong>svn merge</strong></span>-Befehlen benötigt wird.
        (Wir werden später in diesem Kapitel mehr über diese Metadaten
        erfahren.)</p>
<p>Nach der Übernahme kann es möglich sein, dass Sie noch
        einige Konflikte auflösen müssen (wie bei <span class="command"><strong>svn
        update</strong></span>) oder möglicherweise noch einige kleinere
        Bearbeitungen durchzuführen haben, damit alles wieder
        funktioniert. (Denken Sie daran, dass die Abwesenheit
        <span class="emphasis"><em>syntaktischer</em></span> Konflikte nicht bedeutet,
        dass keine <span class="emphasis"><em>semantischen</em></span> Konflikte
        vorhanden sind!) Falls ernsthafte Probleme auftauchen, können
        Sie jederzeit die lokalen Änderungen mit <strong class="userinput"><code>svn revert
        . -R</code></strong> wieder rückgängig machen und eine lange
        &#8222;<span class="quote">was geht hier eigentlich vor</span>&#8220;-Unterredung mit
        Ihren Mitarbeitern führen. Falls jedoch alles gut aussieht,
        können Sie die Änderungen an das Repository übergeben:</p>
<pre class="screen">
$ svn commit -m "Die letzten Änderungen von trunk mit my-calc-branch zusammengeführt."
Sende          .
Sende          button.c
Sende          integer.c
Übertrage Daten ..
Revision 357 übertragen.
</pre>
<p>An dieser Stelle ist Ihr Zweig &#8222;<span class="quote">synchron</span>&#8220; mit
        dem Stamm, und Sie können sich ruhig zurücklehnen in der
        Gewissheit, dass Sie sich nicht zu weit von der Arbeit aller
        anderen entfernen, während Sie isoliert weiterarbeiten.</p>
<div class="sidebar">
<p class="title"><b>Warum stattdessen keine Patches verwenden?</b></p>
<p>Eine Frage könnte Ihnen durch den Kopf gehen, besonders,
          falls Sie ein Unix-Benutzer sind: Warum soll ich überhaupt
          <span class="command"><strong>svn merge</strong></span> verwenden? Warum kann ich
          dieselbe Aufgabe nicht mit dem Betriebssystembefehl
          <span class="command"><strong>patch</strong></span> lösen? Zum Beispiel:</p>
<pre class="screen">
$ cd my-calc-branch
$ svn diff -r 341:HEAD http://svn.example.com/repos/calc/trunk &gt; patchfile
$ patch -p0  &lt; patchfile
Patching file integer.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
</pre>
<p>Bei diesem speziellen Beispiel gibt es wahrhaftig keinen
          großen Unterschied. Allerdings hat <span class="command"><strong>svn
          merge</strong></span> besondere Fähigkeiten, die über die des
          Programms <span class="command"><strong>patch</strong></span> hinaus gehen. Das von
          <span class="command"><strong>patch</strong></span> verwendete Dateiformat ist sehr
          eingeschränkt; es kann lediglich Dateiinhalte verändern. Es
          besteht keine Möglichkeit, Änderungen an
          <span class="emphasis"><em>Bäumen</em></span>, etwa das Hinzufügen, Entfernen
          oder Umbenennen von Dateien und Verzeichnissen
          abzubilden. Desweiteren bemerkt das Programm
          <span class="command"><strong>patch</strong></span> keine Änderungen an
          Eigenschaften. Falls Sallys Änderung etwa ein neues
          Verzeichnis hinzugefügt hätte, wäre es in der Ausgabe von
          <span class="command"><strong>svn diff</strong></span> überhaupt nicht erwähnt worden.
          <span class="command"><strong>svn diff</strong></span> gibt nur das eingeschränkte
          patch-Format aus, so dass es einige der Konzepte gar nicht
          wiedergeben kann.</p>
<p>Der Befehl <span class="command"><strong>svn merge</strong></span> jedoch kann
          Änderungen an der Baumstruktur und an Eigenschaften
          erfassen, indem sie direkt auf Ihre Arbeitskopie angewendet
          werden. Noch wichtiger ist, dass dieser Befehl alle
          Änderungen festhält, die auf Ihren Zweig angewendet wurden,
          so dass Subversion genau Bescheid weiß, welche Änderungen an
          welcher Stelle vorhanden sind (siehe <a class="xref" href="svn.branchmerge.html#svn.branchmerge.basicmerging.mergeinfo" title="4.3.3. Mergeinfo und Vorschauen">Abschnitt 4.3.3, &#8222;Mergeinfo und Vorschauen&#8220;</a>).  Dies
          ist eine kritische Fähigkeit, die die Verwaltung von Zweigen
          brauchbar macht; ohne sie müssten Benutzer sich manuelle
          Aufzeichnungen darüber machen, welche Änderungsmengen
          zusammengeführt worden sind und welche noch nicht.</p>
</div>
<p>Nehmen wir an, noch eine Woche sei ins Land gegangen. Sie
        haben weitere Änderungen an Ihren Zweig übergeben, und Ihre
        Kollegen haben damit weitergemacht, den Stamm zu
        verbessern. Nun möchten Sie mal wieder die letzten Änderungen
        vom Stamm mit Ihrem Zweig abgleichen, damit Sie wieder
        synchron sind. Starten Sie einfach noch einmal den
        <span class="command"><strong>svn merge</strong></span>-Befehl!</p>
<pre class="screen">
$ svn merge http://svn.example.com/repos/calc/trunk
--- Zusammenführen von r357 bis r380 in ».«:
U    integer.c
U    Makefile
A    README
</pre>
<p>Subversion weiß, welche Änderungen Sie bereits mit Ihrem
        Zweig abgeglichen haben, so dass es sorgfältig nur die
        Änderungen berücksichtigt, die Sie noch nicht haben. Einmal
        mehr müssen Sie bauen, testen und die lokalen Änderungen an
        Ihren Zweig mit <span class="command"><strong>svn commit</strong></span>
        übergeben.</p>
<p>Was passiert jedoch, wenn Sie schließlich Ihre Arbeit
        abgeschlossen haben? Ihre neue Funktion ist fertig, und Sie
        sind bereit, die Änderungen von Ihrem Zweig zurück auf den
        Stamm zu überführen (so dass Ihr Team die Früchte Ihrer Arbeit
        genießen kann). Die Vorgehensweise ist einfach. Zunächst
        synchronisieren Sie Ihren Zweig noch einmal mit dem Stamm, wie
        Sie es bisher gemacht haben:</p>
<pre class="screen">
$ svn merge http://svn.example.com/repos/calc/trunk
--- Zusammenführen von r381 bis r385 in ».«:
U    button.c
U    README

$ # bauen, testen, ...

$ svn commit -m "Letzte Zusammenführung der Änderungen von trunk changes in my-calc-branch."
Sende          .
Sende          button.c
Sende          README
Übertrage Daten ..
Revision 390 übertragen.
</pre>
<p>Nun verwenden Sie <span class="command"><strong>svn merge</strong></span>, um Ihre
        Änderungen vom Zweig zurück auf den Stamm zu überführen. Sie
        benötigen eine aktuelle Arbeitskopie von
        <code class="filename">/trunk</code>. Sie bekommen sie entweder durch
        <span class="command"><strong>svn checkout</strong></span>, indem Sie von irgendwo auf
        Ihrer Platte eine alte Arbeitskopie vom Stamm hervorholen,
        oder den Befehl <span class="command"><strong>svn switch</strong></span> (siehe <a class="xref" href="svn.branchmerge.html#svn.branchmerge.switchwc" title="4.5. Zweige durchlaufen">Abschnitt 4.5, &#8222;Zweige durchlaufen&#8220;</a>) verwenden. Wie auch
        immer Sie Ihre Arbeitskopie bereitstellen, denken Sie daran,
        dass Sie die Überführung in einer Arbeitskopie durchführen,
        die <span class="emphasis"><em>keine</em></span> lokalen Änderungen beinhaltet
        und jüngst aktualisiert wurde (d.h., keine Mischung aus
        lokalen Revisionen ist). Falls Ihre Arbeitskopie nicht
        &#8222;<span class="quote">sauber</span>&#8220; in diesem Sinn ist, könnte es Ihnen
        einige unnötige konfliktbezogene Kopfschmerzen bereiten, und
        <span class="command"><strong>svn merge</strong></span> wird wahrscheinlich einen Fehler
        ausgeben.</p>
<p>Sobald Sie eine saubere Arbeitskopie des Stamms haben,
        sind Sie bereit, Ihren Zweig damit zusammenzuführen:</p>
<pre class="screen">
$ pwd
/home/user/calc-trunk

$ svn update  # (stellen Sie sicher, dass die Arbeitskopie aktuell ist)
Revision 390.

$ svn merge --reintegrate http://svn.example.com/repos/calc/branches/my-calc-branch
-- Zusammenführen der Unterschiede zwischen Projektarchiv-URLs in ».«:
U    button.c
U    integer.c
U    Makefile
 U   .

$ # bauen, testen, überprüfen, ...

$ svn commit -m "Merge my-calc-branch back into trunk!"
Sende          .
Sende          button.c
Sende          integer.c
Sende          Makefile
Übertrage Daten ..
Revision 391 übertragen.
</pre>
<p>Gratulation! Ihr Zweig ist nun zurück in die
        Hauptentwicklungslinie überführt worden. Beachten Sie, dass
        dieses Mal die Option <code class="option">--reintegrate</code> verwendet
        wurde. Diese Option ist kritisch, wenn Änderungen von einem
        Zweig in die ursprüngliche Entwicklungslinie reintegriert
        werden &#8211; vergessen Sie sie nicht! Sie wird benötigt, da
        diese Art der &#8222;<span class="quote">Rücküberführung</span>&#8220; etwas anderes
        ist, als was Sie bisher gemacht haben. Vorher haben wir
        <span class="command"><strong>svn merge</strong></span> aufgefordert, die &#8222;<span class="quote">nächste
        Änderungsmenge</span>&#8220; von einer Entwicklungslinie (dem Stamm)
        zu holen und sie mit einer anderen (Ihrem Zweig)
        abzugleichen. Das ist recht überschaubar, und Subversion weiß
        jedesmal, wo es wieder ansetzen soll. Bei unseren
        vorangehenden Beispielen können Sie sehen, dass es erst die
        Intervalle 345:356 vom Stamm auf den Zweig überführte; später
        fuhr es mit dem nächsten verfügbaren aufeinanderfolgenden
        Intervall 356:380 fort.  Wenn Sie die letzte Synchronisierung
        machen, wird es das Intervall 380:385 zusammenführen.</p>
<p>Wenn Sie jedoch den Zweig auf den Stamm zurückführen,
        sehen die dem zugrundeliegenden Berechnungen ganz anders
        aus. Ihr Zweig ist nun ein Mischmasch aus abgeglichenen
        Änderungen vom Stamm und privaten Änderungen auf dem Zweig, so
        dass es kein einfaches, aufeinanderfolgendes Intervall mit
        Revisionen zum Herüberkopieren gibt. Indem Sie die Option
        <code class="option">--reintegrate</code> angeben, fordern Sie Subversion
        auf, sorgfältig <span class="emphasis"><em>nur</em></span> die Änderungen von
        Ihrem Zweig zu replizieren. (Und tatsächlich macht es das so,
        dass es die letzte Version auf dem Stamm mit der letzten
        Version auf dem Zweig vergleicht: Der Unterschied macht genau
        die Änderung auf dem Zweig aus!)</p>
<p>Nachdem nun Ihr privater Zweig mit dem Stamm
        zusammengeführt wurde, können Sie ihn aus dem Repository
        löschen:</p>
<pre class="screen">
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
      -m "Remove my-calc-branch."
Revision 392 übertragen.
</pre>
<p>Aber halt! Ist die Geschichte des Zweigs nicht wertvoll?
        Was, wenn jemand sich eines Tages die Evolution Ihrer Funktion
        ansehen möchte und hierfür auf die Änderungen des Zweiges
        schauen möchte? Keine Sorge! Denken Sie daran, dass, obwohl
        Ihr Zweig nicht mehr im Verzeichnis
        <code class="filename">/branches</code> sichtbar ist, seine Existenz
        gleichwohl ein unveränderbarer Teil der Geschichte des
        Repositorys ist. Ein einfacher Befehl <span class="command"><strong>svn
        log</strong></span> auf dem <code class="filename">/branches</code> URL wird
        die gesamte Geschichte des Zweiges anzeigen. Ihr Zweig kann
        eines Tages sogar wiederbelebt werden, sollten Sie dieses
        wünschen (siehe <a class="xref" href="svn.branchmerge.html#svn.branchmerge.basicmerging.resurrect" title="4.3.5. Zurückholen gelöschter Objekte">Abschnitt 4.3.5, &#8222;Zurückholen gelöschter Objekte&#8220;</a>).</p>
<p>Sobald in Subversion 1.5 eine Zusammenführung mit
        <code class="option">--reintegrate</code> vom Zweig auf den Stamm
        durchgeführt wurde, kann der Zweig nicht mehr für weitere
        Arbeiten verwendet werden. Er kann weder Änderungen vom Stamm
        korrekt absorbieren, noch kann er ordentlich auf den Stamm
        zurückintegriert werden. Aus diesem Grund sollten Sie ihn
        zerstören und erneut aus dem Stamm erzeugen, wenn Sie weiter
        auf dem Zweig arbeiten wollen:</p>
<pre class="screen">
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
      -m "my-calc-branch löschen."
Revision 392 übertragen.

$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/new-branch
      -m "Einen neuen Zweig von trunk anlegen."
Revision 393 übertragen.

$ cd my-calc-branch

$ svn switch http://svn.example.com/repos/calc/branches/new-branch
Aktualisiert zu Revision 393.
</pre>
<p>Der letzte Befehl des vorangegangenen Beispiels &#8211;
        <span class="command"><strong>svn switch</strong></span> &#8211; ist eine Art, ein
        bestehendes Arbeitsverzeichnis auf ein unterschiedliches
        Repository-Verzeichnis zu aktualisieren.  Wir werden das
        genauer in <a class="xref" href="svn.branchmerge.html#svn.branchmerge.switchwc" title="4.5. Zweige durchlaufen">Abschnitt 4.5, &#8222;Zweige durchlaufen&#8220;</a>
        besprechen.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.basicmerging.mergeinfo"></a>4.3.3. Mergeinfo und Vorschauen</h3></div></div></div>
<p>Der grundsätzliche Mechanismus, den Subversion verwendet,
        um Änderungsmengen zu verfolgen &#8211; d.h. welche Änderungen
        auf welchen Zweig übertragen worden sind &#8211; besteht aus
        dem Festhalten von Daten in Eigenschaften. Daten über das
        Zusammenführen werden speziell in der Eigenschaft
        <code class="literal">svn:mergeinfo</code> vermerkt, die an Dateien und
        Verzeichnissen hängt. (Falls Sie mit Subversion-Eigenschaften
        nicht vertraut sind, ist es nun an der Zeit, <a class="xref" href="svn.advanced.html#svn.advanced.props" title="3.2. Properties">Abschnitt 3.2, &#8222;Properties&#8220;</a> zu überfliegen.)</p>
<p>Sie können sich die Eigenschaft ansehen, wie jede andere
        auch:</p>
<pre class="screen">
$ cd my-calc-branch
$ svn propget svn:mergeinfo .
/trunk:341-390
</pre>
<p>Es wird <span class="emphasis"><em>nicht</em></span> empfohlen, dass Sie
        selbst den Wert dieser Eigenschaft ändern, es sei denn, Sie
        wissen wirklich, was Sie tun. Diese Eigenschaft wird
        automatisch von Subversion gepflegt, sobald Sie den Befehl
        <span class="command"><strong>svn merge</strong></span> ausführen. Ihr Wert gibt
        Aufschluss darüber, welche Änderungen (von einem gegebenen
        Pfad) mit dem in Frage kommenden Verzeichnis abgeglichen
        wurden. In diesem Fall ist der Pfad
        <code class="filename">/trunk</code>, und das Verzeichnis, das die
        bestimmten Änderungen erhalten hat, ist
        <code class="filename">/branches/my-calc-branch</code>.</p>
<p>Es gibt auch einen Unterbefehl, <span class="command"><strong>svn
        mergeinfo</strong></span>, der hilfreich dabei ist, nicht nur die
        Änderungsmengen anzuzeigen, die ein Verzeichnis absorbiert
        hat, sondern auch, welche Änderungsmengen für einen Abgleich
        noch in Frage kommen. Das ergibt eine Art Vorschau der
        nächsten Änderungsmengen, die <span class="command"><strong>svn merge</strong></span> auf
        Ihren Zweig abgleichen wird.</p>
<pre class="screen">
$ cd my-calc-branch

# Welche Änderungen wurden bereits vom Stamm auf den Zweig abgeglichen?
$ svn mergeinfo http://svn.example.com/repos/calc/trunk
r341
r342
r343
&#8230;
r388
r389
r390

# Welche Änderungen kommen für einen Abgleich vom Stamm auf den Zweig noch in Frage?
$ svn mergeinfo http://svn.example.com/repos/calc/trunk --show-revs eligible
r391
r392
r393
r394
r395
</pre>
<p>Der Befehl <span class="command"><strong>svn mergeinfo</strong></span> erwartet einen
        &#8222;<span class="quote">Quell</span>&#8220;-URL (woher die Änderungen kommen würden)
        und einen optionalen &#8222;<span class="quote">Ziel</span>&#8220;-URL (wohin die
        Änderungen abgeglichen würden). Falls kein Ziel-URL angegeben
        ist, wird angenommen, dass das aktuelle Arbeitsverzeichnis das
        Ziel ist. Weil wir im vorangegangenen Beispiel unser
        Arbeitsverzeichnis vom Zweig abfragen, geht der Befehl davon
        aus, dass wir daran interessiert sind, Änderungen für
        <code class="filename">/branches/mybranch</code> vom angegebenen
        Stamm-URL zu erhalten.</p>
<p>Eine andere Methode, eine genauere Vorschau auf einen
        Abgleich zu bekommen, ist die Verwendung der Option
        <code class="option">--dry-run</code>:</p>
<pre class="screen">
$ svn merge http://svn.example.com/repos/calc/trunk --dry-run
U    integer.c

$ svn status
#  es wird nichts ausgegeben, die Arbeitskopie ist unverändert
</pre>
<p>Die Option <code class="option">--dry-run</code> macht tatsächlich
        überhaupt keine lokalen Änderungen an der Arbeitskopie. Sie
        zeigt nur Status-Codes, die ausgegeben
        <span class="emphasis"><em>würden</em></span>, wenn ein echter Abgleich
        stattfände. Sie ist nützlich, um eine Vorschau für einen
        möglichen Abgleich auf &#8222;<span class="quote">hoher Ebene</span>&#8220; zu erhalten,
        falls <span class="command"><strong>svn diff</strong></span> zu detailliert wäre.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tipp]" src="images/tip.png"></td>
<th align="left">Tipp</th>
</tr>
<tr><td align="left" valign="top"><p>Nach dem Durchführen eines Abgleichs, aber vor der
          Übergabe des Ergebnisses, können Sie <strong class="userinput"><code>svn diff
          --depth=empty
          <em class="replaceable"><code>/pfad/zum/abgleichs/ziel</code></em></code></strong>
          verwenden, um nur die Änderungen am unmittelbaren Ziel des
          Abgleichs zu sehen. Falls das Ziel ein Verzeichnis war,
          werden nur Unterschiede von Eigenschaften angezeigt. Das ist
          eine praktische Methode, um sich die Änderungen an der
          Eigenschaft <code class="literal">svn:mergeinfo</code> anzusehen, die
          dort durch den Abgleich vermerkt wurden, und die Sie daran
          erinnern, was Sie eben abgeglichen haben.</p></td></tr>
</table></div>
<p>Natürlich ist die beste Methode, eine Vorschau eines
        Abgleichs zu erhalten, ihn zu machen! Denken Sie daran, dass
        der Aufruf von <span class="command"><strong>svn merge</strong></span> an sich nichts
        Riskantes ist (es sei denn, sie haben lokale Änderungen an
        Ihrer Arbeitskopie gemacht &#8211; aber wir haben bereits
        betont, dass Sie in eine derartige Umgebung nicht abgleichen
        sollten). Falls Ihnen das Ergebnis des Abgleichs nicht
        gefallen sollte, rufen Sie einfach <strong class="userinput"><code>svn revert
        . -R</code></strong> auf, um die Änderungen an Ihrer Arbeitskopie
        rückgängig zu machen, und versuchen Sie den Befehl erneut mit
        unterschiedlichen Optionen. Der Abgleich ist solange nicht
        endgültig, bis Sie mit <span class="command"><strong>svn commit</strong></span> das
        Ergebnis übergeben.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tipp]" src="images/tip.png"></td>
<th align="left">Tipp</th>
</tr>
<tr><td align="left" valign="top"><p>Während es vollkommen in Ordnung ist, durch wiederholte
          Aufrufe von <span class="command"><strong>svn merge</strong></span> und <span class="command"><strong>svn
          revert</strong></span> mit Abgleichen zu experimentieren, könnte
          es allerdings sein, dass Sie über einige lästige (aber
          leicht zu umgehende) Fallstricke stolpern. Wenn zum Beispiel
          durch den Abgleich eine neue Datei hinzugefügt wird (d.h.,
          sie wird zum Hinzufügen markiert), so wird <span class="command"><strong>svn
          revert</strong></span> sie nicht wirklich entfernen; es entfernt
          lediglich die Markierung zum Hinzufügen. Was übrig bleibt,
          ist eine unversionierte Datei. Wenn Sie dann den Abgleich
          erneut versuchen, könnten Sie einen Konflikt bekommen, weil
          die unversionierte Datei &#8222;<span class="quote">im Weg steht</span>&#8220;. Die
          Lösung? Nach dem Rückgängigmachen sollten Sie die
          Arbeitskopie aufräumen und unversionierte Dateien und
          Verzeichnisse entfernen. Die Ausgabe von <span class="command"><strong>svn
          status</strong></span> sollte so sauber wie möglich sein und
          idealerweise gar nichts anzeigen.</p></td></tr>
</table></div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.basicmerging.undo"></a>4.3.4. Änderungen rückgängig machen</h3></div></div></div>
<p>Sehr häufig wird <span class="command"><strong>svn merge</strong></span> verwendet,
        um eine Änderung rückgängig zu machen, die bereits an das
        Repository übergeben worden war. Nehmen wir einmal an, Sie
        arbeiten fröhlich in einer Arbeitskopie von
        <code class="filename">/calc/trunk</code> und entdecken, dass die
        damalige Änderung an <code class="filename">integer.c</code> in
        Revision 303 völlig falsch war. Sie hätte nie übergeben werden
        sollen. Sie können <span class="command"><strong>svn merge</strong></span> verwenden, um
        die Änderung in Ihrer Arbeitskopie
        &#8222;<span class="quote">zurückzunehmen</span>&#8220;, und dann die lokale Änderung an
        das Repository übergeben. Alles, was Sie hierfür tun müssen,
        ist, eine <span class="emphasis"><em>umgekehrte</em></span> Differenz anzugeben.
        (Sie machen das durch die Angabe von <code class="option">--revision
        303:302</code> oder durch das äquivalente <code class="option">--change
        -303</code>.)</p>
<pre class="screen">
$ svn merge -c -303 http://svn.example.com/repos/calc/trunk
--- Reverse-merging r303 into 'integer.c':
-- Rückwärtiges Zusammenführen von r303 in »integer.c«:
U    integer.c

$ svn status
 M     .
M      integer.c

$ svn diff
&#8230;
# überprüfen, ob die Änderung entfernt wurde
&#8230;

$ svn commit -m "Änderung aus in r303 rückgängig machen."
Sende          integer.c
Übertrage Daten .
Revision 350 übertragen.
</pre>
<p>Wie wir früher bereits erwähnten, kann man eine
        Repository-Version als eine bestimmte Änderungsmenge
        betrachten. Bei Verwendung der Option <code class="option">-r</code> wird
        <span class="command"><strong>svn merge</strong></span> aufgefordert, eine Änderungsmenge
        oder ein ganzes Intervall von Änderungsmengen auf Ihre
        Arbeitskopie anzuwenden. In unserem Fall, bei dem wir eine
        Änderung zurücknehmen, fordern wir <span class="command"><strong>svn
        merge</strong></span> auf, die Änderungsmenge #303
        <span class="emphasis"><em>rückwärts</em></span> auf unsere Arbeitskopie
        anzuwenden.</p>
<p>Merken Sie sich, dass ein solches Rückgängigmachen wie
        jeder andere <span class="command"><strong>svn merge</strong></span>-Vorgang ist, so dass
        Sie <span class="command"><strong>svn status</strong></span> und <span class="command"><strong>svn
        diff</strong></span> benutzen sollten, um sicherzustellen, dass Ihre
        Arbeit in dem Zustand ist, den Sie haben möchten, und
        verwenden Sie anschließend <span class="command"><strong>svn commit</strong></span>, um
        die endgültige Version in das Repository zu bringen. Nach der
        Übergabe wird sich diese bestimmte Änderungsmenge nicht mehr
        in der <code class="literal">HEAD</code>-Revision wiederfinden.</p>
<p>Nun denken Sie vielleicht: Gut, aber das hat doch nicht
        wirklich die Übergabe rückgängig gemacht, oder? Die Änderung
        besteht immer noch in Revision 303. Falls jemand eine Version
        des Projektes <code class="filename">calc</code> zwischen den
        Revisionen 303 und 349 auscheckt, wird doch trotzdem die
        fehlerhafte Änderung sichtbar, oder nicht?</p>
<p>Ja, das stimmt. Wenn wir davon sprechen, eine Änderung zu
        &#8222;<span class="quote">entfernen</span>&#8220;, sprechen wir eigentlich darüber, sie
        aus der <code class="literal">HEAD</code>-Revision zu entfernen. Die
        ursprüngliche Änderung besteht immer noch in der Geschichte
        des Repositorys. Für die meisten Situationen ist das
        ausreichend. Die meisten Leute sind sowieso nur am
        <code class="literal">HEAD</code> eines Projektes interessiert. Es gibt
        jedoch Spezialfälle, in denen Sie wirklich alle Beweise der
        Übergabe vernichten möchten.  (Vielleicht hat jemand ein
        vertrauliches Dokument in das Repository übergeben.) Das ist
        leider nicht so einfach, da Subversion absichtlich so
        konstruiert wurde, dass es niemals Informationen
        verliert. Revisionen sind unveränderliche Bäume, die
        aufeinander aufbauen. Die Beseitigung einer Revision aus der
        Geschichte würde einen Dominoeffekt auslösen, Chaos in allen
        nachfolgenden Revisionen anrichten und möglicherweise alle
        Arbeitskopien ungültig machen.
        <sup>[<a name="id386707" href="#ftn.id386707" class="footnote">21</a>]</sup>
      </p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.basicmerging.resurrect"></a>4.3.5. Zurückholen gelöschter Objekte</h3></div></div></div>
<p>Das Tolle an Versionskontrollsystemen ist, dass
        Informationen nie verlorengehen. Selbst wenn Sie eine Datei
        oder ein Verzeichnis löschen, ist es zwar nicht mehr in der
        <code class="literal">HEAD</code>-Revision vorhanden, jedoch noch in
        früheren Revisionen. Eine der häufigsten Fragen neuer Benutzer
        ist: &#8222;<span class="quote">Wie bekomme ich meine alte Datei oder mein altes
        Verzeichnis zurück?</span>&#8220;</p>
<p>Der erste Schritt ist es, genau zu definieren
        <span class="emphasis"><em>welches</em></span> Objekt Sie zurückholen
        möchten. Hier ist eine nützliche Metapher: Sie können sich
        vorstellen, dass jedes Objekt im Repository in einem
        zweidimensionalen Koordinatensystem befindet. Die erste
        Koordinate ist ein bestimmter Revisionsbaum und die zweite
        Koordinate ist ein Pfad innerhalb dieses Baumes. So kann jede
        Version Ihrer Datei oder Ihres Verzeichnisses durch ein
        bestimmtes Koordinatenpaar definiert werden. (Erinnern Sie
        sich an die Syntax einer &#8222;<span class="quote">Peg-Revision</span>&#8220; &#8211;
        foo.c@224 &#8211; die in <a class="xref" href="svn.advanced.html#svn.advanced.pegrevs" title="3.9. Peg and Operative Revisions">Abschnitt 3.9, &#8222;Peg and Operative Revisions&#8220;</a> erwähnt wurde.) </p>
<p>Zunächst sollten Sie <span class="command"><strong>svn log</strong></span> benutzen,
        um das exakte Koordinatenpaar zu ermitteln, das Sie
        zurückholen wollen. Eine gute Strategie ist es, <strong class="userinput"><code>svn
        log --verbose</code></strong> in einem Verzeichnis aufzurufen, in
        dem das gelöschte Objekt einmal enthalten war. Die Option
        <code class="option">--verbose</code> (<code class="option">-v</code>) gibt eine
        Liste aller geänderten Objekte in jeder Revision aus; Sie
        müssen nur noch die Revision finden, in der Sie die Datei oder
        das Verzeichnis gelöscht haben. Sie können das visuell tun
        oder ein Werkzeug zur Untersuchung der Protokollausgaben
        einsetzen (mit <span class="command"><strong>grep</strong></span> oder vielleicht durch
        eine inkrementelle Suche in einem Editor).</p>
<pre class="screen">
$ cd parent-dir
$ svn log -v
&#8230;
------------------------------------------------------------------------
r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines
Geänderte Pfade:
   D /calc/trunk/real.c
   M /calc/trunk/integer.c

Schnelle Funktionen zur Fourier-Transformation zu integer.c hinzugefügt.
real.c gelöscht, da Code jetzt in double.c.
&#8230;
</pre>
<p>In diesem Beispiel nehmen wir an, dass Sie nach der
        gelöschten Datei <code class="filename">real.c</code> suchen. Beim
        Durchsehen der Protokolle des Elternverzeichnisses haben Sie
        entdeckt, dass diese Datei in Revision 808 gelöscht
        wurde. Daher war die letzte Revision in der die Datei noch
        vorhanden war die unmittelbare Vorgänger-Revision. Die
        Schlussfolgerung: Sie möchten den Pfad
        <code class="filename">/calc/trunk/real.c</code> aus Revision 807
        zurückholen.</p>
<p>Das war der schwierige Teil &#8211; die
        Nachforschung. Nun, da Sie wissen, was Sie wiederherstellen
        wollen, haben Sie die Wahl zwischen zwei verschiedenen
        Methoden.</p>
<p>Die eine Option ist, <span class="command"><strong>svn merge</strong></span> zu
        verwenden, um Revision 808 &#8222;<span class="quote">rückwärts</span>&#8220;
        anzuwenden. (Wir haben bereits in
        <a class="xref" href="svn.branchmerge.html#svn.branchmerge.basicmerging.undo" title="4.3.4. Änderungen rückgängig machen">Abschnitt 4.3.4, &#8222;Änderungen rückgängig machen&#8220;</a>
        besprochen, wie Änderungen rückgängig gemacht werden.) Das
        hätte den Effekt, <code class="filename">real.c</code> als lokale
        Änderung erneut hinzuzufügen. Die Datei würde zum Hinzufügen
        ins Repository markiert, und nach der Übergabe wäre die Datei
        wieder in <code class="literal">HEAD</code> vorhanden.</p>
<p>In diesem besonderen Beispiel ist das aber wahrscheinlich
        nicht die beste Strategie. Die Rückwärts-Anwendung von
        Revision 808 würde nicht nur <code class="filename">real.c</code> zum
        Hinzufügen markieren, sondern, wie aus den Protokollmeldungen
        hervorgeht, dass ebenso bestimmte Änderungen an
        <code class="filename">integer.c</code> zurücknehmen, was Sie aber
        nicht wollen. Sie können sicherlich Revision 808 rückwärts
        anwenden und dann mit <span class="command"><strong>svn revert</strong></span> die
        lokalen Änderungen an <code class="filename">integer.c</code>
        zurücknehmen; allerdings ist diese Technik nicht sehr
        effektiv. Was wäre, wenn 90 Dateien in Revision 808 geändert
        worden wären?</p>
<p>Eine zweite, zielorientiertere, Strategie ist es, den
        Befehl <span class="command"><strong>svn merge</strong></span> überhaupt nicht zu
        verwenden, sondern stattdessen <span class="command"><strong>svn
        copy</strong></span>. Kopieren Sie einfach das exakte
        &#8222;<span class="quote">Koordinatenpaar</span>&#8220; aus Revision und Pfad vom
        Repository in Ihre Arbeitskopie:</p>
<pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk/real.c@807 ./real.c

$ svn status
A  +   real.c

$ svn commit -m "real.c aus revision 807 wiederhergestellt, /calc/trunk/real.c."
Hinzufügen     real.c
Übertrage Daten .
Revision 1390 übertragen.
</pre>
<p>Das Plus-Zeichen in der Statusausgabe zeigt an, dass das
        Objekt nicht bloß zu Hinzufügen vorgemerkt ist, sondern zum
        Hinzufügen &#8222;<span class="quote">mit Geschichte</span>&#8220;. Subversion merkt
        sich, woher es kopiert wurde. Künftig wird beim Anwenden von
        <span class="command"><strong>svn log</strong></span> auf diese Datei die gesamte
        Geschichte, über das Zurückholen hinweg, inklusive der
        Geschichte vor Revision 807 durchlaufen. In anderen Worten,
        dieses neue <code class="filename">real.c</code> ist nicht wirklich
        neu; es ist ein direkter Nachfahre der ursprünglichen,
        gelöschten Datei. Dies ist normalerweise eine gute und
        nützliche Sache. Falls Sie jedoch die Datei
        <span class="emphasis"><em>ohne</em></span> geschichtliche Verbindung zur alten
        Datei zurückholen wollen, funktioniert diese Technik
        ebensogut:</p>
<pre class="screen">
$ svn cat http://svn.example.com/repos/calc/trunk/real.c@807 &gt; ./real.c

$ svn add real.c
A         real.c

$ svn commit -m "real.c aus Revision 807 wiederhergestellt."
Hinzufügen     real.c
Übertrage Daten .
Revision 1390 übertragen.
</pre>
<p>Obwohl unser Beispiel zeigt, wie eine Datei zurückgeholt
        wird, sollten sie beachten, dass dieselben Techniken auch beim
        Wiederherstellen von gelöschten Verzeichnissen
        funktionieren. Beachten Sie auch, dass die Wiederherstellung
        nicht unbedingt in Ihrer Arbeitskopie passieren muss &#8211;
        sie kann auch vollständig im Repository ausgeführt
        werden:</p>
<pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk/real.c@807 \
           http://svn.example.com/repos/calc/trunk/ \
      -m "real.c aus Revision 807 wiederhergestellt."
Revision 1390 übertragen.

$ svn update
A    real.c
Aktualisiert zu Revision 1390.
</pre>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.advanced"></a>4.4. Fortgeschrittenes Zusammenführen</h2></div></div></div>
<p>Hier endet die automatische Magie. Früher oder später,
      sobald Sie den Dreh beim Verzweigen und Zusammenführen heraus
      haben, werden Sie Subversion fragen müssen,
      <span class="emphasis"><em>bestimmte</em></span> Änderungen von einem Ort zum
      anderen zusammenzuführen. Um dies tun zu können, werden Sie
      damit beginnen müssen, kompliziertere Argumente an <span class="command"><strong>svn
      merge</strong></span> zu übergeben. Der nächste Abschnitt beschreibt
      die vollständig erweiterte Syntax des Befehls und behandelt eine
      Anzahl verbreiteter Szenarien, die diese benötigen.</p>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.cherrypicking"></a>4.4.1. Die Rosinen herauspicken</h3></div></div></div>
<p>Genauso oft wie der Begriff &#8222;<span class="quote">Änderungsmenge</span>&#8220;
        wird die Wendung <em class="firstterm">die Rosinen
        herauspicken</em> in Versionskontrollsystemen
        verwendet. Das bezieht sich darauf, <span class="emphasis"><em>eine</em></span>
        bestimmte Änderungsmenge von einem Zweig auszuwählen und sie
        auf einen anderen anzuwenden. Die Rosinen herauszupicken kann
        sich auch darauf beziehen, eine bestimmte Menge von (nicht
        notwendigerweise angrenzenden) Änderungsmengen von einem auf
        einen anderen Zweig zu duplizieren. Dies steht im Gegensatz zu
        den üblicheren Zusammenführungs-Szenarien, bei denen der
        &#8222;<span class="quote">nächste</span>&#8220; zusammenhängende Bereich von Revisionen
        automatisch dupliziert wird.</p>
<p>Warum sollte jemand nur eine einzelne Änderung wollen? Das
        kommt häufiger vor, als Sie denken. Gehen wir beispielsweise
        einmal zurück in die Vergangenheit und stellen uns vor, dass
        Sie Ihren Zweig noch nicht wieder mit dem Stamm
        zusammengeführt hätten. In der Kaffeeküche bekommen Sie mit,
        dass Sally eine interessante Änderung an
        <code class="filename">integer.c</code> auf dem Stamm gemacht hat. Als
        Sie sich die Geschichte der Übergaben auf dem Stamm ansehen,
        entdecken Sie, dass sie in Revision 355 einen kritischen
        Fehler beseitigt hat, der direkte Auswirkungen auf die
        Funktion hat, an der Sie gerade arbeiten. Es kann sein, dass
        Sie noch nicht bereit sind, alle Änderungen vom Stamm zu
        übernehmen, jedoch benötigen Sie diese bestimmte
        Fehlerbehebung, um mit Ihrer Arbeit weitermachen zu
        können.</p>
<pre class="screen">
$ svn diff -c 355 http://svn.example.com/repos/calc/trunk

Index: integer.c
===================================================================
--- integer.c   (revision 354)
+++ integer.c   (revision 355)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info-&gt;operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info-&gt;operating_system, "Macintosh"); break;
     case 8:  sprintf(info-&gt;operating_system, "Z-System"); break;
-    case 9:  sprintf(info-&gt;operating_system, "CP/MM");
+    case 9:  sprintf(info-&gt;operating_system, "CP/M"); break;
     case 10:  sprintf(info-&gt;operating_system, "TOPS-20"); break;
     case 11:  sprintf(info-&gt;operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info-&gt;operating_system, "QDOS"); break;
</pre>
<p>Ebenso wie Sie <span class="command"><strong>svn diff</strong></span> im vorigen
        Beispiel benutzt haben, um sich Revision 355 anzusehen, können
        Sie die gleiche Option an <span class="command"><strong>svn merge</strong></span>
        übergeben:</p>
<pre class="screen">
$ svn merge -c 355 http://svn.example.com/repos/calc/trunk
U    integer.c

$ svn status
M      integer.c
</pre>
<p>Sie können nun Ihre üblichen Tests durchführen, bevor Sie
        diese Änderung an den Zweig übergeben. Nach der Übergabe merkt
        sich Subversion, dass r355 mit dem Zweig zusammengeführt
        wurde, so dass künftige &#8222;<span class="quote">magische</span>&#8220;
        Zusammenführungen, die Ihren Zweig mit dem Stamm
        synchronisieren, r355 überspringen. (Das Zusammenführen
        derselben Änderung auf denselben Zweig führt fast immer zu
        einem Konflikt!)</p>
<pre class="screen">
$ cd my-calc-branch

$ svn propget svn:mergeinfo .
/trunk:341-349,355

# Beachten Sie, dass r355 nicht als Zusammenführungs-Kandidat aufgeführt wird
# da es bereits zusammengeführt wurde.
$ svn mergeinfo http://svn.example.com/repos/calc/trunk --show-revs eligible
r350
r351
r352
r353
r354
r356
r357
r358
r359
r360

$ svn merge http://svn.example.com/repos/calc/trunk
--- Zusammenführen von r350 bis r354 in ».«:
 U   .
U    integer.c
U    Makefile
--- Zusammenführen von r356 bis r360 in ».«:
 U   .
U    integer.c
U    button.c
</pre>
<p>Dieser Anwendungsfall des Abgleichens (oder
        <em class="firstterm">Nachziehens</em>) von Fehlerbehebungen von
        einem Zweig zu einem anderen ist vielleicht der gängigste Grund
        für Änderungen, die Rosinen herauszupicken; es kommt ständig
        vor, beispielsweise, wenn ein Team einen
        &#8222;<span class="quote">Software-Release-Zweig</span>&#8220; verwendet.  (Wir
        erörtern dieses Muster in <a class="xref" href="svn.branchmerge.html#svn.branchmerge.commonpatterns.release" title="4.8.1. Release-Zweige">Abschnitt 4.8.1, &#8222;Release-Zweige&#8220;</a>.)</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warnung]" src="images/warning.png"></td>
<th align="left">Warnung</th>
</tr>
<tr><td align="left" valign="top"><p>Haben Sie bemerkt, wie im letzten Beispiel der Aufruf
          von <span class="command"><strong>svn merge</strong></span> dazu geführt hat, zwei
          unterschiedliche Abgleichsintervalle anzuwenden? Der Befehl
          führte zwei unabhängige Patches auf Ihrer Arbeitskopie aus,
          um die Änderungsmenge 355 zu überspringen, die Ihr Zweig
          bereits beinhaltete. An und für sich ist daran nichts
          falsch, bis auf die Tatsache, dass die Möglichkeit besteht,
          eine Konfliktauflösung komplizierter zu machen. Falls das
          erste Änderungsintervall Konflikte erzeugt,
          <span class="emphasis"><em>müssen</em></span> Sie diese interaktiv auflösen,
          um die Zusammenführung fortzusetzen und das zweite
          Änderungsintervall anzuwenden. Wenn Sie die
          Konfliktauflösung der ersten Phase aufschieben, wird der
          komplette Zusammenführungsbefehl mit einer Fehlermeldung
          abbrechen.
          <sup>[<a name="id387341" href="#ftn.id387341" class="footnote">22</a>]</sup> 
        </p></td></tr>
</table></div>
<p>Ein Wort zur Warnung: Während <span class="command"><strong>svn diff</strong></span>
        und <span class="command"><strong>svn merge</strong></span> vom Konzept her sehr ähnlich
        sind, haben sie in vielen Fällen eine unterschiedliche Syntax.
        Gehen Sie sicher, dass Sie Details hierzu in <a class="xref" href="svn.ref.html" title="Kapitel 9. Subversion Complete Reference">Kapitel 9, <i>Subversion Complete Reference</i></a> nachlesen oder <span class="command"><strong>svn help</strong></span>
        fragen.  Zum Beispiel benötigt <span class="command"><strong>svn merge</strong></span>
        einen Pfad in der Arbeitskopie als Ziel, d.h., einen Ort, an
        dem es den erzeugten Patch anwenden kann.  Falls das Ziel
        nicht angegeben wird, nimmt es an, dass Sie eine der folgenden
        häufigen Operationen durchführen möchten:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Sie möchten Verzeichnisänderungen auf Ihr aktuelles
            Arbeitsverzeichnis abgleichen.</p></li>
<li><p>Sie möchten die Änderungen in einer bestimmten Datei
            mit einer Datei gleichen Namens in Ihrem aktuellen
            Arbeitsverzeichnis zusammenführen.</p></li>
</ul></div>
<p>Falls Sie ein Verzeichnis zusammenführen und keinen
        Zielpfad angegeben haben, nimmt <span class="command"><strong>svn merge</strong></span>
        den ersten Fall an und versucht, die Änderungen auf Ihr
        aktuelles Arbeitsverzeichnis anzuwenden. Falls Sie eine Datei
        zusammenführen und diese Datei (oder eine gleichnamige Datei)
        in Ihrem aktuellen Arbeitsverzeichnis existiert, nimmt
        <span class="command"><strong>svn merge</strong></span> den zweiten Fall an und wendet
        die Änderungen auf eine lokale Datei gleichen Namens
        an.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.advancedsyntax"></a>4.4.2. Merge-Syntax: Die vollständige Enthüllung</h3></div></div></div>
<p>Sie haben nun einige Beispiele zum Befehl <span class="command"><strong>svn
        merge</strong></span> gesehen und werden bald einige mehr sehen.
        Falls Sie verwirrt darüber sind, wie das Zusammenführen genau
        funktioniert, sind Sie nicht alleine. Viele Anwender
        (besonders diejenigen, für die Versionskontrolle etwas Neues
        ist) sind anfangs verwirrt darüber, wie die korrekte Syntax
        des Befehls lautet und wann das Feature verwendet werden soll.
        Aber, keine Angst, dieser Befehl ist tatsächlich viel
        einfacher als Sie denken! Es gibt eine einfache Technik, die
        verstehen hilft, wie sich <span class="command"><strong>svn merge</strong></span> genau
        verhält.</p>
<p>Die Hauptquelle der Verwirrung ist der
        <span class="emphasis"><em>Name</em></span> des Befehls.  Der Begriff
        &#8222;<span class="quote">merge</span>&#8220; (Zusammenführung, Mischung) deutet
        irgendwie an, dass Zweige miteinander verschmolzen werden,
        oder dass irgendeine geheimnisvolle Mischung der Daten
        erfolgt. Das ist nicht der Fall. Ein besserer Name für den
        Befehl wäre vielleicht <span class="command"><strong>svn
          ermittele-die-Unterschiede-und-wende-sie-an</strong></span>
        gewesen, da das alles ist, was passiert: Die Bäume im
        Repository werden verglichen und die Unterschiede in eine
        Arbeitskopie eingearbeitet.</p>
<p>Falls Sie <span class="command"><strong>svn merge</strong></span> benutzen, um
        einfache Kopien von Änderungen zwischen Zweigen vorzunehmen,
        wird es üblicherweise automatisch das Richtige machen.
        Beispielsweise wird ein Befehl wie der folgende:</p>
<pre class="screen">
$ svn merge http://svn.example.com/repos/calc/some-branch
</pre>
<p>versuchen, alle Änderungen, die auf
        <code class="filename">some-branch</code> gemacht worden sind, in Ihr
        aktuelles Arbeitsverzeichnis zu kopieren, welches vermutlich
        eine Arbeitskopie ist, die mit dem Zweig irgendeine
        historische Verbindung teilt. Der Befehl ist klug genug, nur
        die Änderungen zu kopieren, die Ihre Arbeitskopie noch nicht
        hat. Wenn Sie diesen Befehl einmal die Woche wiederholen, wird
        er nur die &#8222;<span class="quote">neuesten</span>&#8220; Änderungen vom Zweig
        kopieren, die seit Ihrem letzten Zusammenführen
        stattfanden.</p>
<p>Wenn Sie den Befehl <span class="command"><strong>svn merge</strong></span> in seiner
        ganzen Pracht wählen, indem Sie ihm bestimmte
        Revisionsintervalle zum kopieren übergeben, benötigt der
        Befehl drei Hauptargumente:</p>
<div class="orderedlist"><ol type="1">
<li><p>Einen Anfangsbaum im Repository (häufig
        <em class="firstterm">linke Seite</em> des Vergleichs
        genannt)</p></li>
<li><p>Einen Endbaum im Repository (häufig
        <em class="firstterm">rechte Seite</em> des Vergleichs
        genannt)</p></li>
<li><p>Eine Arbeitskopie, die die Unterschiede als
        lokale Änderungen aufnimmt (häufig <em class="firstterm">Ziel</em>
        der Zusammenführung genannt)</p></li>
</ol></div>
<p>Sobald diese drei Argumente angegeben sind, werden die
        zwei Bäume miteinander verglichen und die Unterschiede als
        lokale Änderungen auf die Ziel-Arbeitskopie angewendet. Wenn
        der Befehl fertig ist, sieht das Ergebnis so aus, als hätten
        Sie die Dateien manuell editiert oder verschiedene
        <span class="command"><strong>svn add</strong></span>- oder <span class="command"><strong>svn
          delete</strong></span>-Befehle ausgeführt. Wenn Ihnen das Ergebnis
        gefällt, können Sie es übergeben. Falls nicht, können Sie
        einfach mit <span class="command"><strong>svn revert</strong></span> alle Änderungen
        rückgängig machen.</p>
<p>Die Syntax von <span class="command"><strong>svn merge</strong></span> erlaubt Ihnen,
        die drei notwendigen Argumente auf eine recht flexible Weise
        anzugeben. Hier sind einige Beispiele:</p>
<pre class="screen">
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
</pre>
<p>Die erste Syntax führt alle drei Argumente explizit auf,
        indem jeder Baum mit dem Format <span class="emphasis"><em>URL@REV</em></span>
        bezeichnet und die Ziel-Arbeitskopie angegeben wird. Die
        zweite Syntax kann als Kurzform verwendet werden, wenn Sie
        zwei unterschiedliche Revisionen desselben URL vergleichen.
        Die letzte Syntax zeigt, dass das Arbeitskopie-Argument
        optional ist; entfällt es, wird das aktuelle Verzeichnis
        genommen.</p>
<p>Obwohl das erste Beispiel die &#8222;<span class="quote">vollständige</span>&#8220;
        Syntax von <span class="command"><strong>svn merge</strong></span> zeigt, muss sie sehr
        sorgfältig verwendet werden; es können hierbei
        Zusammenführungen entstehen, bei denen keinerlei
        <code class="literal">svn:mergeinfo</code> Metadaten aufgezeichnet
        werden. Der nächste Abschnitt geht näher darauf ein.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.nomergedata"></a>4.4.3. Zusammenführen ohne Mergeinfo</h3></div></div></div>
<p>Subversion versucht immer wenn es kann, Metadaten über das
        Zusammenführen zu erzeugen, um spätere Aufrufe von
        <span class="command"><strong>svn merge</strong></span> schlauer zu machen. Trotzdem
        gibt es Situationen, in denen
        <code class="literal">svn:mergeinfo</code>-Daten nicht erzeugt oder
        geändert werden.  Denken Sie daran, vor diesen Szenarien auf
        der Hut zu sein:</p>
<div class="variablelist"><dl>
<dt><span class="term">Zusammenführen von Quellen ohne Beziehung</span></dt>
<dd><p>Falls Sie <span class="command"><strong>svn merge</strong></span> dazu
            auffordern, zwei URLs zu vergleichen, die nicht
            miteinander in Beziehung stehen, wird trotzdem ein Patch
            erzeugt und auf die Arbeitskopie angewendet, allerdings
            werden keine Metadaten erzeugt. Es gibt keine gemeinsame
            Geschichte der zwei Quellen, und spätere
            &#8222;<span class="quote">schlaue</span>&#8220; Zusammenführungen hängen von dieser
            gemeinsamen Geschichte ab.</p></dd>
<dt><span class="term">Zusammenführen aus fremden Repositorys</span></dt>
<dd><p>Obwohl es möglich ist, einen Befehl wie <strong class="userinput"><code>svn
              merge -r 100:200
              <em class="replaceable"><code>http://svn.foreignproject.com/repos/trunk</code></em></code></strong>
            auszuführen, wird auch dieser resultierende Patch keine
            historischen Metadaten über die Zusammenführung haben.
            Zum gegenwärtigen Zeitpunkt hat Subversion keine
            Möglichkeit, unterschiedliche Repository-URLs innerhalb
            des <code class="literal">svn:mergeinfo</code>-Propertys zu
            repräsentieren.</p></dd>
<dt><span class="term">Verwendung von <code class="option">--ignore-ancestry</code></span></dt>
<dd><p>Wenn diese Option an <span class="command"><strong>svn merge</strong></span>
            übergeben wird, veranlasst das die Zusammenführungs-Logik,
            ohne nachzudenken Unterschiede auf dieselbe Art zu
            erzeugen, wie es <span class="command"><strong>svn diff</strong></span> macht, und
            ignoriert dabei irgendwelche historischen Verbindungen.
            Wir werden das später in diesem Kapitel in <a class="xref" href="svn.branchmerge.html#svn.branchmerge.advanced.ancestry" title="4.4.7. Die Abstammung berücksichtigen oder ignorieren">Abschnitt 4.4.7, &#8222;Die Abstammung berücksichtigen oder ignorieren&#8220;</a>
            erörtern.</p></dd>
<dt><span class="term">Zusammenführen rückgängig machen</span></dt>
<dd><p>Weiter oben in diesem Kapitel 
              (<a class="xref" href="svn.branchmerge.html#svn.branchmerge.basicmerging.undo" title="4.3.4. Änderungen rückgängig machen">Abschnitt 4.3.4, &#8222;Änderungen rückgängig machen&#8220;</a>)
              haben wir darüber gesprochen, wie man mit <span class="command"><strong>svn
                merge</strong></span> einen &#8222;<span class="quote">Rückwärts-Patch</span>&#8220;
              verwendet, um Änderungen rückgängig zu machen. Wenn
              diese Technik dazu verwendet wird, um eine Änderung in
              der Geschichte eines Objektes zurückzunehmen (z.B. r5
              an den Stamm übergeben, und dann sofort r5 mit
              <strong class="userinput"><code>svn merge . -c -5</code></strong> rückgängig
              machen), hat dies keine Auswirkungen auf die
              aufgezeichneten Metadaten.
            <sup>[<a name="id387951" href="#ftn.id387951" class="footnote">23</a>]</sup>
            </p></dd>
</dl></div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.mergeconflicts"></a>4.4.4. Mehr über Konflikte beim Zusammenführen</h3></div></div></div>
<p>Wie der Befehl <span class="command"><strong>svn update</strong></span> wendet auch 
        <span class="command"><strong>svn merge</strong></span> Änderungen auf Ihre Arbeitskopie
        an.  Und deshalb kann er auch Konflikte erzeugen. Die von
        <span class="command"><strong>svn merge</strong></span> hervorgerufenen Konflikte sind
        jedoch manchmal anders geartet, und dieser Abschnitt erklärt
        diese Unterschiede.</p>
<p>Zunächst gehen wir davon aus, dass Ihre Arbeitskopie keine
        lokalen Änderungen enthält. Wenn Sie mit <span class="command"><strong>svn
          update</strong></span> auf eine bestimmte Revision aktualisieren,
        werden die vom Server gesendeten Änderungen immer
        &#8222;<span class="quote">sauber</span>&#8220; auf Ihre Arbeitskopie angewendet. Der
        Server erzeugt das Delta, indem er zwei Bäume vergleicht: eine
        virtuelle Momentaufnahme Ihrer Arbeitskopie und der
        Revisionsbaum, an dem Sie interessiert sind. Da die linke
        Seite des Vergleichs völlig gleich zu dem ist, was Sie bereits
        haben, wird das Delta garantiert Ihre Arbeitskopie korrekt in
        den rechten Baum überführen.</p>
<p><span class="command"><strong>svn merge</strong></span> jedoch kann das nicht
        gewährleisten und kann viel chaotischer sein: Der
        fortgeschrittene Benutzer kann den Server auffordern,
        <span class="emphasis"><em>irgendwelche</em></span> zwei Bäume miteinander zu
        vergleichen, sogar solche, die nicht mit der Arbeitskopie in
        Beziehung stehen! Das bedeutet, dass ein hohes Potenzial für
        menschliche Fehler besteht. Benutzer werden manchmal die
        falschen zwei Bäume miteinander vergleichen, so dass ein Delta
        erzeugt wird, das sich nicht sauber anwenden lässt.
        <span class="command"><strong>svn merge</strong></span> wird sein Bestes geben, um soviel
        wie möglich vom Delta anzuwenden, doch bei einigen Teilen kann
        das unmöglich sein. So wie der Unix-Befehl
        <span class="command"><strong>patch</strong></span> sich manchmal über &#8222;<span class="quote">failed
          hunks</span>&#8220; beschwert, wird sich <span class="command"><strong>svn
          merge</strong></span> ähnlich über &#8222;<span class="quote">skipped
        targets</span>&#8220; beschweren:</p>
<pre class="screen">
$ svn merge -r 1288:1351 http://svn.example.com/repos/branch
U    foo.c
U    bar.c
Fehlendes Ziel: »baz.c« übersprungen.
U    glub.c
U    sputter.h

Konflikt in »glorb.h« entdeckt.
Auswahl: (p) zurückstellen, (df) voller Diff, (e) editieren,
        (h) Hilfe für weitere Optionen:
</pre>
<p>Im vorangegangenen Beispiel kann es der Fall gewesen sein,
        dass <code class="filename">baz.c</code> in beiden Momentaufnahmen des
        Zweiges vorkommt, die verglichen werden, und das resultierende
        Delta den Inhalt der Datei verändern will, die in der
        Arbeitskopie aber nicht vorhanden ist. Wie auch immer, die
        &#8222;<span class="quote">skipped</span>&#8220;-Nachricht bedeutet, dass der Benutzer
        höchstwahrscheinlich die falschen Bäume miteinander
        vergleicht; es ist das klassische Zeichen für einen
        Anwenderfehler. Falls dies passiert, ist es einfach, alle
        durch das Zusammenführen hervorgerufenen Änderungen rekursiv
        rückgängig zu machen (<strong class="userinput"><code>svn revert .
          --recursive</code></strong>), alle unversionierten Dateien oder
        Verzeichnisse zu löschen, die nach dem Rückgängigmachen
        zurückgeblieben sind, und <span class="command"><strong>svn merge</strong></span> noch
        einmal mit unterschiedlichen Argumenten aufzurufen.</p>
<p>Beachten Sie auch, dass das vorangegangene Beispiel einen
        Konflikt in <code class="filename">glorb.h</code> anzeigt. Wir
        bemerkten bereits, dass die Arbeitskopie keine lokalen
        Änderungen besitzt: Wie kann da ein Konflikt entstehen? Noch
        einmal: Weil der Benutzer <span class="command"><strong>svn merge</strong></span> dazu
        verwenden kann, ein altes Delta zu definieren und auf die
        Arbeitskopie anzuwenden, kann es sein, dass dieses alte Delta
        textuelle Änderungen enthält, die nicht sauber in eine
        Arbeitsdatei eingearbeitet werden können, selbst dann nicht,
        wenn die Datei keine lokalen Änderungen vorzuweisen
        hat.</p>
<p>Ein weiterer kleiner Unterschied zwischen <span class="command"><strong>svn
          update</strong></span> und <span class="command"><strong>svn merge</strong></span> sind die
        Namen der erzeugten Textdateien, falls ein Konflikt entsteht.
        In <a class="xref" href="svn.tour.html#svn.tour.cycle.resolve" title="2.4.5. Konflikte auflösen (Änderungen anderer einarbeiten)">Abschnitt 2.4.5, &#8222;Konflikte auflösen (Änderungen anderer einarbeiten)&#8220;</a> sahen wir, dass
        bei einer Aktualisierung die Dateien namens
        <code class="filename">filename.mine</code>,
        <code class="filename">filename.rOLDREV</code> und
        <code class="filename">filename.rNEWREV</code> erzeugt werden. Falls
        <span class="command"><strong>svn merge</strong></span> einen Konflikt hervorruft,
        erstellt es jedoch drei Dateien namens
        <code class="filename">filename.working</code>,
        <code class="filename">filename.left</code> und
        <code class="filename">filename.right</code>.  In diesem Fall
        beschreiben die Begriffe  &#8222;<span class="quote">left</span>&#8220; (links) und
        &#8222;<span class="quote">right</span>&#8220; (rechts) von welcher Seite des Vergleichs
        zwischen den beiden Bäumen die Datei hergeleitet wurde. Auf
        alle Fälle werden Ihnen diese unterschiedlichen Namen dabei
        helfen, zwischen Konflikten zu unterscheiden, die durch eine
        Aktualisierung entstanden, und solchen die durch eine
        Zusammenführung hervorgerufen wurden .</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.blockchanges"></a>4.4.5. Änderungen blockieren</h3></div></div></div>
<p>Manchmal gibt es eine bestimmte Änderungsmenge, die Sie
        nicht automatisch zusammengeführt haben wollen. Beispielsweise
        ist vielleicht die Vorgehensweise Ihres Teams dergestalt, dass
        Neuentwicklungen auf <code class="filename">/trunk</code> gemacht
        werden, aber konservativer, wenn es darum geht, Änderungen auf
        einen stabilen Zweig zurückzuportieren, den sie zur
        Veröffentlichung benutzen. Auf der einen Seite können Sie
        die Rosinen in Form von einzelnen Änderungsmengen manuell aus
        dem Stamm herauspicken und in den Zweig einpflegen &#8211; nur
        die Änderungen, die stabil genug sind, um die Qualitätsprüfung
        zu bestehen. Vielleicht ist es ja auch nicht ganz so streng,
        und Sie möchten normalerweise, dass <span class="command"><strong>svn
          merge</strong></span> die meisten Änderungen vom Stamm automatisch
        mit dem Zweig zusammenführt. In diesem Fall könnten Sie ein
        Verfahren gebrauchen, dass es Ihnen erlaubt, einige bestimmte
        Änderungen auszulassen, d.h. zu vermeiden, dass sie
        automatisch in den Zweig eingebracht werden.</p>
<p>Die einzige Möglichkeit, mit Subversion 1.5 eine
        Änderungsmenge zu blockieren, besteht darin, dem System
        vorzugaukeln, dass die Änderung <span class="emphasis"><em>bereits</em></span>
        eingearbeitet wurde. Dazu können Sie den Befehl mit der Option
        <code class="option">--record-only</code> aufrufen:</p>
<pre class="screen">
$ cd my-calc-branch

$ svn propget svn:mergeinfo .
/trunk:1680-3305

# In den Metadaten r3328 als bereits zusammengeführt vermerken.
$ svn merge -c 3328 --record-only http://svn.example.com/repos/calc/trunk

$ svn status
M     .

$ svn propget svn:mergeinfo .
/trunk:1680-3305,3328

$ svn commit -m "Das Zusammenführen von r3328 mit dem Zweig verhindern."
&#8230;
</pre>
<p>Diese Technik funktioniert zwar, sie ist allerdings auch
        ein wenig gefährlich. Das Hauptproblem ist, dass wir nicht
        klar unterscheiden zwischen &#8222;<span class="quote">ich habe diese Änderung
          bereits</span>&#8220; und &#8222;<span class="quote">ich habe diese Änderung
          nicht</span>&#8220;. Wir belügen das System gewissermaßen, indem
        wir es glauben lassen, dass die Änderung schon eingearbeitet
        sei. Das schiebt die Verantwortung, sich daran zu erinnern,
        dass die Änderung tatsächlich gar nicht übernommen wurde
        sondern nicht gewünscht war, auf Sie &#8211; den Benutzer. Es
        gibt keine Möglichkeit, Subversion nach einer Liste
        &#8222;<span class="quote">blockierter Änderungen</span>&#8220; zu fragen. Wenn Sie sie
        verfolgen möchten (so dass Sie eines Tages die Blockierung
        aufheben können) müssen Sie sie irgendwo in eine Textdatei
        schreiben oder in einem erfundenen Property festhalten. Leider
        ist das in Subversion 1.5 die einzige Möglichkeit mit
        blockierten Revisionen umzugehen; ein besseres Interface dafür
        ist für künftige Versionen geplant.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.logblame"></a>4.4.6. Protokolle und Anmerkungen, die Zusammenführungen anzeigen</h3></div></div></div>
<p>Ein Hauptmerkmal jedes Versionskontrollsystems ist es,
        darüber Buch zu führen, wer was wann geändert hat. Die Befehle
        <span class="command"><strong>svn log</strong></span> und <span class="command"><strong>svn blame</strong></span>
        sind die geeigneten Werkzeuge hierfür: Wenn sie auf
        individuelle Dateien angewendet werden, zeigen sie nicht nur
        die Geschichte der Änderungsmengen, die in diese Datei
        hineinflossen, sondern auch, welcher Benutzer wann welche
        Zeile im Quelltext geschrieben hat.</p>
<p>Wenn jedoch Änderungen über Zweige hinweg dupliziert
        werden, wird es schnell kompliziert. Wenn Sie z.B.
        <span class="command"><strong>svn log</strong></span> nach der Geschichte Ihres Zweigs
        fragen, wird es Ihnen exakt jede Revision anzeigen, die je in
        den Zweig hineingeflossen ist:</p>
<pre class="screen">
$ cd my-calc-branch
$ svn log -q
------------------------------------------------------------------------
r390 | user | 2002-11-22 11:01:57 -0600 (Fr, 22. Nov 2002) | 1 line
------------------------------------------------------------------------
r388 | user | 2002-11-21 05:20:00 -0600 (Do, 21. Nov 2002) | 2 lines
------------------------------------------------------------------------
r381 | user | 2002-11-20 15:07:06 -0600 (Mi, 20. Nov 2002) | 2 lines
------------------------------------------------------------------------
r359 | user | 2002-11-19 19:19:20 -0600 (Di, 19. Nov 2002) | 2 lines
------------------------------------------------------------------------
r357 | user | 2002-11-15 14:29:52 -0600 (Fr, 15. Nov 2002) | 2 lines
------------------------------------------------------------------------
r343 | user | 2002-11-07 13:50:10 -0600 (Do, 07. Nov 2002) | 2 lines
------------------------------------------------------------------------
r341 | user | 2002-11-03 07:17:16 -0600 (So, 03. Nov 2002) | 2 lines
------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Di, 29. Oct 2002) | 2 lines
------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fr, 22. Feb 2002) | 2 lines
------------------------------------------------------------------------
</pre>
<p>Aber ist das wirklich eine genaue Wiedergabe aller
        Änderungen, die auf dem Zweig stattgefunden haben? Was hier
        ausgelassen wird, ist, dass die Revisionen 390, 381 und 357
        tatsächlich Ergebnisse des Zusammenführens von Änderungen aus
        dem Stamm waren. Wenn Sie sich eins dieser Protokolle im
        Detail anschauen, können Sie die verschiedenen
        Änderungsmengen vom Stamm, die die Änderungen auf dem Zweig
        ausmachen, nirgendwo sehen:</p>
<pre class="screen">
$ svn log -v -r 390
------------------------------------------------------------------------
r390 | user | 2002-11-22 11:01:57 -0600 (Fri, 22 Nov 2002) | 1 line
Geänderte Pfade:
   M /branches/my-calc-branch/button.c
   M /branches/my-calc-branch/README

Letzte Zusammenführung der Änderungen von trunk changes in my-calc-branch.
</pre>
<p>Wir wissen, dass diese Zusammenführung in den Zweig nichts
        anderes war als eine Zusammenführung von Änderungen vom Stamm.
        Wie können wir zusätzlich diese Änderungen sehen? Die Antwort
        lautet, die Option <code class="option">--use-merge-history</code>
        (<code class="option">-g</code>) zu verwenden. Diese Option expandiert
        diejenigen &#8222;<span class="quote">Teil</span>&#8220;-Änderungen, aus denen die
        Zusammenführung bestand.</p>
<pre class="screen">
$ svn log -v -r 390 -g
------------------------------------------------------------------------
r390 | user | 2002-11-22 11:01:57 -0600 (Fri, 22 Nov 2002) | 1 line
Geänderte Pfade:
   M /branches/my-calc-branch/button.c
   M /branches/my-calc-branch/README

Letzte Zusammenführung der Änderungen von trunk changes in my-calc-branch.
------------------------------------------------------------------------
r383 | sally | 2002-11-21 03:19:00 -0600 (Thu, 21 Nov 2002) | 2 lines
Geänderte Pfade:
   M /branches/my-calc-branch/button.c
Zusammengeführt mittels: r390

Inverse Grafik auf Knopf behoben.
------------------------------------------------------------------------
r382 | sally | 2002-11-20 16:57:06 -0600 (Wed, 20 Nov 2002) | 2 lines
Geänderte Pfade:
   M /branches/my-calc-branch/README
Zusammengeführt mittels: r390

Meine letzte Änderung in README dokumentiert.
</pre>
<p>Dadurch, dass wir die Protokoll-Operation aufgefordert
        haben, die Geschichte der Zusammenführungen zu verwenden,
        sehen wir nicht nur die Revision, die wir abgefragt haben
        (r390), sondern auch die zwei Revisionen, die hier mitkamen
        &#8211; ein paar Änderungen, die Sally auf dem Stamm gemacht
        hat. Das ist ein wesentlich vollständigeres Bild der
        Geschichte!</p>
<p>Auch der <span class="command"><strong>svn blame</strong></span>-Befehl versteht die
        Option <code class="option">--use-merge-history</code>
        (<code class="option">-g</code>).  Falls diese Option vergessen wird,
        könnte jemand, der sich die zeilenweisen Anmerkungen von
        <code class="filename">button.c</code> ansieht, fälschlicherweise davon
        ausgehen, dass Sie für die Zeilen verantwortlich sind, die
        einen bestimmten Fehler beseitigt haben:</p>
<pre class="screen">
$ svn blame button.c
&#8230;
   390    user    retval = inverse_func(button, path);
   390    user    return retval;
   390    user    }
&#8230;
</pre>
<p>Obwohl es zutrifft, dass Sie diese drei Zeilen in Revision
        390 übergeben haben, sind zwei davon tatsächlich von Sally in
        Revision 383 geschrieben worden:</p>
<pre class="screen">
$ svn blame button.c -g
&#8230;
G    383    sally   retval = inverse_func(button, path);
G    383    sally   return retval;
     390    user    }
&#8230;
</pre>
<p>Nun wissen wir, wer <span class="emphasis"><em>wirklich</em></span> für die
        zwei Zeilen Quelltext verantwortlich ist!</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.ancestry"></a>4.4.7. Die Abstammung berücksichtigen oder ignorieren</h3></div></div></div>
<p>Wenn Sie sich mit einem Subversion-Entwickler unterhalten,
        wird wahrscheinlich auch der Begriff
        <em class="firstterm">Abstammung</em> erwähnt. Dieses Wort wird
        verwendet, um die Beziehung zwischen zwei Objekten im
        Repository zu beschreiben: Wenn sie in Beziehung zueinander
        stehen, heißt es, dass ein Objekt vom anderen abstammt.</p>
<p>Nehmen wir an, Sie übergeben Revision 100, die eine
        Änderung an der Datei <code class="filename">foo.c</code> beinhaltet.
        Dann ist  <code class="filename">foo.c@99</code> ein
        &#8222;<span class="quote">Vorfahre</span>&#8220; von <code class="filename">foo.c@100</code>.
        Wenn Sie dagegen in Revision 101 die Löschung von
        <code class="filename">foo.c</code> übergeben und in Revision 102 eine
        neue Datei mit demselben Namen hinzufügen, hat es zwar den
        Anschein, dass <code class="filename">foo.c@99</code> und
        <code class="filename">foo.c@102</code> in Beziehung zueinander stehen
        (sie haben denselben Pfad), es handelt sich allerdings um
        völlig unterschiedliche Objekte im Repository. Sie haben weder
        eine gemeinsame Geschichte noch
        &#8222;<span class="quote">Abstammung</span>&#8220;.</p>
<p>Wir erwähnen das, um auf einen wichtigen Unterschied
        zwischen den Befehlen <span class="command"><strong>svn diff</strong></span> und
        <span class="command"><strong>svn merge</strong></span> hinzuweisen. Der erstere Befehl
        ignoriert die Abstammung, wohingegen letzterer diese beachtet.
        Wenn Sie beispielsweise mit <span class="command"><strong>svn diff</strong></span> die
        Revisionen 99 und 102 von <code class="filename">foo.c</code>
        vergleichen, werden Sie zeilenbasierte Unterschiede sehen; der
        Befehl <span class="command"><strong>diff</strong></span> vergleicht blind zwei Pfade.
        Wenn Sie aber dieselben Objekte mit <span class="command"><strong>svn
        merge</strong></span> vergleichen, wird es feststellen, dass sie
        nicht in Beziehung stehen und versuchen, die alte Datei zu
        löschen und dann die neue hinzuzufügen; die Ausgabe wird eine
        Löschung gefolgt von einer Hinzufügung anzeigen:</p>
<pre class="screen">
D    foo.c
A    foo.c
      </pre>
<p>Die meisten Zusammenführungen vergleichen Bäume, die von
        der Abstammung  her miteinander in Beziehung stehen, deshalb
        verhält sich <span class="command"><strong>svn merge</strong></span> auf diese Weise.
        Gelegentlich möchten Sie jedoch mit dem
        <span class="command"><strong>merge</strong></span>-Befehl zwei Bäume vergleichen, die
        nicht miteinander in Beziehung stehen. Es kann z.B. sein, dass
        Sie zwei Quelltext-Bäume importiert haben, die unterschiedliche
        Lieferantenstände eines Software-Projektes repräsentieren
        (siehe <a class="xref" href="svn.branchmerge.html#svn.advanced.vendorbr" title="4.9. Lieferanten-Zweige">Abschnitt 4.9, &#8222;Lieferanten-Zweige&#8220;</a>).  Falls Sie 
        <span class="command"><strong>svn merge</strong></span> dazu aufforderten, die beiden Bäume
        miteinander zu vergleichen, würden Sie sehen, dass der
        vollständige erste Baum gelöscht und anschließend der
        vollständige zweite Baum hinzugefügt würde! In diesen
        Situationen möchten Sie, dass <span class="command"><strong>svn merge</strong></span>
        lediglich einen pfadbasierten Vergleich vornimmt und
        Beziehungen zwischen Dateien und Verzeichnissen außer Acht
        lässt. Fügen Sie die Option <code class="option">--ignore-ancestry</code>
        dem <span class="command"><strong>merge</strong></span>-Befehl hinzu, und er wird sich
        verhalten wie <span class="command"><strong>svn diff</strong></span>.  (Auf der anderen
        Seite wird die Option <code class="option">--notice-ancestry</code> den
        Befehl <span class="command"><strong>svn diff</strong></span> dazu veranlassen, sich wie
        <span class="command"><strong>svn merge</strong></span> zu verhalten.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.moves"></a>4.4.8. Zusammenführen und Verschieben</h3></div></div></div>
<p>Es ist ein verbreiteter Wunsch, Software zu refaktorieren,
        besonders in Java-basierten Software-Projekten. Dateien und
        Verzeichnisse werden hin und her geschoben und umbenannt, was
        häufig zu erheblichen Beeinträchtigungen für alle
        Projektmitarbeiter führt. Das hört sich an, als sei das der
        klassische Fall, um nach einem Zweig zu greifen, nicht wahr?
        Sie erzeugen einfach einen Zweig, schieben das Zeug herum und
        führen anschließend den Zweig mit dem Stamm zusammen.</p>
<p>Leider funktioniert dieses Szenario im Augenblick noch
        nicht so richtig und gilt als einer der Schwachpunkte von
        Subversion. Das Problem ist, das der Subversion-Befehl
        <span class="command"><strong>svn update</strong></span> nicht so stabil ist, wie er sein
        sollte, besonders wenn es um Kopier- und Verschiebeoperationen
        geht.</p>
<p>Wenn Sie <span class="command"><strong>svn copy</strong></span> zum Duplizieren einer
        Datei verwenden, merkt sich das Repository, woher die neue
        Datei kam, versäumt aber, diese Information an den Client zu
        senden, der <span class="command"><strong>svn update</strong></span> oder <span class="command"><strong>svn
        merge</strong></span> ausführt. Statt dem Client mitzuteilen:
        &#8222;<span class="quote">Kopiere die Datei, die du bereits hast an diesen neuen
        Ort</span>&#8220;, sendet es eine völlig neue Datei. Das kann zu
        Problemen führen, besonders, weil dasselbe mit umbenannten
        Dateien passiert. Eine weniger bekannte Tatsache über
        Subversion ist, dass es keine &#8222;<span class="quote">echten
        Umbenennungen</span>&#8220; hat &#8211; der Befehl <span class="command"><strong>svn
        move</strong></span> ist weiter nichts als eine Verbindung von
        <span class="command"><strong>svn copy</strong></span> und <span class="command"><strong>svn
        delete</strong></span>.</p>
<p>Nehmen wir beispielsweise an, dass Sie während Ihrer
        Arbeit auf Ihrem privaten Zweig <code class="filename">integer.c</code>
        in <code class="filename">whole.c</code> umbenennen. Tatsächlich haben
        Sie eine neue Datei auf Ihrem Zweig erzeugt, die eine Kopie
        der ursprünglichen Datei ist, und letztere gelöscht.
        Zwischenzeitlich hat Sally einige Verbesserungen an
        <code class="filename">integer.c</code> in <code class="filename">trunk</code>
        übergeben. Nun entscheiden Sie sich, Ihren Zweig mit dem Stamm
        zusammenzuführen:</p>
<pre class="screen">
$ cd calc/trunk

$ svn merge --reintegrate http://svn.example.com/repos/calc/branches/my-calc-branch
-- Zusammenführen der Unterschiede zwischen Projektarchiv-URLs in ».«:
D   integer.c
A   whole.c
U   .
      </pre>
<p>Auf den ersten Blick sieht es gar nicht schlecht aus,
        jedoch ist es nicht das, was Sie und Sally erwartet hätten.
        Die Zusammenführung hat die letzte Version der Datei
        <code class="filename">integer.c</code> gelöscht (diejenige, die Sallys
        Änderungen beinhaltet) und blindlings Ihre neue Datei
        <code class="filename">whole.c</code> hinzugefügt &#8211; die ein
        Duplikat der <span class="emphasis"><em>älteren</em></span> Version von
        <code class="filename">integer.c</code> ist. Das Endergebnis ist, dass
        durch die Zusammenführung Ihrer &#8222;<span class="quote">Umbenennung</span>&#8220; auf
        dem Zweig mit dem Stamm Sallys jüngste Änderungen aus der
        letzten Revision entfernt wurden.</p>
<p>Es ist kein echter Datenverlust. Sallys Änderungen
        befinden sich noch immer in der Geschichte des Repositorys,
        allerdings mag es nicht sofort ersichtlich sein, dass es
        passiert ist. Die Lehre, die es aus dieser Geschichte zu
        ziehen gilt, lautet, dass Sie sehr vorsichtig mit dem
        Zusammenführen von Kopien und Umbenennungen zwischen Zweigen
        sein sollten, solange sich Subversion an dieser Stelle nicht
        verbessert hat.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.pre1.5clients"></a>4.4.9. Abblocken von Clients, die Zusammenführungen nicht
        ausreichend unterstützen</h3></div></div></div>
<p>Wenn Sie gerade Ihren Server auf Subversion 1.5 oder
        größer umgestellt haben, besteht ein signifikantes Risiko,
        dass Subversion-Clients einer kleineren Version als 1.5 Ihre
        automatische Zusammenführungs-Verfolgung durcheinander bringen
        können. Warum? Wenn ein älterer Subversion-Client <span class="command"><strong>svn
        merge</strong></span> ausführt, modifiziert er nicht den Wert des
        Propertys <code class="literal">svn:mergeinfo</code>.  Obwohl die
        anschließende Übergabe das Ergebnis einer Zusammenführung ist,
        wird dem Repository nichts über die duplizierten Änderungen
        mitgeteilt &#8211; diese Information ist verloren. Wenn später
        Clients, die Zusammenführungsinformationen auswerten,
        automatische Zusammenführungen versuchen, werden Sie
        wahrscheinlich in alle möglichen Konflikte laufen, die durch
        wiederholte Zusammenführungen hervorgerufen wurden.</p>
<p>Wenn Sie und Ihr Team auf die Zusammenführungs-Verfolgung
        von Subversion angewiesen sind, sollten Sie Ihr Repository
        dergestalt konfigurieren, dass ältere Clients daran gehindert
        werden, Änderungen zu übergeben. Die einfache Methode hierfür
        ist es, den &#8222;<span class="quote">Fähigkeiten</span>&#8220;-Parameter im
        <code class="literal">start-commit</code> Hook-Skript zu untersuchen.
        Wenn der Client meldet, dass er mit
        <code class="literal">mergeinfo</code> umgehen kann, kann das Skript den
        Beginn der Übergabe erlauben.  Wenn der Client diese Fähigkeit
        nicht meldet, wird die Übergabe abgelehnt. Wir werden mehr
        über Hook-Skripte im nächsten Kapitel erfahren; siehe <a class="xref" href="svn.reposadmin.html#svn.reposadmin.create.hooks" title="5.3.2. Erstellen von Repository-Hooks">Abschnitt 5.3.2, &#8222;Erstellen von Repository-Hooks&#8220;</a> und <a class="xref" href="svn.ref.reposhooks.start-commit.html" title="start-commit">start-commit</a> für
        Details.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.finalword"></a>4.4.10. Das abschließende Wort zur Zusammenführungs-Verfolgung</h3></div></div></div>
<p>Unter dem Strich bedeutet das, dass die Fähigkeit von
        Subversion zur Zusammenführungs-Verfolgung eine höchst
        komplexe interne Implementierung besitzt und das Property
        <code class="literal">svn:mergeinfo</code> das einzige Fenster zu diesem
        Räderwerk ist. Da diese Fähigkeit relativ neu ist, kann eine
        Anzahl von Randfällen und mögliche unerwartete
        Verhaltensweisen auftauchen.</p>
<p>So kann zum Beispiel Mergeinfo manchmal durch einen
        einfachen <span class="command"><strong>svn copy</strong></span>- oder <span class="command"><strong>svn
        move</strong></span>-Befehl erzeugt werden. Manchmal wird Mergeinfo
        an Dateien auftauchen, von denen Sie nicht erwartet hätten,
        dass sie durch die Operation berührt worden wären. Manchmal
        wird Mergeinfo überhaupt nicht erzeugt, obwohl Sie es erwartet
        hätten. Darüberhinaus umgibt die Verwaltung der
        Mergeinfo-Metadaten eine ganze Menge von Systematiken und
        Verhalten, wie &#8222;<span class="quote">explizite</span>&#8220; gegenüber
        &#8222;<span class="quote">implizite</span>&#8220; Mergeinfo, &#8222;<span class="quote">operative</span>&#8220;
        gegenüber &#8222;<span class="quote">inoperativen</span>&#8220; Revisionen, besondere
        Mechanismen von  Mergeinfo-&#8222;<span class="quote">Auslassung</span>&#8220; und sogar
        &#8222;<span class="quote">Vererbung</span>&#8220; von Eltern- zu
        Kindverzeichnissen.</p>
<p>Wir haben uns entschieden, diese detaillierten Themen aus
        einer Reihe von Gründen nicht in diesem Buch zu behandeln.
        Erstens ist der Detaillierungsgrad für einen normalen
        Benutzer absolut erdrückend. Zweitens glauben wir, dass das
        Verständnis diese Konzepte für einen typischen Benutzer nicht
        unbedingt erforderlich sein <span class="emphasis"><em>sollte</em></span> während
        Subversion sich verbessert; letztendlich werden sie als
        nervige Implementierugsdetails in den Hintergrund treten. Wenn
        Sie, nachdem dies gesagt ist, diese Dinge mögen, können Sie
        einen fantastischen Überblick in einer Arbeit nachlesen, die
        auf der Webseite von CollabNet veröffentlicht ist:<a class="ulink" href="http://www.collab.net/community/subversion/articles/merge-info.html" target="_top">http://www.collab.net/community/subversion/articles/merge-info.html</a>.</p>
<p>Fürs Erste empfiehlt CollabNet, sich an die folgenden
        bewährten Praktiken zu halten, wenn Sie Fehler und
        merkwürdiges Verhalten bei automatischen Zusammenführungen
        vermeiden wollen:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Wenden Sie für kurzlebige Arbeitszweige das Verfahren
            an, das in <a class="xref" href="svn.branchmerge.html#svn.branchmerge.basicmerging" title="4.3. Grundlegendes Zusammenführen">Abschnitt 4.3, &#8222;Grundlegendes Zusammenführen&#8220;</a>
            beschrieben wird.</p></li>
<li><p>Machen Sie Zusammenführungen langlebiger
            Release-Zweige (wie in  <a class="xref" href="svn.branchmerge.html#svn.branchmerge.commonpatterns" title="4.8. Verbreitete Verzweigungsmuster">Abschnitt 4.8, &#8222;Verbreitete Verzweigungsmuster&#8220;</a> beschrieben)
            nur im Wurzelverzeichnis des Zweigs und nicht in
            Unterverzeichnissen.</p></li>
<li><p>Machen Sie Zusammenführungen in Arbeitsverzeichnisse
            niemals mit einer Mischung aus Arbeitsrevisionsnummern oder
            &#8222;<span class="quote">umgeschalteten</span>&#8220; Unterverzeichnissen (wie als
            Nächstes in <a class="xref" href="svn.branchmerge.html#svn.branchmerge.switchwc" title="4.5. Zweige durchlaufen">Abschnitt 4.5, &#8222;Zweige durchlaufen&#8220;</a>
            beschrieben). Das Ziel einer Zusammenführung sollte eine
            Arbeitskopie sein, die einen <span class="emphasis"><em>einzigen</em></span>
            Ort zu einem einzelnen Zeitpunkt im Repository
            repräsentiert.</p></li>
<li><p>Editieren Sie niemals direkt das Property
            <code class="literal">svn:mergeinfo</code>; verwenden Sie
            <span class="command"><strong>svn merge</strong></span> mit der Option
            <code class="option">--record-only</code>, um eine gewünschte
            Änderung an den Metadaten zu bewirken (wie in <a class="xref" href="svn.branchmerge.html#svn.branchmerge.advanced.blockchanges" title="4.4.5. Änderungen blockieren">Abschnitt 4.4.5, &#8222;Änderungen blockieren&#8220;</a>
            gezeigt).</p></li>
<li><p>Stellen Sie jederzeit sicher, dass Sie vollständigen
            Lesezugriff auf die Quellen für die Zusammenführung haben
            und dass Ihre Ziel-Arbeitskopie keine dünn besetzten
            Verzeichnisse besitzt.</p></li>
</ul></div>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.switchwc"></a>4.5. Zweige durchlaufen</h2></div></div></div>
<p>Der Befehl <span class="command"><strong>svn switch</strong></span> überführt eine
      bestehende Arbeitskopie, so dass sie einen anderen Zweig
      repräsentiert. Obwohl dieser Befehl strenggenommen für die
      Arbeit mit Zweigen nicht notwendig ist, stellt er eine nette
      Abkürzung dar. In unserem früheren Beispiel haben Sie nach dem
      Anlegen Ihres eigenen privaten Zweigs eine frische Arbeitskopie
      des neuen Repository-Verzeichnisses ausgecheckt. Stattdessen
      können Sie Subversion einfach mitteilen, dass es Ihre
      Arbeitskopie von <code class="filename">/calc/trunk</code> ändern soll,
      um den neuen Ort des Zweigs widerzuspiegeln:</p>
<pre class="screen">
$ cd calc

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/trunk

$ svn switch http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile
Aktualisiert zu Revision 341.

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/branches/my-calc-branch
</pre>
<p>&#8222;<span class="quote">Das Umschalten</span>&#8220; einer Arbeitskopie ohne lokale
      Änderungen auf einen anderen Zweig hat zur Folge, dass die
      Arbeitskopie genau so aussieht, als sei das Verzeichnis frisch
      ausgecheckt worden. Es ist gewöhnlicherweise effizienter, diesen
      Befehl zu verwenden, da sich Zweige oftmals nur in kleinen
      Teilen unterscheiden. Der Server sendet nur die minimale Menge
      von Änderungen, die notwendig sind, damit Ihre Arbeitskopie den
      Inhalt des Zweig-Verzeichnisses wiedergibt.</p>
<p>Der Befehl <span class="command"><strong>svn switch</strong></span> versteht auch die
      Option <code class="option">--revision</code> (<code class="option">-r</code>), so
      dass Sie nicht immer gezwungen sind, Ihre Arbeitskopie auf den
      <code class="literal">HEAD</code> des Zweigs zu setzen.</p>
<p>Natürlich sind die meisten Projekte komplizierter als unser
      <code class="filename">calc</code>-Beispiel und enthalten mehrere
      Unterverzeichnisse. Subversion-Benutzer wenden bei der
      Verwendung von Zweigen häufig einen bestimmten Algorithmus
      an:</p>
<div class="orderedlist"><ol type="1">
<li><p>Kopiere den vollständigen &#8222;<span class="quote">Stamm</span>&#8220; des
            Projektes in ein neues Zweig-Verzeichnis.</p></li>
<li><p>Schalte nur einen <span class="emphasis"><em>Teil</em></span> der
            Arbeitskopie vom Stamm auf den Zweig um.</p></li>
</ol></div>
<p>In anderen Worten: Wenn ein Benutzer weiß, dass die Arbeit
      auf dem Zweig nur in einem bestimmten Unterverzeichnis
      stattfinden muss, verwendet er <span class="command"><strong>svn switch</strong></span>
      lediglich, um dieses Unterverzeichnis auf den Zweig zu bringen.
      (Manchmal schalten Benutzer sogar nur eine einzelne Datei auf
      den Zweig um!) Auf diese Art kann ein Benutzer für einen großen
      Teil der Arbeitskopie weiterhin normale Aktualisierungen auf dem
      &#8222;<span class="quote">Stamm</span>&#8220; erhalten, wohingegen die umgeschalteten
      Teile unberührt bleiben (es sei denn, jemand übergibt etwas an
      den Zweig). Diese Möglichkeit fügt dem Konzept einer
      &#8222;<span class="quote">gemischten Arbeitskopie</span>&#8220; eine völlig neue
      Dimension hinzu &#8211; Arbeitskopien können nicht nur eine
      Mischung unterschiedlicher Revisionen enthalten, sondern auch
      eine Mischung unterschiedlicher Repository-Orte.</p>
<p>Falls Ihre Arbeitskopie eine Anzahl umgeschalteter
      Unterverzeichnisse aus unterschiedlichen Repository-Orten
      enthält, funktioniert sie immer noch normal. Wenn Sie
      aktualisieren, erhalten Sie entsprechende Patches für jeden
      Unterbaum. Wenn Sie übergeben, werden Ihre lokalen Änderungen
      nach wie vor als eine einzelne atomare Änderung auf das
      Repository angewendet.</p>
<p>Während es normal ist, das eine Arbeitskopie eine Mischung
      unterschiedlicher Repository-Orte repräsentiert, ist darauf zu
      achten, dass all diese Orte sich innerhalb
      <span class="emphasis"><em>desselben</em></span> Repositorys befinden.
      Subversion-Repositorys können noch nicht miteinander
      kommunizieren; diese Möglichkeit ist für die Zukunft geplant.
      <sup>[<a name="id389628" href="#ftn.id389628" class="footnote">24</a>]</sup>
    </p>
<div class="sidebar">
<p class="title"><b>Umschalten und Aktualisierungen</b></p>
<p>Ist Ihnen aufgefallen, dass die Ausgaben von <span class="command"><strong>svn
        switch</strong></span> und <span class="command"><strong>svn update</strong></span> gleich
        aussehen? Der switch-Befehl ist tatsächlich eine Obermenge des
        update-Befehls.</p>
<p>Wenn Sie <span class="command"><strong>svn update</strong></span> aufrufen, fordern
        Sie das Repository auf, zwei Bäume zu vergleichen. Das
        Repository macht es und schickt eine Beschreibung der
        Unterschiede zurück an den Client. Der einzige Unterschied
        zwischen <span class="command"><strong>svn switch</strong></span> und <span class="command"><strong>svn
        update</strong></span> ist, dass letzterer Befehl stets zwei
        identische Repository-Pfade miteinander vergleicht.</p>
<p>Das heißt, falls Ihre Arbeitskopie
        <code class="filename">/calc/trunk</code> widerspiegelt, wird
        <span class="command"><strong>svn update</strong></span> automatisch Ihre Arbeitskopie
        von <code class="filename">/calc/trunk</code> mit
        <code class="filename">/calc/trunk</code> in der Revision
        <code class="literal">HEAD</code> vergleichen. Falls Sie Ihre
        Arbeitskopie auf einen Zweig umschalten, wird <span class="command"><strong>svn
        switch</strong></span> Ihre Arbeitskopie von
        <code class="filename">/calc/trunk</code> mit einem
        <span class="emphasis"><em>anderen</em></span> Zweig-Verzeichnis in der
        <code class="literal">HEAD</code>-Revision vergleichen.</p>
<p>In anderen Worten: Eine Aktualisierung bewegt Ihre
        Arbeitskopie durch die Zeit. Eine Umschaltung bewegt Ihre
        Arbeitskopie durch die Zeit <span class="emphasis"><em>und</em></span> den
        Raum.</p>
</div>
<p>Da <span class="command"><strong>svn switch</strong></span> eigentlich eine Variante
      von <span class="command"><strong>svn update</strong></span> ist, teilt es dasselbe
      Verhalten; irgendwelche lokalen Änderungen Ihrer Arbeitskopie
      bleiben erhalten, wenn neue Daten aus dem Repository
      ankommen.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tipp]" src="images/tip.png"></td>
<th align="left">Tipp</th>
</tr>
<tr><td align="left" valign="top">
<p>Haben Sie sich jemals dabei ertappt, dass Sie (in Ihrer
          <code class="filename">/trunk</code>-Arbeitskopie) komplexe
          Änderungen gemacht haben und plötzlich feststellen:
          &#8222;<span class="quote">Verdammt, diese Änderungen sollten auf einen eigenen
          Zweig!</span>&#8220; Eine gute Technik, um das zu bewerkstelligen,
          lässt sich in zwei Schritten zusammenfassen:</p>
<pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/newbranch \
      -m "Zweig 'newbranch' angelegt."
Revision 353 übertragen.
$ svn switch http://svn.example.com/repos/calc/branches/newbranch
Revision 353.
</pre>
<p>Der Befehl <span class="command"><strong>svn switch</strong></span>
          bewahrt wie <span class="command"><strong>svn update</strong></span> Ihre lokalen
          Änderungen. An dieser Stelle spiegelt Ihre Arbeitskopie den
          neu erzeugten Zweig wieder, und Ihr nächster Aufruf von
          <span class="command"><strong>svn commit</strong></span> wird Ihre Änderungen dorthin
          senden.</p>
</td></tr>
</table></div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.tags"></a>4.6. Tags</h2></div></div></div>
<p>Ein weiterer verbreiteter Begriff in der Versionskontrolle
      ist ein <em class="firstterm">Tag</em>. Ein Tag ist lediglich eine
      &#8222;<span class="quote">Momentaufnahme</span>&#8220; eines Projekts. In Subversion
      scheint dieses Konzept bereits überall vorhanden zu sein. Jede
      Revision im Repository ist genau das &#8211; eine Momentaufnahme
      des Dateisystems nach einer Übergabe.</p>
<p>Allerdings möchten Menschen häufig sprechendere Namen für
      Tags vergeben, wie etwa <code class="literal">release-1.0</code>. Und sie
      möchten Momentaufnahmen kleinerer Unterverzeichnisse des
      Dateisystems erstellen. Schließlich ist es nicht gerade einfach,
      sich daran zu erinnern, dass Release 1.0 einer Software ein
      bestimmtes Unterverzeichnis der Revision 4822 ist.</p>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.tags.mksimple"></a>4.6.1. Erzeugen eines einfachen Tags</h3></div></div></div>
<p>Wieder einmal hilft Ihnen <span class="command"><strong>svn copy</strong></span> bei
        der Arbeit. Wenn Sie eine Momentaufnahme von
        <code class="filename">/calc/trunk</code> machen wollen, genau so, wie
        es in der Revision <code class="literal">HEAD</code> aussieht, machen
        Sie davon eine Kopie:</p>
<pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/release-1.0 \
      -m "Ein Tag für die Ausgabe 1.0 des 'calc' Projektes anlegen."

Revision 902 übertragen.
</pre>
<p>Dieses Beispiel geht davon aus, dass ein Verzeichnis
        <code class="filename">/calc/tags</code> bereits besteht. (Falls nicht,
        können Sie es mit <span class="command"><strong>svn mkdir</strong></span> erstellen.)
        Nach Abschluss der Kopie ist das neue Verzeichnis
        <code class="filename">release-1.0</code> für immer eine Momentaufnahme
        des Verzeichnisses <code class="filename">/trunk</code> in der Revision
        <code class="literal">HEAD</code> zum Zeitpunkt, an dem Sie die Kopie
        erstellt haben. Natürlich können Sie auch angeben, welche
        Revision Sie genau kopieren möchten, für den Fall, dass jemand
        anderes Änderungen an das Projekt übergeben haben könnte,
        während Sie nicht hingeschaut haben. Wenn Sie also wissen,
        dass Revision 901 von <code class="filename">/calc/trunk</code> genau
        die Momentaufnahme ist, die Sie möchten, können Sie sie mit
        der Option <code class="option">-r 901</code> an den Befehl <span class="command"><strong>svn
        copy</strong></span> übergeben.</p>
<p>Moment mal: ist die Erstellung eines Tags nicht dasselbe
        Vorgehen wie bei der Erstellung eines Zweigs? Ja, es ist es
        tatsächlich. In Subversion gibt es keinen Unterschied zwischen
        einem Tag und einem Zweig. Beides sind gewöhnliche
        Verzeichnisse, die durch Kopieren erzeugt werden. Genauso wie
        bei Zweigen, ist der einzige Grund warum ein kopiertes
        Verzeichnis ein &#8222;<span class="quote">Tag</span>&#8220; ist, weil
        <span class="emphasis"><em>Menschen</em></span> sich entschieden haben, es so zu
        betrachten: Solange niemand etwas an das Verzeichnis übergibt,
        bleibt es für immer eine Momentaufnahme. Wenn jemand damit
        beginnt, etwas dorthin zu übergeben, wird es ein Zweig.</p>
<p>Wenn Sie ein Repository verwalten, gibt es zwei Ansätze
        für den Umgang mit Tags. Der erste Ansatz ist &#8222;<span class="quote">Hände
        weg</span>&#8220;: Als Vereinbarung im Projekt entscheiden Sie, wohin
        Sie Ihre Tags kopieren möchten; stellen Sie sicher, dass alle
        Benutzer wissen, wie sie ihre zu kopierenden Verzeichnisse
        behandeln sollen, d.h., stellen Sie sicher, dass sie nichts
        dorthin übergeben. Der zweite Ansatz ist etwas paranoider: Sie
        können eins der Zugriffskontrollskripte verwenden, die mit
        Subversion ausgeliefert werden, um zu verhindern, dass
        irgendjemand etwas anderes im Tag-Bereich macht, als dort neue
        Kopien zu erzeugen (siehe <a class="xref" href="svn.serverconfig.html" title="Kapitel 6. Die Administration eines Subversion-Servers">Kapitel 6, <i>Die Administration eines Subversion-Servers</i></a>).
        Der paranoide Ansatz ist normalerweise nicht notwendig. Falls
        ein Benutzer versehentlich eine Änderung an ein
        Tag-Verzeichnis übergeben hat, können Sie die Änderung einfach
        rückgängig machen, wie im vorhergehenden Abschnitt
        beschrieben. Schließlich handelt es sich um
        Versionskontrolle!</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.tags.mkcomplex"></a>4.6.2. Erzeugen eines komplexen Tags</h3></div></div></div>
<p>Manchmal möchten Sie vielleicht eine
        &#8222;<span class="quote">Momentaufnahme</span>&#8220; machen, die komplizierter ist
        als ein einzelnes Verzeichnis mit einer einzigen
        Revision.</p>
<p>Stellen Sie sich beispielsweise vor, Ihr Projekt sei viel
        größer als unser <code class="filename">calc</code> Beispiel: Nehmen
        wir an, es enthalte eine große Zahl von Unterverzeichnissen
        und viel mehr Dateien. Während Ihrer Arbeit könnte es sein,
        dass Sie sich entscheiden, eine Arbeitskopie anzulegen, die
        bestimmte Merkmale und Fehlerbehebungen beinhaltet. Sie können
        dies hinbekommen, indem Sie selektiv Dateien oder
        Verzeichnisse auf bestimmte Revisionen zurückdatieren (unter
        Verwendung von <span class="command"><strong>svn update</strong></span> mit der Option
        <code class="option">-r</code>), indem Sie Dateien und Verzeichnisse auf
        bestimmte Zweige umschalten (mit <span class="command"><strong>svn
        switch</strong></span>) oder sogar, indem Sie ein paar lokale
        Änderungen vornehmen. Wenn Sie fertig sind, ist Ihre
        Arbeitskopie ein Mischmasch aus Repository-Quellen
        verschiedener Revisionen. Nach dem Testen wissen Sie jedoch,
        dass das genau die Kombination ist, die Sie mit einem Tag
        versehen möchten.</p>
<p>Nun ist es an der Zeit, eine Momentaufnahme zu machen.
        Einen URL auf einen anderen zu kopieren hilft hier nicht
        weiter. In diesem Fall möchten Sie eine Momentaufnahme der
        exakten Anordnung Ihrer Arbeitskopie machen und sie im
        Repository speichern. Glücklicherweise besitzt <span class="command"><strong>svn
        copy</strong></span> vier verschiedene Anwendungsfälle (über die Sie
        in <a class="xref" href="svn.ref.html" title="Kapitel 9. Subversion Complete Reference">Kapitel 9, <i>Subversion Complete Reference</i></a> nachlesen können), zu denen auch
        die Fähigkeit gehört, einen Arbeitskopie-Baum ins Repository
        zu kopieren:</p>
<pre class="screen">
$ ls
my-working-copy/

$ svn copy my-working-copy \
           http://svn.example.com/repos/calc/tags/mytag \
           -m "Ein Tag für den Zustand meines Arbeitsverzeichnisses anlegen."

Revision 940 übertragen.
</pre>
<p>Nun gibt es ein neues Verzeichnis im Repository,
        <code class="filename">/calc/tags/mytag</code>, das eine exakte
        Momentaufnahme Ihrer Arbeitskopie ist &#8211; gemischte
        Revisionen, URLs, lokale Änderungen, usw.</p>
<p>Andere Benutzer haben interessante Anwendungsfälle für
        diese Fähigkeit von Subversion gefunden. Manchmal gibt es
        Situationen, in denen Sie ein paar lokale Änderungen in Ihrer
        Arbeitskopie gemacht haben, die ein Mitarbeiter sehen soll.
        Statt <span class="command"><strong>svn diff</strong></span> aufzurufen und eine
        Patch-Datei zu versenden (die allerdings weder Änderungen an
        Verzeichnissen, symbolischen Links oder Propertys beinhaltet),
        können Sie <span class="command"><strong>svn copy</strong></span> verwenden, um Ihre
        Arbeitskopie in einen privaten Bereich des Repositorys
        &#8222;<span class="quote">abzulegen</span>&#8220;. Ihr Mitarbeiter kann dann entweder
        eine exakte Kopie Ihrer Arbeitskopie auschecken oder
        <span class="command"><strong>svn merge</strong></span> verwenden, um genau Ihre
        Änderungen zu empfangen.</p>
<p>Obwohl dies eine nette Methode ist, schnell eine
        Momentaufnahme Ihrer Arbeitskopie anzulegen, sollten Sie
        beachten, dass es <span class="emphasis"><em>keine</em></span> gute
        Vorgehensweise ist, einen Zweig zu erstellen. Die Erzeugung
        eines Zweigs sollte ein Ereignis für sich sein, wohingegen
        diese Methode die Erzeugung eines Zweigs mit zusätzlichen
        Änderungen an Dateien innerhalb einer einzelnen Revision
        verbindet. Das macht es später sehr schwer, eine einzelne
        Revisionsnummer als Verzweigungspunkt zu
        identifizieren.</p>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.maint"></a>4.7. Verwaltung von Zweigen</h2></div></div></div>
<p>Sie haben mittlerweile vielleicht festgestellt, dass
      Subversion äußerst flexibel ist. Da Zweigen und Tags derselbe
      Mechanismus zugrundeliegt (Verzeichniskopien) und weil Zweige
      und Tags im normalen Dateisystem auftauchen, finden viele Leute
      Subversion einschüchternd. Es ist beinahe
      <span class="emphasis"><em>zu</em></span> flexibel. In diesem Abschnitt machen wir
      einige Vorschläge, wie Sie Ihre Daten im Laufe der Zeit
      organisieren und verwalten können.</p>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.maint.layout"></a>4.7.1. Aufbau des Repositorys</h3></div></div></div>
<p>Es gibt einige empfohlene Standards, ein Repository zu
        organisieren. Die meisten Leute erzeugen ein
        <code class="filename">trunk</code>-Verzeichnis, um die Hauptlinie der
        Entwicklung aufzunehmen, ein
        <code class="filename">branches</code>-Verzeichnis für Zweig-Kopien und
        ein <code class="filename">tags</code>-Verzeichnis für Tag-Kopien.
        Falls ein Repository nur ein Projekt beinhaltet, werden oft
        diese Verzeichnisse auf der obersten Ebene angelegt:</p>
<pre class="screen">
/trunk
/branches
/tags
</pre>
<p>Falls ein Repository mehrere Projekte enthält, teilen
        Administratoren das Repository üblicherweise nach den
        Projekten ein (lesen Sie in <a class="xref" href="svn.reposadmin.html#svn.reposadmin.projects.chooselayout" title="5.2.1. Planung der Organisation Ihres Repositorys">Abschnitt 5.2.1, &#8222;Planung der Organisation Ihres Repositorys&#8220;</a> mehr über
        &#8222;<span class="quote">Projekt-Wurzelverzeichnisse</span>&#8220;):</p>
<pre class="screen">
/paint/trunk
/paint/branches
/paint/tags
/calc/trunk
/calc/branches
/calc/tags
</pre>
<p>Natürlich ist es Ihnen freigestellt, diese verbreiteten
        Strukturen zu ignorieren. Sie können alle möglichen
        Variationen erzeugen, die am besten für Sie oder Ihr Team
        funktionieren. Denken Sie daran, dass es, wie auch immer Sie
        sich entscheiden, nicht für die Ewigkeit sein muss. Sie können
        jederzeit Ihr Repository umorganisieren. Da Zweige und Tags
        gewöhnliche Verzeichnisse sind, kann der Befehl <span class="command"><strong>svn
        move</strong></span> sie nach Belieben verschieben oder umbenennen.
        Die Umstrukturierung ist einfach eine Sache von serverseitigen
        Verschiebebefehlen. Wenn Ihnen der Aufbau des Repositorys
        nicht zusagt, jonglieren Sie einfach mit den Verzeichnissen
        herum.</p>
<p>Obwohl es einfach ist, Verzeichnisse zu verschieben,
        sollten Sie Rücksicht auf Ihre Benutzer nehmen. Ihr Jonglieren
        kann verwirrend für Benutzer mit bestehenden Arbeitskopien
        sein. Falls ein Benutzer eine Arbeitskopie eines bestimmten
        Repository-Verzeichnisses hat, könnte Ihre <span class="command"><strong>svn
        move</strong></span>-Operation den Pfad von der letzten Revision
        entfernen. Wenn der Benutzer beim nächsten Mal <span class="command"><strong>svn
        update</strong></span> aufruft, wird ihm mitgeteilt, dass die
        Arbeitskopie einen Pfad repräsentiere, der nicht mehr bestehe,
        so dass er gezwungen ist, mit <span class="command"><strong>svn switch</strong></span>
        auf den neuen Ort umzuschalten.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.maint.lifetime"></a>4.7.2. Lebensdauer von Daten</h3></div></div></div>
<p>Eine weitere nette Eigenschaft des Subversion-Modells ist
        die Möglichkeit, Zweigen und Tags eine begrenzte Lebensdauer
        zu geben, so wie jedem anderen versionierten Objekt. Nehmen
        wir beispielsweise an, dass Sie letztendlich Ihre Arbeit auf
        dem persönlichen Zweig des <code class="filename">calc</code>-Projektes
        abschließen. Nachdem Sie all Ihre Änderungen zurück nach
        <code class="filename">/calc/trunk</code> gebracht haben, braucht Ihr
        privater Zweig nicht mehr herumzuliegen:</p>
<pre class="screen">
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m "Veralteten Zweig des Projekts calc gelöscht."

Revision 375 übertragen.
</pre>
<p>Nun ist Ihr Zweig verschwunden. Selbstverständlich ist er
        nicht wirklich verschwunden: das Verzeichnis fehlt einfach in
        der <code class="literal">HEAD</code>-Revision, so dass es niemanden
        mehr ablenken kann. Wenn Sie <span class="command"><strong>svn checkout</strong></span>,
        <span class="command"><strong>svn switch</strong></span> oder <span class="command"><strong>svn list</strong></span>
        verwenden, um sich eine frühere Revision anzusehen, werden Sie
        immer noch Ihren alten Zweig sehen.</p>
<p>Falls es nicht ausreichen sollte, im gelöschten
        Verzeichnis zu stöbern, können Sie es jederzeit wieder
        zurückholen. Das Wiederbeleben von Daten in Subversion ist
        sehr einfach. Falls ein gelöschtes Verzeichnis (oder eine
        gelöschte Datei) wieder nach <code class="literal">HEAD</code> gebracht
        werden soll, verwenden Sie einfach <span class="command"><strong>svn copy</strong></span>
        zum Kopieren aus der alten Revision:</p>
<pre class="screen">
$ svn copy http://svn.example.com/repos/calc/branches/my-calc-branch@374 \
           http://svn.example.com/repos/calc/branches/my-calc-branch \
           -m "my-calc-branch wiederhergestellt."

Revision 376 übertragen.
</pre>
<p>In unserem Beispiel hatte Ihr persönlicher Zweig eine
        relativ kurze Lebensdauer: Sie haben ihn vielleicht angelegt,
        um einen Fehler zu beseitigen oder eine neue Funktion
        einzubauen. Wenn Ihr Arbeitspaket abgeschlossen ist, kann auch
        der Zweig geschlossen werden. In der Softwareentwicklung ist
        es allerdings auch üblich, zwei &#8222;<span class="quote">Haupt</span>&#8220;-Zweige zu
        haben, die für lange Zeit nebeneinander bestehen. Es ist zum
        Beispiel an der Zeit, eine stabile Version des
        <code class="filename">calc</code>-Projektes zu veröffentlichen, und
        Sie wissen, dass es wohl noch ein paar Monate dauern wird, um
        Fehler aus der Software zu entfernen. Sie wollen weder, dass
        dem Projekt neue Funktionen hinzugefügt werden, noch möchten
        Sie alle Entwicklern auffordern, das Programmieren
        einzustellen. Stattdessen erstellen Sie einen
        &#8222;<span class="quote">stabilen</span>&#8220; Zweig der Software, auf dem sich nicht
        viel verändern wird:</p>
<pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/stable-1.0 \
           -m "Stabilen Zweig für Projekt calc angelegt."

Revision 377 übertragen.
</pre>
<p>Nun können Entwickler die neuesten (oder experimentellen)
        Funktionen <code class="filename">/calc/trunk</code> hinzufügen,
        während Sie zum Grundsatz erklären, dass ausschließlich
        Fehlerbehebungen an
        <code class="filename">/calc/branches/stable-1.0</code> übergeben
        werden. Das heißt, während auf dem Stamm weitergearbeitet
        wird, überträgt jemand selektiv Fehlerbehebungen auf den
        stabilen Zweig. Selbst wenn die Software von hier bereits
        ausgeliefert worden ist, werden Sie diesen Zweig
        wahrscheinlich noch für eine lange Zeit pflegen &#8211; das
        heißt, so lange, wie Sie diese Auslieferung beim Kunden
        unterstützen werden. Wir werden das im nächsten Abschnitt
        näher erörtern.</p>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.commonpatterns"></a>4.8. Verbreitete Verzweigungsmuster</h2></div></div></div>
<p>Es gibt zahlreiche unterschiedliche Anwendungsfälle für  das
      Verzweigen und <span class="command"><strong>svn merge</strong></span>; dieser Abschnitt
      beschreibt die verbreitetesten.</p>
<p>Am häufigsten wird Versionskontrolle in der
      Softwareentwicklung verwendet, so dass wir an dieser Stelle
      kurz zwei der gebräuchlichsten Verzweigungs-  und
      Zusammenführungsmuster vorstellen, die von Entwicklerteams
      benutzt werden. Falls Sie Subversion nicht in der
      Softwareentwicklung verwenden, können Sie den Abschnitt getrost
      überspringen. Falls Sie ein Softwareentwickler sind, der
      Versionskontrolle das erste Mal verwendet, sollten Sie gut
      aufpassen, da es sich bei diesen Mustern um bewährte
      Vorgehensweisen handelt, die von erfahrenen Menschen empfohlen
      werden. Diese Prozesse sind nicht spezifisch für Subversion; sie
      sind anwendbar auf alle Versionskontrollsysteme. Trotzdem
      mag es hilfreich sein, wenn sie anhand von Subversion erklärt
      werden.</p>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.commonpatterns.release"></a>4.8.1. Release-Zweige</h3></div></div></div>
<p>Die meiste Software hat einen typischen Lebenszyklus:
        Erstellung, Test, Freigabe und wieder von vorne. Bei diesem
        Prozess gibt es zwei Probleme. Erstens müssen Entwickler neue
        Funktionen schreiben, während das Qualitätssicherungsteam sich
        Zeit zum Testen der vermeintlich stabilen Software nimmt.  Die
        Arbeit kann allerdings nicht liegenbleiben während die
        Software getestet wird. Zweitens muss das Team fast immer
        ältere, bereits an den Kunden herausgegebene Software
        unterstützen; falls im neuesten Quelltext ein Fehler entdeckt
        wird, besteht der Fehler wahrscheinlich auch in der
        herausgegebenen Version. Die Kunden möchten dann eine
        Fehlerbehebung, ohne auf ein größeres, neues Release zu
        warten.</p>
<p>Hier kann Versionskontrolle helfen. Die typische
        Vorgehensweise ist wie folgt:</p>
<div class="orderedlist"><ol type="1">
<li><p><span class="emphasis"><em>Entwickler übergeben alles Neue an den
            Stamm.</em></span>

            Tägliche Änderungen werden an <code class="filename">/trunk</code>
            übergeben: neue Funktionen, Fehlerbehebungen usw.</p></li>
<li><p><span class="emphasis"><em>Der Stamm wird in einen
            &#8222;<span class="quote">Release</span>&#8220;-Zweig kopiert.</em></span>

            Wenn das Team der Auffassung ist, dass die Software reif
            für eine Freigabe ist (z.B. Release 1.0 ), kann
            <code class="filename">/trunk</code> nach
            <code class="filename">/branches/1.0</code> kopiert werden.</p></li>
<li><p><span class="emphasis"><em>Die Teams arbeiten parallel.</em></span>

            Ein Team beginnt, den Release-Zweig sorgfältig zu testen,
            während ein anderes Team mit der Arbeit (z.B. für Release
            2.0) in <code class="filename">/trunk</code> fortfährt. Falls hier
            oder dort Fehler entdeckt werden sollten, werden die
            Fehlerbehebungen nach Bedarf hin oder her kopiert. Zu
            einem gegebenen Zeitpunkt hört jedoch sogar dieser Prozess
            auf. Der Zweig wird für die Abschlusstests vor der
            Freigabe &#8222;<span class="quote">eingefroren</span>&#8220;.</p></li>
<li><p><span class="emphasis"><em>Der Zweig wird markiert und freigegeben.</em></span>

            Nach dem Abschluss der Tests wird
            <code class="filename">/branches/1.0</code> als Momentaufnahme nach
            <code class="filename">/tags/1.0.0</code> kopiert. Das Tag wird
            paketiert und an den Kunden ausgeliefert.</p></li>
<li><p><span class="emphasis"><em>Der Zweig wird gepflegt.</em></span>

            Während die Arbeit für Version 2.0 in
            <code class="filename">/trunk</code> weitergeht, werden weiterhin
            Fehlerbehebungen von <code class="filename">/trunk</code> nach
            <code class="filename">/branches/1.0</code> portiert. Wenn sich
            ausreichend Fehlerbehebungen angesammelt haben, könnte
            sich das Management entschließen, ein Release 1.0.1
            herauszugeben: <code class="filename">/branches/1.0</code> wird
            nach <code class="filename">/tags/1.0.1</code> kopiert, und das Tag
            wird paketiert und freigegeben.</p></li>
</ol></div>
<p>Der gesamte Prozess wiederholt sich während die Software
        reift: Wenn die Arbeit an 2.0 fertig ist, wird ein neuer 2.0
        Release-Zweig erstellt, getestet, markiert und schließlich
        freigegeben. Nach einigen Jahren füllt sich das Repository mit
        einer Anzahl von Release-Zweigen, die weiterhin
        &#8222;<span class="quote">gepflegt</span>&#8220; werden, und einer Zahl von Tags, die
        den endgültigen, ausgelieferten Versionen entsprechen.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.commonpatterns.feature"></a>4.8.2. Funktions-Zweige</h3></div></div></div>
<p>Ein <em class="firstterm">Funktions-Zweig</em> ist die Art von
        Zweig, wie er im Hauptbeispiel dieses Kapitels vorkam (der
        Zweig, auf dem Sie gearbeitet haben, während Sally auf
        <code class="filename">/trunk</code> arbeitete). Es ist ein
        vorübergehender Zweig, der angelegt wird, um an einer
        komplexen Änderung zu arbeiten, ohne
        <code class="filename">/trunk</code> zu stören. Anders als
        Release-Zweige (die vielleicht ewig gepflegt werden müssen),
        werden Funktions-Zweige erstellt, eine Zeit lang genutzt,
        zurück in den Stamm integriert und schließlich gelöscht. Sie
        haben einen zeitlich begrenzten Nutzen.</p>
<p>In Projekten gehen die Meinungen oft auseinander, wann der
        richtige Zeitpunkt zum Anlegen eines Funktions-Zweiges
        gekommen ist. Manche Projekte benutzen nie Funktions-Zweige:
        jeder darf Änderungen in <code class="filename">/trunk</code>
        übergeben. Der Vorteil hier ist, dass es einfach ist &#8211;
        niemand benötigt eine Schulung im Verzweigen und
        Zusammenführen. Der Nachteil ist, dass der Code oft instabil
        oder nicht nutzbar ist. Andere Projekte verwenden
        ausschließlich Zweige: Eine Änderung darf
        <span class="emphasis"><em>niemals</em></span> direkt in
        <code class="filename">/trunk</code> übergeben werden. Selbst die
        trivialsten Änderungen werden auf einem kurzlebigen Zweig
        durchgeführt, sorgfältig geprüft und in den Stamm
        zurückgeführt. Danach wird der Zweig gelöscht. Dieses Vorgehen
        garantiert einen außerordentlich stabilen und nutzbaren Stamm,
        jedoch zum Preis eines erheblichen Prozessaufwands.</p>
<p>Die meisten Projekte bewegen sich irgendwo dazwischen.
        Gewöhnlich bestehen sie darauf, dass
        <code class="filename">/trunk</code> stets compilierfähig bleibt und
        Regressionstests besteht. Ein Funktions-Zweig wird nur dann
        benötigt, falls eine Änderung eine große Anzahl
        destabilisierender Übergaben erfordert. Eine gute Faustregel
        ist, diese Frage zu stellen: Wäre, falls ein Entwickler nach Tagen
        isolierter Entwicklung die große Änderung auf einmal übergäbe
        (so dass <code class="filename">/trunk</code> nie instabil würde), die
        Änderung zu umfangreich zum Überprüfen? Falls die Antwort auf
        diese Frage &#8222;<span class="quote">ja</span>&#8220; lautet, sollte die Änderung auf
        einem Funktions-Zweig durchgeführt werden. Während der
        Entwickler schrittweise Änderungen in den Zweig übergibt,
        können sie auf einfache Weise von den Kollegen geprüft
        werden.</p>
<p>Schließlich stellt sich die Frage, wie ein Funktions-Zweig
        am besten mit dem Stamm &#8222;<span class="quote">synchron</span>&#8220; gehalten
        werden kann während die Arbeit weitergeht. Wie wir vorher
        bereits bemerkten, besteht ein großes Risiko, wenn wochen-
        oder monatelang auf dem Zweig gearbeitet wird; währenddessen
        ändert sich auch der Stamm, so dass ein Punkt erreicht werden
        kann, an dem sich die beiden Entwicklungslinien so sehr
        unterscheiden, dass es zu einem Albtraum ausarten kann, den
        Zweig zurück auf den Stamm zu führen.</p>
<p>Diese Situation wird am besten vermieden, indem regelmäßig
        Änderungen vom Stamm in den Zweig eingearbeitet werden. Machen
        Sie es zur Gewohnheit: Arbeiten Sie wöchentlich die Änderungen
        der vergangenen Woche vom Stamm in den Zweig ein.</p>
<p>Irgendwann werden Sie dann bereit sein, den
        &#8222;<span class="quote">synchronisierten</span>&#8220; Funktions-Zweig zurück in den
        Stamm zu führen. Hierzu arbeiten Sie ein letztes Mal die
        jüngsten Änderungen vom Stamm in den Zweig ein. Danach werden
        die letzten Versionen auf dem Stamm und dem Zweig, bis auf Ihre
        Änderungen auf dem Zweig, absolut gleich sein. Dann werden Sie
        den Zweig mit der Option <code class="option">--reintegrate</code> wieder
        mit dem Stamm zusammenführen:</p>
<pre class="screen">
$ cd trunk-working-copy

$ svn update
Revision 1910.

$ svn merge --reintegrate http://svn.example.com/repos/calc/branches/mybranch
-- Zusammenführen der Unterschiede zwischen Projektarchiv-URLs in ».«:
U    real.c
U    integer.c
A    newdirectory
A    newdirectory/newfile
 U   .
&#8230;
</pre>
<p>Aus einem anderen Winkel betrachtet ist dieser
        wöchentliche Abgleich vom Stamm auf den Zweig analog zum
        Ausführen von <span class="command"><strong>svn update</strong></span> in einer
        Arbeitskopie, wobei das finale Zusammenführen <span class="command"><strong>svn
        commit</strong></span> in einer Arbeitskopie entspricht.
        <span class="emphasis"><em>Ist</em></span> denn letztendlich eine Arbeitskopie
        nicht ein sehr flacher privater Zweig? Es ist ein Zweig, der
        nur eine Änderung gleichzeitig aufnehmen kann.</p>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.advanced.vendorbr"></a>4.9. Lieferanten-Zweige</h2></div></div></div>
<p>Besonders in der Softwareentwicklung haben die von Ihnen
      versionsverwalteten Daten oft einen engen Bezug zu Daten von
      anderen, oder sind vielleicht abhängig davon. Allgemein wird der
      Bedarf ihres Projektes erfordern, dass Sie bezüglich der
      externen Datenquelle so aktuell wie möglich bleiben, ohne dabei
      die Stabilität Ihres Projektes zu opfern.  Dieses Szenario
      entfaltet sich immer dort, wo die von einer Gruppe erzeugten
      Informationen direkte Auswirkungen auf diejenigen Informationen
      hat, die von einer anderen Gruppe erstellt werden.</p>
<p>So könnte es sein, dass Softwareentwickler beispielsweise an
      einer Anwendung arbeiten, die die Bibliothek eines
      Drittanbieters benötigt. Subversion hat eine solche Abhängigkeit
      von der Bibliothek Apache Portable Runtime (APR) (siehe <a class="xref" href="svn.developer.html#svn.developer.usingapi.apr" title="8.3.1. The Apache Portable Runtime Library">Abschnitt 8.3.1, &#8222;The Apache Portable Runtime Library&#8220;</a>). Der Quelltext von
      Subversion hängt zur Gewährleistung der Portabilität von der
      APR-Bibliothek ab. In der frühen Phase der Entwicklung von
      Subversion hing das Projekt ziemlich nah am wechselnden API der
      APR, indem es immer die neueste Version des Quelltextes
      verwendete. Nun, da sowohl APR und Subversion gereift sind,
      versucht sich Subversion nur zu wohldefinierten Zeitpunkten mit
      dem APR-API zu synchronisieren, nämlich wenn dieses ausreichend
      getestet und stabil ist.</p>
<p>Falls nun Ihr Projekt von den Informationen anderer
      abhängt, können Sie diese Informationen auf mehrere Arten mit
      Ihren synchronisieren. Am umständlichsten ist es, wenn Sie
      mündliche oder schriftliche Anweisungen an alle
      Projektmitarbeiter ausgeben, dass sie sicherzustellen haben,
      stets über die für Ihr Projekt benötigten Versionen der
      Drittanbieter zu verfügen. Falls die Daten des Drittanbieters
      sich in einem Subversion-Repository befinden, können Sie auch
      mithilfe der Subversion-Externals-Definition bestimmte Versionen
      dieser Daten mit Ihrer eigenen Arbeitskopie verbinden (siehe
      <a class="xref" href="svn.advanced.html#svn.advanced.externals" title="3.8. Externals Definitions">Abschnitt 3.8, &#8222;Externals Definitions&#8220;</a>).</p>
<p>Allerdings möchten Sie von Zeit zu Zeit spezielle
      Anpassungen des Drittanbieter-Codes in Ihrem eigenen
      Versionskontrollsystem verwalten. Um auf unser Beispiel aus der
      Softwareentwicklung zurückzukommen, müssen Entwickler manchmal
      die Bibliothek der Drittanbieter für ihre Zwecke verändern.
      Diese Änderungen können neue Funktionalitäten oder
      Fehlerbehebungen beinhalten und werden nur solange intern
      verwaltet, bis sie eines Tages Teil einer offiziellen
      Auslieferung der Bibliothek werden. Es kann aber auch sein, dass
      diese Änderungen niemals an die Entwickler der Bibliothek
      zurückgegeben werden, sondern lediglich als spezielle
      Anpassungen bestehen, um die Bibliothek für Bedürfnisse der
      Softwareentwickler geeigneter zu machen.</p>
<p>Nun sind Sie in einer interessanten Situation: Ihr Projekt
      könnte seine Änderungen an den Daten von Drittanbietern auf
      getrennte Art und Weise verwalten, etwa in Form von
      Patch-Dateien oder als vollständig alternative Versionen. Jedoch
      wird so etwas schnell zu einem Albtraum, wenn es um die Pflege
      geht, da es ein Mechanismus benötigt wird, um diese Änderungen
      auf den Code des Drittanbieters anzuwenden und diese Anpassung
      bei jeder Folgelieferung zu wiederholen.</p>
<p>Die Lösung dieses Problems besteht in der Verwendung von
      <em class="firstterm">Lieferanten-Zweigen</em>.  Ein
      Lieferanten-Zweig ist ein Verzeichnisbaum in Ihrem eigenen
      Versionskontrollsystem, der Informationen enthält, die von einem
      Drittanbieter &#8211; oder Lieferanten &#8211; bereitgestellt
      wird. Jede Version der Lieferantendaten, die Sie in Ihr Projekt
      aufnehmen wollen, wird <em class="firstterm">Zulieferung</em>
      genannt.</p>
<p>Lieferanten-Zweige bieten zwei Vorteile. Erstens, wird durch
      das Vorhalten der aktuellen Zulieferung in Ihrem eigenen
      Versionskontrollsystem sichergestellt, dass für Ihre
      Projektmitarbeiter stets die richtige Version der
      Lieferantendaten verfügbar ist. Sie erhalten die richtige
      Version automatisch beim Aktualisieren ihrer Arbeitskopien.
      Zweitens, da die Daten in Ihrem eigenen Subversion-Repository
      vorgehalten werden, können Sie dort auch Ihren Anpassungen
      speichern &#8211; es besteht keine Notwendigkeit mehr, Ihre
      Änderungen automatisch (oder schlimmer noch, manuell) in die
      Zulieferungen einzuarbeiten.</p>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.advanced.vendorbr.general"></a>4.9.1. Allgemeines Vorgehen für die Verwaltung von Lieferanten-Zweigen</h3></div></div></div>
<p>Die Verwaltung von Lieferanten-Zweigen funktioniert im
        Allgemeinen so: Zunächst erzeugen Sie ein übergeordnetes
        Hauptverzeichnis (etwa <code class="filename">/vendor</code>), um
        Lieferanten-Zweige aufzunehmen. Dann importieren Sie den Code
        des Drittanbieters in ein Unterverzeichnis des
        Hauptverzeichnisses. Anschließend kopieren Sie dieses
        Unterverzeichnis an die passende Stelle Ihres
        Hauptentwicklungszweigs (z.B. <code class="filename">/trunk</code>).
        Ihre lokalen Änderungen nehmen Sie stets im
        Hauptentwicklungszweig vor. Jede erneut veröffentlichte
        Version des von Ihnen verfolgten Codes pflegen Sie in den
        Lieferanten-Zweig ein und überführen die Änderungen nach
        <code class="filename">/trunk</code>, wobei eventuelle Konflikte
        zwischen Ihren lokalen Änderungen und dem Code des Zulieferers
        aufgelöst werden.</p>
<p>Ein Beispiel hilft, um dieses Vorgehen zu erklären. Wir
        gehen von einem Szenario aus, in dem Ihr Entwicklerteam ein
        Taschenrechner-Programm entwickelt, dass mit einer Bibliothek
        eines Drittanbieters für die Arithmetik mit komplexen Zahlen,
        namens libcomplex, verlinkt wird. Wir beginnen mit dem Anlegen
        des Lieferanten-Zweiges und dem Import der ersten Zulieferung.
        Wir nennen unser Verzeichnis für den Lieferanten-Zweig
        <code class="filename">libcomplex</code>, und die Lieferungen werden in
        einem Unterverzeichnis namens <code class="filename">current</code>
        abgelegt. Da <span class="command"><strong>svn import</strong></span> alle dazwischen
        liegenden Elternverzeichnisse erzeugt, können wir all diese
        Schritte mit einem einzigen Befehl bewerkstelligen:</p>
<pre class="screen">
$ svn import /path/to/libcomplex-1.0 \
             http://svn.example.com/repos/vendor/libcomplex/current \
             -m 'Importing der ersten 1.0 Zulieferung'
&#8230;
</pre>
<p>Nun haben wir die aktuelle Version des Quelltextes von
        libcomplex in <code class="filename">/vendor/libcomplex/current</code>.
        Jetzt erzeugen wir ein Tag aus dieser Version (siehe <a class="xref" href="svn.branchmerge.html#svn.branchmerge.tags" title="4.6. Tags">Abschnitt 4.6, &#8222;Tags&#8220;</a>) und kopieren sie dann in
        den Hauptentwicklungszweig. Unsere Kopie erzeugt ein neues
        Verzeichnis <code class="filename">libcomplex</code> im bestehenden
        <code class="filename">calc</code> Projektverzeichnis. In dieser
        kopierten Version der Lieferantendaten werden wir unsere
        Anpassungen vornehmen:</p>
<pre class="screen">
$ svn copy http://svn.example.com/repos/vendor/libcomplex/current  \
           http://svn.example.com/repos/vendor/libcomplex/1.0      \
           -m 'Tag libcomplex-1.0'
&#8230;
$ svn copy http://svn.example.com/repos/vendor/libcomplex/1.0  \
           http://svn.example.com/repos/calc/libcomplex        \
           -m 'libcomplex-1.0 in den Huptzweig bringen'
&#8230;
</pre>
<p>Wir checken nun den Hauptzweig unseres Projektes aus
        &#8211; der nun eine Kopie der ersten Zulieferung enthält
        &#8211; und fangen damit an, den Quelltext von libcomplex
        anzupassen. Ehe wir uns versehen, ist unsere angepasste
        Version von libcomplex vollständig in unser
        Taschenrechner-Programm integriert.
        <sup>[<a name="id391641" href="#ftn.id391641" class="footnote">25</a>]</sup>
      </p>
<p>Ein paar Wochen später veröffentlichen die Entwickler von
        libcomplex eine neue Version ihrer Bibliothek &#8211; Version
        1.1 &#8211; die die Funktionalität enthält, die wir dringend
        benötigen.  Wir möchten die neue Version verwenden, ohne
        jedoch unsere Anpassungen zu verlieren, die wir in der
        bestehenden Version vorgenommen haben. Unterm Strich möchten
        wir die bestehende Baseline-Version libcomplex 1.0 durch eine
        Kopie von libcomplex 1.1 ersetzen und die vorher gemachten
        Anpassungen an dieser Bibliothek erneut auf die neue Version
        anwenden.  Tatsächlich gehen wir das Problem allerdings aus
        der anderen Richtung an, indem wir die Änderungen an
        libcomplex zwischen Version 1.0 und 1.1 in unsere angepasste
        Kopie einpflegen.</p>
<p>Um diesen Wechsel auf die neue Version durchzuführen,
        checken wir eine Kopie des Lieferanten-Zweigs aus und ersetzen
        den Code im Verzeichnis <code class="filename">current</code> mit dem
        neuen Quelltext von libcomplex 1.1. Wir kopieren im wahrsten
        Sinne des Wortes die neuen Dateien über die bestehenden, indem
        wir etwa das Archiv von libcomplex 1.1 in das bestehende
        Verzeichnis entpacken. Das Ziel ist, dass das Verzeichnis
        <code class="filename">current</code> nur den Code von libcomplex 1.1
        enthält, und dass dieser Code unter Versionskontrolle steht.
        Oh, und wir wollen, dass das alles mit der geringsten Störung
        an der Versionskontroll-Historie passiert.</p>
<p>Nachdem wir den 1.0 Code mit dem 1.1 Code ersetzt haben,
        wird uns <span class="command"><strong>svn status</strong></span> sowohl Dateien mit
        lokalen Änderungen als auch einige unversionierte Dateien
        anzeigen. Wenn wir das getan haben, was wir tun sollten, sind
        die unversionierten Dateien nur die mit Version 1.1 von
        libcomplex hinzugekommenen neuen Dateien &#8211; wir rufen für
        diese <span class="command"><strong>svn add</strong></span> auf, um sie unter
        Versionskontrolle zu bringen. Falls der Code von 1.1 bestimmte
        Dateien nicht mehr beinhaltet, die noch im Baum von 1.0
        vorhanden waren, kann es schwierig sein, sie zu
        identifizieren; Sie müssten die beiden Bäume mit einem
        externen Werkzeug vergleichen und dann mit <span class="command"><strong>svn
        delete</strong></span> Dateien entfernen, die in 1.0 jedoch nicht in
        1.1 vorhanden sind. (Es könnte ebenso in Ordnung sein, diese
        Dateien ungenutzt beizubehalten!) Sobald letztendlich unsere
        Arbeitskopie von <code class="filename">current</code> nur den Code von
        libcomplex 1.1 enthält, übergeben wir die Änderungen, die uns
        hierher gebracht haben.</p>
<p>Unser <code class="filename">current</code>-Zweig enthält nun die
        neue Zulieferung. Wir erzeugen nun ein Tag 1.1 (genauso, wie
        wie es mit der Zulieferung 1.0 gemacht haben) und arbeiten
        dann die Unterschiede zwischen dem Tag der vorherigen Version
        und der neuen aktuellen Version in unseren
        Hauptentwicklungszweig ein:</p>
<pre class="screen">
$ cd working-copies/calc
$ svn merge http://svn.example.com/repos/vendor/libcomplex/1.0      \
            http://svn.example.com/repos/vendor/libcomplex/current  \
            libcomplex
&#8230; # alle Konflikte zwischen ihren und unseren Änderungen auflösen
$ svn commit -m 'merging libcomplex-1.1 into the main branch'
&#8230;
</pre>
<p>Im trivialen Fall würde die neue Version der
        Drittanbieter-Bibliothek aus der Datei- und
        Verzeichnisperspektive genau so aussehen wie die vorherige
        Version. Keine der libcomplex Dateien wäre gelöscht, umbenannt
        oder an einen anderen Ort verschoben worden &#8211; die neue
        Version würde gegenüber der vorherigen lediglich textuelle
        Änderungen enthalten. In einer vollkommenen Welt würden sich
        unsere Anpassungen sauber in die neue Version einfügen, ganz
        ohne Komplikationen oder Konflikte.</p>
<p>Allerdings gestalten sich die Dinge nicht immer so
        einfach, und tatsächlich ist es normal, dass sich
        Quelltext-Dateien zwischen Software-Veröffentlichungen
        verschieben. Das verkompliziert das Vorgehen, um
        sicherzustellen, dass unsere Anpassungen für die neue Version
        immer noch gültig sind, und es kann schnell passieren, dass
        wir in eine Situation gelangen, in der wir unsere Anpassungen
        manuell in die neue Version einpflegen müssen. Sobald
        Subversion die Geschichte einer gegebenen Quelltext-Datei
        kennt &#8211; inklusive aller früheren Orte &#8211; ist das
        Vorgehen des Einpflegens in eine neue Version der Bibliothek
        recht einfach. Allerdings sind wir dafür verantwortlich,
        Subversion mitzuteilen, wie sich die Organisation des
        Quelltextes zwischen den Zulieferungen geändert hat.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.advanced.vendorbr.svn_load_dirs"></a>4.9.2. svn_load_dirs.pl</h3></div></div></div>
<p>Zulieferungen, die mehr als ein paar Löschungen,
        Hinzufügungen und Verschiebungen beinhalten, verkomplizieren
        das Vorgehen bei der Aktualisierung auf neuere Versionen der
        Drittanbieter-Daten. Aus diesem Grund stellt Subversion das
        Skript <span class="command"><strong>svn_load_dirs.pl</strong></span> zur Verfügung, das
        Sie dabei unterstützt. Dieses Skript automatisiert die zum
        Importieren notwendigen Schritte, die wir beim Vorgehen zur
        allgemeinen Verwaltung von Lieferanten-Zweigen erwähnten, um
        zu gewährleisten, dass es dabei zu möglichst wenig Fehlern
        kommt. Sie werden zwar immer noch dafür verantwortlich sein,
        mit den Zusammenführungs-Befehlen die neuen Versionen der
        Drittanbieter-Daten in Ihren Hauptentwicklungszweig
        einzupflegen, jedoch kann Ihnen
        <span class="command"><strong>svn_load_dirs.pl</strong></span> dabei helfen, diesen Punkt
        schneller und leichter zu erreichen.</p>
<p>Kurz gesagt ist <span class="command"><strong>svn_load_dirs.pl</strong></span> eine
        Verbesserung von <span class="command"><strong>svn import</strong></span> mit folgenden
        wichtigen Eigenschaften:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Es kann jederzeit aufgerufen werden, um ein
            bestehendes Verzeichnis im Repository exakt mit einem
            externen Verzeichnis abzugleichen, wobei alle notwendigen
            Hinzufügungen und Löschungen ausgeführt werden und
            darüberhinaus noch optionale Verschiebungen.</p></li>
<li><p>Es kümmert sich um komplizierte Abfolgen von
            Operationen zwischen denen Subversion eine eingeschobene
            Übergabe erforderlich macht &#8211; etwa vor dem
            zweifachen Umbenennen einer Datei oder eines
            Verzeichnisses.</p></li>
<li><p>Vom frisch importierten Verzeichnis wird optional ein
            Tag angelegt.</p></li>
<li><p>Es legt optional beliebige Propertys für Dateien und
            Verzeichnisse an, deren Name einem regulären Ausdruck
            entspricht.</p></li>
</ul></div>
<p><span class="command"><strong>svn_load_dirs.pl</strong></span> benötigt drei zwingend
        erforderliche Argumente. Das erste Argument ist der URL zum
        Basis-Subversion-Verzeichnis, in dem gearbeitet wird. Dieses
        Argument wird gefolgt von dem URL &#8211; relativ zum ersten
        Argument &#8211; wohin die aktuelle Zulieferung importiert
        werden soll. Schließlich gibt das dritte Argument an, aus
        welchem lokalen Verzeichnis importiert werden soll. In unserem
        vorigen Beispiel würde ein typischer Aufruf von
        <span class="command"><strong>svn_load_dirs.pl</strong></span> wie folgt aussehen:</p>
<pre class="screen">
$ svn_load_dirs.pl http://svn.example.com/repos/vendor/libcomplex \
                   current                                        \
                   /path/to/libcomplex-1.1
&#8230;
</pre>
<p>Sie können <span class="command"><strong>svn_load_dirs.pl</strong></span> mitteilen,
        dass Sie ein Tag von der neuen Zulieferung anlegen möchten,
        indem Sie die Option <code class="option">-t</code> gefolgt von einem
        Tag-Namen übergeben. Dieser Tag-Name ist auch ein URL relativ
        zum ersten Argument des Programms.</p>
<pre class="screen">
$ svn_load_dirs.pl -t libcomplex-1.1                              \
                   http://svn.example.com/repos/vendor/libcomplex \
                   current                                        \
                   /path/to/libcomplex-1.1
&#8230;
</pre>
<p>Wenn Sie <span class="command"><strong>svn_load_dirs.pl</strong></span> aufrufen,
        untersucht es den Inhalt Ihre existierenden Zulieferung
        &#8222;<span class="quote">current</span>&#8220; und vergleicht sie mit der
        vorgeschlagenen neuen Zulieferung. Im trivialen Fall werden
        keine Dateien ausschließlich in einer und nicht in der anderen
        Zulieferung vorhanden sein, so dass das Skript den Import ohne
        Probleme durchführt. Falls sich jedoch zwischen den Versionen
        Unterschiede in der Dateistruktur ergeben sollten, fragt
        <span class="command"><strong>svn_load_dirs.pl</strong></span> nach, wie die Unterschiede
        aufgelöst werden sollen. So haben Sie zum Beispiel die
        Möglichkeit, dem Skript mitzuteilen, dass die Datei
        <code class="filename">math.c</code> aus Version 1.0 von libcomplex in
        der Version 1.1 von libcomplex in
        <code class="filename">arithmetic.c</code> umbenannt wurde. Alle
        Diskrepanzen, die sich nicht durch Verschiebungen erklären
        lassen, werden als normale Löschungen und Hinzufügungen
        behandelt.</p>
<p>Das Skript akzeptiert auch eine gesonderte
        Konfigurationsdatei, in der Propertys auf Dateien und
        Verzeichnisse gesetzt werden können, deren Name einem
        regulären Ausdruck entspricht und dem Repository
        <span class="emphasis"><em>hinzugefügt</em></span> werden. Diese
        Konfigurationsdatei wird <span class="command"><strong>svn_load_dirs.pl</strong></span>
        mit der Option <code class="option">-p</code> bekanntgegeben. Jede Zeile
        der Konfigurationsdatei ist eine durch Leerraum begrenzte
        Menge aus zwei oder vier Werten: ein regulärer Ausdruck wie in
        Perl, zu dem der entsprechende Pfad passen muss, ein
        Schlüsselwort zur Kontrolle (entweder <code class="literal">break</code>
        oder <code class="literal">cont</code>) und optional ein Property-Name
        und ein Wert.</p>
<pre class="screen">
\.png$              break   svn:mime-type   image/png
\.jpe?g$            break   svn:mime-type   image/jpeg
\.m3u$              cont    svn:mime-type   audio/x-mpegurl
\.m3u$              break   svn:eol-style   LF
.*                  break   svn:eol-style   native
</pre>
<p>Für jeden hinzugefügten Pfad der dem regulären Ausdruck
        einer Zeile entspricht, werden die Property-Änderungen der
        Reihe nach durchgeführt, es sei denn, das
        Kontroll-Schlüsselwort ist <code class="literal">break</code> (was
        bedeutet, dass keine weiteren Property-Änderungen für diesen
        Pfad durchgeführt werden sollen). Falls das
        Kontroll-Schlüsselwort <code class="literal">cont</code> ist &#8211;
        eine Abkürzung für <code class="literal">continue</code> (fortfahren)
        &#8211; wird mit der nächsten Zeile der Konfigurationsdatei
        fortgefahren.</p>
<p>Jeglicher Leerraum im regulären Ausdruck, im Namen des
        Propertys oder im Wert des Propertys muss entweder mit
        einfachen oder doppelten Anführungszeichen umgeben werden.
        Anführungszeichen, die nicht zum Umfassen von Leerraum
        verwendet werden, können mit einem vorangestellten umgekehrten
        Schrägstrich (<code class="literal">\</code>) maskiert werden. Der
        umgekehrte Schrägstrich maskiert nur Anführungszeichen beim
        Lesen der Konfigurationsdatei, darum sollten Sie darüberhinaus
        keine weiteren Zeichen maskieren.</p>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.summary"></a>4.10. Zusammenfassung</h2></div></div></div>
<p>Wir haben in diesem Kapitel sehr viel durchgenommen. Wir
      haben die Konzepte hinter Tags und Zweigen besprochen und
      gezeigt, wie Subversion diese Konzepte durch das Kopieren von
      Verzeichnissen mit dem Befehl <span class="command"><strong>svn copy</strong></span>
      umsetzt. Wir zeigten, wie mit <span class="command"><strong>svn merge</strong></span>
      Änderungen von einem Zweig in einen anderen überführt werden
      können oder fehlerhafte Änderungen rückgängig gemacht werden.
      Wir besprachen, wie mit <span class="command"><strong>svn switch</strong></span>
      Arbeitskopien aus verschiedenen Repository-Quellen erstellt
      werden können. Und wir sprachen darüber, wie Zweige in einem
      Repository verwaltet werden können.</p>
<p>Erinnern Sie sich an das Mantra von Subversion: Zweige und
      Tags sind billig.  Scheuen Sie nicht, sie bei Bedarf zu
      nutzen!</p>
<p>Als eine hilfreiche Erinnerung an die besprochenen
      Operationen sei hier noch einmal eine Referenztabelle angeführt,
      die Sie benutzen können, während Sie damit beginnen, Zweige zu
      verwenden.</p>
<div class="table">
<a name="svn.branchemerge.summary.tbl-1"></a><p class="title"><b>Tabelle 4.1. Befehle zum Verzweigen und Zusammenführen</b></p>
<div class="table-contents"><table summary="Befehle zum Verzweigen und Zusammenführen" border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>Aktion</th>
<th>Befehl</th>
</tr></thead>
<tbody>
<tr>
<td>Erstellung eines Zweigs oder eines Tags</td>
<td><strong class="userinput"><code>svn copy <em class="replaceable"><code>URL1</code></em> <em class="replaceable"><code>URL2</code></em></code></strong></td>
</tr>
<tr>
<td>Umschalten einer Arbeitskopie auf einen Zweig oder
              ein Tag</td>
<td><strong class="userinput"><code>svn switch <em class="replaceable"><code>URL</code></em></code></strong></td>
</tr>
<tr>
<td>Synchronisierung eines Zweigs mit dem Stamm</td>
<td><strong class="userinput"><code>svn merge <em class="replaceable"><code>trunkURL</code></em>; svn commit</code></strong></td>
</tr>
<tr>
<td>Anzeige der Zusammenführungs-Geschichte oder in
              Frage kommender Änderungsmengen</td>
<td><strong class="userinput"><code>svn mergeinfo target --from-source=<em class="replaceable"><code>URL</code></em></code></strong></td>
</tr>
<tr>
<td>Zurückführen des Zweigs in den Stamm</td>
<td><strong class="userinput"><code>svn merge --reintegrate <em class="replaceable"><code>branchURL</code></em>; svn commit</code></strong></td>
</tr>
<tr>
<td>Einarbeiten einer bestimmten Änderung</td>
<td><strong class="userinput"><code>svn merge -c <em class="replaceable"><code>REV</code></em> <em class="replaceable"><code>URL</code></em>; svn commit</code></strong></td>
</tr>
<tr>
<td>Einarbeiten einer Serie von Änderungen</td>
<td><strong class="userinput"><code>svn merge -r <em class="replaceable"><code>REV1</code></em>:<em class="replaceable"><code>REV2</code></em> <em class="replaceable"><code>URL</code></em>; svn commit</code></strong></td>
</tr>
<tr>
<td>Eine Änderung für das automatische Zusammenführen
              blockieren</td>
<td><strong class="userinput"><code>svn merge -c <em class="replaceable"><code>REV</code></em> --record-only <em class="replaceable"><code>URL</code></em>; svn commit</code></strong></td>
</tr>
<tr>
<td>Vorschau einer Zusammenführung</td>
<td><strong class="userinput"><code>svn merge <em class="replaceable"><code>URL</code></em> --dry-run</code></strong></td>
</tr>
<tr>
<td>Verwerfen des Ergebnisses einer Zusammenführung</td>
<td><strong class="userinput"><code>svn revert -R .</code></strong></td>
</tr>
<tr>
<td>Etwas aus der Geschichte wiederbeleben</td>
<td><strong class="userinput"><code>svn copy <em class="replaceable"><code>URL</code></em>@<em class="replaceable"><code>REV</code></em> <em class="replaceable"><code>localPATH</code></em></code></strong></td>
</tr>
<tr>
<td>Eine übergebene Änderung rückgängig machen</td>
<td><strong class="userinput"><code>svn merge -c -<em class="replaceable"><code>REV</code></em> <em class="replaceable"><code>URL</code></em>; svn commit</code></strong></td>
</tr>
<tr>
<td>Anzeige der Geschichte unter Berücksichtigung von
              Zusammenführungen</td>
<td><strong class="userinput"><code>svn log -g; svn blame -g</code></strong></td>
</tr>
<tr>
<td>Erzeugen eines Tags aus einer Arbeitskopie</td>
<td><strong class="userinput"><code>svn copy . <em class="replaceable"><code>tagURL</code></em></code></strong></td>
</tr>
<tr>
<td>Einen Zweig oder ein Tag verschieben</td>
<td><strong class="userinput"><code>svn mv <em class="replaceable"><code>URL1</code></em> <em class="replaceable"><code>URL2</code></em></code></strong></td>
</tr>
<tr>
<td>Einen Zweig oder ein Tag löschen</td>
<td><strong class="userinput"><code>svn rm <em class="replaceable"><code>URL</code></em></code></strong></td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.id384682" href="#id384682" class="para">20</a>] </sup>Subversion unterstützt nicht das Kopieren zwischen
        verschiedenen Repositorys. Wenn Sie mit <span class="command"><strong>svn
        copy</strong></span> oder <span class="command"><strong>svn move</strong></span> URLs
        verwenden, können Sie nur Objekte innerhalb desselben
        Repositorys kopieren oder verschieben.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id386707" href="#id386707" class="para">21</a>] </sup>Allerdings gibt es im Subversion-Projekt Pläne, eines
            Tages einen Befehl zu implementieren, der die Aufgabe
            erledigen würde, Informationen dauerhaft zu löschen. Bis
            dahin, siehe 
            <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.tk.svndumpfilter" title="5.4.1.3. svndumpfilter">Abschnitt 5.4.1.3, &#8222;svndumpfilter&#8220;</a>
            für einen möglichen Notbehelf.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id387341" href="#id387341" class="para">22</a>] </sup>Zumindest trifft das zur Zeit für Subversion 1.5 zu.
              Dieses Verhalten könnte sich in künftigen Versionen von
              Subversion verbessern.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id387951" href="#id387951" class="para">23</a>] </sup>Interessanterweise werden wir nach dem
                Zurücknehmen einer Revision auf diese Art nicht in der
                Lage sein, diese Revision erneut mit <strong class="userinput"><code>svn
                  merge . -c 5</code></strong> anzuwenden, da aus den
                Metadaten hervorgeht, dass r5 bereits angewendet
                wurde. Wir müssten die Option
                <code class="option">--ignore-ancestry</code> verwenden, damit
                der Befehl die bestehenden Metadaten ignoriert.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id389628" href="#id389628" class="para">24</a>] </sup>Sie <span class="emphasis"><em>können</em></span> jedoch <span class="command"><strong>svn
          switch</strong></span> mit der Option <code class="option">--relocate</code>
          verwenden, falls sich der URL Ihres Servers geändert hat,
          und Sie die bestehende Arbeitskopie nicht aufgeben wollen.
          Siehe <a class="xref" href="svn.ref.svn.c.switch.html" title="svn switch">svn switch</a> für weitere
          Informationen und ein Beispiel.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id391641" href="#id391641" class="para">25</a>] </sup>Und er ist natürlich völlig frei von Fehlern!</p></div>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="svn.advanced.html">Zurück</a> </td>
<td width="20%" align="center"> </td>
<td width="40%" align="right"> <a accesskey="n" href="svn.reposadmin.html">Weiter</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Kapitel 3. Advanced Topics </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td>
<td width="40%" align="right" valign="top"> Kapitel 5. Verwaltung des Repositorys</td>
</tr>
</table>
</div>
</body>
</html>
