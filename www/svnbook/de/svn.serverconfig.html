<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Kapitel 6. Die Administration eines Subversion-Servers</title>
<link rel="stylesheet" href="styles.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="index.html" title="Versionskontrolle mit Subversion">
<link rel="up" href="index.html" title="Versionskontrolle mit Subversion">
<link rel="prev" href="svn.reposadmin.html" title="Kapitel 5. Verwaltung des Repositorys">
<link rel="next" href="svn.customization.html" title="Kapitel 7. Customizing Your Subversion Experience">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Kapitel 6. Die Administration eines Subversion-Servers</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="svn.reposadmin.html">Zurück</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a accesskey="n" href="svn.customization.html">Weiter</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="chapter" lang="de">
<div class="titlepage"><div><div><h2 class="title">
<a name="svn.serverconfig"></a>Kapitel 6. Die Administration eines Subversion-Servers</h2></div></div></div>
<div class="toc">
<p><b>Inhaltsverzeichnis</b></p>
<dl>
<dt><span class="sect1"><a href="svn.serverconfig.html#svn.serverconfig.overview">6.1. Überblick</a></span></dt>
<dt><span class="sect1"><a href="svn.serverconfig.html#svn.serverconfig.choosing">6.2. Auswahl einer Serverkonfiguration</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.serverconfig.html#svn.serverconfig.choosing.svnserve">6.2.1. Der svnserve-Server</a></span></dt>
<dt><span class="sect2"><a href="svn.serverconfig.html#svn.serverconfig.choosing.svn-ssh">6.2.2. svnserve über SSH</a></span></dt>
<dt><span class="sect2"><a href="svn.serverconfig.html#svn.serverconfig.choosing.apache">6.2.3. Der Apache HTTP Server</a></span></dt>
<dt><span class="sect2"><a href="svn.serverconfig.html#svn.serverconfig.choosing.recommendations">6.2.4. Empfehlungen</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.serverconfig.html#svn.serverconfig.svnserve">6.3. svnserve, ein maßgefertigter Server</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.serverconfig.html#svn.serverconfig.svnserve.invoking">6.3.1. Der Serverstart</a></span></dt>
<dt><span class="sect2"><a href="svn.serverconfig.html#svn.serverconfig.svnserve.auth">6.3.2. Integrierte Authentifikation und Autorisation</a></span></dt>
<dt><span class="sect2"><a href="svn.serverconfig.html#svn.serverconfig.svnserve.sasl">6.3.3. Using <span class="command"><strong>svnserve</strong></span> with SASL</a></span></dt>
<dt><span class="sect2"><a href="svn.serverconfig.html#svn.serverconfig.svnserve.sshauth">6.3.4. Tunneling over SSH</a></span></dt>
<dt><span class="sect2"><a href="svn.serverconfig.html#svn.serverconfig.svnserve.sshtricks">6.3.5. SSH configuration tricks</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.serverconfig.html#svn.serverconfig.httpd">6.4. httpd, the Apache HTTP Server</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.serverconfig.html#svn.serverconfig.httpd.prereqs">6.4.1. Prerequisites</a></span></dt>
<dt><span class="sect2"><a href="svn.serverconfig.html#svn.serverconfig.httpd.basic">6.4.2. Basic Apache Configuration</a></span></dt>
<dt><span class="sect2"><a href="svn.serverconfig.html#svn.serverconfig.httpd.authn">6.4.3. Authentication Options</a></span></dt>
<dt><span class="sect2"><a href="svn.serverconfig.html#svn.serverconfig.httpd.authz">6.4.4. Authorization Options</a></span></dt>
<dt><span class="sect2"><a href="svn.serverconfig.html#svn.serverconfig.httpd.extra">6.4.5. Extra Goodies</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.serverconfig.html#svn.serverconfig.pathbasedauthz">6.5. Path-Based Authorization</a></span></dt>
<dt><span class="sect1"><a href="svn.serverconfig.html#svn.serverconfig.multimethod">6.6. Supporting Multiple Repository Access Methods</a></span></dt>
</dl>
</div>
<p>Der Zugriff auf ein Subversion-Repository kann problemlos 
	von mehreren Clients, welche auf demselben Rechner wie 
	Subversion laufen, gleichzeitig erfolgen &#8211; unter Verwendung der 
	<code class="literal">file://</code>-Methode. Aber typischerweise läuft
	der Subversion-Server auf einem separaten Rechner, und der Zugriff
	erfolgt von Clients auf vielen verschiedenen Computern aus der ganzen
	Firma &#8211; ja sogar der ganzen Welt.</p>
<p>In diesem Kapitel erklären wir, wie Sie ihr Subversion-Repository
    für den Fernzugriff von Clients fit machen. Wir werden
	ausführlich auf alle aktuell verfügbaren Servermechanismen von 
	Subversion eingehen und über ihre Konfiguration und Verwendung reden.
	Nach dem Lesen dieses Kapitels sollten Sie in der Lage sein, zu entscheiden,
	welche Netzwerk-Konfiguration Ihren Bedürfnissen entspricht und wie
	diese auf ihrem Server eingerichtet wird.</p>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.serverconfig.overview"></a>6.1. Überblick</h2></div></div></div>
<p>Subversion wurde mit einer abstrakten
	Netzwerkschicht entworfen. Dies bedeutet, dass auf ein 
	Repository automatisiert von beliebigen Server-Prozessen zugegriffen
    werden kann, und die für Clients vorhandene &#8222;<span class="quote">Repository-Access</span>&#8220;-API
    (Programmierschnittstelle) erlaubt es Programmierern, Plugins 
	zu entwickeln, die relevante Netzwerkprotokolle verstehen. Theoretisch ermöglicht 
	dies Subversion, eine unbegrenzte Zahl an Netzwerkprotokollen zu verwenden.
	Zum Zeitpunkt an dem dies geschrieben wird, gibt es aber nur zwei Server.</p>
<p>Apache ist ein sehr beliebter Webserver, welcher mittels des
	<span class="command"><strong>mod_dav_svn</strong></span>-Moduls auf Repositorys zugreifen und 
	diese für Clients verfügbar machen kann. Verwendet wird dabei das
	WebDAV/DeltaV-Protokoll, welches eine Erweiterung von HTTP ist.
	Da Apache ein stark erweiterbarer Webserver ist, bietet er
	eine Menge an &#8222;<span class="quote">frei verfügbaren</span>&#8220; Funktionen/Modulen,
	wie SSL-verschlüsselte Verbindungen, Logging, sowie die Integration diverser
	Authentifikationssysteme von Drittanbietern und einen eingeschränkten
	Web-Browser-gestützten Repository-Lesezugriff.</p>
<p>In der anderen Ecke befindet sich <span class="command"><strong>svnserve</strong></span>:
	ein kleiner, leichtgewichtiger Server, der ein einfaches Netzwerkprotokoll
	für die Zugriffe der Clients verwendet. Da dieses Protokoll für die 
	Verwendung mit Subversion entwickelt wurde und, im Gegensatz zu HTTP,
	zustandsorientiert ist, bietet es einen deutlich schnelleren Netzwerkzugriff &#8211;
	spart allerdings auch einige wichtige Funktionen aus. So bietet er eine 
	SASL-basierte Verschlüsselung und Authentifikation, hat aber keine 
	Logging-Funktionen oder eingebauten Web-Browser-Zugriff. Wie auch immer,
	er ist extrem einfach einzurichten und für kleinere Teams, welche einfach
	nur schnell mit Subversion "loslegen" wollen, die beste Wahl.</p>
<p>Ein dritte Möglichkeit ist, <span class="command"><strong>svnserve</strong></span> durch
	SSH-Verbindungen zu tunneln. Auch wenn in diesem Fall weiterhin 
	<span class="command"><strong>svnserve</strong></span> verwendet wird, so unterscheidet sich
	die Funktionalität ziemlich von der normalen Nutzung von
	<span class="command"><strong>svnserve</strong></span>. SSH wird zur Verschlüsselung der gesamten 
	Kommunikation verwendet. Ebenso zur Authentifizierung, was die
	Verwendung von realen Nutzerkonten auf dem Subversion-Server notwendig
	macht (anders als beim einfachen <span class="command"><strong>svnserve</strong></span>, der seine
	eigene Nutzerverwaltung hat). Des weiteren ist es notwendig &#8211; da jeder
	angemeldete Nutzer einen eigenen <span class="command"><strong>svnserve</strong></span>-Prozess
	startet &#8211; einer Gruppe von lokalen Nutzern (aus Sicht der Rechtevergabe)
	vollen Zugriff auf das Repository via <code class="literal">file://</code> URLs zu
	ermöglichen. Pfad-basierte Zugriffskontrolle schließt sich in diesem Fall aus,
	da die Nutzer direkt auf die Datenbank-Dateien zugreifen.</p>
<p><a class="xref" href="svn.serverconfig.html#svn.serverconfig.overview.tbl-1" title="Tabelle 6.1. Vergleich der Serveroptionen für Subversion">Tabelle 6.1, &#8222;Vergleich der Serveroptionen für Subversion&#8220;</a> zeigt eine kurze Zusammenfassung
	der drei typischen Server-Konfigurationen.</p>
<div class="table">
<a name="svn.serverconfig.overview.tbl-1"></a><p class="title"><b>Tabelle 6.1. Vergleich der Serveroptionen für Subversion</b></p>
<div class="table-contents"><table summary="Vergleich der Serveroptionen für Subversion" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Funktionen</th>
<th>Apache + mod_dav_svn</th>
<th>svnserve</th>
<th>svnserve via SSH</th>
</tr></thead>
<tbody>
<tr>
<td>Authentifizierungsmöglichkeiten</td>
<td>HTTP(S) basic auth, X.509 Zertifikate, LDAP, NTLM,
              oder jede andere für den Apache Webserver verfügbare Methode</td>
<td>CRAM-MD5 als Voreinstellung,  LDAP, NTLM
            oder jede andere für SASL verfügbare Methode</td>
<td>SSH</td>
</tr>
<tr>
<td>Nutzerkonfigurationen</td>
<td>private <code class="filename">users</code> Datei oder jede andere für den Apache Webserver verfügbare Methode (LDAP, SQL, etc)</td>
<td>private <code class="filename">users</code> Datei, oder jede andere für SASL verfügbare Methode (LDAP, SQL, etc.)</td>
<td>lokale Nutzerkonten auf dem Server</td>
</tr>
<tr>
<td>Autorisierungsmöglichkeiten</td>
<td>Lese-/Schreibzugriff auf das komplette Repository
             oder pfadbasierte Rechtevergabe</td>
<td>Lese-/Schreibzugriff auf das komplette Repository
             oder pfadbasierte Rechtevergabe</td>
<td>Lese-/Schreibzugriff nur auf ganzes Repository einstellbar</td>
</tr>
<tr>
<td>Verschlüsselung</td>
<td>optional mit SSL</td>
<td>optional mit der SASL-Funktionen</td>
<td>Bestandteil der SSH-Verbindung</td>
</tr>
<tr>
<td>Loggen</td>
<td>Apache-seitiges Loggen aller HTTP-Anfragen,
            optionales &#8222;<span class="quote">High-Level</span>&#8220;-Loggen aller Client-Operationen</td>
<td>kein Loggen</td>
<td>kein Loggen</td>
</tr>
<tr>
<td>Interoperabilität</td>
<td>Zugriff durch andere WebDAV-Clients</td>
<td>Verbindung nur mit svn-Clients möglich</td>
<td>Verbindung nur mit svn-Clients möglich</td>
</tr>
<tr>
<td>web-basierte Anzeige des Repositorys</td>
<td>eingeschränkte Unterstützung, alternativ mittels Programmen von Drittanbietern,
              wie etwa ViewVC, erweiterbar</td>
<td>nur mittels Programmen von Drittanbietern, wie etwa ViewVC</td>
<td>nur mittels Programmen von Drittanbietern, wie etwa ViewVC</td>
</tr>
<tr>
<td>Master-Slave-Server Replikationen</td>
<td>transparenter Schreib-Proxy vom Slave zum Master</td>
<td>beschränkt auf nur lesbare Slave-Server</td>
<td>beschränkt auf nur lesbare Slave-Server</td>
</tr>
<tr>
<td>Geschwindigkeit</td>
<td>ein wenig langsamer</td>
<td>ein wenig schneller</td>
<td>ein wenig schneller</td>
</tr>
<tr>
<td>Erstkonfiguration</td>
<td>eher komplexer</td>
<td>sehr einfach</td>
<td>durchschnittlich</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break">
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.serverconfig.choosing"></a>6.2. Auswahl einer Serverkonfiguration</h2></div></div></div>
<p>Also dann, welchen Server sollten Sie nun verwenden? Welcher ist der beste?</p>
<p>Auf diese Frage gibt es offensichtlich nicht die eine, richtige Antwort.
	Denn jedes Team stellt andere Anforderungen, und die verschieden Server bieten unterschiedliche
	Funktionen und Voraussetzungen. Das Subversion-Projekt selbst bevorzugt keinen der genannten Server
	oder betrachtet einen als etwas &#8222;<span class="quote">offizieller</span>&#8220; als die anderen.</p>
<p>Wir beleuchten nun die einzelnen Gründe, die für die eine oder andere Konstellation
	sprechen, ebenso auch Gründe, welche vielleicht <span class="emphasis"><em>gegen</em></span> 
	eine der Möglichkeiten sprechen.</p>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.serverconfig.choosing.svnserve"></a>6.2.1. Der svnserve-Server</h3></div></div></div>
<div class="variablelist"><dl>
<dt><span class="term">Gründe, die für eine Nutzung sprechen:</span></dt>
<dd><div class="itemizedlist"><ul type="disc">
<li><p>Das Aufsetzen geht schnell und einfach.</p></li>
<li><p>Das verwendete Netzwerkprotokoll ist zustandsorientiert
            und merklich schneller als WebDAV.</p></li>
<li><p>Es müssen keine lokalen Nutzerkonten auf dem Server eingerichtet werden.</p></li>
<li><p>Das Passwort wird nicht über das Netzwerk übertragen.</p></li>
</ul></div></dd>
<dt><span class="term">Gründe, warum Sie svnserve eventuell nicht verwenden wollen:</span></dt>
<dd><div class="itemizedlist"><ul type="disc">
<li><p>Es gibt standardmäßig nur eine Authentifizierungsmethode,
                das Netzwerkprotokoll ist unverschlüsselt und das Passwort wird
                vom Server im Klartext gespeichert. (Mit SASL können diese Probleme zwar
                umgangen werden, dies erfordert aber eine etwas aufwendigere Konfiguration.)</p></li>
<li><p>Es wird nichts geloggt, auch keine Fehler.</p></li>
<li><p>Keinen eingebauten Webbrowser-gestützten Lesezugriff. (Wenn Sie dies 
                wünschen, müssen Sie einen eigenständigen Webserver sowie Repository-Browser-Software
                installieren.)</p></li>
</ul></div></dd>
</dl></div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.serverconfig.choosing.svn-ssh"></a>6.2.2. svnserve über SSH</h3></div></div></div>
<div class="variablelist"><dl>
<dt><span class="term">Gründe, die für eine Nutzung sprechen:</span></dt>
<dd><div class="itemizedlist"><ul type="disc">
<li><p>Das verwendete Netzwerkprotokoll ist zustandsorientiert
            und merklich schneller als WebDAV.</p></li>
<li><p>Sie können  bestehende Nutzerzugänge des SSH-Servers
            verwenden.</p></li>
<li><p>Der gesamte Netzwerkverkehr ist verschlüsselt.</p></li>
</ul></div></dd>
<dt><span class="term">Gründe, warum Sie auf diese Konstellation eventuell verzichten wollen:</span></dt>
<dd><div class="itemizedlist"><ul type="disc">
<li><p>Es steht nur eine Authentifizierungsmöglichkeit zur Verfügung.</p></li>
<li><p>Es wird nichts geloggt, auch keine Fehler.</p></li>
<li><p>Die verwendeten Nutzer müssen in derselben Nutzergruppe (auf dem Server) sein,
            oder sich einen SSH-Key teilen.</p></li>
<li><p>Bei unsachgemäßer Verwendung kann es zu Problemen mit den Dateirechten kommen.</p></li>
</ul></div></dd>
</dl></div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.serverconfig.choosing.apache"></a>6.2.3. Der Apache HTTP Server</h3></div></div></div>
<div class="variablelist"><dl>
<dt><span class="term">Gründe, die für eine Nutzung sprechen:</span></dt>
<dd><div class="itemizedlist"><ul type="disc">
<li><p>Subversion hat damit Zugriff auf alle für
              den Apache verfügbaren Authentifizierungsmethoden (und das sind viele).</p></li>
<li><p>Es müssen auf dem Server keine Nutzerkonten angelegt werden.</p></li>
<li><p>Apache loggt nach Wunsch (fast) alles.</p></li>
<li><p>Der Netzwerkverkehr kann mittels SSL verschlüsselt werden.</p></li>
<li><p>In der Regel lässt sich das HTTP(S)-Protokoll problemlos durch Firewalls routen.</p></li>
<li><p>Auf das Repository kann lesend auch via Webbrowser zugegriffen werden.</p></li>
<li><p>Das Repository lässt sich als Netzlaufwerk einhängen (mounten). Änderungen
                  an den Dateien unterliegen trotzdem der Versionskontrolle. 
                  (siehe <a class="xref" href="svn.webdav.html#svn.webdav.autoversioning" title="C.2. Autoversioning">Abschnitt C.2, &#8222;Autoversioning&#8220;</a>.)</p></li>
</ul></div></dd>
<dt><span class="term">Was gegen den Apache Webserver spricht:</span></dt>
<dd><div class="itemizedlist"><ul type="disc">
<li><p>Er ist merklich langsamer als <span class="command"><strong>svnserve</strong></span>, da HTTP als 
                zustandsloses Protokoll eine höhere Netzwerklast verursacht.</p></li>
<li><p>Die Ersteinrichtung kann etwas schwierig sein.</p></li>
</ul></div></dd>
</dl></div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.serverconfig.choosing.recommendations"></a>6.2.4. Empfehlungen</h3></div></div></div>
<p>Im Allgemeinen empfehlen die Autoren dieses Buches eine einfache
        <span class="command"><strong>svnserve</strong></span>-Installation für kleine Teams, denen an
        einer schnellen und unkomplizierten  Nutzung von Subversion gelegen ist.
        Dies ist die Variante, welche sich am einfachsten einrichten und administrieren lässt.
        Sollte später Bedarf bestehen, so kann immer noch auf eine komplexere Servervariante
        gewechselt werden.</p>
<p>Es folgen einige allgemeine Empfehlungen und Tipps, basierend auf
        mehrjähriger Erfahrung in der Nutzerbetreuung:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>
            Falls Sie für ihr Team die einfachste Servervariante suchen,
            dann kommen Sie mit einer Standard-<span class="command"><strong>svnserve</strong></span>-Installation
            am schnellsten ans Ziel. Beachten Sie aber, dass der Inhalt ihres Repositorys
            im Klartext über das Netzwerk übertragen wird. Wenn Sie nur innerhalb ihres
            Firmennetzwerks oder eines VPNs arbeiten, so ist dies kein Beinbruch.
            Ist ihr Repository allerdings vom Internet aus erreichbar, so sollten Sie
            eventuell sicherstellen, dass darin keine sensiblen Daten vorhanden sind
            (z.B. nur Open-Source Code o.ä.), oder Sie legen noch einmal Hand an und
            verschlüsseln mittels SASL die Netzwerkverbindung zur ihrem Repository.
            </p></li>
<li><p>
            Wenn Sie bereits über Systeme zur Authentifizierung (LDAP,
            Active Directory, NTLM, X.509 etc.) verfügen und Subversion in
            diese integrieren möchten, so  bleibt Ihnen die Wahl zwischen einer
            Apache-gestützten Variante oder eines mit SASL vermählten <span class="command"><strong>svnserve</strong></span>.
            Stehen serverseitige Logs zur Aufzeichnung von Client-Aktivitäten und Serverfehlern
            auf Ihrer Wunschliste, dann ist Apache die einzige Option.  
            </p></li>
<li><p>
             Wenn Sie sich für die Verwendung von Apache oder eines
             Standard-<span class="command"><strong>svnserve</strong></span> entschieden haben, 
             dann legen Sie auf ihrem System einen einfachen <span class="command"><strong>svn</strong></span>-Nutzer
             an und lassen den Serverprozess unter diesem Nutzer laufen.
             Stellen Sie zudem sicher, dass das gesamte Verzeichnis mit dem Repository nur
             diesem <span class="command"><strong>svn</strong></span>-Nutzer gehört. Damit wird der Zugriff auf ihr
             Repository durch das Dateisystem des Serverbetriebssystems verwaltet, und 
             nur der Serverprozess kann noch Änderungen daran vornehmen.
             </p></li>
<li><p>
            Wenn Sie bereits über eine aus SSH-Zugängen bestehende Infrastruktur
            verfügen, und Ihre Nutzer auf dem Subversion-Server schon
            lokale Zugänge haben, dann ist die Verwendung einer
            <span class="command"><strong>svnserve</strong></span>-über-SSH-Lösung sinnvoll.
            Wir empfehlen diese Variante allerdings nur sehr ungern.
            Es ist im Allgemeinen sicherer, Ihren Nutzern nur durch 
            <span class="command"><strong>svnserve</strong></span> oder Apache verwaltete Zugänge
            den Zugriff auf Ihr Repository zu ermöglichen und eben nicht
            mittels vollwertiger Nutzerzugänge auf dem Serversystem.
            Falls der Wunsch nach einer starken Netzwerkverschlüsselung Sie
            auf die Verwendung des SSH gebracht hat, dann empfehlen wir Ihnen
            stattdessen die Verwendung von Apache und SSL, bzw. die Kombination
            aus <span class="command"><strong>svnserve</strong></span> und SASL-Verschlüsselung.
            </p></li>
<li><p>          
            Lassen Sie sich bitte <span class="emphasis"><em>nicht</em></span> von der Idee verführen,
            allen Ihren Nutzern direkten Zugriff auf das Repository mittels der 
            <code class="literal">file://</code>-Methode zu geben. Auch wenn der Zugriff
            auf das Repository durch eine Netzwerkfreigabe erfolgt, bleibt es immmer
            noch eine schlechte Idee.
            Dadurch wird jeglicher Sicherheitspuffer zwischen dem Nutzer und dem Repository
            entfernt: Ein Anwender kann ohne (oder auch mit) Absicht die Datenbank des Repositorys
            beschädigen. 
            Es wird zudem schwierig, das Repository offline zu nehmen um eine Inspektion
            oder ein Upgrade durchzuführen. Zudem kann es Ihnen eine Menge Probleme mit
            den Dateirechten einbringen (siehe <a class="xref" href="svn.serverconfig.html#svn.serverconfig.multimethod" title="6.6. Supporting Multiple Repository Access Methods">Abschnitt 6.6, &#8222;Supporting Multiple Repository Access Methods&#8220;</a>). 
            Beachten Sie bitte auch, dass dies einer der Gründe ist, warum wir vor der
            Verwendung der <code class="literal">svn+ssh://</code>-Methode für den Repository-Zugriff
            warnen. Vom Standpunkt der Sicherheit ist dies effektiv dasselbe wie
            die Verwendung von <code class="literal">file://</code> für den Zugriff durch lokale 
            Benutzer und kann zu denselben Problemen führen, wenn der Administrator nicht
            alle Vorsicht walten lässt.
             
            </p></li>
</ul></div>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.serverconfig.svnserve"></a>6.3. svnserve, ein maßgefertigter Server</h2></div></div></div>
<p>Das Programm <span class="command"><strong>svnserve</strong></span> ist ein leichtgewichtiger Server,
      welcher für die Kommunikation mit den Clients ein auf TCP/IP basierendes,
      zustandsorientiertes Protokoll verwendet. Um sich mit dem Server zu
      verbinden, verwenden die Clients entweder das <code class="literal">svn://</code>-
      oder das <code class="literal">svn+ssh://</code>-Schema. In diesem Abschnitt behandeln
      wir die unterschiedlichen Möglichkeiten, <span class="command"><strong>svnserve</strong></span>
      einzusetzen, wie sich die Clients am Server authentifizieren und wie
      die passenden Zugangsrechte zum Repository korrekt eingerichtet werden.
      </p>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.serverconfig.svnserve.invoking"></a>6.3.1. Der Serverstart</h3></div></div></div>
<p>Es gibt mehrere Möglichkeiten, <span class="command"><strong>svnserve</strong></span>
      zu starten:
      </p>
<div class="itemizedlist"><ul type="disc">
<li><p><span class="command"><strong>svnserve</strong></span> als eigenständigen Dienst (engl. daemon)
        starten und auf Anfragen von Clients reagieren lassen.</p></li>
<li><p><span class="command"><strong>svnserve</strong></span> bei Bedarf mit Hilfe
        des Unix-Dienstes <span class="command"><strong>inetd</strong></span> starten, wenn auf einem 
        festgelegten Port Anfragen eines svn-Clients ankommen.</p></li>
<li><p>Einen SSH-Server verwenden, um <span class="command"><strong>svnserve</strong></span>
        fallweise über einen verschlüsselten SSH-Tunnel zu betreiben.</p></li>
<li><p><span class="command"><strong>svnserve</strong></span> als Microsoft-Windows-Dienst laufen lassen.</p></li>
</ul></div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.svnserve.invoking.daemon"></a>6.3.1.1. svnserve als Unix-Dienst</h4></div></div></div>
<p>Die einfachste Variante ist, <span class="command"><strong>svnserve</strong></span> als
          eigenständigen (Unix-)Dienst laufen zu lassen. Verwenden Sie hierfür
          die <code class="option">-d</code> Option beim Aufruf:
          </p>
<pre class="screen">
$ svnserve -d
$               # svnserve läuft nun als Dienst und lauscht auf Port 3690
</pre>
<p>Wird <span class="command"><strong>svnserve</strong></span> als Dienst betrieben, 
          können Sie mit den Optionen  <code class="option">--listen-port</code> und
          <code class="option">--listen-host</code> festlegen, auf welchem Port und unter 
          welchem Hostnamen er lauschen soll.</p>
<p>Wurde <span class="command"><strong>svnserve</strong></span> auf diese Weise erfolgreich gestartet,
        stehen nun alle Repositorys auf dem Server für Nutzer im Netzwerk zur Verfügung.
        Für einen Zugriff muss ein Client den <span class="emphasis"><em>absoluten</em></span> Pfad zum
        Repository im URL angeben. Ist das Repository beispielsweise im Verzeichnis
        <code class="filename">/var/svn/project1</code> gespeichert, so sieht ein entsprechender URL
        für den Zugriff folgendermaßen aus: <code class="uri">svn://host.example.com/var/svn/project1</code>.
        Um die Sicherheit zu erhöhen, kann <span class="command"><strong>svnserve</strong></span> beim Start mit
        der Option <code class="option">-r</code> auf ein bestimmtes Verzeichnis beschränkt werden, so dass nur noch
        die darin liegenden Repositorys im Netz verfügbar sind. Ein Beispiel:</p>
<pre class="screen">
$ svnserve -d -r /var/svn
&#8230;
</pre>
<p>Mit der <code class="option">-r</code>-Option wird festgelegt, welches
        Verzeichnis vom <span class="command"><strong>svnserve</strong></span> bei Anfragen als
        Wurzelverzeichnis (engl. root) verwendet wird. Ein Client muss
        nun in seiner URL nur noch den Pfad relativ zum neuen Wurzelverzeichnis
        angeben, was die URL erheblich verkürzt und
        die Verzeichnisstruktur etwas verschleiert:</p>
<pre class="screen">
$ svn checkout svn://host.example.com/project1
&#8230;
</pre>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.svnserve.invoking.inetd"></a>6.3.1.2. svnserve über inetd starten</h4></div></div></div>
<p>Wenn Sie <span class="command"><strong>inetd</strong></span> zum Starten des 
          Prozesses verwenden wollen,
          so übergeben Sie <span class="command"><strong>svnserve</strong></span> beim Aufruf
          die Option <code class="option">-i</code> (<code class="option">--inetd</code>). Im folgenden Beispiel sehen
          wir die Ausgaben beim Aufruf von <code class="literal">svnserve -i</code>
          auf der Kommandozeile. Beachten Sie aber, dass dies nicht
          der Weg ist, wie der Dienst normalerweise gestartet wird &#8211; eine genaue
          Beschreibung, wie <span class="command"><strong>svnserve</strong></span> über <span class="command"><strong>inetd</strong></span> gestartet
          wird, folgt anschließend.</p>
<pre class="screen">
$ svnserve -i
( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )
</pre>
<p>Mit der <code class="option">--inetd</code>-Option versucht <span class="command"><strong>svnserve</strong></span>
        mit dem Subversion-Client unter Verwendung eines speziellen Protokolls via   
       <code class="filename">stdin</code> und <code class="filename">stdout</code> zu sprechen.
       Dies ist der normale Weg für ein Programm, welches über <span class="command"><strong>inetd</strong></span>
       gestartet wurde. Die IANA (Internet Assigned Numbers Authority) hat für das 
       Subversion-Protokoll den Port 3690 reserviert &#8211; auf einem Unix-ähnlichen System
       fügen Sie einfach folgende Zeilen (wenn noch nicht vorhanden) in die Datei 
       <code class="filename">/etc/services</code> ein:</p>
<pre class="screen">
svn           3690/tcp   # Subversion
svn           3690/udp   # Subversion
</pre>
<p>Wenn Sie den klassischen Unix-<span class="command"><strong>inetd</strong></span>
        verwenden, können Sie die folgende Zeile in die Datei <code class="filename">/etc/inetd.conf</code> einfügen:</p>
<pre class="screen">
svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i
</pre>
<p>Stellen Sie sicher, dass &#8222;<span class="quote">svnowner</span>&#8220; der Nutzer ist,
        welcher alle notwendigen Zugriffsrechte auf ihre Repositorys hat.
        Kommt nun eine Anfrage eines Subversion-Clients auf Port 3690 herein,
        so wird <span class="command"><strong>inetd</strong></span> einen <span class="command"><strong>svnserve</strong></span>-Prozess
        starten, um die Anfrage zu bedienen. Wahrscheinlich möchten Sie
        noch die <code class="option">-r</code>-Option zur oben genannten Zeile hinzufügen,
        um einzuschränken, welche Repositorys exportiert werden dürfen.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.svnserve.invoking.tunnel"></a>6.3.1.3. svnserve über einen Tunnel</h4></div></div></div>
<p>Eine dritte Möglichkeit ist, <span class="command"><strong>svnserve</strong></span> mittels
          der <code class="option">-t</code>-Option im Tunnel-Modus aufzurufen.
          Bei diesem Aufruf wird vorausgesetzt, dass ein anderes Programm für
          den Remote-Zugriff &#8211; etwa <span class="command"><strong>rsh</strong></span> oder <span class="command"><strong>ssh</strong></span> &#8211;
          den Nutzer bereits erfolgreich authentifiziert hat, um nun einen privaten
          <span class="command"><strong>svnserve</strong></span>-Prozess als <span class="emphasis"><em>dieser Nutzer</em></span>
          zu starten. (Beachten Sie, dass für Sie als Nutzer selten bis nie die
          Notwendigkeit bestehen wird, <span class="command"><strong>svnserve</strong></span> mit der 
          <code class="option">-t</code>-Option von Hand auf der Kommandozeile aufzurufen &#8211; 
          der SSH-Dienst wird dies in der Regel für Sie machen.) <span class="command"><strong>svnserve</strong></span>
          wird sich nun normal verhalten (Abwicklung der Kommunikation über <code class="filename">stdin</code>
          und <code class="filename">stdout</code>) und davon ausgehen, dass alle Daten mit Hilfe des Tunnels
          zum Client weitergeleitet werden. Wird <span class="command"><strong>svnserve</strong></span> wie in diesem Fall
          durch ein Tunnel-Programm aufgerufen, ist es notwendig, dass der aufrufende Nutzer volle Lese-
          und Schreibrechte  auf die Dateien der Repository-Datenbank hat.
          Es verhält sich dabei im Grunde genommen so, als wenn der Nutzer mit einem
          <code class="literal">file://</code>-URL auf ein Repository zugreifen würde.</p>
<p>Wir werden diese Option noch genauer in diesem Kapitel behandeln, und zwar in <a class="xref" href="svn.serverconfig.html#svn.serverconfig.svnserve.sshauth" title="6.3.4. Tunneling over SSH">Abschnitt 6.3.4, &#8222;Tunneling over SSH&#8220;</a>.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.svnserve.invoking.winservice"></a>6.3.1.4. svnserve als Dienst unter Windows</h4></div></div></div>
<p>Gehört ihr Windows zur NT-Familie (2000, 2003, XP oder Vista),
          so können Sie <span class="command"><strong>svnserve</strong></span> auch als normalen
          Windows-Dienst laufen lassen. Dies ist wesentlich sinnvoller, als
          die Option <code class="option">--daemon</code> (<code class="option">-d</code>) zu verwenden und ihn
          als selbstständigen Dienst zu betreiben. Sie müssten dann immer eine
          Konsole (cmd) öffnen, den passenden Befehl aufrufen und die Konsole
          anschließend die ganze Zeit geöffnet lassen. Ein Windows-Dienst dagegen
          läuft im Hintergrund, kann bereits beim Hochfahren
          automatisch starten und lässt sich wie jeder andere Windows-Dienst
          mit demselben Administrationsprogramm starten und stoppen.</p>
<p>Es ist notwendig, den neuen Windows-Dienst unter Verwendung des
          Kommandozeilenprogramms <span class="command"><strong>SC.EXE</strong></span> einzurichten.
          Ähnlich der <span class="command"><strong>inetd</strong></span>-Konfigurationszeile
          müssen Sie den genauen Aufruf für den Start von
          <span class="command"><strong>svnserve</strong></span> festlegen:</p>
<pre class="screen">
C:\&gt; sc create svn
        binpath= "C:\svn\bin\svnserve.exe --service -r C:\repos"
        displayname= "Subversion Server"
        depend= Tcpip
        start= auto
</pre>
<p>Hiermit erzeugen Sie einen neuen Windows-Dienst mit dem
          Namen &#8222;<span class="quote">svn</span>&#8220;, welcher jedesmal das Programm
          <span class="command"><strong>svnserve.exe</strong></span> startet (und in diesem Fall
          <code class="filename">C:\repos</code> als Wurzelverzeichnis verwendet).
          In diesem Beispiel müssen jedoch einige wichtige Punkte beachtet werden.</p>
<p>Als erstes ist es wichtig, dass das Programm <span class="command"><strong>svnserve.exe</strong></span>
          immer mit der Option <code class="option">--service</code> aufgerufen wird.
          Alle weiteren Optionen müssen in derselben Zeile folgen, allerdings
          dürfen sich widersprechende Option nicht verwendet werden &#8211; wie etwa
          <code class="option">--daemon</code> (<code class="option">-d</code>), <code class="option">--tunnel</code> oder <code class="option">--inetd</code> (<code class="option">-i</code>).
          Optionen wie <code class="option">-r</code> oder <code class="option">--listen-port</code> sind 
          hingegen in Ordnung. Zweitens, seien Sie beim Aufruf von <span class="command"><strong>SC.EXE</strong></span>
          mit Leerzeichen vorsichtig: Beim Schreiben der <code class="literal">Schlüssel= Wert</code>-Zeile
          darf zwischen <code class="literal">Schlüssel</code> und <code class="literal">=</code> kein 
          Leerzeichen stehen, vor <code class="literal">Wert</code> muss genau ein Leerzeichen stehen.
          Seien Sie zuletzt auch bei der Verwendung von Leerzeichen innerhalb ihres 
          Kommandozeilenaufrufes vorsichtig. Sollten Verzeichnisangaben etwa Leerzeichen
          (oder andere zu schützende Zeichen) enthalten, so umschließen Sie sie mit
          zusätzlichen doppelten Anführungszeichen:</p>
<pre class="screen">
C:\&gt; sc create svn
        binpath= "\"C:\program files\svn\bin\svnserve.exe\" --service -r C:\repos"
        displayname= "Subversion Server"
        depend= Tcpip
        start= auto
</pre>
<p>Beachten Sie bitte auch, dass das Wort <code class="literal">binpath</code>
          etwas irreführend ist &#8211; sein Wert ist eine <span class="emphasis"><em>Kommandozeile</em></span>
          und nicht der Pfad zu einem Programm. Dies ist der Grund, warum
          Sie vorhandene Leerzeichen mit doppelten Anführungszeichen schützen müssen.</p>
<p>Ist der Dienst erstmal eingerichtet, können Sie ihn mit Hilfe
          von grafischen Programmen (etwa der Microsoft Management Console)
          stoppen, starten oder seinen Status abfragen. Alternativ steht ihnen
          auch die Kommandozeile zur Verfügung:</p>
<pre class="screen">
C:\&gt; net stop svn
C:\&gt; net start svn
</pre>
<p>Der Dienst kann natürlich auch wieder deinstalliert werden, indem
          Sie den Befehl <strong class="userinput"><code>sc delete svn</code></strong> aufrufen.
          Stoppen Sie den Dienst aber vorher!
          Das Programm <span class="command"><strong>SC.EXE</strong></span> kennt noch etliche andere nützliche
          Optionen und Parameter, ein Aufruf von <strong class="userinput"><code>sc /?</code></strong> verrät
          ihnen, welche das sind.</p>
</div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.serverconfig.svnserve.auth"></a>6.3.2. Integrierte Authentifikation und Autorisation</h3></div></div></div>
<p>Wenn sich ein Subversion-Client mit einem <span class="command"><strong>svnserve</strong></span>-Prozess
        verbindet, geschieht folgendes:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Der Client wählt ein bestimmtes Repository.</p></li>
<li><p>Der Server liest die zum Repository gehörende Datei <code class="filename">conf/svnserve.conf</code>
        und führt die darin enthaltenen Regeln für die Authentifikation (Legitimation, Identitätsprüfung)
        und die Autorisation (Berechtigungen, Befugnisse) aus.</p></li>
<li>
<p>Je nach festgelegten Regeln und Einstellungen geht es mit einem
        der folgenden Punkte weiter:</p>
<div class="itemizedlist"><ul type="circle">
<li><p>Der Client kann seine Anfragen anonym, also ohne eine 
              vorhergehende Authentifikationsanfrage, senden.</p></li>
<li><p>Der Client kann jederzeit eine Anmeldeaufforderung erhalten.</p></li>
<li><p>Läuft die Verbindung über einen Tunnel, so erklärt der Client,
              dass eine externe Anmeldung stattgefunden hat (meistens durch SSH).</p></li>
</ul></div>
</li>
</ul></div>
<p>Der <span class="command"><strong>svnserve</strong></span>-Server beherrscht als Standardeinstellung
        nur den CRAM-MD5-Anmeldedialog
       <sup>[<a name="id401546" href="#ftn.id401546" class="footnote">40</a>]</sup>.
        Im Kern läuft dieser wie folgt ab:
        Der Server sendet einen kleinen Datensatz als Anfrage an den Client. 
        Dieser erzeugt mittels des MD5-Hash-Algorithmus einen 
        Fingerprint/Hash des Passwortes zusammen mit dem Datensatz
        und sendet diesen Fingerprint als Antwort zurück an den Server.
        Der Server vollzieht nun dieselbe Operation mit dem Passwort und dem
        Datensatz und vergleicht anschließend seinen Fingerprint mit dem 
        des Clients. <span class="emphasis"><em>Während des gesamten Vorgangs wird das eigentliche Passwort
        nie über das Netzwerk gesendet.</em></span></p>
<p>Enthält ihr <span class="command"><strong>svnserve</strong></span>-Server Unterstützung für
        SASL, so beherrscht er nicht nur die CRAM-MD5-Anmeldung, sondern noch 
        eine Menge anderer Verfahren zur Authentifikation.
        Lesen Sie <a class="xref" href="svn.serverconfig.html#svn.serverconfig.svnserve.sasl" title="6.3.3. Using svnserve with SASL">Abschnitt 6.3.3, &#8222;Using <span class="command"><strong>svnserve</strong></span> with SASL&#8220;</a> weiter unten,
        um zu lernen, wie die einzelnen Möglichkeiten zur Authentifikation
        und Verschlüsselung in SASL eingerichtet werden.</p>
<p>Es ist selbstverständlich auch möglich, dass sich der Client
        über ein eigenständiges Tunnel-Programm anmeldet, etwa <span class="command"><strong>ssh</strong></span>.
        In einem solchem Fall stellt der Server nur fest, unter welchem Nutzerkonto
        er gestartet wurde, und verwendet dieses für die weitere Anmeldung.
        Mehr dazu im Kapitel <a class="xref" href="svn.serverconfig.html#svn.serverconfig.svnserve.sshauth" title="6.3.4. Tunneling over SSH">Abschnitt 6.3.4, &#8222;Tunneling over SSH&#8220;</a>.</p>
<p>Wie Sie sicher bereits bemerkt haben, ist die Datei <code class="filename">svnserve.conf</code>
        in jedem Repository die zentrale Anlaufstelle für alle Regeln im Rahmen der
        Nutzeranmeldung und Rechtevergabe. Die Datei hat dasselbe Format wie die anderen
        Konfigurationsdateien (siehe <a class="xref" href="svn.customization.html#svn.advanced.confarea" title="7.1. Runtime Configuration Area">Abschnitt 7.1, &#8222;Runtime Configuration Area&#8220;</a>):
        Die Abschnittsbezeichnungen sind von eckigen Klammern umschlossen 
        (<code class="literal">[</code> und <code class="literal">]</code>), Kommentare werden mit Rauten
        (<code class="literal">#</code>) eingeleitet, und jeder Abschnitt enthält spezielle Variablen,
        denen Werte zugewiesen werden (<code class="literal">variable = value</code>).
        Lassen Sie uns einen Blick in diese Dateien werfen, um zu sehen wie sie verwendet werden.</p>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.svnserve.auth.users"></a>6.3.2.1. Erstellen einer Passwortdatei und festlegen der Authentifizierungsumgebung (Realm)</h4></div></div></div>
<p>Zu Beginn enthält der Abschnitt <code class="literal">[general]</code> in
          der Datei <code class="filename">svnserve.conf</code> alle Einstellungen, welche
          für den Start notwendig sind. Lassen Sie uns anfangen und den Variablen 
          Werte zuweisen: Wählen Sie den Namen der Datei, welche die Namen
          ihrer Nutzer und deren Passwörter enthält, und entscheiden Sie sich 
          für den Namen der Authentifizierungsumgebung:</p>
<pre class="screen">
[general]
password-db = passwortdatei
realm = Anmeldedomäne
</pre>
<p>Den Namen des <code class="literal">realm</code> können Sie frei wählen.
          Er teilt den Clients mit, an welcher &#8222;<span class="quote">Authentifizierungsumgebung</span>&#8220;
          sie sich anmelden. Der Subversion-Client zeigt diesen Namen im
          Anmeldedialog und verwendet ihn auch (zusammen mit dem Namen und Port des Servers)
          als Schlüssel, welcher als Teil des Anmeldenachweises auf der Festplatte des 
          Nutzers gespeichert wird 
          (siehe dazu <a class="xref" href="svn.advanced.html#svn.serverconfig.netmodel.credcache" title="3.11.2. Client Credentials Caching">Abschnitt 3.11.2, &#8222;Client Credentials Caching&#8220;</a>).
          Die Variable  <code class="literal">password-db</code> enthält den Namen der Passwortdatei,
          die vom Aufbau her gleich ist und die Namen der Nutzer und deren Passwörter speichert.
          Als Beispiel:</p>
<pre class="screen">
[users]
harry = geheimespasswort
sally = undnocheins
</pre>
<p> 
          Der Wert von <code class="literal">password-db</code> kann
          den absoluten oder relativen Pfad zur Benutzerdatei enthalten.
          In der Regel, ist es am einfachsten diese Datei ebenfalls
          im <code class="filename">conf/</code>-Verzeichnis des Repositorys
          zu speichern &#8211; also dort, wo auch <code class="filename">svnserve.conf</code>
          liegt. Andererseits möchten Sie vielleicht eine Passwortdatei 
          für mehrere Repositories verwenden; in diesem Fall sollten Sie
          die Datei an einem zentraleren Ort ablegen.
          Die Repositorys, die sich die Benutzerdatei teilen, sollten so
		  konfiguriert sein, dass sie derselben Authentifizierungsumgebung
		  angehören, da die Benutzerliste 
		  im Wesentlichen einen Authentifizierungs-Bereich definiert.
          Wo die Datei auch liegen mag, stellen Sie sicher, die Lese-
          und Schreibrechte entsprechend zu setzen. Falls Sie wissen,
          unter welchem Konto <span class="command"><strong>svnserve</strong></span> laufen wird,
          sollten Sie den Lesezugriff zur Benutzerdatei auf das
          Notwendige beschränken.
          </p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.svnserve.auth.general"></a>6.3.2.2. Setzen von Zugriffsbeschränkungen</h4></div></div></div>
<p>
		Es sind noch zwei weitere Variablen in der Datei <code class="filename">svnserve.conf</code>
		zu setzten: Sie legen fest, was nicht authentifizierten (anonymen)
		und authentifizierten Nutzern erlaubt ist. Die Variablen 
		<code class="literal">anon-access</code> und <code class="literal">auth-access</code>
		können auf die Werte <code class="literal">none</code>, <code class="literal">read</code>
        oder <code class="literal">write</code> gesetzt werden. Wenn Sie den Wert auf 
        <code class="literal">none</code> setzen, so unterbinden Sie sowohl den Lese- als
        auch den Schreibzugriff &#8211; <code class="literal">read</code> erlaubt den Nur-Lese-Zugriff
        auf das Repository und  <code class="literal">write</code> gibt auf das gesamte Repository
        Lese- und Schreibzugriff. 
		</p>
<pre class="screen">
[general]
password-db = Benutzerdatei
realm = Ihr realm

# Anonyme Benutzer können nur lesend zugreifen
anon-access = read

# Authentifizierte Benutzer können sowohl lesen als auch schreiben
auth-access = write
</pre>
<p>Tatsächlich sind die in diesem Beispiel gezeigten Einstellungen,
		auch die Standardwerte der Variablen, falls Sie vergessen sollten, sie
		zu setzten. Für den Fall, dass Sie noch zurückhaltender sein möchten, können Sie den anonymen
		Zugriff auch komplett unterbinden:</p>
<pre class="screen">
[general]
password-db = Benutzerdatei
realm = Ihr realm

# Anonyme Benutzer sind nicht erlaubt
anon-access = none

# Authentifizierte Benutzer können sowohl lesen als auch schreiben
auth-access = write
</pre>
<p>Der Serverprozess versteht nicht nur diese &#8222;<span class="quote">pauschalen</span>&#8220;
		Zugriffseinstellungen für ein Repository, sondern auch feiner
		granulierte Zugriffsrechte auf einzelne Dateien und Verzeichnisse
		innerhalb des Repositories. Um diese Funktion nutzen zu können, müssen Sie eine
		Datei anlegen, welche die umfangreicheren Regeln enthält und anschließend die
		Variable <code class="literal">authz-db</code> mit folgenden Wert setzten:
		</p>
<pre class="screen">
[general]
password-db = Benutzerdatei
realm = Ihr realm

# Zum Festlegen von umfangreicheren Zugriffsregeln für bestimmte Bereiche
authz-db = Auth-Datei
</pre>
<p>
		Wir werden die Syntax der <code class="filename">Auth-Datei</code>
		noch später in diesem Kapitel besprechen, und zwar in
		<a class="xref" href="svn.serverconfig.html#svn.serverconfig.pathbasedauthz" title="6.5. Path-Based Authorization">Abschnitt 6.5, &#8222;Path-Based Authorization&#8220;</a>. Beachten Sie,
		dass die <code class="literal">authz-db</code>-Variable die Verwendung der
		<code class="literal">anon-access</code>- und <code class="literal">auth-access</code>-Variablen 
        nicht ausschließt &#8211; wenn alle diese Variablen gleichzeitig
		gesetzt sind, so müssen auch <span class="emphasis"><em>alle</em></span> diese Regeln 
		erfolgreich greifen, bevor ein Zugriff erlaubt wird.
		</p>
</div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.serverconfig.svnserve.sasl"></a>6.3.3. Using <span class="command"><strong>svnserve</strong></span> with SASL</h3></div></div></div>
<p>For many teams, the built-in CRAM-MD5 authentication is
        all they need from <span class="command"><strong>svnserve</strong></span>.  However, if
        your server (and your Subversion clients) were built with the
        Cyrus Simple Authentication and Security Layer (SASL) library,
        you have a number of authentication and encryption
        options available to you.</p>
<div class="sidebar">
<p class="title"><b>What Is SASL?</b></p>
<p>The Cyrus Simple Authentication and Security Layer is
          open source software written by Carnegie Mellon University.
          It adds generic authentication and encryption capabilities
          to any network protocol, and as of Subversion 1.5 and later,
          both the <span class="command"><strong>svnserve</strong></span> server
          and <span class="command"><strong>svn</strong></span> client know how to make use of
          this library.  It may or may not be available to you: if
          you're building Subversion yourself, you'll need to have at
          least version 2.1 of SASL installed on your system, and
          you'll need to make sure that it's detected during
          Subversion's build process.  If you're using a prebuilt
          Subversion binary package, you'll have to check with the
          package maintainer as to whether SASL support was compiled
          in.  SASL comes with a number of pluggable modules that
          represent different authentication systems: Kerberos
          (GSSAPI), NTLM, One-Time-Passwords (OTP), DIGEST-MD5, LDAP,
          Secure-Remote-Password (SRP), and others.  Certain
          mechanisms may or may not be available to you; be sure to
          check which modules are provided.</p>
<p>You can download Cyrus SASL (both code and
          documentation) from
          <a class="ulink" href="http://asg.web.cmu.edu/sasl/sasl-library.html" target="_top">http://asg.web.cmu.edu/sasl/sasl-library.html</a>.</p>
</div>
<p>Normally, when a subversion client connects to
        <span class="command"><strong>svnserve</strong></span>, the server sends a greeting that
        advertises a list of the capabilities it supports, and the
        client responds with a similar list of capabilities.  If the
        server is configured to require authentication, it then sends
        a challenge that lists the authentication mechanisms
        available; the client responds by choosing one of the
        mechanisms, and then authentication is carried out in some
        number of round-trip messages.  Even when SASL capabilities
        aren't present, the client and server inherently know how to
        use the CRAM-MD5 and ANONYMOUS mechanisms (see
        <a class="xref" href="svn.serverconfig.html#svn.serverconfig.svnserve.auth" title="6.3.2. Integrierte Authentifikation und Autorisation">Abschnitt 6.3.2, &#8222;Integrierte Authentifikation und Autorisation&#8220;</a>).  If server
        and client were linked against SASL, a number of other
        authentication mechanisms may also be available.  However,
        you'll need to explicitly configure SASL on the server side to
        advertise them.</p>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.svnserve.sasl.authn"></a>6.3.3.1. Authenticating with SASL</h4></div></div></div>
<p>To activate specific SASL mechanisms on the server,
          you'll need to do two things.  First, create
          a <code class="literal">[sasl]</code> section in your
          repository's <code class="filename">svnserve.conf</code> file with an
          initial key-value pair:</p>
<pre class="programlisting">
          [sasl]
          use-sasl = true
</pre>
<p>Second, create a main SASL configuration file
          called <code class="filename">svn.conf</code> in a place where the
          SASL library can find it&#8212;typically in the directory
          where SASL plug-ins are located.  You'll have to locate the
          plug-in directory on your particular system, such
          as <code class="filename">/usr/lib/sasl2/</code>
          or <code class="filename">/etc/sasl2/</code>.  (Note that this
          is <span class="emphasis"><em>not</em></span>
          the <code class="filename">svnserve.conf</code> file that lives
          within a repository!)</p>
<p>On a Windows server, you'll also have to edit the system
          registry (using a tool such as <span class="command"><strong>regedit</strong></span>)
          to tell SASL where to find things.  Create a registry key
          named <code class="literal">[HKEY_LOCAL_MACHINE\SOFTWARE\Carnegie
          Mellon\Project Cyrus\SASL Library]</code>, and place two
          keys inside it: a key called <code class="literal">SearchPath</code>
          (whose value is a path to the directory containing the SASL
          <code class="filename">sasl*.dll</code> plug-in libraries), and a key
          called
          <code class="literal">ConfFile</code> (whose value is a path to the
          parent directory containing
          the <code class="filename">svn.conf</code> file you created).</p>
<p>Because SASL provides so many different kinds of
          authentication mechanisms, it would be foolish (and far
          beyond the scope of this book) to try to describe every
          possible server-side configuration.  Instead, we recommend
          that you read the documentation supplied in the
          <code class="filename">doc/</code> subdirectory of the SASL source
          code.  It goes into great detail about every mechanism and
          how to configure the server appropriately for each.  For the
          purposes of this discussion, we'll just demonstrate a simple
          example of configuring the DIGEST-MD5 mechanism.  For
          example, if your <code class="filename">subversion.conf</code>
          (or <code class="filename">svn.conf</code>) file contains the
          following:</p>
<pre class="screen">
pwcheck_method: auxprop
auxprop_plugin: sasldb
sasldb_path: /etc/my_sasldb
mech_list: DIGEST-MD5
</pre>
<p>you've told SASL to advertise the DIGEST-MD5
          mechanism to clients and to check user passwords against a
          private password database located
          at <code class="filename">/etc/my_sasldb</code>.  A system
          administrator can then use
          the <span class="command"><strong>saslpasswd2</strong></span> program to add or modify
          usernames and passwords in the database:</p>
<pre class="screen">
$ saslpasswd2 -c -f /etc/my_sasldb -u realm username
</pre>
<p>A few words of warning: first, make sure the
          &#8222;<span class="quote">realm</span>&#8220; argument
          to <span class="command"><strong>saslpasswd2</strong></span> matches the same realm
          you've defined in your
          repository's <code class="filename">svnserve.conf</code> file; if
          they don't match, authentication will fail.  Also, due to a
          shortcoming in SASL, the common realm must be a string with
          no space characters.  Finally, if you decide to go with the
          standard SASL password database, make sure
          the <span class="command"><strong>svnserve</strong></span> program has read access to
          the file (and possibly write access as well, if you're using
          a mechanism such as OTP).</p>
<p>This is just one simple way of configuring SASL.  Many
          other authentication mechanisms are available, and passwords
          can be stored in other places such as in LDAP or a SQL
          database.  Consult the full SASL documentation for
          details.</p>
<p>Remember that if you configure your server to only allow
          certain SASL authentication mechanisms, this forces all
          connecting clients to have SASL support as well.  Any
          Subversion client built without SASL support (which includes
          all pre-1.5 clients) will be unable to authenticate.  On the
          one hand, this sort of restriction may be exactly what you
          want (&#8222;<span class="quote">My clients must all use Kerberos!</span>&#8220;).
          However, if you still want non-SASL clients to be able to
          authenticate, be sure to advertise the CRAM-MD5 mechanism as
          an option.  All clients are able to use CRAM-MD5, whether
          they have SASL capabilities or not.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.svnserve.sasl.encryption"></a>6.3.3.2. SASL encryption</h4></div></div></div>
<p>SASL is also able to perform data encryption if a
          particular mechanism supports it.  The built-in CRAM-MD5
          mechanism doesn't support encryption, but DIGEST-MD5 does,
          and mechanisms such as SRP actually require use of the
          OpenSSL library.  To enable or disable different levels of
          encryption, you can set two values in your repository's
          <code class="filename">svnserve.conf</code> file:</p>
<pre class="screen">
[sasl]
use-sasl = true
min-encryption = 128
max-encryption = 256
</pre>
<p>The <code class="literal">min-encryption</code> and
          <code class="literal">max-encryption</code> variables control the
          level of encryption demanded by the server.  To disable
          encryption completely, set both values to 0.  To enable
          simple checksumming of data (i.e., prevent tampering and
          guarantee data integrity without encryption), set both
          values to 1.  If you wish to allow&#8212;but not
          require&#8212;encryption, set the minimum value to 0, and
          the maximum value to some bit length.  To require encryption
          unconditionally, set both values to numbers greater than 1.
          In our previous example, we require clients to do at least
          128-bit encryption, but no more than 256-bit
          encryption.</p>
</div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.serverconfig.svnserve.sshauth"></a>6.3.4. Tunneling over SSH</h3></div></div></div>
<p><span class="command"><strong>svnserve</strong></span>'s built-in authentication (and
        SASL support) can be very handy, because it avoids the need to
        create real system accounts.  On the other hand, some
        administrators already have well-established SSH
        authentication frameworks in place.  In these situations, all
        of the project's users already have system accounts and the
        ability to &#8222;<span class="quote">SSH into</span>&#8220; the server machine.</p>
<p>It's easy to use SSH in conjunction with
        <span class="command"><strong>svnserve</strong></span>.  The client simply uses the
        <code class="literal">svn+ssh://</code> URL scheme to connect:</p>
<pre class="screen">
$ whoami
harry

$ svn list svn+ssh://host.example.com/repos/project
harryssh@host.example.com's password:  *****

foo
bar
baz
&#8230;
</pre>
<p>In this example, the Subversion client is invoking a local
        <span class="command"><strong>ssh</strong></span> process, connecting to
        <code class="literal">host.example.com</code>, authenticating as the
        user <code class="literal">harryssh</code> (according to SSH user
        configuration), then spawning a private
        <span class="command"><strong>svnserve</strong></span> process on the remote machine
        running as the user <code class="literal">harryssh</code>.  The
        <span class="command"><strong>svnserve</strong></span> command is being invoked in tunnel
        mode (<code class="option">-t</code>), and its network protocol is being
        &#8222;<span class="quote">tunneled</span>&#8220; over the encrypted connection by
        <span class="command"><strong>ssh</strong></span>, the tunnel agent.
        If the client performs a commit, the authenticated username
        <code class="literal">harryssh</code> will be used as the author
        of the new revision.</p>
<p>The important thing to understand here is that the
        Subversion client is <span class="emphasis"><em>not</em></span> connecting to a
        running <span class="command"><strong>svnserve</strong></span> daemon.  This method of
        access doesn't require a daemon, nor does it notice one if
        present.  It relies wholly on the ability of
        <span class="command"><strong>ssh</strong></span> to spawn a temporary
        <span class="command"><strong>svnserve</strong></span> process, which then terminates
        when the network connection is closed.</p>
<p>When using <code class="literal">svn+ssh://</code> URLs to access a
        repository, remember that it's the <span class="command"><strong>ssh</strong></span>
        program prompting for authentication, and
        <span class="emphasis"><em>not</em></span> the <span class="command"><strong>svn</strong></span> client
        program.  That means there's no automatic password-caching
        going on (see <a class="xref" href="svn.advanced.html#svn.serverconfig.netmodel.credcache" title="3.11.2. Client Credentials Caching">Abschnitt 3.11.2, &#8222;Client Credentials Caching&#8220;</a>).  The
        Subversion client often makes multiple connections to the
        repository, though users don't normally notice this due to the
        password caching feature.  When using
        <code class="literal">svn+ssh://</code> URLs, however, users may be
        annoyed by <span class="command"><strong>ssh</strong></span> repeatedly asking for a
        password for every outbound connection.  The solution is to
        use a separate SSH password-caching tool such as
        <span class="command"><strong>ssh-agent</strong></span> on a Unix-like system, or
        <span class="command"><strong>pageant</strong></span> on Windows.</p>
<p>When running over a tunnel, authorization is primarily
        controlled by operating system permissions to the repository's
        database files; it's very much the same as if Harry were
        accessing the repository directly via a
        <code class="literal">file://</code> URL.  If multiple system users are
        going to be accessing the repository directly, you may want to
        place them into a common group, and you'll need to be careful
        about umasks (be sure to read <a class="xref" href="svn.serverconfig.html#svn.serverconfig.multimethod" title="6.6. Supporting Multiple Repository Access Methods">Abschnitt 6.6, &#8222;Supporting Multiple Repository Access Methods&#8220;</a> later in this
        chapter).  But even in the case of tunneling, you can still use the
        <code class="filename">svnserve.conf</code> file to block access, by
        simply setting <code class="literal">auth-access = read</code>
        or <code class="literal">auth-access = none</code>.
        <sup>[<a name="id402604" href="#ftn.id402604" class="footnote">41</a>]</sup>
      </p>
<p>You'd think that the story of SSH tunneling would end
        here, but it doesn't.  Subversion allows you to create custom
        tunnel behaviors in your runtime <code class="filename">config</code>
        file (see <a class="xref" href="svn.customization.html#svn.advanced.confarea" title="7.1. Runtime Configuration Area">Abschnitt 7.1, &#8222;Runtime Configuration Area&#8220;</a>.)  For
        example, suppose you want to use RSH instead of SSH.
        <sup>[<a name="id402635" href="#ftn.id402635" class="footnote">42</a>]</sup>
        In the <code class="literal">[tunnels]</code> section of your
        <code class="filename">config</code> file, simply define it like
        this:</p>
<pre class="screen">
[tunnels]
rsh = rsh
</pre>
<p>And now, you can use this new tunnel definition by using a
        URL scheme that matches the name of your new variable:
        <code class="literal">svn+rsh://host/path</code>.  When using the new
        URL scheme, the Subversion client will actually be running the
        command <strong class="userinput"><code>rsh host svnserve -t</code></strong> behind the
        scenes.  If you include a username in the URL (e.g.,
        <code class="literal">svn+rsh://username@host/path</code>), the client
        will also include that in its command (<strong class="userinput"><code>rsh
        username@host svnserve -t</code></strong>).  But you can define new
        tunneling schemes to be much more clever than that:</p>
<pre class="screen">
[tunnels]
joessh = $JOESSH /opt/alternate/ssh -p 29934
</pre>
<p>This example demonstrates a couple of things.  First, it
        shows how to make the Subversion client launch a very specific
        tunneling binary (the one located at
        <code class="filename">/opt/alternate/ssh</code>) with specific
        options.  In this case, accessing an
        <code class="literal">svn+joessh://</code> URL would invoke the
        particular SSH binary with <code class="option">-p 29934</code> as
        arguments&#8212;useful if you want the tunnel program to
        connect to a nonstandard port.</p>
<p>Second, it shows how to define a custom environment
        variable that can override the name of the tunneling program.
        Setting the <code class="literal">SVN_SSH</code> environment variable is
        a convenient way to override the default SSH tunnel agent.
        But if you need to have several different overrides for
        different servers, each perhaps contacting a different port or
        passing a different set of options to SSH, you can use the
        mechanism demonstrated in this example.  Now if we were to set
        the <code class="literal">JOESSH</code> environment variable, its value
        would override the entire value of the tunnel
        variable&#8212;<span class="command"><strong>$JOESSH</strong></span> would be executed
        instead of <strong class="userinput"><code>/opt/alternate/ssh -p
        29934</code></strong>.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.serverconfig.svnserve.sshtricks"></a>6.3.5. SSH configuration tricks</h3></div></div></div>
<p>It's possible to control not only the way in which the
        client invokes <span class="command"><strong>ssh</strong></span>, but also to control
        the behavior of <span class="command"><strong>sshd</strong></span> on your server
        machine.  In this section, we'll show how to control the
        exact <span class="command"><strong>svnserve</strong></span> command executed
        by <span class="command"><strong>sshd</strong></span>, as well as how to have multiple
        users share a single system account.</p>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.svnserve.sshtricks.setup"></a>6.3.5.1. Initial setup</h4></div></div></div>
<p>To begin, locate the home directory of the account
          you'll be using to launch <span class="command"><strong>svnserve</strong></span>.  Make
          sure the account has an SSH public/private keypair
          installed, and that the user can log in via public-key
          authentication.  Password authentication will not work,
          since all of the following SSH tricks revolve around using
          the SSH <code class="filename">authorized_keys</code> file.</p>
<p>If it doesn't already exist, create the
          <code class="filename">authorized_keys</code> file (on Unix,
          typically <code class="filename">~/.ssh/authorized_keys</code>).
          Each line in this file describes a public key that is
          allowed to connect.  The lines are typically of the
          form:</p>
<pre class="screen">
  ssh-dsa AAAABtce9euch&#8230; user@example.com
</pre>
<p>The first field describes the type of key, the second
          field is the base64-encoded key itself, and the third field
          is a comment.  However, it's a lesser known fact that the
          entire line can be preceded by a <code class="literal">command</code>
          field:</p>
<pre class="screen">
  command="program" ssh-dsa AAAABtce9euch&#8230; user@example.com
</pre>
<p>When the <code class="literal">command</code> field is set, the
          SSH daemon will run the named program instead of the
          typical tunnel-mode <span class="command"><strong>svnserve</strong></span> invocation that the
          Subversion client asks for.  This opens the door to a number
          of server-side tricks.  In the following examples, we
          abbreviate the lines of the file as:</p>
<pre class="screen">
  command="program" TYPE KEY COMMENT
</pre>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.svnserve.sshtricks.fixedcmd"></a>6.3.5.2. Controlling the invoked command</h4></div></div></div>
<p>Because we can specify the executed server-side command,
          it's easy to name a specific <span class="command"><strong>svnserve</strong></span>
          binary to run and to pass it extra arguments:</p>
<pre class="screen">
  command="/path/to/svnserve -t -r /virtual/root" TYPE KEY COMMENT
</pre>
<p>In this example, <code class="filename">/path/to/svnserve</code>
          might be a custom wrapper script
          around <span class="command"><strong>svnserve</strong></span> which sets the umask (see
          <a class="xref" href="svn.serverconfig.html#svn.serverconfig.multimethod" title="6.6. Supporting Multiple Repository Access Methods">Abschnitt 6.6, &#8222;Supporting Multiple Repository Access Methods&#8220;</a>.)  It also
          shows how to anchor <span class="command"><strong>svnserve</strong></span> in a virtual
          root directory, just as one often does when
          running <span class="command"><strong>svnserve</strong></span> as a daemon process.
          This might be done either to restrict access to parts of the
          system, or simply to relieve the user of having to type an
          absolute path in the <code class="literal">svn+ssh://</code>
          URL.</p>
<p>It's also possible to have multiple users share a single
          account.  Instead of creating a separate system account for
          each user, generate a public/private key pair for each
          person.  Then place each public key into
          the <code class="filename">authorized_users</code> file, one per
          line, and use the <code class="option">--tunnel-user</code>
          option:</p>
<pre class="screen">
  command="svnserve -t --tunnel-user=harry" TYPE1 KEY1 harry@example.com
  command="svnserve -t --tunnel-user=sally" TYPE2 KEY2 sally@example.com
</pre>
<p>This example allows both Harry and Sally to connect to
          the same account via public key authentication.  Each of
          them has a custom command that will be executed;
          the <code class="option">--tunnel-user</code> option 
          tells <span class="command"><strong>svnserve</strong></span> to assume that the named
          argument is the authenticated user.  Without
          <code class="option">--tunnel-user</code>, it would appear as though
          all commits were coming from the one shared system
          account.</p>
<p>A final word of caution: giving a user access to the
          server via public-key in a shared account might still allow
          other forms of SSH access, even if you've set
          the <code class="literal">command</code> value
          in <code class="filename">authorized_keys</code>.  For example, the
          user may still get shell access through SSH or be able to
          perform X11 or general port forwarding through your server.
          To give the user as little permission as possible, you may
          want to specify a number of restrictive options immediately
          after the <code class="literal">command</code>:</p>
<pre class="screen">
  command="svnserve -t --tunnel-user=harry",no-port-forwarding,no-agent-forw
arding,no-X11-forwarding,no-pty TYPE1 KEY1 harry@example.com
</pre>
<p>Note that this all must be on one line&#8212;truly on
          one line&#8212;since SSH <code class="filename">authorized_keys</code> 
          files do not even allow the conventional backslash character
          (<code class="literal">\</code>) for line continuation.  The only
          reason we've shown it with a line break is to fit it on
          the physical page of a book.</p>
</div>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.serverconfig.httpd"></a>6.4. httpd, the Apache HTTP Server</h2></div></div></div>
<p>The Apache HTTP Server is a &#8222;<span class="quote">heavy-duty</span>&#8220;
      network server that Subversion can leverage.  Via a custom
      module, <span class="command"><strong>httpd</strong></span> makes Subversion repositories
      available to clients via the WebDAV/DeltaV protocol, which is an
      extension to HTTP 1.1 (see <a class="ulink" href="http://www.webdav.org/" target="_top">http://www.webdav.org/</a>
      for more information).  This protocol takes the ubiquitous HTTP
      protocol that is the core of the World Wide Web, and adds
      writing&#8212;specifically, versioned
      writing&#8212;capabilities.  The result is a standardized,
      robust system that is conveniently packaged as part of the
      Apache 2.0 software, supported by numerous operating systems
      and third-party products, and doesn't require network
      administrators to open up yet another custom port.
      <sup>[<a name="id403109" href="#ftn.id403109" class="footnote">43</a>]</sup>
      While an Apache-Subversion server has more features than
      <span class="command"><strong>svnserve</strong></span>, it's also a bit more difficult
      to set up.  With flexibility often comes more complexity.</p>
<p>Much of the following discussion includes references to
      Apache configuration directives.  While some examples are given
      of the use of these directives, describing them in full is
      outside the scope of this chapter.  The Apache team maintains
      excellent documentation, publicly available on their web site at
      <a class="ulink" href="http://httpd.apache.org" target="_top">http://httpd.apache.org</a>.  For example, a general
      reference for the configuration directives is located at
      <a class="ulink" href="http://httpd.apache.org/docs-2.0/mod/directives.html" target="_top">       http://httpd.apache.org/docs-2.0/mod/directives.html</a>.</p>
<p>Also, as you make changes to your Apache setup, it is likely
      that somewhere along the way a mistake will be made.  If you are
      not already familiar with Apache's logging subsystem, you should
      become aware of it.  In your <code class="filename">httpd.conf</code>
      file are directives that specify the on-disk locations of the
      access and error logs generated by Apache (the
      <code class="literal">CustomLog</code> and <code class="literal">ErrorLog</code>
      directives, respectively).
      Subversion's <span class="command"><strong>mod_dav_svn</strong></span> uses Apache's error
      logging interface as well.  You can always browse the contents
      of those files for information that might reveal the source of a
      problem that is not clearly noticeable otherwise.</p>
<div class="sidebar">
<p class="title"><b>Why Apache 2?</b></p>
<p>If you're a system administrator, it's very likely that
        you're already running the Apache web server and have some
        prior experience with it.  At the time of this writing, Apache 1.3
        is the more popular version of Apache.  The world has
        been somewhat slow to upgrade to the Apache 2.x series for
        various reasons: some people fear change, especially changing
        something as critical as a web server.  Other people depend on
        plug-in modules that work only against the Apache 1.3 API, and
        they are waiting for a 2.x port.  Whatever the reason, many
        people begin to worry when they first discover that
        Subversion's Apache module is written specifically for the
        Apache 2 API.</p>
<p>The proper response to this problem is: don't worry about
        it.  It's easy to run Apache 1.3 and Apache 2 side by side;
        simply install them to separate places and use Apache 2 as a
        dedicated Subversion server that runs on a port other than 80.
        Clients can access the repository by placing the port number
        into the URL:</p>
<pre class="screen">
$ svn checkout http://host.example.com:7382/repos/project
</pre>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.serverconfig.httpd.prereqs"></a>6.4.1. Prerequisites</h3></div></div></div>
<p>To network your repository over HTTP, you basically need
        four components, available in two packages.  You'll need
        Apache <span class="command"><strong>httpd</strong></span> 2.0, the
        <span class="command"><strong>mod_dav</strong></span> DAV module that comes with it,
        Subversion, and the <span class="command"><strong>mod_dav_svn</strong></span>
        filesystem provider module distributed with Subversion.
        Once you have all of those components, the process of
        networking your repository is as simple as:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Getting httpd 2.0 up and running with
            the <span class="command"><strong>mod_dav</strong></span> module</p></li>
<li><p>Installing the <span class="command"><strong>mod_dav_svn</strong></span> backend
            to <span class="command"><strong>mod_dav</strong></span>, which uses Subversion's
            libraries to access the repository</p></li>
<li><p>Configuring your <code class="filename">httpd.conf</code>
            file to export (or expose) the repository</p></li>
</ul></div>
<p>You can accomplish the first two items either by
        compiling <span class="command"><strong>httpd</strong></span> and Subversion from
        source code or by installing prebuilt binary packages of
        them on your system.  For the most up-to-date information on
        how to compile Subversion for use with the Apache HTTP Server,
        as well as how to compile and configure Apache itself for
        this purpose, see the <code class="filename">INSTALL</code> file in
        the top level of the Subversion source code tree.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.serverconfig.httpd.basic"></a>6.4.2. Basic Apache Configuration</h3></div></div></div>
<p>Once you have all the necessary components installed on
        your system, all that remains is the configuration of Apache
        via its <code class="filename">httpd.conf</code> file.  Instruct Apache
        to load the <span class="command"><strong>mod_dav_svn</strong></span> module using the
        <code class="literal">LoadModule</code> directive.  This directive must
        precede any other Subversion-related configuration items.  If
        your Apache was installed using the default layout, your
        <span class="command"><strong>mod_dav_svn</strong></span> module should have been
        installed in the <code class="filename">modules</code> subdirectory of
        the Apache install location (often
        <code class="filename">/usr/local/apache2</code>).  The
        <code class="literal">LoadModule</code> directive has a simple syntax,
        mapping a named module to the location of a shared library on
        disk:</p>
<pre class="screen">
LoadModule dav_svn_module     modules/mod_dav_svn.so
</pre>
<p>Note that if <span class="command"><strong>mod_dav</strong></span> was compiled as a
        shared object (instead of statically linked directly to the
        <span class="command"><strong>httpd</strong></span> binary), you'll need a similar
        <code class="literal">LoadModule</code> statement for it, too.  Be sure
        that it comes before the <span class="command"><strong>mod_dav_svn</strong></span> line:</p>
<pre class="screen">
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
</pre>
<p>At a later location in your configuration file, you now
        need to tell Apache where you keep your Subversion repository
        (or repositories).  The <code class="literal">Location</code> directive
        has an XML-like notation, starting with an opening tag and
        ending with a closing tag, with various other configuration
        directives in the middle.  The purpose of the
        <code class="literal">Location</code> directive is to instruct Apache to
        do something special when handling requests that are directed
        at a given URL or one of its children.  In the case of
        Subversion, you want Apache to simply hand off support for
        URLs that point at versioned resources to the DAV layer.  You
        can instruct Apache to delegate the handling of all URLs whose
        path portions (the part of the URL that follows the server's
        name and the optional port number) begin with
        <code class="filename">/repos/</code> to a DAV provider whose
        repository is located at
        <code class="filename">/var/svn/repository</code> using the
        following <code class="filename">httpd.conf</code> syntax:</p>
<pre class="screen">
&lt;Location /repos&gt;
  DAV svn
  SVNPath /var/svn/repository
&lt;/Location&gt;
</pre>
<p>If you plan to support multiple Subversion repositories
        that will reside in the same parent directory on your local
        disk, you can use an alternative
        directive&#8212;<code class="literal">SVNParentPath</code>&#8212;to
        indicate that common parent directory.  For example, if you
        know you will be creating multiple Subversion repositories in
        a directory <code class="filename">/var/svn</code> that would be
        accessed via URLs such as
        <code class="uri">http://my.server.com/svn/repos1</code>,
        <code class="uri">http://my.server.com/svn/repos2</code>, and so on, you
        could use the <code class="filename">httpd.conf</code> configuration
        syntax in the following example:</p>
<pre class="screen">
&lt;Location /svn&gt;
  DAV svn

  # any "/svn/foo" URL will map to a repository /var/svn/foo
  SVNParentPath /var/svn
&lt;/Location&gt;
</pre>
<p>Using the previous syntax, Apache will delegate the
        handling of all URLs whose path portions begin with
        <code class="filename">/svn/</code> to the Subversion DAV provider,
        which will then assume that any items in the directory
        specified by the <code class="literal">SVNParentPath</code> directive
        are actually Subversion repositories.  This is a particularly
        convenient syntax in that, unlike the use of the
        <code class="literal">SVNPath</code> directive, you don't have to
        restart Apache to create and network new repositories.</p>
<p>Be sure that when you define your new
        <code class="literal">Location</code>, it doesn't overlap with other
        exported locations.  For example, if your main
        <code class="literal">DocumentRoot</code> is exported to
        <code class="filename">/www</code>, do not export a Subversion
        repository in <code class="literal">&lt;Location /www/repos&gt;</code>.
        If a request comes in for the URI
        <code class="filename">/www/repos/foo.c</code>, Apache won't know
        whether to look for a file <code class="filename">repos/foo.c</code> in
        the <code class="literal">DocumentRoot</code>, or whether to delegate
        <span class="command"><strong>mod_dav_svn</strong></span> to return
        <code class="filename">foo.c</code> from the Subversion repository.
        The result is often an error from the server of the form
        <code class="literal">301 Moved Permanently</code>.</p>
<div class="sidebar">
<p class="title"><b>Server Names and the COPY Request</b></p>
<p>Subversion makes use of the <code class="literal">COPY</code>
          request type to perform server-side copies of files and
          directories.  As part of the sanity checking done by the
          Apache modules, the source of the copy is expected to be
          located on the same machine as the destination of the copy.
          To satisfy this requirement, you might need to
          tell <span class="command"><strong>mod_dav</strong></span> the name you use as the
          hostname of your server.  Generally, you can use
          the <code class="literal">ServerName</code> directive in
          <code class="filename">httpd.conf</code> to accomplish this.</p>
<pre class="screen">
ServerName svn.example.com
</pre>
<p>If you are using Apache's virtual hosting support via
          the <code class="literal">NameVirtualHost</code> directive, you may
          need to use the <code class="literal">ServerAlias</code> directive to
          specify additional names by which your server is known.
          Again, refer to the Apache documentation for full
          details.</p>
</div>
<p>At this stage, you should strongly consider the question
        of permissions.  If you've been running Apache for some time
        now as your regular web server, you probably already have a
        collection of content&#8212;web pages, scripts, and such.
        These items have already been configured with a set of
        permissions that allows them to work with Apache, or more
        appropriately, that allows Apache to work with those files.
        Apache, when used as a Subversion server, will also need the
        correct permissions to read and write to your Subversion
        repository.</p>
<p>You will need to determine a permission system setup that
        satisfies Subversion's requirements without messing up any
        previously existing web page or script installations.  This
        might mean changing the permissions on your Subversion
        repository to match those in use by other things that Apache
        serves for you, or it could mean using the
        <code class="literal">User</code> and <code class="literal">Group</code>
        directives in <code class="filename">httpd.conf</code> to specify that
        Apache should run as the user and group that owns your
        Subversion repository.  There is no single correct way to set
        up your permissions, and each administrator will have
        different reasons for doing things a certain way.  Just be
        aware that permission-related problems are perhaps the most
        common oversight when configuring a Subversion repository for
        use with Apache.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.serverconfig.httpd.authn"></a>6.4.3. Authentication Options</h3></div></div></div>
<p>At this point, if you configured
        <code class="filename">httpd.conf</code> to contain something such as the
        following:</p>
<pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
&lt;/Location&gt;
</pre>
<p>your repository is &#8222;<span class="quote">anonymously</span>&#8220;
        accessible to the world.  Until you configure some
        authentication and authorization policies, the Subversion
        repositories that you make available via the
        <code class="literal">Location</code> directive will be generally
        accessible to everyone.  In other words:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Anyone can use a Subversion client to check out a
            working copy of a repository URL (or any of its
            subdirectories).</p></li>
<li><p>Anyone can interactively browse the repository's
            latest revision simply by pointing a web browser to
            the repository URL.</p></li>
<li><p>Anyone can commit to the repository.</p></li>
</ul></div>
<p>Of course, you might have already set up
        a <code class="filename">pre-commit</code> hook script to prevent
        commits (see <a class="xref" href="svn.reposadmin.html#svn.reposadmin.create.hooks" title="5.3.2. Erstellen von Repository-Hooks">Abschnitt 5.3.2, &#8222;Erstellen von Repository-Hooks&#8220;</a>).
        But as you read on, you'll see that it's also possible to use
        Apache's built-in methods to restrict access in specific
        ways.</p>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.httpd.authn.basic"></a>6.4.3.1. Setting up HTTP authentication</h4></div></div></div>
<p>The easiest way to authenticate a client is via the
          HTTP Basic authentication mechanism, which simply uses a
          username and password to verify that a user is who she says
          she is.  Apache provides an <span class="command"><strong>htpasswd</strong></span>
          utility for managing the list of acceptable usernames and
          passwords.  Let's grant commit access to
          Sally and Harry.  First, we need to add them to the password
          file:</p>
<pre class="screen">
$ ### First time: use -c to create the file
$ ### Use -m to use MD5 encryption of the password, which is more secure
$ htpasswd -cm /etc/svn-auth-file harry
New password: *****
Re-type new password: *****
Adding password for user harry
$ htpasswd -m /etc/svn-auth-file sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</pre>
<p>Next, you need to add some more
          <code class="filename">httpd.conf</code> directives inside your
          <code class="literal">Location</code> block to tell Apache what to do
          with your new password file.  The
          <code class="literal">AuthType</code> directive specifies the type of
          authentication system to use.  In this case, we want to
          specify the <code class="literal">Basic</code> authentication system.
          <code class="literal">AuthName</code> is an arbitrary name that you
          give for the authentication domain.  Most browsers will
          display this name in the pop-up dialog box when the browser
          is querying the user for her name and password.  Finally,
          use the <code class="literal">AuthUserFile</code> directive to specify
          the location of the password file you created using
          <span class="command"><strong>htpasswd</strong></span>.</p>
<p>After adding these three directives, your
          <code class="literal">&lt;Location&gt;</code> block should look
          something like this:</p>
<pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
&lt;/Location&gt;
</pre>
<p>This <code class="literal">&lt;Location&gt;</code> block is not
          yet complete, and it will not do anything useful.  It's
          merely telling Apache that whenever authorization is
          required, Apache should harvest a username and password from
          the Subversion client.  What's missing here, however, are
          directives that tell Apache <span class="emphasis"><em>which</em></span> sorts
          of client requests require authorization.  Wherever
          authorization is required, Apache will demand authentication
          as well.  The simplest thing to do is protect all requests.
          Adding <code class="literal">Require valid-user</code> tells Apache
          that all requests require an authenticated user:</p>
<pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
  Require valid-user
&lt;/Location&gt;
</pre>
<p>Be sure to read the next section (<a class="xref" href="svn.serverconfig.html#svn.serverconfig.httpd.authz" title="6.4.4. Authorization Options">Abschnitt 6.4.4, &#8222;Authorization Options&#8220;</a>) for more detail on the
          <code class="literal">Require</code> directive and other ways to set
          authorization policies.</p>
<p>One word of warning: HTTP Basic Auth passwords pass in
          very nearly plain text over the network, and thus are
          extremely insecure.</p>
<p>Another option is to not use Basic authentication, but to
          use Digest authentication instead.  Digest authentication
          allows the server to verify the client's
          identity <span class="emphasis"><em>without</em></span> passing the plain-text
          password over the network.  Assuming that the client and
          server both know the user's password, they can verify that
          the password is the same by using it to apply a hashing
          function to a one-time bit of information.  The server sends
          a small random-ish string to the client; the client uses the
          user's password to hash the string; the server then looks to
          see whether the hashed value is what it expected.</p>
<p>Configuring Apache for Digest authentication is also
          fairly easy, and only a small variation on our prior
          example.  Be sure to consult Apache's documentation for full
          details.</p>
<pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
  AuthType Digest
  AuthName "Subversion repository"
  AuthDigestDomain /svn/
  AuthUserFile /etc/svn-auth-file
  Require valid-user
&lt;/Location&gt;
</pre>
<p>If you're looking for maximum security, public key
          cryptography is the best solution.  It may be best to use
          some sort of SSL encryption, so that clients authenticate
          via <code class="literal">https://</code> instead
          of <code class="literal">http://</code>; at a bare minimum, you can
          configure Apache to use a self-signed server certificate.
          <sup>[<a name="id403986" href="#ftn.id403986" class="footnote">44</a>]</sup>
          Consult Apache's documentation (and OpenSSL documentation)
          about how to do that.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.httpd.authn.sslcerts"></a>6.4.3.2. SSL certificate management</h4></div></div></div>
<p>Businesses that need to expose their repositories for access
          outside the company firewall should be conscious of the
          possibility that unauthorized parties could be
          &#8222;<span class="quote">sniffing</span>&#8220; their network traffic.  SSL makes
          that kind of unwanted attention less likely to result in
          sensitive data leaks.</p>
<p>If a Subversion client is compiled to use OpenSSL,
          it gains the ability to speak to an Apache server via
          <code class="literal">https://</code> URLs.  The Neon library used by
          the Subversion client is not only able to verify server
          certificates, but can also supply client certificates when
          challenged.  When the client and server have exchanged SSL
          certificates and successfully authenticated one another, all
          further communication is encrypted via a session key.</p>
<p>It's beyond the scope of this book to describe how to
          generate client and server certificates and how to
          configure Apache to use them.  Many other books, including
          Apache's own documentation, describe this task.  But what we
          <span class="emphasis"><em>can</em></span> cover here is how to manage
          server and client certificates from an ordinary Subversion
          client.</p>
<p>When speaking to Apache via <code class="literal">https://</code>,
          a Subversion client can receive two different types of
          information:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>A server certificate</p></li>
<li><p>A demand for a client certificate</p></li>
</ul></div>
<p>If the client receives a server certificate, it needs to
          verify that it trusts the certificate: is the server really
          who it claims to be?  The OpenSSL library does this by
          examining the signer of the server certificate, or
          <em class="firstterm">certificate authority</em> (CA).  If
          OpenSSL is unable to automatically trust the CA, or if some
          other problem occurs (such as an expired certificate or
          hostname mismatch), the Subversion command-line client will
          ask you whether you want to trust the server certificate
          anyway:</p>
<pre class="screen">
$ svn list https://host.example.com/repos/project

Error validating server certificate for 'https://host.example.com:443':
 - The certificate is not issued by a trusted authority. Use the
   fingerprint to validate the certificate manually!
Certificate information:
 - Hostname: host.example.com
 - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT
 - Issuer: CA, example.com, Sometown, California, US
 - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b

(R)eject, accept (t)emporarily or accept (p)ermanently?
</pre>
<p>This dialogue should look familiar; it's essentially the
          same question you've probably seen coming from your web
          browser (which is just another HTTP client like Subversion).
          If you choose the <code class="literal">(p)</code>ermanent option, the server certificate
          will be cached in your private runtime
          <code class="filename">auth/</code> area in just the same way your
          username and password are cached (see <a class="xref" href="svn.advanced.html#svn.serverconfig.netmodel.credcache" title="3.11.2. Client Credentials Caching">Abschnitt 3.11.2, &#8222;Client Credentials Caching&#8220;</a>).  If cached,
          Subversion will automatically trust this certificate
          in future negotiations.</p>
<p>Your runtime <code class="filename">servers</code> file also gives
          you the ability to make your Subversion client automatically
          trust specific CAs, either globally or on a per-host basis.
          Simply set the <code class="literal">ssl-authority-files</code>
          variable to a semicolon-separated list of PEM-encoded CA
          certificates:</p>
<pre class="screen">
[global]
ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem
</pre>
<p>Many OpenSSL installations also have a predefined set
          of &#8222;<span class="quote">default</span>&#8220; CAs that are nearly universally
          trusted.  To make the Subversion client automatically trust
          these standard authorities, set the
          <code class="literal">ssl-trust-default-ca</code> variable to
          <code class="literal">true</code>.</p>
<p>When talking to Apache, a Subversion client might also
          receive a challenge for a client certificate.  Apache is
          asking the client to identify itself: is the client really
          who it says it is?  If all goes correctly, the Subversion
          client sends back a private certificate signed by a CA that
          Apache trusts.  A client certificate is usually stored on
          disk in encrypted format, protected by a local password.
          When Subversion receives this challenge, it will ask you for
          a path to the certificate and the password that
          protects it:</p>
<pre class="screen">
$ svn list https://host.example.com/repos/project

Authentication realm: https://host.example.com:443
Client certificate filename: /path/to/my/cert.p12
Passphrase for '/path/to/my/cert.p12':  ********
&#8230;
</pre>
<p>Notice that the client certificate is a
          &#8222;<span class="quote">p12</span>&#8220; file.  To use a client certificate with
          Subversion, it must be in PKCS#12 format, which is a
          portable standard.  Most web browsers are already able to
          import and export certificates in that format.   Another
          option is to use the OpenSSL command-line tools to convert
          existing certificates into PKCS#12.</p>
<p>Again, the runtime <code class="filename">servers</code> file
          allows you to automate this challenge on a per-host basis.
          Either or both pieces of information can be described in
          runtime variables:</p>
<pre class="screen">
[groups]
examplehost = host.example.com

[examplehost]
ssl-client-cert-file = /path/to/my/cert.p12
ssl-client-cert-password = somepassword
</pre>
<p>Once you've set the
          <code class="literal">ssl-client-cert-file</code> and
          <code class="literal">ssl-client-cert-password</code> variables, the
          Subversion client can automatically respond to a client
          certificate challenge without prompting you.
          <sup>[<a name="id404226" href="#ftn.id404226" class="footnote">45</a>]</sup>
        </p>
</div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.serverconfig.httpd.authz"></a>6.4.4. Authorization Options</h3></div></div></div>
<p>At this point, you've configured authentication, but not
        authorization.  Apache is able to challenge clients and
        confirm identities, but it has not been told how to allow or
        restrict access to the clients bearing those identities.  This
        section describes two strategies for controlling access to
        your repositories.</p>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.httpd.authz.blanket"></a>6.4.4.1. Blanket access control</h4></div></div></div>
<p>The simplest form of access control is to authorize
          certain users for either read-only access to a repository or
          read/write access to a repository.</p>
<p>You can restrict access on all repository operations by
          adding the <code class="literal">Require valid-user</code> directive
          to your <code class="literal">&lt;Location&gt;</code> block.  Using
          our previous example, this would mean that only clients that
          claimed to be either <code class="literal">harry</code> or
          <code class="literal">sally</code> and that provided the correct
          password for their respective username would be allowed to
          do anything with the Subversion repository:</p>
<pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file

  # only authenticated users may access the repository
  Require valid-user
&lt;/Location&gt;
</pre>
<p>Sometimes you don't need to run such a tight ship.  For
          example, Subversion's own source code repository at
          <a class="ulink" href="http://svn.collab.net/repos/svn" target="_top">http://svn.collab.net/repos/svn</a> allows anyone
          in the world to perform read-only repository tasks (such as
          checking out working copies and browsing the repository with
          a web browser), but restricts all write operations to
          authenticated users.  To do this type of selective
          restriction, you can use the <code class="literal">Limit</code> and
          <code class="literal">LimitExcept</code> configuration directives.
          Like the <code class="literal">Location</code> directive, these blocks
          have starting and ending tags, and you would nest them
          inside your <code class="literal">&lt;Location&gt;</code>
          block.</p>
<p>The parameters present on the <code class="literal">Limit</code>
          and <code class="literal">LimitExcept</code> directives are HTTP
          request types that are affected by that block.  For example,
          if you wanted to disallow all access to your repository
          except the currently supported read-only operations, you
          would use the <code class="literal">LimitExcept</code> directive,
          passing the <code class="literal">GET</code>,
          <code class="literal">PROPFIND</code>, <code class="literal">OPTIONS</code>, and
          <code class="literal">REPORT</code> request type parameters.  Then the
          previously mentioned <code class="literal">Require valid-user</code>
          directive would be placed inside the
          <code class="literal">&lt;LimitExcept&gt;</code> block instead of just
          inside the <code class="literal">&lt;Location&gt;</code> block.</p>
<pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file

  # For any operations other than these, require an authenticated user.
  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
    Require valid-user
  &lt;/LimitExcept&gt;
&lt;/Location&gt;
</pre>
<p>These are only a few simple examples.  For more in-depth
          information about Apache access control and the
          <code class="literal">Require</code> directive, take a look at the
          <code class="literal">Security</code> section of the Apache
          documentation's tutorials collection at <a class="ulink" href="http://httpd.apache.org/docs-2.0/misc/tutorials.html" target="_top">http://httpd.apache.org/docs-2.0/misc/tutorials.html</a>.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.httpd.authz.perdir"></a>6.4.4.2. Per-directory access control</h4></div></div></div>
<p>It's possible to set up finer-grained permissions using
          a second Apache httpd module,
          <span class="command"><strong>mod_authz_svn</strong></span>.  This module grabs the
          various opaque URLs passing from client to server, asks
          <span class="command"><strong>mod_dav_svn</strong></span> to decode them, and then
          possibly vetoes requests based on access policies defined in
          a configuration file.</p>
<p>If you've built Subversion from source code,
          <span class="command"><strong>mod_authz_svn</strong></span> is automatically built
          and installed alongside <span class="command"><strong>mod_dav_svn</strong></span>.
          Many binary distributions install it automatically as well.
          To verify that it's installed correctly, make sure it comes
          right after <span class="command"><strong>mod_dav_svn</strong></span>'s
          <code class="literal">LoadModule</code> directive in
          <code class="filename">httpd.conf</code>:</p>
<pre class="screen">
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
LoadModule authz_svn_module   modules/mod_authz_svn.so
</pre>
<p>To activate this module, you need to configure your
          <code class="literal">Location</code> block to use the
          <code class="literal">AuthzSVNAccessFile</code> directive, which
          specifies a file containing the permissions policy for paths
          within your repositories.  (In a moment, we'll discuss the
          format of that file.)</p>
<p>Apache is flexible, so you have the option to configure
          your block in one of three general patterns.  To begin,
          choose one of these basic configuration patterns.  (The
          following examples are very simple; look at Apache's own
          documentation for much more detail on Apache authentication
          and authorization options.)</p>
<p>The simplest block is to allow open access to everyone.
          In this scenario, Apache never sends authentication
          challenges, so all users are treated as
          &#8222;<span class="quote">anonymous.</span>&#8220; (See
          <a class="xref" href="svn.serverconfig.html#svn.serverconfig.httpd.authz.perdir.ex-1" title="Beispiel 6.1. A sample configuration for anonymous access">Beispiel 6.1, &#8222;A sample configuration for anonymous access&#8220;</a>.)</p>
<div class="example">
<a name="svn.serverconfig.httpd.authz.perdir.ex-1"></a><p class="title"><b>Beispiel 6.1. A sample configuration for anonymous access</b></p>
<div class="example-contents"><pre class="programlisting">
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /var/svn

  # our access control policy
  AuthzSVNAccessFile /path/to/access/file
&lt;/Location&gt;
          </pre></div>
</div>
<br class="example-break"><p>On the opposite end of the paranoia scale, you can
          configure your block to demand authentication from everyone.
          All clients must supply credentials to identify themselves.
          Your block unconditionally requires authentication via the
          <code class="literal">Require valid-user</code> directive, and it
          defines a means to authenticate.  (See
          <a class="xref" href="svn.serverconfig.html#svn.serverconfig.httpd.authz.perdir.ex-2" title="Beispiel 6.2. A sample configuration for authenticated access">Beispiel 6.2, &#8222;A sample configuration for authenticated access&#8220;</a>.)</p>
<div class="example">
<a name="svn.serverconfig.httpd.authz.perdir.ex-2"></a><p class="title"><b>Beispiel 6.2. A sample configuration for authenticated access</b></p>
<div class="example-contents"><pre class="programlisting">
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /var/svn

  # our access control policy
  AuthzSVNAccessFile /path/to/access/file

  # only authenticated users may access the repository
  Require valid-user

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
&lt;/Location&gt;
          </pre></div>
</div>
<br class="example-break"><p>A third very popular pattern is to allow a combination
          of authenticated and anonymous access.  For example, many
          administrators want to allow anonymous users to read certain
          repository directories, but want only authenticated users to
          read (or write) more sensitive areas.  In this setup, all
          users start out accessing the repository anonymously.  If
          your access control policy demands a real username at any
          point, Apache will demand authentication from the client.
          To do this, use both the <code class="literal">Satisfy Any</code>
          and <code class="literal">Require valid-user</code> directives
          together.  (See
          <a class="xref" href="svn.serverconfig.html#svn.serverconfig.httpd.authz.perdir.ex-3" title="Beispiel 6.3. A sample configuration for mixed authenticated/anonymous access">Beispiel 6.3, &#8222;A sample configuration for mixed
            authenticated/anonymous access&#8220;</a>.)</p>
<div class="example">
<a name="svn.serverconfig.httpd.authz.perdir.ex-3"></a><p class="title"><b>Beispiel 6.3. A sample configuration for mixed
            authenticated/anonymous access</b></p>
<div class="example-contents"><pre class="programlisting">
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /var/svn

  # our access control policy
  AuthzSVNAccessFile /path/to/access/file

  # try anonymous access first, resort to real
  # authentication if necessary.
  Satisfy Any
  Require valid-user

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
&lt;/Location&gt;
          </pre></div>
</div>
<br class="example-break"><p>Once you've settled on one of these three
          basic <code class="filename">httpd.conf</code> templates, you need to
          create your file containing access rules for particular
          paths within the repository.  We describe this later in
          this chapter, in
          <a class="xref" href="svn.serverconfig.html#svn.serverconfig.pathbasedauthz" title="6.5. Path-Based Authorization">Abschnitt 6.5, &#8222;Path-Based Authorization&#8220;</a>.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.httpd.authz.pathauthzoff"></a>6.4.4.3. Disabling path-based checks</h4></div></div></div>
<p>The <span class="command"><strong>mod_dav_svn</strong></span> module goes through a
          lot of work to make sure that data you've marked
          &#8222;<span class="quote">unreadable</span>&#8220; doesn't get accidentally leaked.
          This means it needs to closely monitor all of the paths
          and file-contents returned by commands such as <span class="command"><strong>svn
          checkout</strong></span> and <span class="command"><strong>svn update</strong></span>.
          If these commands encounter a path that isn't
          readable according to some authorization policy, the
          path is typically omitted altogether.  In the case of
          history or rename tracing&#8212;for example, running a command such
          as <strong class="userinput"><code>svn cat -r OLD foo.c</code></strong> on a file that
          was renamed long ago&#8212;the rename tracking will simply
          halt if one of the object's former names is determined to be
          read-restricted.</p>
<p>All of this path checking can sometimes be quite
          expensive, especially in the case of <span class="command"><strong>svn
          log</strong></span>.  When retrieving a list of revisions, the
          server looks at every changed path in each revision and
          checks it for readability.  If an unreadable path is
          discovered, it's omitted from the list of the
          revision's changed paths (normally seen with
          the <code class="option">--verbose</code> option), and the whole log
          message is suppressed.  Needless to say, this can be
          time-consuming on revisions that affect a large number of
          files.  This is the cost of security: even if you haven't
          configured a module such as
          <span class="command"><strong>mod_authz_svn</strong></span> at all, the
          <span class="command"><strong>mod_dav_svn</strong></span> module is still asking Apache
          <span class="command"><strong>httpd</strong></span> to run authorization checks on
          every path.  The <span class="command"><strong>mod_dav_svn</strong></span> module has
          no idea what authorization modules have been installed, so
          all it can do is ask Apache to invoke whatever might be
          present.</p>
<p>On the other hand, there's also an escape hatch of
          sorts, which allows you to trade security features for
          speed.  If you're not enforcing any sort of per-directory
          authorization (i.e., not using
          <span class="command"><strong>mod_authz_svn</strong></span> or similar module),
          you can disable all of this path checking.  In your
          <code class="filename">httpd.conf</code> file, use the
          <code class="literal">SVNPathAuthz</code> directive as shown in
          <a class="xref" href="svn.serverconfig.html#svn.serverconfig.httpd.authz.pathauthzoff.ex-1" title="Beispiel 6.4. Disabling path checks altogether">Beispiel 6.4, &#8222;Disabling path checks altogether&#8220;</a>.
        </p>
<div class="example">
<a name="svn.serverconfig.httpd.authz.pathauthzoff.ex-1"></a><p class="title"><b>Beispiel 6.4. Disabling path checks altogether</b></p>
<div class="example-contents"><pre class="programlisting">
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /var/svn

  SVNPathAuthz off
&lt;/Location&gt;
          </pre></div>
</div>
<br class="example-break"><p>The <code class="literal">SVNPathAuthz</code> directive
          is &#8222;<span class="quote">on</span>&#8220; by default.  When
          set to &#8222;<span class="quote">off,</span>&#8220; all path-based authorization
          checking is disabled;
          <span class="command"><strong>mod_dav_svn</strong></span> stops invoking authorization
          checks on every path it discovers.</p>
</div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.serverconfig.httpd.extra"></a>6.4.5. Extra Goodies</h3></div></div></div>
<p>We've covered most of the authentication and authorization
        options for Apache and <span class="command"><strong>mod_dav_svn</strong></span>.  But
        there are a few other nice features that Apache
        provides.</p>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.httpd.extra.browsing"></a>6.4.5.1. Repository browsing</h4></div></div></div>
<p>One of the most useful benefits of an Apache/WebDAV
          configuration for your Subversion repository is that the
          youngest revisions of your versioned files and directories
          are immediately available for viewing via a regular web
          browser.  Since Subversion uses URLs to identify versioned
          resources, those URLs used for HTTP-based repository access
          can be typed directly into a web browser.  Your browser will
          issue an HTTP <code class="literal">GET</code> request for that URL;
          based on whether that URL represents a versioned directory
          or file, <span class="command"><strong>mod_dav_svn</strong></span> will respond with a
          directory listing or with file contents.</p>
<p>Since the URLs do not contain any information about
          which version of the resource you wish to
          see, <span class="command"><strong>mod_dav_svn</strong></span> will always answer with
          the youngest version.  This functionality has the wonderful
          side effect that you can pass around Subversion URLs to your
          peers as references to documents, and those URLs will always
          point at the latest manifestation of that document.  Of
          course, you can even use the URLs as hyperlinks from other
          web sites, too.</p>
<div class="sidebar">
<p class="title"><b>Can I View Older Revisions?</b></p>
<p>With an ordinary web browser?  In one word: nope.  At
            least, not with <span class="command"><strong>mod_dav_svn</strong></span> as your
            only tool.</p>
<p>Your web browser speaks ordinary HTTP only.  That
            means it knows only how to GET public URLs, which
            represent the latest versions of files and directories.
            According to the WebDAV/DeltaV specification, each server
            defines a private URL syntax for older versions of
            resources, and that syntax is opaque to clients.  To find
            an older version of a file, a client must follow a
            specific procedure to &#8222;<span class="quote">discover</span>&#8220; the proper
            URL; the procedure involves issuing a series of WebDAV
            PROPFIND requests and understanding DeltaV concepts.  This
            is something your web browser simply can't do.</p>
<p>So, to answer the question, one obvious way to see
            older revisions of files and directories is by passing the
            <code class="option">--revision</code> (<code class="option">-r</code>) argument
            to the <span class="command"><strong>svn list</strong></span> and <span class="command"><strong>svn
            cat</strong></span> commands.  To browse old revisions with your
            web browser, however, you can use third-party software.  A
            good example of this is ViewVC (<a class="ulink" href="http://viewvc.tigris.org/" target="_top">http://viewvc.tigris.org/</a>).  ViewVC was originally
            written to display CVS repositories through the Web,
            <sup>[<a name="id405003" href="#ftn.id405003" class="footnote">46</a>]</sup>
            and the latest releases are able to understand Subversion
            repositories as well.</p>
</div>
<div class="sect4" lang="de">
<div class="titlepage"><div><div><h5 class="title">
<a name="svn.serverconfig.httpd.extra.browsing.mimetype"></a>6.4.5.1.1. Proper MIME type</h5></div></div></div>
<p>When browsing a Subversion repository, the web browser
            gets a clue about how to render a file's contents by
            looking at the <code class="literal">Content-Type:</code> header
            returned in Apache's response to the
            HTTP <code class="literal">GET</code> request.  The value of this
            header is some sort of MIME type.  By default, Apache will
            tell the web browsers that all repository files are of
            the &#8222;<span class="quote">default</span>&#8220; MIME type,
            typically <code class="literal">text/plain</code>.  This can be
            frustrating, however, if a user wishes repository files to
            render as something more meaningful&#8212;for example,
            it might be nice to have a <code class="filename">foo.html</code> file
            in the repository actually render as HTML when
            browsing.</p>
<p>To make this happen, you need only to make sure that
            your files have the
            proper <code class="literal">svn:mime-type</code> set.  We discuss this 
            in more detail in
            <a class="xref" href="svn.advanced.html#svn.advanced.props.special.mime-type" title="3.3.1. File Content Type">Abschnitt 3.3.1, &#8222;File Content Type&#8220;</a>,
            and you can even configure your client to automatically
            attach proper <code class="literal">svn:mime-type</code> properties
            to files entering the repository for the first time; see
            <a class="xref" href="svn.advanced.html#svn.advanced.props.auto" title="3.2.4. Automatic Property Setting">Abschnitt 3.2.4, &#8222;Automatic Property Setting&#8220;</a>.</p>
<p>So in our example, if one were to set
          the <code class="literal">svn:mime-type</code> property
          to <code class="literal">text/html</code> on
          file <code class="filename">foo.html</code>, Apache would
          properly tell your web browser to render the file as HTML.
          One could also attach proper <code class="literal">image/*</code>
          MIME-type properties to image files and ultimately get an
          entire web site to be viewable directly from a repository!
          There's generally no problem with this, as long as the web
          site doesn't contain any dynamically generated
          content.</p>
</div>
<div class="sect4" lang="de">
<div class="titlepage"><div><div><h5 class="title">
<a name="svn.serverconfig.httpd.extra.browsing.xslt"></a>6.4.5.1.2. Customizing the look</h5></div></div></div>
<p>You generally will get more use out of URLs to
            versioned files&#8212;after all, that's where the
            interesting content tends to lie.  But you might have
            occasion to browse a Subversion directory listing, where
            you'll quickly note that the generated HTML used to
            display that listing is very basic, and certainly not
            intended to be aesthetically pleasing (or even
            interesting).  To enable customization of these directory
            displays, Subversion provides an XML index feature.  A
            single <code class="literal">SVNIndexXSLT</code> directive in your
            repository's <code class="literal">Location</code> block of
            <code class="filename">httpd.conf</code> will
            instruct <span class="command"><strong>mod_dav_svn</strong></span> to generate XML
            output when displaying a directory listing, and to
            reference the XSLT stylesheet of your choice:</p>
<pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
  SVNIndexXSLT "/svnindex.xsl"
  &#8230;
&lt;/Location&gt;
</pre>
<p>Using the <code class="literal">SVNIndexXSLT</code> directive and
           a creative XSLT stylesheet, you can make your directory
           listings match the color schemes and imagery used in other
           parts of your web site.  Or, if you'd prefer, you can use
           the sample stylesheets provided in the Subversion source
           distribution's <code class="filename">tools/xslt/</code> directory.
           Keep in mind that the path provided to the
           <code class="literal">SVNIndexXSLT</code> directory is actually a URL
           path&#8212;browsers need to be able to read your
           stylesheets to make use of them!</p>
</div>
<div class="sect4" lang="de">
<div class="titlepage"><div><div><h5 class="title">
<a name="svn.serverconfig.httpd.extra.browsing.reposlisting"></a>6.4.5.1.3. Listing repositories</h5></div></div></div>
<p>If you're serving a collection of repositories from a
            single URL via the <code class="literal">SVNParentPath</code>
            directive, then it's also possible to have Apache display
            all available repositories to a web browser.  Just
            activate the <code class="literal">SVNListParentPath</code>
            directive:</p>
<pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /var/svn
  SVNListParentPath on
  &#8230;
&lt;/Location&gt;
</pre>
<p>If a user now points her web browser to the
          URL <code class="literal">http://host.example.com/svn/</code>, she'll
          see a list of all Subversion repositories sitting
          in <code class="filename">/var/svn</code>.  Obviously, this can
          be a security problem, so this feature is turned off by
          default.</p>
</div>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.httpd.extra.logging"></a>6.4.5.2. Apache logging</h4></div></div></div>
<p>Because Apache is an HTTP server at heart, it contains
          fantastically flexible logging features.  It's beyond the
          scope of this book to discuss all of the ways logging can be
          configured, but we should point out that even the most
          generic <code class="filename">httpd.conf</code> file will cause
          Apache to produce two logs:
          <code class="filename">error_log</code>
          and <code class="filename">access_log</code>.  These logs may appear
          in different places, but are typically created in the
          logging area of your Apache installation.  (On Unix, they
          often live
          in <code class="filename">/usr/local/apache2/logs/</code>.)</p>
<p>The <code class="filename">error_log</code> describes any internal
          errors that Apache runs into as it works.
          The <code class="filename">access_log</code> file records every
          incoming HTTP request received by Apache.  This makes it
          easy to see, for example, which IP addresses Subversion
          clients are coming from, how often particular clients use
          the server, which users are authenticating properly, and
          which requests succeed or fail.</p>
<p>Unfortunately, because HTTP is a stateless protocol,
          even the simplest Subversion client operation generates
          multiple network requests.  It's very difficult to look at
          the <code class="filename">access_log</code> and deduce what the
          client was doing&#8212;most operations look like a series
          of cryptic <code class="literal">PROPPATCH</code>, <code class="literal">GET</code>,
          <code class="literal">PUT</code>, and <code class="literal">REPORT</code>
          requests.  To make things worse, many client operations send
          nearly identical series of requests, so it's even harder to
          tell them apart.</p>
<p><span class="command"><strong>mod_dav_svn</strong></span>, however, can come to
          your aid.  By activating an &#8222;<span class="quote">operational
          logging</span>&#8220; feature, you can
          ask <span class="command"><strong>mod_dav_svn</strong></span> to create a separate log
          file describing what sort of high-level operations your
          clients are performing.</p>
<p>To do this, you need to make use of
          Apache's <code class="literal">CustomLog</code> directive (which is
          explained in more detail in Apache's own documentation).
          Be sure to invoke this
          directive <span class="emphasis"><em>outside</em></span> your
          Subversion <code class="literal">Location</code> block:</p>
<pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  &#8230;
&lt;/Location&gt;

CustomLog logs/svn_logfile "%t %u %{SVN-ACTION}e" env=SVN-ACTION
</pre>
<p>In this example, we're asking Apache to create a special
          logfile, <code class="filename">svn_logfile</code>, in the standard
          Apache <code class="filename">logs</code> directory.
          The <code class="literal">%t</code> and <code class="literal">%u</code>
          variables are replaced by the time and username of the
          request, respectively.  The really important parts are the
          two instances of <code class="literal">SVN-ACTION</code>.
          When Apache sees that variable, it substitutes the value of
          the <code class="literal">SVN-ACTION</code> environment variable,
          which is automatically set by <span class="command"><strong>mod_dav_svn</strong></span>
          whenever it detects a high-level client action.</p>
<p>So, instead of having to interpret a
          traditional <code class="filename">access_log</code> like
          this:</p>
<pre class="screen">
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc/!svn/vcc/default HTTP/1.1" 207 398
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc/!svn/bln/59 HTTP/1.1" 207 449
[26/Jan/2007:22:25:29 -0600] "PROPFIND /svn/calc HTTP/1.1" 207 647
[26/Jan/2007:22:25:29 -0600] "REPORT /svn/calc/!svn/vcc/default HTTP/1.1" 200 607
[26/Jan/2007:22:25:31 -0600] "OPTIONS /svn/calc HTTP/1.1" 200 188
[26/Jan/2007:22:25:31 -0600] "MKACTIVITY /svn/calc/!svn/act/e6035ef7-5df0-4ac0-b811-4be7c823f998 HTTP/1.1" 201 227
&#8230;
</pre>
<p>you can peruse a much more
          intelligible <code class="filename">svn_logfile</code> like
          this:</p>
<pre class="screen">
[26/Jan/2007:22:24:20 -0600] - get-dir /tags r1729 props
[26/Jan/2007:22:24:27 -0600] - update /trunk r1729 depth=infinity send-copyfrom-args
[26/Jan/2007:22:25:29 -0600] - status /trunk/foo r1729 depth=infinity
[26/Jan/2007:22:25:31 -0600] sally commit r1730
</pre>
<p>For an exhaustive list of all actions logged, see <a class="xref" href="svn.ref.mod_dav_svn.conf.html#svn.ref.mod_dav_svn.conf.logging" title="High-level logging">&#8222;High-level logging&#8220;</a>.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.httpd.extra.writethruproxy"></a>6.4.5.3. Write-through proxying</h4></div></div></div>
<p>One of the nice advantages of using Apache as a
          Subversion server is that it can be set up for simple
          replication.  For example, suppose that your team is
          distributed across four offices around the globe.  The
          Subversion repository can exist only in one of those
          offices, which means the other three offices will not enjoy
          accessing it&#8212;they're likely to experience
          significantly slower traffic and response times when
          updating and committing code.  A powerful solution is to set
          up a system consisting of one <em class="firstterm">master</em>
          Apache server and several <em class="firstterm">slave</em>
          Apache servers.  If you place a slave server in each office,
          users can check out a working copy from whichever slave
          is closest to them.  All read requests go to their local
          slave.  Write requests get automatically routed to the
          single master server.  When the commit completes, the master
          then automatically &#8222;<span class="quote">pushes</span>&#8220; the new revision to
          each slave server using the <span class="command"><strong>svnsync</strong></span>
          replication tool.</p>
<p>This configuration creates a huge perceptual speed
          increase for your users, because Subversion client traffic
          is typically 80&#8211;90% read requests.  And if those
          requests are coming from a <span class="emphasis"><em>local</em></span>
          server, it's a huge win.</p>
<p>In this section, we'll walk you through a standard setup
          of this single-master/multiple-slave system.  However, keep
          in mind that your servers must be running at least Apache
          2.2.0 (with <span class="command"><strong>mod_proxy</strong></span> loaded) and
          Subversion 1.5 (<span class="command"><strong>mod_dav_svn</strong></span>).</p>
<div class="sect4" lang="de">
<div class="titlepage"><div><div><h5 class="title">
<a name="svn.serverconfig.httpd.extra.writethruproxy.configure"></a>6.4.5.3.1. Configure the servers</h5></div></div></div>
<p>First, configure your master server's
            <code class="filename">httpd.conf</code> file in the usual way.
            Make the repository available at a certain URI location,
            and configure authentication and authorization however
            you'd like.  After that's done, configure each of your
            &#8222;<span class="quote">slave</span>&#8220; servers in the exact same way, but
            add the special <code class="literal">SVNMasterURI</code> directive
            to the block:</p>
<pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNPath /var/svn/repos
  SVNMasterURI http://master.example.com/svn
  &#8230;
&lt;/Location&gt;
</pre>
<p>This new directive tells a slave server to redirect
            all write requests to the master.  (This is done
            automatically via Apache's <span class="command"><strong>mod_proxy</strong></span>
            module.)  Ordinary read requests, however, are still
            serviced by the slaves.  Be sure that your master and
            slave servers all have matching authentication and
            authorization configurations;  if they fall out of sync,
            it can lead to big headaches.</p>
<p>Next, we need to deal with the problem of infinite
            recursion.  With the current configuration, imagine what
            will happen when a Subversion client performs a commit to
            the master server.  After the commit completes, the server
            uses <span class="command"><strong>svnsync</strong></span> to replicate the new
            revision to each slave.  But because
            <span class="command"><strong>svnsync</strong></span> appears to be just another
            Subversion client performing a commit, the slave will
            immediately attempt to proxy the incoming write request
            back to the master!  Hilarity ensues.</p>
<p>The solution to this problem is to have the master
            push revisions to a different
            <code class="literal">&lt;Location&gt;</code> on the slaves.  This
            location is configured to <span class="emphasis"><em>not</em></span> proxy
            write requests at all, but to accept normal commits from
            (and only from) the master's IP address:</p>
<pre class="screen">
&lt;Location /svn-proxy-sync&gt;
  DAV svn
  SVNPath /var/svn/repos
  Order deny,allow
  Deny from all
  # Only let the server's IP address access this Location:
  Allow from 10.20.30.40
  &#8230;
&lt;/Location&gt;
</pre>
</div>
<div class="sect4" lang="de">
<div class="titlepage"><div><div><h5 class="title">
<a name="svn.serverconfig.httpd.extra.writethruproxy.replicate"></a>6.4.5.3.2. Set up replication</h5></div></div></div>
<p>Now that you've configured
            your <code class="literal">Location</code> blocks on master and
            slaves, you need to configure the master to replicate to
            the slaves.  This is done the usual way&#8212;
            using <span class="command"><strong>svnsync</strong></span>.  If you're not familiar
            with this tool, see
            <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.replication" title="5.4.7. Repository Replication">Abschnitt 5.4.7, &#8222;Repository Replication&#8220;</a> for
            details.</p>
<p>First, make sure that each slave repository has a
            <code class="filename">pre-revprop-change</code> hook script which
            allows remote revision property changes.  (This is
            standard procedure for being on the receiving end of
            <span class="command"><strong>svnsync</strong></span>.) Then log into the master
            server and configure each of the slave repository URIs to
            receive data from the master repository on the local
            disk:</p>
<pre class="screen">
$ svnsync init http://slave1.example.com/svn-proxy-sync file://var/svn/repos
Copied properties for revision 0.
$ svnsync init http://slave2.example.com/svn-proxy-sync file://var/svn/repos
Copied properties for revision 0.
$ svnsync init http://slave3.example.com/svn-proxy-sync file://var/svn/repos
Copied properties for revision 0.

# Perform the initial replication

$ svnsync sync http://slave1.example.com/svn-proxy-sync
Transmitting file data ....
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .......
Committed revision 2.
Copied properties for revision 2.
&#8230;

$ svnsync sync http://slave2.example.com/svn-proxy-sync
Transmitting file data ....
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .......
Committed revision 2.
Copied properties for revision 2.
&#8230;

$ svnsync sync http://slave3.example.com/svn-proxy-sync
Transmitting file data ....
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .......
Committed revision 2.
Copied properties for revision 2.
&#8230;
</pre>
<p>After this is done, we configure the master server's
            <code class="literal">post-commit</code> hook script to invoke
            <span class="command"><strong>svnsync</strong></span> on each slave server:</p>
<pre class="programlisting">
#!/bin/sh
# Post-commit script to replicate newly committed revision to slaves

svnsync sync http://slave1.example.com/svn-proxy-sync &gt; /dev/null 2&gt;&amp;1
svnsync sync http://slave2.example.com/svn-proxy-sync &gt; /dev/null 2&gt;&amp;1
svnsync sync http://slave3.example.com/svn-proxy-sync &gt; /dev/null 2&gt;&amp;1
</pre>
<p>The extra bits on the end of each line aren't
            necessary, but they're a sneaky way to allow the sync
            commands to run in the background so that the Subversion
            client isn't left waiting forever for the commit to
            finish.  In addition to this
            <code class="literal">post-commit</code> hook, you'll need a
            <code class="literal">post-revprop-change</code> hook as well so
            that when a user, say, modifies a log message, the slave
            servers get that change also:</p>
<pre class="programlisting">
#!/bin/sh
# Post-revprop-change script to replicate revprop-changes to slaves

REV=${2}
svnsync copy-revprops http://slave1.example.com/svn-proxy-sync ${REV} &gt; /dev/null 2&gt;&amp;1
svnsync copy-revprops http://slave2.example.com/svn-proxy-sync ${REV} &gt; /dev/null 2&gt;&amp;1
svnsync copy-revprops http://slave3.example.com/svn-proxy-sync ${REV} &gt; /dev/null 2&gt;&amp;1
</pre>
<p>The only thing we've left out here is what to do about
            locks.  Because locks are strictly enforced by the master
            server (the only place where commits happen), we don't
            technically need to do anything.  Many teams don't use
            Subversion's locking features at all, so it may be a
            nonissue for you.  However, if lock changes aren't
            replicated from master to slaves, it means that clients
            won't be able to query the status of locks
            (e.g., <strong class="userinput"><code>svn status -u</code></strong> will show no
            information about repository locks).  If this bothers you,
            you can write <code class="literal">post-lock</code> and
            <code class="literal">post-unlock</code> hook scripts that run
            <span class="command"><strong>svn lock</strong></span> and <span class="command"><strong>svn
            unlock</strong></span> on each slave machine, presumably through
            a remote shell method such as SSH.  That's left as an
            exercise for the reader!</p>
</div>
<div class="sect4" lang="de">
<div class="titlepage"><div><div><h5 class="title">
<a name="svn.serverconfig.httpd.extra.writethruproxy.caveats"></a>6.4.5.3.3. Caveats</h5></div></div></div>
<p>Your master/slave replication system should now be
            ready to use.  A couple of words of warning are in order,
            however.  Remember that this replication isn't entirely
            robust in the face of computer or network crashes.  For
            example, if one of the automated
            <span class="command"><strong>svnsync</strong></span> commands fails to complete for
            some reason, the slaves will begin to fall behind.  For
            example, your remote users will see that they've committed
            revision 100, but then when they run <span class="command"><strong>svn
            update</strong></span>, their local server will tell them that
            revision 100 doesn't yet exist!  Of course, the problem
            will be automatically fixed the next time another commit
            happens and the subsequent <span class="command"><strong>svnsync</strong></span> is
            successful&#8212;the sync will replicate all waiting
            revisions.  But still, you may want to set up some sort of
            out-of-band monitoring to notice synchronization failures
            and force <span class="command"><strong>svnsync</strong></span> to run when things go
            wrong.</p>
<div class="sidebar">
<p class="title"><b>Can We Set Up Replication with svnserve?</b></p>
<p>If you're using <span class="command"><strong>svnserve</strong></span> instead
              of Apache as your server, you can certainly configure
              your repository's hook scripts to invoke
              <span class="command"><strong>svnsync</strong></span> as we've shown here, thereby
              causing automatic replication from master to slaves.
              Unfortunately, at the time of this writing there is no way to
              make slave <span class="command"><strong>svnserve</strong></span> servers
              automatically proxy write requests back to the master
              server.  This means your users would only be able to
              check out read-only working copies from the slave
              servers.  You'd have to configure your slave servers to
              disallow write access completely.  This might be useful
              for creating read-only &#8222;<span class="quote">mirrors</span>&#8220; of popular
              open source projects, but it's not a transparent
              proxying system.</p>
</div>
</div>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.serverconfig.httpd.extra.other"></a>6.4.5.4. Other Apache features</h4></div></div></div>
<p>Several of the features already provided by Apache in
          its role as a robust web server can be leveraged for
          increased functionality or security in Subversion as well.
          The Subversion client is able to use SSL (the Secure Sockets
          Layer, discussed earlier).  If your Subversion client is
          built to support SSL, it can access your Apache server
          using <code class="literal">https://</code> and enjoy a high-quality
          encrypted network session.</p>
<p>Equally useful are other features of the Apache and
          Subversion relationship, such as the ability to specify a
          custom port (instead of the default HTTP port 80) or a
          virtual domain name by which the Subversion repository
          should be accessed, or the ability to access the repository
          through an HTTP proxy.</p>
<p>Finally, because <span class="command"><strong>mod_dav_svn</strong></span> is
          speaking a subset of the WebDAV/DeltaV protocol, it's
          possible to access the repository via third-party DAV
          clients.  Most modern operating systems (Win32, OS X, and
          Linux) have the built-in ability to mount a DAV server as a
          standard network &#8222;<span class="quote">shared folder.</span>&#8220; This is a
          complicated topic, but also wondrous when implemented.  For
          details, read <a class="xref" href="svn.webdav.html" title="Anhang C. WebDAV and Autoversioning">Anhang C, <i>WebDAV and Autoversioning</i></a>.</p>
<p>Note that there are a number of other small tweaks one can
          make to <span class="command"><strong>mod_dav_svn</strong></span> that are too obscure
          to mention in this chapter.  For a complete list of
          all <code class="filename">httpd.conf</code> directives
          that <span class="command"><strong>mod_dav_svn</strong></span> responds to, see
          <a class="xref" href="svn.ref.mod_dav_svn.conf.html#svn.ref.mod_dav_svn.conf.directives" title="Directives">&#8222;Directives&#8220;</a>.</p>
</div>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.serverconfig.pathbasedauthz"></a>6.5. Path-Based Authorization</h2></div></div></div>
<p>Both Apache and <span class="command"><strong>svnserve</strong></span> are capable of
      granting (or denying) permissions to users.  Typically this is
      done over the entire repository: a user can read the repository
      (or not), and she can write to the repository (or not).  It's
      also possible, however, to define finer-grained access rules.
      One set of users may have permission to write to a certain
      directory in the repository, but not others; another directory
      might not even be readable by all but a few special
      people.</p>
<p>Both servers use a common file format to describe these
      path-based access rules.  In the case of Apache, one needs to
      load the <span class="command"><strong>mod_authz_svn</strong></span> module and then add
      the <code class="literal">AuthzSVNAccessFile</code> directive (within
      the <code class="filename">httpd.conf</code> file) pointing to your own
      rules file.  (For a full explanation, see
      <a class="xref" href="svn.serverconfig.html#svn.serverconfig.httpd.authz.perdir" title="6.4.4.2. Per-directory access control">Abschnitt 6.4.4.2, &#8222;Per-directory access control&#8220;</a>.)  If
      you're using <span class="command"><strong>svnserve</strong></span>, you need to make
      the <code class="literal">authz-db</code> variable
      (within <code class="filename">svnserve.conf</code>) point to your
      rules file.</p>
<div class="sidebar">
<p class="title"><b>Do You Really Need Path-Based Access Control?</b></p>
<p>A lot of administrators setting up Subversion for the
        first time tend to jump into path-based access control without
        giving it a lot of thought.  The administrator usually knows
        which teams of people are working on which projects, so it's
        easy to jump in and grant certain teams access to certain
        directories and not others.  It seems like a natural thing,
        and it appeases the administrator's desire to maintain tight
        control of the repository.</p>
<p>Note, though, that there are often invisible (and
        visible!) costs associated with this feature.  In the visible
        category, the server needs to do a lot more work to ensure
        that the user has the right to read or write each specific
        path; in certain situations, there's very noticeable
        performance loss.  In the invisible category, consider the
        culture you're creating.  Most of the time, while certain
        users <span class="emphasis"><em>shouldn't</em></span> be committing changes to
        certain parts of the repository, that social contract doesn't
        need to be technologically enforced.  Teams can sometimes
        spontaneously collaborate with each other; someone may want to
        help someone else out by committing to an area she doesn't
        normally work on.  By preventing this sort of thing at the
        server level, you're setting up barriers to unexpected
        collaboration.  You're also creating a bunch of rules that
        need to be maintained as projects develop, new users are
        added, and so on.  It's a bunch of extra work to
        maintain.</p>
<p>Remember that this is a version control system!  Even if
        somebody accidentally commits a change to something she
        shouldn't, it's easy to undo the change.  And if a user
        commits to the wrong place with deliberate malice, it's a
        social problem anyway, and that the problem needs to be dealt
        with outside Subversion.</p>
<p>So, before you begin restricting users' access rights, ask
        yourself whether there's a real, honest need for this, or whether it's
        just something that &#8222;<span class="quote">sounds good</span>&#8220; to an
        administrator.  Decide whether it's worth sacrificing some
        server speed, and remember that there's very little risk
        involved; it's bad to become dependent on technology as a
        crutch for social problems.
        <sup>[<a name="id406150" href="#ftn.id406150" class="footnote">47</a>]</sup>
      </p>
<p>As an example to ponder, consider that the Subversion
        project itself has always had a notion of who is allowed to
        commit where, but it's always been enforced socially.  This is
        a good model of community trust, especially for open source
        projects.  Of course, sometimes there <span class="emphasis"><em>are</em></span>
        truly legitimate needs for path-based access control; within
        corporations, for example, certain types of data really can be
        sensitive, and access needs to be genuinely restricted to
        small groups of people.</p>
</div>
<p>Once your server knows where to find your rules file, it's
      time to define the rules.</p>
<p>The syntax of the file is the same familiar one used
      by <code class="filename">svnserve.conf</code> and the runtime
      configuration files.  Lines that start with a hash
      (<code class="literal">#</code>) are ignored.  In its simplest form, each
      section names a repository and path within it, as well as the
      authenticated usernames are the option names within each
      section.  The value of each option describes the user's level of
      access to the repository path: either
      <code class="literal">r</code> (read-only) or <code class="literal">rw</code>
      (read/write).  If the user is not mentioned at all, no access is
      allowed.</p>
<p>To be more specific: the value of the section names is
      either of the form <code class="literal">[repos-name:path]</code> or of the
      form <code class="literal">[path]</code>.  If you're using the
      <code class="literal">SVNParentPath</code> directive, it's important
      to specify the repository names in your sections.  If you omit
      them, a section such as
      <code class="literal">[/some/dir]</code> will match the path
      <code class="filename">/some/dir</code> in <span class="emphasis"><em>every</em></span>
      repository.  If you're using the <code class="literal">SVNPath</code>
      directive, however, it's fine to only define paths in your
      sections&#8212;after all, there's only one repository.</p>
<pre class="screen">
[calc:/branches/calc/bug-142]
harry = rw
sally = r
</pre>
<p>In this first example, the user <code class="literal">harry</code> has
      full read and write access on the
      <code class="filename">/branches/calc/bug-142</code> directory in the
      <code class="literal">calc</code> repository, but the user
      <code class="literal">sally</code> has read-only access.  Any other users
      are blocked from accessing this directory.</p>
<p>Of course, permissions are inherited from parent to child
      directory.  That means we can specify a subdirectory with a
      different access policy for Sally:</p>
<pre class="screen">
[calc:/branches/calc/bug-142]
harry = rw
sally = r

# give sally write access only to the 'testing' subdir
[calc:/branches/calc/bug-142/testing]
sally = rw
</pre>
<p>Now Sally can write to the <code class="filename">testing</code>
      subdirectory of the branch, but can still only read other parts.
      Harry, meanwhile, continues to have complete read/write access
      to the whole branch.</p>
<p>It's also possible to explicitly deny permission to someone
      via inheritance rules, by setting the username variable to
      nothing:</p>
<pre class="screen">
[calc:/branches/calc/bug-142]
harry = rw
sally = r

[calc:/branches/calc/bug-142/secret]
harry =
</pre>
<p>In this example, Harry has read/write access to the
      entire <code class="filename">bug-142</code> tree, but has absolutely no
      access at all to the <code class="filename">secret</code> subdirectory
      within it.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tipp]" src="images/tip.png"></td>
<th align="left">Tipp</th>
</tr>
<tr><td align="left" valign="top"><p>The thing to remember is that the most specific path
        always matches first.  The server tries to match the path
        itself, and then the parent of the path, then the parent of
        that, and so on.  The net effect is that mentioning a specific
        path in the access file will always override any permissions
        inherited from parent directories.</p></td></tr>
</table></div>
<p>By default, nobody has any access to the repository at all.
      That means that if you're starting with an empty file, you'll
      probably want to give at least read permission to all users at
      the root of the repository.  You can do this by using the
      asterisk variable (<code class="literal">*</code>), which means &#8222;<span class="quote">all
      users</span>&#8220;:</p>
<pre class="screen">
[/]
* = r
</pre>
<p>This is a common setup; notice that no repository
      name is mentioned in the section name.  This makes all repositories
      world-readable to all users. Once all users have read access to
      the repositories, you can give explicit
      <code class="literal">rw</code> permission to certain users on specific
      subdirectories within specific repositories.</p>
<p>The asterisk variable (<code class="literal">*</code>) is also worth
      special mention because it's the
      <span class="emphasis"><em>only</em></span> pattern that matches an anonymous
      user.  If you've configured your server block to allow a mixture
      of anonymous and authenticated access, all users start out
      accessing anonymously.  The server looks for a
      <code class="literal">*</code> value defined for the path being accessed;
      if it can't find one, it demands real authentication from
      the client.</p>
<p>The access file also allows you to define whole groups of
      users, much like the Unix <code class="filename">/etc/group</code>
      file:</p>
<pre class="screen">
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = harry, sally, joe, frank, sally, jane
</pre>
<p>Groups can be granted access control just like users.
      Distinguish them with an &#8222;<span class="quote">at</span>&#8220;
      (<code class="literal">@</code>) prefix:</p>
<pre class="screen">
[calc:/projects/calc]
@calc-developers = rw

[paint:/projects/paint]
jane = r
@paint-developers = rw
</pre>
<p>Another important fact is that
    the <span class="emphasis"><em>first</em></span> matching rule is the one which gets
    applied to a user.  In the prior example, even though Jane is a
    member of the <code class="literal">paint-developers</code> group (which has
    read/write access), the <code class="literal">jane = r</code> rule will be
    discovered and matched before the group rule, thus denying Jane
    write access.</p>
<p>Groups can also be defined to contain other groups:</p>
<pre class="screen">
[groups]
calc-developers = harry, sally, joe
paint-developers = frank, sally, jane
everyone = @calc-developers, @paint-developers
</pre>
<p>Subversion 1.5 brings another useful feature to the access
      file syntax:  username aliases.  Some authentication systems
      expect and carry relatively short usernames of the sorts we've
      been describing here&#8212;<code class="literal">harry</code>,
      <code class="literal">sally</code>, <code class="literal">joe</code>, and so on.  But
      other authentication systems&#8212;such as those which use LDAP
      stores or SSL client certificates&#8212;may carry much more
      complex usernames.  For example, Harry's username in an
      LDAP-protected system might be <code class="literal">CN=Harold
      Hacker,OU=Engineers,DC=red-bean,DC=com</code>.  With
      usernames like that, the access file can become quite bloated
      with long or obscure usernames that are easy to mistype.
      Fortunately, username aliases allow you to have to type the
      correct complex username only once, in a statement which assigns to
      it a more easily digestable alias.</p>
<pre class="screen">
[aliases]
harry = CN=Harold Hacker,OU=Engineers,DC=red-bean,DC=com
sally = CN=Sally Swatterbug,OU=Engineers,DC=red-bean,DC=com
joe = CN=Gerald I. Joseph,OU=Engineers,DC=red-bean,DC=com
&#8230;
</pre>
<p>Once you've defined a set of aliases, you can refer to the
      users elsewhere in the access file via their aliases in all the
      same places you could have instead used their actual usernames.
      Simply prepend an ampersand to the alias to distinguish it from
      a regular username:</p>
<pre class="screen">
[groups]
calc-developers = &amp;harry, &amp;sally, &amp;joe
paint-developers = &amp;frank, &amp;sally, &amp;jane
everyone = @calc-developers, @paint-developers
</pre>
<p>You might also choose to use aliases if your users'
      usernames change frequently.  Doing so allows you to need to
      update only the aliases table when these username changes occur,
      instead of doing global-search-and-replace operations on the
      whole access file.</p>
<div class="sidebar">
<p class="title"><b>Partial Readability and Checkouts</b></p>
<p>If you're using Apache as your Subversion server and have
      made certain subdirectories of your repository unreadable to
      certain users, you need to be aware of a possible
      nonoptimal behavior with <span class="command"><strong>svn checkout</strong></span>.</p>
<p>When the client requests a checkout or update over HTTP, it
      makes a single server request and receives a single (often
      large) server response.  When the server receives the request,
      that is the <span class="emphasis"><em>only</em></span> opportunity Apache has to
      demand user authentication.  This has some odd side effects.
      For example, if a certain subdirectory of the repository is
      readable only by user Sally, and user Harry checks out a parent
      directory, his client will respond to the initial authentication
      challenge as Harry.  As the server generates the large response,
      there's no way it can resend an authentication challenge when
      it reaches the special subdirectory; thus the subdirectory is
      skipped altogether, rather than asking the user to
      reauthenticate as Sally at the right moment.  In a similar way,
      if the root of the repository is anonymously world-readable,
      the entire checkout will be done without
      authentication&#8212;again, skipping the unreadable directory,
      rather than asking for authentication partway through.</p>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.serverconfig.multimethod"></a>6.6. Supporting Multiple Repository Access Methods</h2></div></div></div>
<p>You've seen how a repository can be accessed in many
      different ways.  But is it possible&#8212;or safe&#8212;for your
      repository to be accessed by multiple methods simultaneously?
      The answer is yes, provided you use a bit of foresight.</p>
<p>At any given time, these processes may require read and
      write access to your repository:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Regular system users using a Subversion client (as
          themselves) to access the repository directly via
          <code class="literal">file://</code> URLs</p></li>
<li><p>Regular system users connecting to SSH-spawned private
          <span class="command"><strong>svnserve</strong></span> processes (running as
          themselves), which access the repository</p></li>
<li><p>An <span class="command"><strong>svnserve</strong></span> process&#8212;either a
          daemon or one launched by
          <span class="command"><strong>inetd</strong></span>&#8212;running as a particular fixed
          user</p></li>
<li><p>An Apache <span class="command"><strong>httpd</strong></span> process, running as a
          particular fixed user</p></li>
</ul></div>
<p>The most common problem administrators run into is
      repository ownership and permissions.  Does every process (or
      user) in the preceding list have the rights to read and write the
      repository's underlying data files?  Assuming you have a
      Unix-like operating system, a straightforward approach might be
      to place every potential repository user into a
      new <code class="literal">svn</code> group, and make the repository wholly
      owned by that group.  But even that's not enough, because a
      process may write to the database files using an unfriendly
      umask&#8212;one that prevents access by other users.</p>
<p>So the next step beyond setting up a common group for
      repository users is to force every repository-accessing process
      to use a sane umask.  For users accessing the repository
      directly, you can make the <span class="command"><strong>svn</strong></span> program into a
      wrapper script that first runs <strong class="userinput"><code>umask 002</code></strong> and
      then runs the real <span class="command"><strong>svn</strong></span> client program.  You
      can write a similar wrapper script for the
      <span class="command"><strong>svnserve</strong></span> program, and add a <strong class="userinput"><code>umask
      002</code></strong> command to Apache's own startup script,
      <code class="filename">apachectl</code>.  For example:</p>
<pre class="screen">
$ cat /usr/bin/svn

#!/bin/sh

umask 002
/usr/bin/svn-real "$@"

</pre>
<p>Another common problem is often encountered on Unix-like
      systems.  If your repository is backed by Berkeley DB, for
      example, it occasionally creates new log files to journal its
      actions.  Even if the Berkeley DB repository is wholly owned by
      the <span class="command"><strong>svn</strong></span> group, these newly created log files
      won't necessarily be owned by that same group, which then
      creates more permissions problems for your users.  A good
      workaround is to set the group SUID bit on the
      repository's <code class="filename">db</code> directory. This causes all
      newly created log files to have the same group owner as the
      parent directory.</p>
<p>Once you've jumped through these hoops, your repository
      should be accessible by all the necessary processes.  It may
      seem a bit messy and complicated, but the problems of having
      multiple users sharing write access to common files are classic
      ones that are not often elegantly solved.</p>
<p>Fortunately, most repository administrators will never
      <span class="emphasis"><em>need</em></span> to have such a complex configuration.
      Users who wish to access repositories that live on the same
      machine are not limited to using <code class="literal">file://</code>
      access URLs&#8212;they can typically contact the Apache HTTP
      server or <span class="command"><strong>svnserve</strong></span> using
      <code class="literal">localhost</code> for the server name in their
      <code class="literal">http://</code> or <code class="literal">svn://</code> URL.
      And maintaining multiple server processes for your Subversion
      repositories is likely to be more of a headache than necessary.
      We recommend that you choose a single server that best meets your
      needs and stick with it!</p>
<div class="sidebar">
<p class="title"><b>The svn+ssh:// Server Checklist</b></p>
<p>It can be quite tricky to get a bunch of users with
        existing SSH accounts to share a repository without
        permissions problems.  If you're confused about all the things
        that you (as an administrator) need to do on a Unix-like
        system, here's a quick checklist that resummarizes some of the
        topics discussed in this section:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>All of your SSH users need to be able to read and
            write to the repository, so put all the SSH users into a
            single group.</p></li>
<li><p>
            Make the repository wholly owned by that group.
            </p></li>
<li><p>Set the group permissions to
            read/write.</p></li>
<li><p>Your users need to use a sane umask when accessing the
            repository, so make sure <span class="command"><strong>svnserve</strong></span>
            (<code class="filename">/usr/bin/svnserve</code>, or wherever it
            lives in <code class="literal">$PATH</code>) is actually a wrapper
            script that runs <strong class="userinput"><code>umask 002</code></strong> and
            executes the real <span class="command"><strong>svnserve</strong></span>
            binary.</p></li>
<li><p>Take similar measures when using
            <span class="command"><strong>svnlook</strong></span> and
            <span class="command"><strong>svnadmin</strong></span>.  Either run them with a sane
            umask or wrap them as just described.</p></li>
</ul></div>
</div>
</div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.id401546" href="#id401546" class="para">40</a>] </sup>See RFC 2195.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id402604" href="#id402604" class="para">41</a>] </sup>Note that using any sort of
            <span class="command"><strong>svnserve</strong></span>-enforced access control at all
            is a bit pointless; the user already has direct access to
            the repository database.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id402635" href="#id402635" class="para">42</a>] </sup>We don't actually recommend this, since RSH
            is notably less secure than SSH.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id403109" href="#id403109" class="para">43</a>] </sup>They really hate doing that.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id403986" href="#id403986" class="para">44</a>] </sup>While self-signed server certificates are still
              vulnerable to a &#8222;<span class="quote">man-in-the-middle</span>&#8220; attack,
              such an attack is much more difficult for a casual
              observer to pull off, compared to sniffing unprotected
              passwords.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id404226" href="#id404226" class="para">45</a>] </sup>More security-conscious folk might not want to store
              the client certificate password in the runtime
              <code class="filename">servers</code> file.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id405003" href="#id405003" class="para">46</a>] </sup>Back then, it was called ViewCVS.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id406150" href="#id406150" class="para">47</a>] </sup>A common theme in this book!</p></div>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="svn.reposadmin.html">Zurück</a> </td>
<td width="20%" align="center"> </td>
<td width="40%" align="right"> <a accesskey="n" href="svn.customization.html">Weiter</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Kapitel 5. Verwaltung des Repositorys </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td>
<td width="40%" align="right" valign="top"> Kapitel 7. Customizing Your Subversion Experience</td>
</tr>
</table>
</div>
</body>
</html>
