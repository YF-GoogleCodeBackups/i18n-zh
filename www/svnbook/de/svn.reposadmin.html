<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Kapitel 5. Verwaltung des Repositorys</title>
<link rel="stylesheet" href="styles.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="index.html" title="Versionskontrolle mit Subversion">
<link rel="up" href="index.html" title="Versionskontrolle mit Subversion">
<link rel="prev" href="svn.branchmerge.html" title="Kapitel 4. Verzweigen und Zusammenführen">
<link rel="next" href="svn.serverconfig.html" title="Kapitel 6. Die Administration eines Subversion-Servers">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Kapitel 5. Verwaltung des Repositorys</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="svn.branchmerge.html">Zurück</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a accesskey="n" href="svn.serverconfig.html">Weiter</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="chapter" lang="de">
<div class="titlepage"><div><div><h2 class="title">
<a name="svn.reposadmin"></a>Kapitel 5. Verwaltung des Repositorys</h2></div></div></div>
<div class="toc">
<p><b>Inhaltsverzeichnis</b></p>
<dl>
<dt><span class="sect1"><a href="svn.reposadmin.html#svn.reposadmin.basics">5.1. Das Subversion Repository, Definition</a></span></dt>
<dt><span class="sect1"><a href="svn.reposadmin.html#svn.reposadmin.planning">5.2. Strategien für die Verwendung eines Repositorys</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.projects.chooselayout">5.2.1. Planung der Organisation Ihres Repositorys</a></span></dt>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.basics.hosting">5.2.2. Entscheiden Sie, wo und wie Ihr Repository untergebracht
        werden soll</a></span></dt>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.basics.backends">5.2.3. Auswahl der Datenspeicherung</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.reposadmin.html#svn.reposadmin.create">5.3. Anlegen und konfigurieren Ihres Repositorys</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.basics.creating">5.3.1. Anlegen des Repositorys</a></span></dt>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.create.hooks">5.3.2. Erstellen von Repository-Hooks</a></span></dt>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.create.bdb">5.3.3. Konfiguration von Berkeley DB</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.reposadmin.html#svn.reposadmin.maint">5.4. Repository-Wartung</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.maint.tk">5.4.1. Der Werkzeugkasten eines Administrators</a></span></dt>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.maint.setlog">5.4.2. Berichtigung des Protokolleintrags</a></span></dt>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.maint.diskspace">5.4.3. Plattenplatzverwaltung</a></span></dt>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.maint.recovery">5.4.4. Berkeley DB Recovery</a></span></dt>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.maint.migrate">5.4.5. Migrating Repository Data Elsewhere</a></span></dt>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.maint.filtering">5.4.6. Filtering Repository History</a></span></dt>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.maint.replication">5.4.7. Repository Replication</a></span></dt>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.maint.backup">5.4.8. Repository Backup</a></span></dt>
<dt><span class="sect2"><a href="svn.reposadmin.html#svn.reposadmin.maint.uuids">5.4.9. Managing Repository UUIDs</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.reposadmin.html#svn.reposadmin.maint.moving-and-removing">5.5. Moving and Removing Repositories</a></span></dt>
<dt><span class="sect1"><a href="svn.reposadmin.html#svn.reposadmin.summary">5.6. Summary</a></span></dt>
</dl>
</div>
<p>Das Subversion-Repository ist die zentrale Lagerhalle für
    Ihre versionierten Daten. In dieser Rolle kann es sich aller Liebe
    und Zuneigung des Administrators gewiss sein. Obwohl das
    Repository an sich im Allgemeinen wenig Pflege erfordert, ist es
    wichtig, zu wissen, wie es angemessen konfiguriert und gepflegt
    wird, um etwaige Probleme zu vermeiden und bestehende Probleme
    sicher aufzulösen.</p>
<p>In diesem Kapitel werden wir erörtern, wie ein
    Subversion-Repository aufgesetzt und konfiguriert wird. Wir werden
    auch über die Repository-Pflege reden und Beispiele dafür geben,
    wann und wie die mit Subversion mitgelieferten Werkzeuge
    <span class="command"><strong>svnlook</strong></span> und <span class="command"><strong>svnadmin</strong></span>
    verwendet werden. Wir werden einige verbreitete Fragen und Fehler
    besprechen und Vorschläge unterbreiten, wie die Daten im
    Repository organisiert werden können.</p>
<p>Falls Sie vorhaben, das Repository lediglich in der Rolle
    eines Benutzers zu verwenden, der seine Daten unter
    Versionskontrolle stellen möchte (d.h. über einen
    Subversion-Client), können Sie dieses Kapitel vollständig
    überspringen. Wenn Sie jedoch ein
    Subversion-Repository-Administrator sind oder werden wollen,
    <sup>[<a name="id392720" href="#ftn.id392720" class="footnote">26</a>]</sup>
    dann ist dieses Kapitel für Sie gemacht.</p>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.reposadmin.basics"></a>5.1. Das Subversion Repository, Definition</h2></div></div></div>
<p>Bevor wir uns in das weite Feld der Repository-Verwaltung
      begeben, wollen wir definieren, was ein Repository ist. Wie
      sieht es aus? Wie fühlt es sich an? Trinkt es seinen Tee heiß
      oder mit Eis, gesüßt oder mit Zitrone? Als Administrator wird
      von Ihnen erwartet, dass Sie den Aufbau eines Repositorys sowohl
      auf der physischen Betriebssystemebene verstehen &#8211; wie sich
      ein Subversion-Repository aussieht und wie es sich gegenüber
      Nicht-Subversion-Werkzeugen verhält &#8211; als auch aus einer
      logischen Perspektive &#8211; wie Daten
      <span class="emphasis"><em>innerhalb</em></span> des Repositorys repräsentiert
      werden.</p>
<p>Mit den Augen eines typischen Dateibrowsers (wie Windows
      Explorer) oder von kommandozeilenorientierten
      Dateisystem-Navigationswerkzeugen ist das Subversion-Repository
      bloß ein weiteres gewöhnliches Verzeichnis voller Zeugs. Es gibt
      einige Unterverzeichnisse mit Konfigurationsdateien, die für
      Menschen lesbar sind, einige Unterverzeichnisse mit weniger
      lesbaren Datendateien usw. Wie in anderen Bereichen des
      Subversion-Designs, wird auch hier viel Wert auf Modularität
      gesetzt, und hierarchische Organisation wird vollgepfropftem
      Chaos vorgezogen. Ein flacher Blick in ein typisches Repository
      aus praxisbezogener Sicht reicht aus, um die grundlegenden
      Komponenten des Repositorys zu offenbaren.</p>
<pre class="screen">
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</pre>
<p>Hier ist ein schneller, oberflächlicher Überblick über das,
      was Sie in diesem Verzeichnislisting sehen. (Verzetteln Sie sich
      nicht mit den Fachausdrücken &#8211; eine detaillierte
      Behandlung dieser Komponenten erfolgt an anderer Stelle in
      diesem und in anderen Kapiteln.)</p>
<div class="variablelist"><dl>
<dt><span class="term">conf</span></dt>
<dd><p>Ein Verzeichnis, das Konfigurationsdateien enthält.</p></dd>
<dt><span class="term">dav</span></dt>
<dd><p>Ein Verzeichnis, das  bereitgestellt wurde, damit
            <code class="filename">mod_dav_svn</code> seine privaten
            Verwaltungsdaten dort ablegen kann</p></dd>
<dt><span class="term">db</span></dt>
<dd><p>Der Datenspeicher für all Ihre versionierten Daten</p></dd>
<dt><span class="term">format</span></dt>
<dd><p>Eine Datei, die eine einzelne Ganzzahl beinhaltet, die
            die Version der Repository-Struktur angibt</p></dd>
<dt><span class="term">hooks</span></dt>
<dd><p>Ein Verzeichnis voller Hook-Script-Vorlagen (und den
            eigentlichen Hook-Scripten, sofern Sie welche installiert
            haben)</p></dd>
<dt><span class="term">locks</span></dt>
<dd><p>Ein Verzeichnis für die Sperrdateien des
            Subversion-Repositorys, die benutzt werden, um die
            Zugreifenden auf das Repository zu verfolgen</p></dd>
<dt><span class="term">README.txt</span></dt>
<dd><p>Eine Datei, deren Inhalt die Leser darüber informiert,
            dass sie in ein Subversion-Repository schauen</p></dd>
</dl></div>
<p>Selbstverständlich wird diese sonst so unauffällige
      Ansammlung aus Dateien und Verzeichnissen, wenn auf sie über die
      Subversion-Bibliotheken zugegriffen wird, eine Implementierung
      eines virtuellen, versionierten Dateisystems, vollständig mit
      anpassbaren Ereignis-Triggern. Dieses Dateisystem hat seine
      eigene Auffassung von Verzeichnissen und Dateien, sehr ähnlich
      den Auffassungen, die echte Dateisysteme (wie NTFS, FAT32, ext3
      usw.) von solchen Dingen haben. Aber dies ist ein spezielles
      Dateisystem &#8211; es hängt diese Dateien und Verzeichnisse an
      Revisionen und hält alle Änderungen, die Sie daran vorgenommen
      haben, sicher abgespeichert und für immer abrufbereit. Hier lebt
      die Gesamtheit Ihrer versionierten Daten.</p>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.reposadmin.planning"></a>5.2. Strategien für die Verwendung eines Repositorys</h2></div></div></div>
<p>Größtenteils wegen der Einfachheit des Gesamtentwurfs des
      Subversion-Repositorys und der ihm zugrundeliegenden Technik,
      ist die Erstellung und Konfiguration eines Repositorys eine
      ziemlich unkomplizierte Aufgabe. Es gibt einige Entscheidungen,
      die Sie im Vorfeld treffen sollten, jedoch sind die eigentlichen
      Arbeitsschritte für die Einrichtung eines Subversion-Repositorys
      recht einfach und neigen zur stupiden Fleißarbeit, falls Sie
      mehrere davon aufzusetzen haben.</p>
<p>Einige Dinge, die Sie jedoch im Vorfeld sorgfältig prüfen
      sollten, sind:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Welche Art von Daten sollen in Ihrem Repository (oder
          Repositorys) abgelegt werden, und wie sind diese Daten
          organisiert?</p></li>
<li><p>Wo soll Ihr Repository untergebracht werden, und wie
          soll darauf zugegriffen werden?</p></li>
<li><p>Welche Art von Zugriffskontrolle und
          Ereignisbenachrichtigung benötigen Sie?</p></li>
<li><p>Welche der verfügbaren Datenspeicherungsarten möchten
          Sie verwenden?</p></li>
</ul></div>
<p>In diesem Abschnitt werden wir versuchen, Ihnen beim
      Beantworten dieser Fragen zu helfen.</p>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.projects.chooselayout"></a>5.2.1. Planung der Organisation Ihres Repositorys</h3></div></div></div>
<p>Obwohl Subversion Ihnen erlaubt, versionierte Dateien und
        Ordner ohne Informationsverlust hin und her zu verschieben und
        sogar Methoden anbietet, um versionierte Geschichte von einem
        Repository in ein anderes zu verschieben, kann das ziemlich
        den Arbeitsablauf derjenigen stören, die oft auf das
        Repository zugreifen und gewisse Dinge an bestimmten Orten
        erwarten. Bevor Sie ein neues Repository erstellen, sollten
        Sie also versuchen, ein wenig in die Zukunft zu schauen;
        planen Sie weitsichtig, bevor Sie Ihre Daten unter
        Versionskontrolle stellen. Durch die vorzeitige gewissenhafte
        &#8222;<span class="quote">Anlage</span>&#8220; Ihres Repositorys oder mehrerer
        Repositorys können Sie viel künftigen Kopfschmerz
        vermeiden.</p>
<p>Nehmen wir an, Sie seien als Repository-Administrator für
        die Versionskontrollsysteme mehrerer Projekte zuständig. Ihre
        erste Entscheidung ist, ob Sie ein einzelnes Repository für
        mehrere Projekte verwenden, jedem Projekt sein eigenes
        Repository geben oder einen Kompromiss aus diesen beiden
        Lösungen  haben wollen.</p>
<p>Ein einzelnes Repository für mehrere Projekte zu
        verwenden, hat einige Vorteile, am offensichtlichsten ist der
        vermiedene doppelte Verwaltungsaufwand. Ein einzelnes
        Repository bedeutet, dass es nur einen Satz Hook-Programme,
        ein Ding zum routinemäßigen Sichern, ein Ding für einen Auszug
        und zum anschließenden Laden nach einer inkompatiblen neuen
        Version von Subversion gibt usw. Sie können Daten auch einfach
        zwischen Projekten verschieben, ohne historische
        Versionierungsinformationen zu verlieren.</p>
<p>Der Nachteil bei der Verwendung eines einzelnen
        Repositorys ist, dass unterschiedliche Projekte auch
        unterschiedliche Anforderungen hinsichtlich der
        Repository-Ereignis-Trigger haben, wie etwa
        Benachrichtigungs-E-Mails bei Commits an unterschiedliche
        Verteiler, oder unterschiedliche Definitionen dazu, was eine
        berechtigte Übergabe ist und was nicht. Das sind natürlich
        keine unüberwindbaren Probleme &#8211; es bedeutet nur, dass
        all Ihre Hook-Skripte die Struktur Ihres Repositorys beachten
        müssen, anstatt davon auszugehen, dass das gesamte Repository
        von einer einzelnen Gruppe zugeordnet ist. Beachten Sie auch,
        dass Subversion Versionsnummern verwendet, die global für das
        gesamte Repository gelten. Obwohl diese Nummern keine
        Zauberkräfte haben, mögen manche Zeitgenossen es trotzdem
        nicht, dass, obwohl in letzter Zeit keine Änderungen in ihrem
        Projekt durchgeführt worden sind, die jüngste Versionsnummer
        im Repository ständig höher wird, weil andere Projekte fleißig
        neue Revisionen hinzufügen.
        <sup>[<a name="id393188" href="#ftn.id393188" class="footnote">27</a>]</sup>
      </p>
<p>Es kann auch eine Lösung in der Mitte gewählt werden.
        Beispielsweise können Projekte danach geordnet werden, wie
        stark sie miteinander verbunden sind. Sie könnten ein paar
        Repositorys haben, die jeweils eine handvoll Projekte
        beherbergen. Auf diese Art können Projekte, die wahrscheinlich
        gemeinsame Daten verwenden wollen, dies auch einfach
        bewerkstelligen, und wenn dem Repository neue Versionen
        hinzugefügt werden, wissen die Entwickler wenigstens, dass
        diese neuen Revisionen zumindest entfernt eine Beziehung zu
        jedem Benutzer dieses Repositorys haben.</p>
<p>Nachdem Sie entschieden haben, wie Sie Ihre Projekte in
        Repositorys aufteilen, möchten Sie sich nun vielleicht
        Gedanken darüber machen, welche Verzeichnishierarchien Sie im
        Repository anlegen wollen. Da Subversion zum Verzweigen und
        Taggen reguläre Verzeichniskopien verwendet (siehe <a class="xref" href="svn.branchmerge.html" title="Kapitel 4. Verzweigen und Zusammenführen">Kapitel 4, <i>Verzweigen und Zusammenführen</i></a>), empfiehlt die
        Subversion-Gemeinschaft, dass Sie einen Ort im Repository für
        jedes <em class="firstterm">Projekt-Wurzelverzeichnis</em> wählen
        &#8211; das oberste Verzeichnis, das Daten für Ihr Projekt
        enthält &#8211; und hierunter dann drei Unterverzeichnisse
        anlegen: <code class="filename">trunk</code>, das Verzeichnis, in dem
        die Hauptentwicklung stattfindet,
        <code class="filename">branches</code>, zur Aufnahme verschiedener
        Zweige der Hauptentwicklungslinie und
        <code class="filename">tags</code>, als Sammlung von Momentaufnahmen
        des Verzeichnisbaums, die erzeugt, vielleicht gelöscht, jedoch
        nie verändert werden.
        <sup>[<a name="id393291" href="#ftn.id393291" class="footnote">28</a>]</sup>
        </p>
<p>Ihr Repository könnte z.B. so aussehen:</p>
<pre class="screen">
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   &#8230;
</pre>
<p>Beachten Sie, dass es unerheblich ist, wo in Ihrem
        Repository sich das Wurzelverzeichnis Ihres Projektes
        befindet.  Falls Sie nur ein Projekt pro Repository haben, ist
        der logische Ort für das Wurzelverzeichnis des Projektes das
        Wurzelverzeichnis des zum Projekt gehörenden Repositorys.
        Falls Sie mehrere Projekte haben, möchten Sie diese vielleicht
        innerhalb des Repositorys gruppieren, indem Sie Projekte
        ähnlichen Zwecks in demselben Unterverzeichnis unterbringen
        oder sie vielleicht nur alphabetisch gruppieren. Eine solche
        Anordnung könnte so aussehen:</p>
<pre class="screen">
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      &#8230;
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      &#8230;
</pre>
<p>Legen Sie Ihr Repository so an, wie es Ihnen am besten
        passt.  Subversion erwartet oder erzwingt keine bestimmte
        Anordnung &#8211; für Subversion ist und bleibt ein
        Verzeichnis ein Verzeichnis. Letztendlich sollten Sie für ein
        Repository eine Struktur wählen, die den Bedürfnissen der
        Leute gerecht wird, die an den Projekten arbeiten, die dort
        untergebracht sind.</p>
<p>Der Vollständigkeit halber erwähnen wir noch eine weitere,
        verbreitete Anordnung. Bei dieser Anordnung befinden sich die
        Verzeichnisse <code class="filename">trunk</code>,
        <code class="filename">tags</code> und <code class="filename">branches</code> im
        Wurzelverzeichnis des Repositorys und die Projekte in
        Unterverzeichnissen davon:</p>
<pre class="screen">
/
   trunk/
      calc/
      calendar/
      spreadsheet/
      &#8230;
   tags/
      calc/
      calendar/
      spreadsheet/
      &#8230;
   branches/
      calc/
      calendar/
      spreadsheet/
      &#8230;
</pre>
<p>An dieser Anordnung ist zwar nichts verkehrt, allerdings
        könnte es für Ihre Benutzer mehr oder weniger intuitiv sein.
        Besonders in Situationen mit vielen Projekten und entsprechend
        vielen Benutzern, kann es vorkommen, dass die Benutzer
        gewöhnlich nur mit einem oder zwei dieser Projekte vertraut
        sind. Allerdings schwächt dieser
        Projekt-als-Geschwister-Zweig-Ansatz die Betonung auf
        Projekt-Individualität und betrachtet die Gesamtmenge der
        Projekte als Ganzes. Das ist jedoch ein sozialer Aspekt. Wir
        mögen unseren ursprünglich geäußerten Vorschlag aus rein
        praktischen Erwägungen &#8211; es ist einfacher, in der
        kompletten Historie eines einzelnen Projektes zu forschen
        (oder sie zu verändern oder woandershin zu migrieren), wenn es
        einen einzelnen Pfad im Repository gibt, der die gesamte
        Historie für dieses eine Projekt, und nur dieses,  beinhaltet
        &#8211; die Vergangenheit, Tags und Zweige.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.basics.hosting"></a>5.2.2. Entscheiden Sie, wo und wie Ihr Repository untergebracht
        werden soll</h3></div></div></div>
<p>Bevor Sie Ihr Subversion-Repository anlegen, bleibt die
        offensichtliche Frage zu beantworten, wo das Ding hin soll.
        Das hängt eng mit etlichen weiteren Fragen zusammen, etwa wie
        auf das Repository zugegriffen werden soll (über einen
        Subversion-Server oder direkt), wer darauf zugreifen soll
        (Benutzer hinter Ihrer Firmen-Firewall oder die weite Welt im
        offenen Netz), welche zusätzlichen Dienste Sie im Zusammenhang
        mit Subversion anbieten wollen (Schnittstellen zum Stöbern im
        Repository, Übergabebenachrichtigungen per E-Mail usw.), Ihre
        Sicherungsstrategie und vieles mehr.</p>
<p>Die Auswahl und Konfigurierung des Servers werden wir in
        <a class="xref" href="svn.serverconfig.html" title="Kapitel 6. Die Administration eines Subversion-Servers">Kapitel 6, <i>Die Administration eines Subversion-Servers</i></a> behandeln; jedoch möchten
        wir an dieser Stelle kurz darauf hinweisen, dass die Antworten
        auf einige der anderen Fragen zur Folge haben, dass Sie bei
        der Entscheidung über den Speicherorte für das Repository
        keine freie Wahl mehr haben.  Beispielsweise könnten bestimmte
        Einsatzumgebungen erfordern, dass von mehreren Rechnern über
        ein freigegebenes Dateisystem auf das Repository zugegriffen
        werden muss, so dass (wie Sie im nächsten Abschnitt lesen
        werden) die Wahl der dem Repository zugrundeliegenden
        Datenspeicherung gar keine Wahl mehr ist, da nur eine der
        verfügbaren Datenspeicherungsverfahren in dieser Umgebung
        funktionieren wird.</p>
<p>Es ist unmöglich, und würde auch den Rahmen dieses Buches
        sprengen, wenn jede erdenkliche Einsatzart von Subversion
        angesprochen würde. Wir ermutigen Sie einfach, Ihre Optionen
        zu prüfen, indem Sie diese Seiten und weitere Quellen als
        Referenz verwenden und weitsichtig planen.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.basics.backends"></a>5.2.3. Auswahl der Datenspeicherung</h3></div></div></div>
<p>Subversion unterstützt zwei Optionen für
        das zugrundeliegende Datenspeicherungsverfahren &#8211; oft
        bezeichnet als &#8222;<span class="quote">das Backend</span>&#8220; oder, etwas
        verwirrend, &#8222;<span class="quote">das (versionierte) Dateisystem</span>&#8220;
        &#8212; welches jedes Repository verwendet. Das eine
        Verfahren speichert alles in einer Berkeley-DB- (oder BDB-)
        Datenbankumgebung; Repositorys, die dieses Verfahren
        verwenden, werden oft &#8222;<span class="quote">BDB-basiert</span>&#8220; genannt. Das
        andere Verfahren speichert die Daten in gewöhnlichen, flachen
        Dateien, die ein spezielles Format verwenden. Unter
        Subversion-Entwicklern hat sich dafür die Bezeichnung
        <em class="firstterm">FSFS</em>
        <sup>[<a name="id393572" href="#ftn.id393572" class="footnote">29</a>]</sup>
        eingebürgert &#8211; eine Implementierung eines versionierten
        Dateisystems, dass direkt das Dateisystem des Betriebssystems
        verwendet &#8211; statt einer Datenbankbibliothek oder einer
        anderen Abstraktionsebene &#8211; um Daten zu speichern</p>
<p><a class="xref" href="svn.reposadmin.html#svn.reposadmin.basics.backends.tbl-1" title="Tabelle 5.1. Vergleich der Repository-Datenspeicherung">Tabelle 5.1, &#8222;Vergleich der Repository-Datenspeicherung&#8220;</a>
        liefert einen Vergleich zwischen Berkeley-DB- und
        FSFS-Repositorys.</p>
<div class="table">
<a name="svn.reposadmin.basics.backends.tbl-1"></a><p class="title"><b>Tabelle 5.1. Vergleich der Repository-Datenspeicherung</b></p>
<div class="table-contents"><table summary="Vergleich der Repository-Datenspeicherung" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Kategorie</th>
<th>Funktion</th>
<th>Berkeley DB</th>
<th>FSFS</th>
</tr></thead>
<tbody>
<tr>
<td rowspan="2">Zuverlässigkeit</td>
<td>Unversehrtheit der Daten</td>
<td>Höchst zuverlässig, wenn es richtig aufgesetzt
                wird; Berkeley DB 4.4 bringt automatische
                Wiederherstellung</td>
<td>Ältere Versionen hatten einige selten
                aufgetretene, jedoch datenzerstörende Fehler</td>
</tr>
<tr>
<td>Empfindlichkeit gegenüber Unterbrechungen</td>
<td>Sehr; Abstürze und Berechtigungsprobleme können
                die Datenbank &#8222;<span class="quote">verklemmt</span>&#8220; hinterlassen,
                was eine Wiederherstellung mithilfe des Journals
                erfordert</td>
<td>Ziemlich unempfindlich</td>
</tr>
<tr>
<td rowspan="4">Zugriffsmöglichkeiten</td>
<td>Benutzbar über eine Laufwerk mit
                Nur-Lese-Zugriff</td>
<td>Nein</td>
<td>Ja</td>
</tr>
<tr>
<td>Plattformunabhängige Speicherung</td>
<td>Nein</td>
<td>Ja</td>
</tr>
<tr>
<td>Benutzbar über Netz-Dateisysteme</td>
<td>Im Allgemeinen nicht</td>
<td>Ja</td>
</tr>
<tr>
<td>Behandlung von Gruppenberechtigungen</td>
<td>Empfindlich für Probleme mit der Benutzer-umask;
                Zugriff am besten nur durch einen Benutzer</td>
<td>Umgeht umask-Probleme</td>
</tr>
<tr>
<td rowspan="3">Skalierbarkeit</td>
<td>Plattenplatzbedarf des Repositorys</td>
<td>Größer (besonders, wenn Protokolldateien nicht
                gekürzt werden)</td>
<td>Kleiner</td>
</tr>
<tr>
<td>Anzahl an Revisionsbäumen</td>
<td>Datenbank; keine Probleme</td>
<td>Einige ältere Dateisysteme lassen sich mit
                tausenden Einträgen in einem Verzeichnis nicht gut
                skalieren</td>
</tr>
<tr>
<td>Verzeichnisse mit vielen Dateien</td>
<td>Langsamer</td>
<td>Schneller</td>
</tr>
<tr>
<td rowspan="2">Arbeitsleistung</td>
<td>Auschecken der letzten Revision</td>
<td>Kein spürbarer Unterschied</td>
<td>Kein spürbarer Unterschied</td>
</tr>
<tr>
<td>Große Übergaben</td>
<td>Insgesamt langsamer, aber die Kosten amortisieren
                sich über die Dauer der Übergabe</td>
<td>Insgesamt schneller, jedoch können
                Abschlussarbeiten zu Zeitüberschreitungen beim Client
                führen.</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>Beide dieser Verfahren haben Vor- und Nachteile. Keins
        davon ist &#8222;<span class="quote">offizieller</span>&#8220; als das andere, obwohl
        das neuere FSFS seit Subversion 1.2 das Standardverfahren ist.
        Beide verfügen über die ausreichende Zuverlässigkeit, um ihnen
        Ihre versionierten Daten anzuvertrauen. Doch wie sie in <a class="xref" href="svn.reposadmin.html#svn.reposadmin.basics.backends.tbl-1" title="Tabelle 5.1. Vergleich der Repository-Datenspeicherung">Tabelle 5.1, &#8222;Vergleich der Repository-Datenspeicherung&#8220;</a> sehen
        können, bietet das FSFS-Verfahren bezüglich seiner
        unterstützten Einsatzumgebungen wesentlich mehr Flexibilität.
        Mehr Flexibilität bedeutet, dass Sie sich mehr anstrengen
        müssen, um es falsch einzusetzen. Dies sind die Gründe &#8211;
        hinzu kommt, dass beim Verzicht auf Berkeley DB sich eine
        Komponente weniger im System befindet &#8211; warum heutzutage
        beinahe jeder das FSFS-Verfahren verwendet, wenn neue
        Repositorys angelegt werden.</p>
<p>Glücklicherweise interessiert es die meisten Programme
        die auf Subversion-Repositorys zugreifen nicht, welches
        Speicherverfahren verwendet wird. Außerdem sind Sie mit Ihrer
        ersten Entscheidung für das Speicherverfahren nicht
        notwendigerweise festgelegt &#8211; falls Sie es sich später
        anders überlegen sollten, bietet Subversion Methoden zur
        Migration der Daten im Repository in ein anderes Repository,
        das ein unterschiedliches Speicherverfahren verwendet. Wir
        werden das später in diesem Kapitel erörtern.</p>
<p>Die folgenden Unterabschnitte bieten einen detaillierten
        Blick auf die verfügbaren Speicherverfahren.</p>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.reposadmin.basics.backends.bdb"></a>5.2.3.1. Berkeley DB</h4></div></div></div>
<p>In der anfänglichen Entwurfsphase von Subversion
          entschieden sich die Entwickler aus einer Reihe von Gründen,
          Berkeley DB zu verwenden. Hierzu zählen die quelloffene
          Lizenz, Transaktionsunterstützung, Zuverlässigkeit,
          Arbeitsleistung, Einfachheit der Programmierschnittstelle,
          Thread-Sicherheit, Cursor-Unterstützung usw.</p>
<p>Berkeley DB bietet echte Transaktionsunterstützung
          &#8211; vielleicht seine stärkste Funktion. Mehrere
          Prozesse, die auf Ihre Subversion-Repositorys zugreifen,
          brauchen sich keine Sorgen machen, dass sie sich
          versehentlich gegenseitig die Daten zerschießen. Die durch
          das Transaktiossystem gebotene Isolation bedeutet, dass der
          Subversion-Repository-Programmcode für jede gegebene
          Operation eine statische Sicht auf die Datenbank hat &#8211;
          keine sich durch die Einflüsse anderer Prozesse ständig
          ändernde Datenbank &#8211; und basierend auf dieser Sicht
          Entscheidungen treffen kann. Falls die getroffene
          Entscheidung zu einem Konflikt damit führt, was eine anderer
          Prozess macht, wird die gesamte Transaktion zurückgerollt,
          als wäre sie nie passiert, und Subversion versucht höflich,
          die Operation mithilfe einer aktualisierten (aber immer noch
          statischen) Sicht der Datenbank erneut durchzuführen.</p>
<p>Eine weitere großartige Funktion von Berkeley DB sind
          <em class="firstterm">Hot Backups</em> &#8211; die Fähigkeit,
          die Datenbankumgebung zu sichern, ohne sie &#8222;<span class="quote">vom
          Netz</span>&#8220; zu nehmen. Wir besprechen später in diesem
          Kapitel, wie Sie Ihr Repository sichern (in <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.backup" title="5.4.8. Repository Backup">Abschnitt 5.4.8, &#8222;Repository Backup&#8220;</a>), doch sollten die
          Vorteile offensichtlich sein, die dadurch entstehen, dass
          Sie vollständige Sicherheitskopien Ihrer Repositorys ohne
          Wartungszeiträume machen können.</p>
<p>Bei Berkeley DB handelt es sich auch um ein sehr
          zuverlässiges Datenbanksystem, wenn es richtig verwendet
          wird. Subversion benutzt das Protokollierungssystem von
          Berkeley DB, was bedeutet, dass die Datenbank zunächst eine
          Beschreibung der Veränderungen in Protokolldateien auf der
          Platte schreibt, bevor die Veränderungen selbst durchgeführt
          werden. Dies stellt sicher, dass, falls etwas schief geht,
          die Datenbank zu einem früheren
          <em class="firstterm">Sicherungspunkt</em> zurückgehen kann
          &#8211; eine Stelle in den Protokolldateien, von der bekannt
          ist, dass sie eine nicht beschädigte Datenbank bezeichnet
          &#8211; und Transaktionen solange wiederholen kann, bis die
          Daten sich wieder in einem brauchbaren zustand befinden.
          Siehe <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.diskspace" title="5.4.3. Plattenplatzverwaltung">Abschnitt 5.4.3, &#8222;Plattenplatzverwaltung&#8220;</a>
          weiter unten in diesem Kapitel für weitere Informationen zu
          Berkeley-DB-Protokolldateien.</p>
<p>Doch keine Rose ohne Dornen, uns so müssen wir auch
          einige bekannte Einschränkungen von Berkeley DB ansprechen.
          Erstens sind Berkeley-DB -Umgebungen nicht portierbar. Sie
          können nicht einfach ein unter Unix erzeugtes
          Subversion-Repository auf ein Windows-System kopieren und
          erwarten, dass es funktioniert. Obwohl ein Großteil des
          Berkeley-DB-Datenbankformats architekturunabhängig ist, sind
          es andere Teile der Umgebung nicht. Zweitens benutzt
          Subversion Berkeley DB auf eine Weise, die nicht auf Windows
          95/98 funktioniert &#8211; falls Sie ein BDB-basiertes
          Repository auf einer Windows-Maschine unterbringen müssen,
          bleiben Sie bei Windows 2000 oder einem seiner
          Nachfolger.</p>
<p>Obwohl Berkeley DB verspricht, sich korrekt auf
          freigegebenen Netzlaufwerken zu verhalten, die bestimmte
          Anforderungen erfüllen,
          <sup>[<a name="id394078" href="#ftn.id394078" class="footnote">30</a>]</sup> bieten die meisten Netz-Dateisysteme
          <span class="emphasis"><em>keine</em></span> derartige Unterstützung. Und
          keinesfalls dürfen Sie zulassen, dass gleichzeitig von
          mehreren Clients auf ein BDB-basiertes Repository auf einer
          Netzfreigabe zugegriffen wird (was eigentlich der Hauptgrund
          dafür ist, das Repository auf einer Netzfreigabe
          unterzubringen).</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warnung]" src="images/warning.png"></td>
<th align="left">Warnung</th>
</tr>
<tr><td align="left" valign="top"><p>Falls Sie versuchen sollten, Berkeley DB auf einem
            Netz-Dateisystem unterzubringen, das die Anforderungen
            nicht erfüllt, ist das Ergebnis unvorhersehbar &#8211; es
            kann sein, dass Sie sofort mysteriöse Fehler wahrnehmen
            oder es kann Monate dauern, bis Sie bemerken, dass Ihre
            Repository-Datenbank fast unmerklich beschädigt ist. Sie
            sollten ernsthaft erwägen, das FSFS-Speicherverfahren für
            Repositorys zu verwenden, die auf einer Netzfreigabe
            untergebracht werden sollen.</p></td></tr>
</table></div>
<p>Schließlich ist Berkeley DB empfindlicher gegenüber
          Unterbrechungen als ein typisches relationales
          Datenbanksystem, da es sich um eine Bibliothek handelt, die
          direkt in Subversion eingebunden ist. Beispielsweise haben
          die meisten SQL-Systeme einen dedizierten Server-Prozess,
          der alle Tabellenzugriffe vermittelt. Falls ein auf die
          Datenbank zugreifendes Programm aus irgendeinem Grund
          abstürzt, bemerkt der Datenbank-Dämon die verlorene
          Verbindung und räumt anschließend auf. Und da der
          Datenbank-Dämon der einzige Prozess ist, der auf die
          Tabellen zugreift, brauchen sich Anwendungsprogramme nicht
          um Berechtigungskonflikte zu kümmern. Das trifft allerdings
          nicht auf Berkeley DB zu. Subversion (und jedes Programm,
          das die Subversion-Bibliotheken verwendet) greift direkt auf
          die Datenbanktabellen zu, was bedeutet, dass ein
          Programmabsturz die Datenbank vorübergehend in einem
          inkonsistenten, nicht zugreifbaren Zustand hinterlassen
          kann, so dass ein Administrator Berkeley DB dazu auffordern
          muss, zu einem Sicherungspunkt zurückzugehen, was etwas
          ärgerlich ist. Neben abgestürzten Prozessen können andere
          Dinge das Repository &#8222;<span class="quote">verklemmen</span>&#8220;, wie etwa
          Programme, die sich wegen Eigentums- und Zugriffsrechten auf
          Datenbankdateien ins Gehege kommen.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">Anmerkung</th>
</tr>
<tr><td align="left" valign="top"><p>Berkeley DB 4.4 bietet (für Subversion 1.4 und spätere
            Versionen) die Fähigkeit, dass Subversion falls erforderlich
            automatisch und transparent Berkeley-DB-Umgebungen 
            wiederherstellt. Wenn sich ein Subversion-Prozess an die
            Berkeley-DB-Umgebung hängt, verwendet er eine Art
            Prozess-Buchhaltung, um unsaubere Verbindungsabbrüche
            früherer Prozesse zu entdecken, führt die notwendige
            Wiederherstellung durch und fährt fort, als wäre nichts
            passiert. Dies verhindert das Vorkommen von Verklemmungen
            zwar nicht vollständig, verringert allerdings erheblich
            den Aufwand an menschlichen Eingriffen, um sich hiervon zu
            erholen.</p></td></tr>
</table></div>
<p>Während ein Berkeley-DB-Repository ziemlich schnell und
          skalierbar ist, wird es am besten von einem einzelnen
          Server-Prozess unter einer Benutzerkennung verwendet &#8211;
          so wie Apaches <span class="command"><strong>httpd</strong></span> oder
          <span class="command"><strong>svnserve</strong></span> (siehe <a class="xref" href="svn.serverconfig.html" title="Kapitel 6. Die Administration eines Subversion-Servers">Kapitel 6, <i>Die Administration eines Subversion-Servers</i></a>) &#8211; statt darauf mit
          mehreren Benutzern über <code class="literal">file://</code> oder
          <code class="literal">svn+ssh://</code> URLs zuzugreifen.  Falls Sie
          mit mehreren Benutzern direkt auf ein Berkeley-DB-Repository
          zugreifen wollen, sollten Sie unbedingt <a class="xref" href="svn.serverconfig.html#svn.serverconfig.multimethod" title="6.6. Supporting Multiple Repository Access Methods">Abschnitt 6.6, &#8222;Supporting Multiple Repository Access Methods&#8220;</a> weiter unten in
          diesem Kapitel lesen.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.reposadmin.basics.backends.fsfs"></a>5.2.3.2. FSFS</h4></div></div></div>
<p>Mitte 2004 entstand ein zweiter Typ eines
          Repository-Speichersystems &#8211; eins, das überhaupt keine
          Datenbank verwendet. Ein FSFS-Repository speichert die zu
          einer Revision gehörenden Änderungen in einer einzelnen
          Datei, so dass sich alle Revisionen eines Repositorys in
          einem Verzeichnis voller nummerierter Dateien befinden.
          Transaktionen werden als individuelle Dateien in getrennten
          Verzeichnissen erzeugt. Sobald sie vollständig ist, wird die
          Transaktionsdatei umbenannt und in das Revisionsverzeichnis
          verschoben, so dass die Atomizität von Übergaben
          gewährleistet ist. Und da eine Revisionsdatei dauerhaft und
          unveränderlich ist, kann das Repository auch im laufenden
          Betrieb gesichert werden, genauso wie ein BDB-basiertes
          Repository.</p>
<p>Die FSFS-Revisionsdateien beschreiben die
          Verzeichnisstruktur einer Revision, Dateiinhalte und Deltas
          zu Dateien in anderen Revisionsbäumen. Anders als eine
          Berkeley-DB-Datenbank, ist dieses Speicherformat auf
          verschiedene Betriebssysteme übertragbar und nicht von einer
          CPU-Architektur abhängig. Da weder Journaldateien noch
          Dateien für gemeinsam benutzten Speicher verwendet werden,
          kann auf das Repository sicher über ein Netzdateisystem
          zugegriffen und es in einer Nur-Lese-Umgebung untersucht
          werden. Das Fehlen der Datenbankverwaltung bedeutet
          ebenfalls eine etwas geringere Größe des Repositorys.</p>
<p>FSFS hat auch eine unterschiedliche Charakteristik, was
          den Durchsatz anbelangt. Wenn eine große Zahl an Dateien
          übergeben wird, kann FSFS schneller Verzeichniseinträge
          hinzufügen. Andererseits schreibt FSFS die letzte Version
          einer Datei als ein Delta gegenüber einer älteren Version,
          was bedeutet, dass das Auschecken des letzten Baums etwas
          langsamer ist als die vollständigen Texte zu holen, die in
          einer Berkeley-DB HEAD-Revision gespeichert sind. FSFS hat
          auch eine längere Verzögerung beim Fertigstellen einer
          Übergabe, was im Extremfall dazu führen kann, dass bei
          Clients Zeitüberschreitungen beim Warten auf eine Antwort
          auftreten.</p>
<p>Der wichtigste Unterschied jedoch ist die
          Unempfänglichkeit von FSFS gegenüber Verklemmungen, wenn
          etwas schief geht. Falls ein Prozess, der eine
          Berkeley-DB-Datenbank benutzt, ein Berechtigungsproblem
          bekommt oder plötzlich abstürzt, kann das die Datenbank in
          einen unbrauchbaren Zustand bringen, bis ein Administrator
          sie wiederherstellt. Falls ein Prozess, der ein
          FSFS-Repository benutzt, in dieselbe Situation gerät, ist
          das Repository hiervon überhaupt nicht betroffen. Das
          Schlimmste, was passieren kann, ist, dass einige
          Transaktionsdaten nicht abgearbeitet werden können.</p>
<p>Das einzige echte Argument, was gegen FSFS spricht, ist
          seine relative Unreife im Gegensatz zu Berkeley DB. Anders
          als Berkeley DB, das auf eine jahrelange Geschichte
          zurückblicken kann, ein eigenes Entwicklerteam hat und sich
          nun mit dem mächtigen Namen Oracle schmücken darf,
          <sup>[<a name="id394368" href="#ftn.id394368" class="footnote">31</a>]</sup>
          ist FSFS eine neuere Technik. Vor Subversion 1.4 purzelten
          immer noch einige ernsthafte Fehler in Bezug auf die
          Unversehrtheit der Daten heraus, die, obwohl sie sehr selten
          ausgelöst wurden, dennoch auftraten.  Nichtsdestoweniger
          ist FSFS schnell zum Speicherverfahren der Wahl für einige
          der größten öffentlichen und privaten Subversion-Repositorys
          geworden und verspricht durch die Bank eine niedrigere
          Einstiegshürde für Subversion.</p>
</div>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.reposadmin.create"></a>5.3. Anlegen und konfigurieren Ihres Repositorys</h2></div></div></div>
<p>Weiter oben in diesem Kapitel (in <a class="xref" href="svn.reposadmin.html#svn.reposadmin.planning" title="5.2. Strategien für die Verwendung eines Repositorys">Abschnitt 5.2, &#8222;Strategien für die Verwendung eines Repositorys&#8220;</a>), schauten wir auf einige
      der wichtigen Entscheidungen, die zu treffen sind, bevor Ihr
      Subversion-Repository angelegt und konfiguriert wird. Jetzt
      schaffen wir es endlich, uns die Hände schmutzig zu machen! In
      diesem Abschnitt werden wir sehen, wie ein Subversion-Repository
      überhaupt angelegt wird und wie es konfiguriert wird, damit es
      bei bestimmten Repository-Ereignissen spezielle Aktionen
      ausführt.</p>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.basics.creating"></a>5.3.1. Anlegen des Repositorys</h3></div></div></div>
<p>Das Anlegen eines Subversion-Repositorys ist eine
        unglaublich einfache Aufgabe. Das mit Subversion gelieferte
        Dienstprogramm <span class="command"><strong>svnadmin</strong></span> stellt ein
        Unterbefehl (<span class="command"><strong>svnadmin create</strong></span>) zur
        Verfügung, der genau das macht.</p>
<pre class="screen">
$ # Ein Repository anlegen
$ svnadmin create /var/svn/repos
$
</pre>
<p>Damit wird ein neues Repository im Verzeichnis
        <code class="filename">/var/svn/repos</code> mit dem
        Standard-Speicherverfahren angelegt. Vor Subversion 1.2 war es
        Berkeley DB, nun ist es FSFS.  Sie können den Dateisystemtypen
        ausdrücklich wählen, indem Sie das Argument
        <code class="option">--fs-type</code> benutzen, das als Parameter
        entweder <code class="literal">fsfs</code> oder <code class="literal">bdb</code>
        zulässt.</p>
<pre class="screen">
$ # Ein FSFS-basiertes Repository anlegen
$ svnadmin create --fs-type fsfs /var/svn/repos
$
</pre>
<pre class="screen">
# Ein Berkeley-DB-basiertes Repository anlegen
$ svnadmin create --fs-type bdb /var/svn/repos
$
</pre>
<p>Nach dem Ausführen dieses einfachen Befehls haben Sie ein
        Subversion-Repository.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tipp]" src="images/tip.png"></td>
<th align="left">Tipp</th>
</tr>
<tr><td align="left" valign="top"><p>Das Pfad-Argument zu <span class="command"><strong>svnadmin</strong></span> ist
          bloß ein gewöhnlicher Pfad im Dateisystem und kein URL wie
          ihn das Client-Programm <span class="command"><strong>svn</strong></span> verwendet, um
          auf Repositorys zu verweisen. Sowohl
          <span class="command"><strong>svnadmin</strong></span> als auch
          <span class="command"><strong>svnlook</strong></span> werden als serverseitige
          Dienstprogramme betrachtet &#8211; sie werden auf dem
          Rechner benutzt, auf dem das Repository untergebracht ist,
          um Aspekte des Repositorys zu untersuchen oder zu verändern;
          tatsächlich sind sie nicht in der Lage, Aufgaben über das
          Netz zu erledigen. Ein verbreiteter Fehler von
          Subversion-Neulingen ist der Versuch, URLs (sogar
          &#8222;<span class="quote">lokale</span>&#8220; vom Typ <code class="literal">file://</code>) an
          diese zwei Programme zu übergeben.</p></td></tr>
</table></div>
<p>Im Unterverzeichnis <code class="filename">db/</code> Ihres
        Repositorys befindet sich die Implementierung des
        versionierten Dateisystems. Das Leben des versionierten
        Dateisystems Ihres Repositorys beginnt mit Revision 0, die aus
        nichts anderem als dem Wurzelverzeichnis
        (<code class="filename">/</code>) besteht. Zu Beginn hat die Revision 0
        ein einziges Revisions-Property, <code class="literal">svn:date</code>,
        das als Wert die Angabe des Zeitpunktes besitzt, zu dem das
        Repository angelegt wurde.</p>
<p>Da Sie nun ein Repository haben, ist es an der Zeit, es
        anzupassen.</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warnung]" src="images/warning.png"></td>
<th align="left">Warnung</th>
</tr>
<tr><td align="left" valign="top"><p>Während einige Teile des Repositorys &#8211; wie die
          Konfigurationsdateien und Hook-Scripts &#8211; für eine
          manuelle Untersuchung und Bearbeitung gedacht sind, sollten
          Sie nicht (und sie sollten es auch nicht nötig haben) an den
          anderen Teilen des Repositorys &#8222;<span class="quote">händisch</span>&#8220;
          herumdoktern. Das Dienstprogramm <span class="command"><strong>svnadmin</strong></span>
          sollte für alle notwendigen Änderungen an Ihrem Repository
          ausreichen; sie können auch Dienstprogramme von
          Drittanbietern (wie das Werkzeugpaket von Berkeley DB)
          verwenden, um in entsprechenden Unterabschnitten des
          Repositorys Änderungen vorzunehmen. Versuchen Sie
          <span class="emphasis"><em>nicht</em></span>, die Historie Ihrer
          Versionskontrolle manuell zu verändern, indem Sie in den
          Speicherdateien des Repositorys herumstochern!</p></td></tr>
</table></div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.create.hooks"></a>5.3.2. Erstellen von Repository-Hooks</h3></div></div></div>
<p>Ein <em class="firstterm">Hook</em> (Haken) ist ein Programm,
        das durch einige Repository-Ereignisse gestartet wird, wie
        etwa die Erzeugung einer neuen Revision oder die Veränderung
        eines unversionierten Propertys. Einige Hooks (die sogenannten
        &#8222;<span class="quote">Pre-Hooks</span>&#8220;) starten vor einer
        Repository-Operation und bieten eine Möglichkeit sowohl zu
        berichten, was passieren wird, als auch zu verhindern, dass es
        überhaupt passiert. Andere Hooks (die
        &#8222;<span class="quote">Post-Hooks</span>&#8220;) starten nach Abschluss eines
        Repository-Ereignisses und sind nützlich für Aufgaben, die das
        Repository inspizieren &#8211; aber nicht verändern. Jedem
        Hook wird ausreichend Information übergeben, damit er
        feststellen kann, um welches Ereignis es sich handelt (oder
        handelte), welche genauen Änderungen am Repository
        beabsichtigt sind (oder durchgeführt wurden) und wie der Name des
        Benutzers lautet, der das Ereignis ausgelöst hat.</p>
<p>Das Verzeichnis für die <code class="filename">Hooks</code> ist
        standardmäßig mit Vorlagen für verschiedene Repository-Hooks
        gefüllt:</p>
<pre class="screen">
$ ls repos/hooks/
post-commit.tmpl          post-unlock.tmpl  pre-revprop-change.tmpl
post-lock.tmpl            pre-commit.tmpl   pre-unlock.tmpl
post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl
$
</pre>
<p>Es gibt eine Vorlage für jeden Hook, den Subversion
        unterstützt. Sie können sehen, wodurch jedes dieser Scripte
        gestartet wird und welche Daten übergeben werden, indem Sie
        den Inhalt der Scripte inspizieren. In vielen dieser Vorlagen
        befinden sich auch Beispiele dafür, wie dieses Script zusammen
        mit anderen Programmen aus dem Lieferumfang von Subversion
        verwendet werden kann, um häufige, nützliche Aufgaben zu erledigen.
        Um einen funktionierenden Hook zu installieren, brauchen Sie
        nur ein ausführbares Programm oder Script im Verzeichnis
        <code class="filename">repos/hooks</code> abzulegen, das unter dem
        Namen des Hooks (etwa <span class="command"><strong>start-commit</strong></span> oder
        <span class="command"><strong>post-commit</strong></span>) gestartet werden kann.</p>
<p>Auf Unix Plattformen bedeutet das, ein Script oder
        Programm bereitzustellen (welches ein Shell-Script, ein
        Python-Programm, ein übersetztes C-Binärprogramm oder
        sonstetwas sein kann), das genauso heißt wie der Hook.
        Natürlich sind die Vorlagen nicht nur zur Information da
        &#8211; die einfachste Möglichkeit, unter Unix einen Hook zu
        installieren, ist es, einfach die passende Vorlagedatei in
        eine Datei zu kopieren, der die Dateiendung
        <code class="filename">.tmpl</code> fehlt, den Inhalt anzupassen und
        sicherzustellen, dass das Script ausführbar ist. Unter Windows
        werden jedoch Dateiendungen verwendet, um festzustellen, ob
        ein Programm ausführbar ist, so dass Sie ein Programm zur
        Verfügung stellen müssen, dessen Basisname dem Hook entspricht
        und dessen Endung einer derjenigen entspricht, die Windows für
        ausführbare Programme hält, etwa <code class="filename">.exe</code> für
        Programme und <code class="filename">.bat</code> für
        Batch-Dateien.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tipp]" src="images/tip.png"></td>
<th align="left">Tipp</th>
</tr>
<tr><td align="left" valign="top"><p>Aus Sicherheitsgründen führt Subversion Hook-Programme
          in einer leeren Umgebung aus &#8211; d.h., es sind überhaupt
          keine Umgebungsvariablen gesetzt, nicht einmal
          <code class="literal">$PATH</code> (oder <code class="literal">%PATH%</code>
          unter Windows). Deshalb sind viele Administratoren verwirrt,
          wenn deren Hook-Programme normal starten, wenn sie manuell
          aufgerufen werden, aber nicht laufen, wenn sie Subversion
          startet. Stellen Sie sicher, dass Sie entweder alle
          notwendigen Umgebungsvariablen in Ihren Hook-Programmen
          ausdrücklich setzen und/oder absolute Pfade zu Programmen
          verwenden.</p></td></tr>
</table></div>
<p>Subversion führt die Hooks unter der Benutzerkennung aus,
        die auch der Prozess besitzt, der auf das Repository zugreift.
        Meistens wird auf das Repository über einen Subversion-Server
        zugegriffen, so dass die Benutzerkennung der des
        Serverprozesses entspricht. Die Hooks müssen deshalb mit den
        entsprechenden Berechtigungen des Betriebssystems versehen
        werden, damit diese Benutzerkennung sie ausführen kann. Das
        bedeutet auch, dass der direkte oder indirekte Zugriff auf
        irgendwelche Programme oder Dateien (einschließlich des
        Subversion-Repositorys) durch den Hook auch unter derselben
        Kennung erfolgt. Mit anderen Worten: Achten Sie auf mögliche
        Probleme im Zusammenhang mit Zugriffsrechten, die den Hook
        daran hindern könnten, die Ihm zugeteilten Aufgaben
        wahrzunehmen.</p>
<p>Es gibt mehrere im Subversion-Repository implementierte
        Hooks; Details zu jedem können Sie in <a class="xref" href="svn.ref.html#svn.ref.reposhooks" title="9.11. Repository Hooks">Abschnitt 9.11, &#8222;Repository Hooks&#8220;</a> nachlesen. Als
        Repository-Administrator müssen Sie entscheiden, welche Hooks
        sie einrichten wollen (indem Sie ein entsprechend benanntes
        und mit den nötigen Zugriffsrechten versehenes Hook-Programm
        bereitstellen) und wie Sie sie einsetzen wollen. Wenn Sie diese Entscheidung
        treffen, dann behalten Sie das Gesamtbild des
        Repository-Einsatzes im Auge.  Wenn Sie beispielsweise die
        Konfiguration des Servers verwenden, um festzustellen, welche
        Benutzer Änderungen an Ihr Repository übergeben dürfen,
        benötigen Sie für diese Zugriffskontrolle nicht das
        Hook-System.</p>
<p>Es gibt keinen Mangel an Subversion-Hook-Programmen und
        Scripten, die frei verfügbar sind, entweder von der
        Subversion-Gemeinschaft oder von woanders her. Diese Scripte
        decken ein breites Spektrum ab &#8211; grundlegende
        Zugriffskontrolle, Kontrolle der Prozesstreue,
        Fehlersystemanbindung, E-Mail-basierte oder syndizierte
        Benachrichtigungen bei Übergaben und noch viel mehr. Oder,
        falls Sie Ihren eigenen schreiben wollen, siehe <a class="xref" href="svn.developer.html" title="Kapitel 8. Embedding Subversion">Kapitel 8, <i>Embedding Subversion</i></a>.</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warnung]" src="images/warning.png"></td>
<th align="left">Warnung</th>
</tr>
<tr><td align="left" valign="top"><p>Obwohl Hook-Scripts fast alles machen können, gibt es
          eine Dimension, in der sich Hook-Script-Autoren zurückhalten
          sollten: Ändern Sie <span class="emphasis"><em>keine</em></span>
          Übergabe-Transaktion mithilfe von Hook-Scripten. Trotz der
          Verlockung, Hook-Scripte zur automatischen Korrektur von
          Fehlern, Unzulänglichkeiten oder Prozessverletzungen
          innerhalb der zu übergebenden Dateien einzusetzen, kann das
          zu Problemen führen. Subversion hält bestimmte
          Repository-Daten in clientseitigen Caches vor, und wenn Sie
          auf diese Art eine Übergabe-Transaktion verändern, werden
          die im Cache befindlichen Informationen ungültig, ohne dass
          jemand etwas merkt. Diese Inkonsistenz kann zu
          überraschendem und unerwartetem Verhalten führen. Statt die
          Transaktion zu verändern, sollten Sie sie einfach im
          <code class="filename">pre-commit</code>-Hook auf
          <span class="emphasis"><em>Gültigkeit</em></span> prüfen und die Übergabe
          ablehnen, falls sie den Anforderungen nicht entspricht. Als
          Nebeneffekt werden Ihre Benutzer lernen, wie wertvoll eine
          sorgfältige, sich an den Vorgaben orientierende Arbeitsweise
          ist.</p></td></tr>
</table></div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.create.bdb"></a>5.3.3. Konfiguration von Berkeley DB</h3></div></div></div>
<p>Eine Berkeley-DB-Umgebung ist eine Kapselung einer oder
        mehrerer Datenbanken, Protokolldateien, Regionsdateien und
        Konfigurationsdateien. Die Berkeley-DB-Umgebung hat ihre
        eigene Menge an Konfigurationswerten für Dinge wie die
        Maximalzahl von Datenbanksperren zu einem gegebenen Zeitpunkt,
        die Obergrenze für die Größe der Protokolldateien usw.
        Darüberhinaus wählt Subversions Dateisystemlogik Standardwerte
        für einige der Berkeley-DB-Konfigurationsoptionen. Manchmal
        jedoch benötigt Ihr besonderes Repository, welches eine
        einzigartige Sammlung von Daten und Zugriffsmustern darstellt,
        eine unterschiedliche Menge von Konfigurationswerten.</p>
<p>Den Herstellern von Berkeley-DB ist bewusst, dass
        unterschiedliche Anwendungen und Datenbankumgebungen auch
        unterschiedliche Anforderungen haben, so dass sie einen
        Mechanismus zur Verfügung gestellt haben, der es ermöglicht,
        während der Laufzeit viele der Konfigurationseinstellungen für
        die Berkeley-DB-Umgebung zu überschreiben. BDB prüft, ob es
        eine Datei namens  <code class="filename">DB_CONFIG</code> im
        Umgebungsverzeichnis (das Verzeichnis <code class="filename">db</code>
        des Repositorys) gibt und liest die in dieser Datei
        vorhandenen Optionen. Subversion erzeugt diese Datei selbst,
        wenn der Rest eines Repositorys erstellt wird. Anfangs
        beinhaltet diese Datei einige Standardoptionen sowie Verweise
        zur Berkeley-DB-Dokumentation im Netz, so dass Sie
        nachschlagen können, was diese Optionen bewirken.
        Selbstverständlich können Sie beliebige von Berkeley DB
        unterstützte Optionen der Datei <code class="filename">DB_CONFIG</code>
        hinzufügen. Beachten Sie jedoch, dass Sie es vermeiden
        sollten, obwohl Subversion niemals versucht, den Inhalt der
        Datei zu lesen oder zu interpretieren und auch sonst keinen
        direkten Gebrauch von den dortigen Optionseinstellungen macht,
        die Konfiguration so zu verändern, dass sich Berkeley DB
        anders verhält, als es Subversion erwartet. Die Änderungen an
        <code class="filename">DB_CONFIG</code> werden außerdem erst nach einer
        Wiederherstellung der Datenbankumgebung (mit <span class="command"><strong>svnadmin
        recover</strong></span>) gültig.</p>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.reposadmin.maint"></a>5.4. Repository-Wartung</h2></div></div></div>
<p>Die Wartung eines Subversion-Repositorys kann abschreckend
      sein, was an der Komplexität liegt, die Systemen innewohnt, die
      auf Datenbanken aufbauen. Die Arbeit gut zu machen, bedeutet,
      die Werkzeuge zu kennen &#8211; was sie sind, wann sie zu
      verwenden sind und wie. Dieser Abschnitt stellt Ihnen die
      Repository-Verwaltungswerkzeuge vor, die Subversion mitbringt
      und erörtert, wie sie gehandhabt werden, um Aufgaben zu
      erledigen, wie etwa Repository-Datenmigration, Aktualisierungen,
      Sicherungen und Aufräumarbeiten.</p>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.maint.tk"></a>5.4.1. Der Werkzeugkasten eines Administrators</h3></div></div></div>
<p>Subversion stellt eine Handvoll Dienstprogramme zur
        Verfügung, die nützlich zum Erstellen, Untersuchen, Verändern
        und Reparieren Ihres Repositorys sind. Wir wollen uns diese
        Werkzeuge einmal genauer ansehen. Anschließend werden wir kurz
        einige der zum Berkeley-DB-Paket gehörenden Dienstprogramme
        untersuchen, die auf die Besonderheiten der von Subversion
        verwendeten Datenbank zugeschnittene Funktionen anbieten, die
        mit Subversions eigenen Werkzeugen nicht verfügbar
        sind.</p>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.reposadmin.maint.tk.svnadmin"></a>5.4.1.1. svnadmin</h4></div></div></div>
<p>Das Programm <span class="command"><strong>svnadmin</strong></span> ist der beste
          Freund des Repository-Administrators. Neben der Fähigkeit,
          Subversion-Repositorys zu erzeugen, erlaubt Ihnen dieses
          Programm verschiedene Wartungsarbeiten auf diesen
          Repositorys auszuführen. Die Syntax von
          <span class="command"><strong>svnadmin</strong></span> ist ähnlich wie bei anderen
          Kommandozeilenprogrammen von Subversion:</p>
<pre class="screen">
$ svnadmin help
Aufruf: svnadmin UNTERBEFEHL ARCHIV_PFAD [Optionen &amp; Parameter ...]
Geben Sie »svnadmin help &lt;Unterbefehl&gt;« ein, um Hilfe zu einem Unterbefehl
          zu erhalten.
Geben Sie »svnadmin --version« ein, um die Programmversion und die Datei-
          systemmodule zu sehen.

Verfügbare Unterbefehle:
   crashtest
   create
   deltify
&#8230;
</pre>
<p>Früher in diesem Kapitel (in <a class="xref" href="svn.reposadmin.html#svn.reposadmin.basics.creating" title="5.3.1. Anlegen des Repositorys">Abschnitt 5.3.1, &#8222;Anlegen des Repositorys&#8220;</a>), wurde uns der
          Unterbefehl <span class="command"><strong>svnadmin create</strong></span> vorgestellt.
          Die meisten anderen Unterbefehle von
          <span class="command"><strong>svnadmin</strong></span> werden wir später in diesem
          Kapitel behandeln. Und in <a class="xref" href="svn.ref.html#svn.ref.svnadmin" title="9.2. svnadmin">Abschnitt 9.2, &#8222;svnadmin&#8220;</a> können Sie in einer vollständigen Aufstellung der
          Unterbefehle nachlesen, was jeder zu bieten hat.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.reposadmin.maint.tk.svnlook"></a>5.4.1.2. svnlook</h4></div></div></div>
<p><span class="command"><strong>svnlook</strong></span> ist ein von Subversion
          mitgeliefertes Dienstprogramm zum Untersuchen der
          mannigfaltigen Revisionen und
          <em class="firstterm">Transaktionen</em> (bei denen es sich um
          Revisionen in Entstehung handelt) in einem Repository. Kein
          Teil dieses Programms versucht, das Repository zu verändern.
          <span class="command"><strong>svnlook</strong></span> wird üblicherweise von
          Repository-Hooks verwendet, um die abzuliefernden Änderungen
          zu melden (im Fall des <span class="command"><strong>pre-commit</strong></span>-Hooks)
          oder die gerade an das Repository übergeben wurden (im Fall
          des <span class="command"><strong>post-commit</strong></span>-hooks). Ein
          Repository-Administrator kann dieses Programm zur Diagnose
          benutzen.</p>
<p><span class="command"><strong>svnlook</strong></span> besitzt eine überschaubare
          Syntax:</p>
<pre class="screen">
$ svnlook help
Aufruf: svnlook UNTERBEFEHL ARCHIV_PFAD [Optionen &amp; Parameter ...]
Hinweis: Alle Unterbefehle, die die Parameter »--revision« und »--transaction«
         akzeptieren, werden ohne diese Parameter die neueste
         Revision des Projektarchivs verwenden.
Geben Sie »svnlook help &lt;Unterbefehl&gt;« ein, um Hilfe zu einem Unterbefehl
         zu erhalten.
Geben Sie »svnlook --version« ein, um die Programmversion und die Datei-
         systemmodule zu sehen.
&#8230;
</pre>
<p>Die meisten Unterbefehle von <span class="command"><strong>svnlook</strong></span>
          können entweder auf einem Revisions- oder auf einem
          Transaktionsbaum arbeiten, indem sie Informationen über den
          Baum an sich ausgeben oder darüber, inwiefern er sich von
          einer früheren Revision des Repositorys unterscheidet. Sie
          verwenden die Optionen <code class="option">--revision</code>
          (<code class="option">-r</code>) und <code class="option">--transaction</code>
          (<code class="option">-t</code>), um die zu untersuchende Revision bzw.
          Transaktion anzugeben. Ohne eine der Optionen
          <code class="option">--revision</code> (<code class="option">-r</code>) und
          <code class="option">--transaction</code> (<code class="option">-t</code>)
          untersucht Subversion die jüngste (oder
          <code class="literal">HEAD</code>) Revision des Repositorys. Das
          heißt, die beiden folgenden Befehle machen genau dasselbe,
          wenn 19 die jüngste Revision im Repository unter
          <code class="filename">/var/svn/repos</code> ist:</p>
<pre class="screen">
$ svnlook info /var/svn/repos
$ svnlook info /var/svn/repos -r 19
</pre>
<p>Eine Ausnahme von diesen Regeln zu Unterbefehlen ist der
          Unterbefehl <span class="command"><strong>svnlook youngest</strong></span>, der keine
          Optionen entgegennimmt und einfach die jüngste
          Revisionsnummer des Repositorys ausgibt:</p>
<pre class="screen">
$ svnlook youngest /var/svn/repos
19
$
</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">Anmerkung</th>
</tr>
<tr><td align="left" valign="top"><p>Beachten Sie, dass Sie nur Transaktionen untersuchen
            können, die noch nicht übergeben sind. Die meisten
            Repositorys haben keine derartigen Transaktionen, da
            Transaktionen entweder übergeben (in diesem Fall sollten
            Sie darauf mit der Option <code class="option">--revision</code>
            (<code class="option">-r</code>) zugreifen) oder abgebrochen und
            entfernt sind.</p></td></tr>
</table></div>
<p>Die Ausgabe <span class="command"><strong>svnlook</strong></span> ist so gestaltet,
          dass sie sowohl für Menschen als auch für Maschinen lesbar
          ist. Nehmen wir zum Beispiel die Ausgabe des Unterbefehls
          <span class="command"><strong>svnlook info</strong></span>:</p>
<pre class="screen">
$ svnlook info /var/svn/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
43
Den üblichen griechischen
Baum hinzugefügt.
$
</pre>
<p>Die Ausgabe von <span class="command"><strong>svnlook info</strong></span> besteht
          aus dem Folgenden in entsprechender Reihenfolge:</p>
<div class="orderedlist"><ol type="1">
<li><p>Der Autor gefolgt von einem Zeilenvorschub</p></li>
<li><p>Das Datum gefolgt von einem Zeilenvorschub</p></li>
<li><p>Die Anzahl der Zeichen der Protokollnachricht
              gefolgt von einem Zeilenvorschub.</p></li>
<li><p>Die eigentliche Protokollnachricht gefolgt von einem
              Zeilenvorschub</p></li>
</ol></div>
<p>Diese Ausgabe ist für Menschen lesbar, d.h., Dinge wie
          der Zeitstempel werden als Text dargestellt statt als
          irgendetwas Obskures (wie die Anzahl der Nanosekunden seit
          der Mann von Bofrost das letzte Mal da war). Jedoch ist die
          Ausgabe auch maschinenlesbar &#8211; weil die
          Protokollnachricht mehrere Zeilen umfassen und von der Länge
          her unbegrenzt sein kann, liefert <span class="command"><strong>svnlook</strong></span>
          die Länge der Nachricht vor der eigentlichen Nachricht. Das
          erlaubt Scripten und anderen Programmen, die um diesen
          Befehl herumgeschrieben wurden, intelligente Entscheidungen
          in Bezug auf die Protokollnachricht zu treffen, etwa wieviel
          Speicher für die Nachricht anzufordern ist oder zumindest
          wieviele Bytes zu überspringen sind, falls diese Ausgabe
          nicht das letzte Stück im Datenstrom sein sollte.</p>
<p><span class="command"><strong>svnlook</strong></span> kann eine Auswahl anderer
          Abfragen ausführen: Teilmengen der bereits erwähnten
          Informationen ausgeben, versionierte Verzeichnisbäume
          rekursiv auflisten, berichten, welche Pfade in einer
          bestimmten Revision oder Transaktion verändert wurden,
          textuelle und property-basierte Unterschiede an Dateien und
          Verzeichnissen aufzeigen, usw. Siehe <a class="xref" href="svn.ref.html#svn.ref.svnlook" title="9.3. svnlook">Abschnitt 9.3, &#8222;svnlook&#8220;</a> für eine vollständige Referenz
          der Funktionen von <span class="command"><strong>svnlook</strong></span>.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.reposadmin.maint.tk.svndumpfilter"></a>5.4.1.3. svndumpfilter</h4></div></div></div>
<p>Obwohl es nicht das am meisten verwendete Werkzeug im
          Sortiment des Administrators sein wird, bietet
          <span class="command"><strong>svndumpfilter</strong></span> eine ganz besondere Art von
          nützlichen Funktionen &#8211; die Fähigkeit, schnell und
          einfach Datenströme aus der Repository-Historie zu
          verändern, indem es als ein pfadbasierter Filter
          arbeitet.</p>
<p>Die Syntax von <span class="command"><strong>svndumpfilter</strong></span> lautet
          wie folgt:</p>
<pre class="screen">
$ svndumpfilter help
Aufruf: svndumpfilter UNTERBEFEHL [Optionen &amp; Parameter ...]
Geben Sie »svndumpfilter help &lt;Unterbefehl&gt;« ein, um Hilfe zu einem
          Unterbefehl zu erhalten.
Geben Sie »svndumpfilter --version« ein, um die Programmversion zu sehen.

Verfügbare Unterbefehle:
   exclude
   include
   help (?, h)
</pre>
<p>Es gibt nur zwei interessante Unterbefehle:
          <span class="command"><strong>svndumpfilter exclude</strong></span> und
          <span class="command"><strong>svndumpfilter include</strong></span>. Sie erlauben
          Ihnen, zwischen einer impliziten oder expliziten
          Einbeziehung von Pfaden im Datenstrom zu wählen. Sie können
          mehr über diese Unterbefehle und den einzigartigen Zweck von
          <span class="command"><strong>svndumpfilter</strong></span> später in diesem Kapitel
          unter <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.filtering" title="5.4.6. Filtering Repository History">Abschnitt 5.4.6, &#8222;Filtering Repository History&#8220;</a>
          erfahren.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.reposadmin.maint.tk.svnsync"></a>5.4.1.4. svnsync</h4></div></div></div>
<p>Der Befehl <span class="command"><strong>svnsync</strong></span>, der in Subversion
          1.4 neu hinzugekommen ist, bietet Funktionen zum Verwalten
          eines Nur-Lese-Spiegels des Subversion-Repositorys. Das
          Programm hat eine Aufgabe &#8211; die versionierte Historie
          eines Repositorys in ein anderes zu übertragen. Und während
          es nicht viele Möglichkeiten gibt, dies zu tun, liegt seine
          hauptsächliche Stärke darin, das es aus der Ferne eingesetzt
          werden kann &#8211; das &#8222;<span class="quote">Quell</span>&#8220;- und
          &#8222;<span class="quote">Ziel</span>&#8220;-Repository können auf verschiedenen
          Rechnern liegen und auf einem anderen Rechner als
          <span class="command"><strong>svnsync</strong></span> selbst.</p>
<p>Wie Sie vielleicht erwarten, hat
          <span class="command"><strong>svnsync</strong></span> eine Syntax, die allen anderen
          Programmen aus diesem Kapitel gleicht:</p>
<pre class="screen">
$ svnsync help
Aufruf: svnsync UNTERBEFEHL ZIEL_URL [Optionen &amp; Parameter ...]
Geben Sie »svnsync help &lt;Unterbefehl&gt;« ein, um Hilfe zu einem
          Unterbefehl zu erhalten.
Geben Sie »svnsync --version« ein, um die Programmversion und die Zugriffs-
          module zu sehen.

Verfügbare Unterbefehle:
   initialize (init)
   synchronize (sync)
   copy-revprops
   help (?, h)

$
</pre>
<p>Später in diesem Kapitel werden wir mehr über das
          Replizieren von Repositorys mit  <span class="command"><strong>svnsync</strong></span>
          reden (siehe <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.replication" title="5.4.7. Repository Replication">Abschnitt 5.4.7, &#8222;Repository Replication&#8220;</a>).</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.reposadmin.maint.tk.fsfsreshard"></a>5.4.1.5. fsfs-reshard.py</h4></div></div></div>
<p>Obwohl es kein offizielles Glied in der Werkzeugkette
          von Subversion ist, handelt es sich bei dem Script
          <span class="command"><strong>fsfs-reshard.py</strong></span> (zu finden im Verzeichnis
          <code class="filename">tools/server-side</code> des
          Subversion-Quelltext-Paketes) um ein nützliches Werkzeug zur
          Leistungssteigerung für Administratoren von FSFS-basierten
          Subversion-Repositorys. FSFS-Repositorys enthalten Dateien,
          die die Änderungen in einer einzelnen Revision beschreiben
          sowie Dateien, die die zu einer Revision gehörenden Eigenschaften
          beinhalten. Repositorys, die in einer früheren Version als
          Subversion 1.5 erzeugt wurden, legen diese Dateien in zwei
          Verzeichnissen ab &#8211; eins pro Dateityp. Während neue
          Revisionen an das Repository übergeben werden, legt
          Subversion dort immer mehr Dateien ab &#8211; im Lauf der
          Zeit kann die Anzahl der Dateien recht groß werden. Es wurde
          festgestellt, dass dies bei bestimmten netzbasierten
          Dateisystemen zu Leistungseinbußen kommen kann.</p>
<p>Subversion 1.5 legt FSFS-basierte Repositorys mit einer
          geringfügig veränderten Struktur an, in der der Inhalt
          dieser beiden Verzeichnisse
          <em class="firstterm">aufgebrochen</em> ist, d.h. über mehrere
          Unterverzeichnisse aufgeteilt ist.  Das kann die Zeit
          erheblich beschleunigen, die benötigt wird, um eine dieser
          Dateien zu finden und führt somit zu einer allgemeinen
          Leistungssteigerung beim Lesen aus dem Repository. Die
          Anzahl der Unterverzeichnisse für diese Dateien ist jedoch
          konfigurierbar, und hier setzt
          <span class="command"><strong>fsfs-reshard.py</strong></span> an. Dieses Script mischt
          die Dateistruktur des Repositorys und ordnet sie gemäß der
          Anzahl der gewünschten Unterverzeichnisse neu an. Das ist
          inbesonders dann nützlich, wenn ein älteres Repository in
          die neue Struktur von Subversion 1.5 überführt werden soll
          (was Subversion nicht automatisch für Sie macht) oder falls
          ein bereits aufgeteiltes Repository noch feiner eingestellt
          werden soll.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.reposadmin.maint.tk.bdbutil"></a>5.4.1.6. Dienstprogramme von Berkeley DB</h4></div></div></div>
<p>Falls Sie ein Repository verwenden, das auf Berkeley DB
          basiert, befindet sich die gesamte Struktur und die Daten
          Ihres versionierten Dateisystems in einer Menge von
          Datenbanktabellen innerhalb des Unterverzeichnisses
          <code class="filename">db/</code> Ihres Repositorys. Dieses
          Unterverzeichnis ist ein gewöhnliches Verzeichnis einer
          Berkeley-DB-Umgebung und kann deshalb mit irgendeinem der
          Berkeley Datenbankwerkzeuge verwendet werden, die
          normalerweise mit Berkeley DB ausgeliefert werden.</p>
<p>Für die tägliche Arbeit mit Subversion werden diese
          Werkzeuge nicht benötigt. Die meisten Funktionen, die
          üblicherweise für Subversion-Repositorys gebraucht werden,
          sind in <span class="command"><strong>svnadmin</strong></span> integriert worden.
          Beispielsweise liefern <span class="command"><strong>svnadmin
          list-unused-dblogs</strong></span> und <span class="command"><strong>svnadmin
          list-dblogs</strong></span> eine Teilmenge dessen, was vom
          Berkeley-Dienstprogramm <span class="command"><strong>db_archive</strong></span>
          angeboten wird, und <span class="command"><strong>svnadmin recover</strong></span>
          spiegelt die verbreiteten Anwendungsfälle von
          <span class="command"><strong>db_recover</strong></span> wieder.</p>
<p>Trotzdem gibt es noch ein paar Berkeley-DB-Werkzeuge,
          die Ihnen nützlich sein könnten. Die Programme
          <span class="command"><strong>db_dump</strong></span> und <span class="command"><strong>db_load</strong></span>
          schreiben bzw. lesen ein spezielles Dateiformat, das die
          Schlüssel und Werte in einer Berkeley-DB-Datenbank
          beschreibt. Da Berkeley-Datenbanken nicht zwischen
          Rechnerarchitekturen portierbar sind, stellt dieses Format
          ein nützliches Verfahren zur Übertragung der Datenbanken
          zwischen Maschinen zur Verfügung, wobei die Architektur oder
          das Betriebssystem keine Rolle spielen. Später in diesem
          Kapitel werden wir noch beschreiben, wie Sie auch
          <span class="command"><strong>svnadmin dump</strong></span> und <span class="command"><strong>svnadmin
          load</strong></span> für ähnliche Zwecke verwenden können, doch
          <span class="command"><strong>db_dump</strong></span> und <span class="command"><strong>db_load</strong></span>
          können bestimmte Aufgaben genausogut und viel schneller
          erledigen. Sie können auch dabei dienlich sein, wenn der
          erfahrene Berkeley-DB-Hacker aus irgendwelchen Gründen die
          Daten in einem BDB-basierten Repository direkt vor Ort
          anpassen muss, was die Dienstprogramme von Subversion
          nicht erlauben. Ferner liefert das Dienstprogramm
          <span class="command"><strong>db_stat</strong></span> nützliche Informationen über den
          Zustand Ihrer Berkeley-DB-Umgebung, wozu ausführliche
          Statistiken über das Sperr- und Speicher-Teilsystem
          gehören.</p>
<p>Besuchen Sie für weitergehende Informationen zur
          Berkeley-Werkzeugsammlung den Dokumentationsabschnitt der
          Berkeley-DB-Abteilung auf der Seite von Oracle bei <a class="ulink" href="http://www.oracle.com/technology/documentation/berkeley-db/db/" target="_top">http://www.oracle.com/technology/documentation/berkeley-db/db/</a>.</p>
</div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.maint.setlog"></a>5.4.2. Berichtigung des Protokolleintrags</h3></div></div></div>
<p>Manchmal kommt es vor, dass ein Benutzer einen Fehler im
        Protokolleintrag gemacht hat (einen Tippfehler oder vielleicht
        eine Fehlinformation). Falls das Repository entsprechend
        eingestellt ist (indem der Hook
        <code class="literal">pre-revprop-change</code> verwendet wird; siehe
        <a class="xref" href="svn.reposadmin.html#svn.reposadmin.create.hooks" title="5.3.2. Erstellen von Repository-Hooks">Abschnitt 5.3.2, &#8222;Erstellen von Repository-Hooks&#8220;</a>), um Änderungen
        am Protokolleintrag vorzunehmen nachdem die Übergabe
        abgeschlossen ist, kann der Benutzer den Protokolleintrag aus
        der Ferne mit dem Befehl <span class="command"><strong>svn propset</strong></span> (siehe
        <a class="xref" href="svn.ref.svn.c.propset.html" title="svn propset">svn propset</a>)
        &#8222;<span class="quote">berichtigen</span>&#8220;.  Wegen der Möglichkeit, dadurch
        für immer Informationen zu verlieren, sind
        Subversion-Repositorys allerdings standardmäßig nicht so
        eingestellt, dass Änderungen an unversionierten Propertys
        erlaubt sind &#8211; außer für einen Administrator.</p>
<p>Falls ein Protokolleintrag durch einen Administrator
        geändert werden muss, kann das mit <span class="command"><strong>svnadmin
        setlog</strong></span> geschehen. Dieser Befehl ändert den
        Protokolleintrag (das Property <code class="literal">svn:log</code>)
        einer gegebenen Revision eines Repositorys, indem der neue
        Inhalt aus einer angegebenen Datei gelesen wird.</p>
<pre class="screen">
$ echo "Hier ist der neue, korrekte Protokolleintrag" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</pre>
<p>Auch der Befehl <span class="command"><strong>svnadmin setlog</strong></span> ist
        standardmäßig durch dieselben Schutzmechanismen gegen die
        Veränderung unversionierter Propertys eingeschränkt wie ein
        Client aus der Ferne &#8211; die Hooks <code class="literal">pre-</code>
        und <code class="literal">post-revprop-change</code> werden immer noch
        ausgelöst und müssen entsprechend eingestellt werden, um
        solche Änderungen zuzulassen. Allerdings kann ein
        Administrator diese Schutzmechanismen umgehen, indem er die
        Option <code class="option">--bypass-hooks</code> an den Befehl
        <span class="command"><strong>svnadmin setlog</strong></span> übergibt.</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warnung]" src="images/warning.png"></td>
<th align="left">Warnung</th>
</tr>
<tr><td align="left" valign="top"><p>Denken Sie trotzdem daran, dass beim Umgehen der Hooks
          auch Dinge umgangen werden wie E-Mail-Benachrichtigungen bei
          Property-Änderungen, Sicherungssysteme, die Änderungen an
          unversionierten Propertys verfolgen, usw. Mit anderen
          Worten: Seien Sie sehr vorsichtig bei der Auswahl dessen,
          was Sie ändern und wie Sie es ändern.</p></td></tr>
</table></div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.maint.diskspace"></a>5.4.3. Plattenplatzverwaltung</h3></div></div></div>
<p>Obwohl die Kosten für Speicherplatz in den letzten Jahren
        unglaublich gefallen sind, ist Plattenplatz immer noch ein
        berechtigtes Anliegen für Administratoren, die große Mengen
        von Daten zu versionieren haben. Jedes im aktiven Repository
        gespeicherte Bisschen Information über die Versionshistorie
        muss zu einem anderen Ort gesichert werden; vielleicht sogar
        öfter, falls eine zyklische Sicherungsstrategie angewendet
        wird. Es ist zweckdienlich zu wissen, welche Teile von
        Subversions Repository am Ort verbleiben müssen, welche
        gesichert werden müssen und welche ruhig entfernt werden
        können.</p>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.reposadmin.maint.diskspace.deltas"></a>5.4.3.1. Wie Subversion Plattenplatz spart</h4></div></div></div>
<p>Um das Repository klein zu halten, verwendet Subversion
          innerhalb des Repositorys
          <em class="firstterm">Delta-Kodierung</em> (oder
          Deltaspeicherung). Unter Delta-Kodierung wird die Kodierung
          eines Datensatzes als eine Sammlung von Unterschieden
          gegenüber einem anderen Datensatz verstanden. Falls die
          beiden Datensätze sehr ähnlich sind, bewirkt diese
          Delta-Kodierung eine Einsparung an Speicherplatz für den als
          Delta gespeicherten Datensatz &#8211; anstatt den
          Platz der Originaldaten zu belegen, wird hierbei nur soviel
          Platz benötigt, um zu sagen: &#8222;<span class="quote">Schau mal, ich sehe
          genau so aus, wie der andere Datensatz da drüben, bis auf
          die folgenden paar Änderungen.</span>&#8220; Das Ergebnis ist,
          dass die meisten der Daten im Repository, die normalerweise
          recht voluminös sind &#8211; nämlich der Inhalt
          versionierter Dateien &#8211; in einer viel geringeren Größe
          gespeichert werden als der ursprüngliche Volltext dieser
          Daten. Und für Repositorys, die mit Subversion 1.4 oder
          später angelegt wurden, ist die Platzersparnis sogar noch
          besser &#8211; jetzt sind die Volltexte der Dateiinhalte
          selbst komprimiert.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">Anmerkung</th>
</tr>
<tr><td align="left" valign="top"><p>Da alle delta-kodierten Daten in einem BDB-basierten
            Repository in einer einzigen Berkeley-DB-Datenbankdatei
            gespeichert werden, wird die verringerte Größe der
            gespeicherten Werte nicht unmittelbar die Größe der
            Datenbankdatei verringern. Berkeley DB führt jedoch intern
            Buch über unbenutzte Bereiche der Datenbankdatei und wird
            zunächst jene aufbrauchen, bevor die Datenbankdatei selbst
            vergrößert wird. Während Delta-Kodierung also nicht
            unmittelbare Platzersparnis bringt, kann sie jedoch das
            künftige Wachstum der Datenbank drastisch
            verlangsamen.</p></td></tr>
</table></div>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.reposadmin.maint.diskspace.deadtxns"></a>5.4.3.2. Entfernen unvollendeter Transaktionen</h4></div></div></div>
<p>Obwohl es selten vorkommt, gibt es Umstände, unter denen
          der Übergabeprozess mit einem Fehler abbricht und die Reste
          einer Revision in Spe  hinterlässt &#8211; eine unvollendete
          Transaktion samt aller Datei- und Verzeichnisänderungen, die
          dazugehören. Dies kann aus verschiedenen Gründen passieren:
          Vielleicht wurde die Operation des Clients vom Benutzer
          unsauber beendet oder es trat mittendrin ein Netzfehler auf.
          Aus welchem Grund auch immer, es können unvollendete
          Transaktionen auftreten. Sie verursachen keine tatsächlichen
          Schäden, außer Plattenplatz zu verschwenden. Ein penibler
          Administrator möchte sie vielleicht dennoch
          entfernen.</p>
<p>Sie können den Befehl <span class="command"><strong>svnadmin lstxns</strong></span>
          verwenden, um die Namen der aktuell ausstehenden
          Transaktionen anzuzeigen:</p>
<pre class="screen">
$ svnadmin lstxns myrepos
19
3a1
a45
$
</pre>
<p>Jeder Eintrag der Ausgabe kann dann mit dem Befehl
          <span class="command"><strong>svnlook</strong></span> (und seiner Option
          <code class="option">--transaction</code> (<code class="option">-t</code>))
          aufgerufen werden, um festzustellen, wer die Transaktion
          erzeugt hat, wann sie erzeugt wurde und welche Änderungen
          sie beinhaltet &#8211; Informationen, die bei der
          Entscheidung helfen können, ob eine Transaktion ein sicherer
          Kandidat zum Löschen ist! Wenn Sie tatsächlich eine
          Transaktion löschen wollen, kann deren Name an den Befehl
          <span class="command"><strong>svnadmin rmtxns</strong></span> übergeben werden, der
          dann die Transaktion aufräumt. <span class="command"><strong>svnadmin
          rmtxns</strong></span> kann seine Eingabe auch direkt aus der
          Ausgabe von <span class="command"><strong>svnadmin lstxns</strong></span>
          beziehen!</p>
<pre class="screen">
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</pre>
<p>Falls Sie auf diese Weise diese beiden Unterbefehle
          verwenden, sollten Sie vorübergehend das Repository für
          Clients unzugänglich machen. So kann niemand eine
          berechtigte Transaktion beginnen, bevor Sie aufgeräumt
          haben.  <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.diskspace.deadtxns.ex-1" title="Beispiel 5.1. txn-info.sh (ausstehende Transaktionen anzeigen)">Beispiel 5.1, &#8222;txn-info.sh (ausstehende Transaktionen anzeigen)&#8220;</a>
          enthält ein kleines Shell-Script, das schnell eine Übersicht
          über jede ausstehende Transaktion in Ihrem Repository
          erzeugen kann.</p>
<div class="example">
<a name="svn.reposadmin.maint.diskspace.deadtxns.ex-1"></a><p class="title"><b>Beispiel 5.1. txn-info.sh (ausstehende Transaktionen anzeigen)</b></p>
<div class="example-contents"><pre class="programlisting">
#!/bin/sh

### Erzeuge Informationen über alle ausstehenden Transaktionen eines
### Subversion Repositorys.

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "Aufruf: $0 REPOS_PATH"
  exit
fi

for TXN in `svnadmin lstxns ${REPOS}`; do 
  echo "---[ Transaktion ${TXN} ]-------------------------------------------"
  svnlook info "${REPOS}" -t "${TXN}"
done
</pre></div>
</div>
<br class="example-break"><p>Die Ausgabe des Scriptes ist im Grunde genommen eine
          Aneinanderreihung mehrerer Teile von <span class="command"><strong>svnlook
          info</strong></span>-Ausgaben (siehe <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.tk.svnlook" title="5.4.1.2. svnlook">Abschnitt 5.4.1.2, &#8222;svnlook&#8220;</a>) und sieht etwa
          so aus:</p>
<pre class="screen">
$ txn-info.sh myrepos
---[ Transaktion 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaktion 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Versuch, über eine schlechte Netzverbindung abzuliefern.
---[ Transaktion a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</pre>
<p>Eine vor langer Zeit aufgegebene Transaktion bedeutet
          normalerweise eine Art fehlgeschlagenen oder unterbrochenen
          Übergabeversuch. Der Zeitstempel einer Transaktion kann eine
          interessante Information sein &#8211; ist es beispielsweise
          wahrscheinlich, dass eine vor neun Monaten begonnene
          Operation immer noch aktiv ist?</p>
<p>Kurz gesagt, Entscheidungen zur Bereinigung von
          Transaktionen sollten klug getroffen werden. Verschiedene
          Informationsquellen &#8211; hierzu gehören die Fehler- und
          Zugriffsprotokolldateien von Apache, die operativen
          Protokolldateien von Subversion, die Revisions-Historie von
          Subversion usw. &#8211; können während des
          Entscheidungsprozesses hinzugezogen werden. Natürlich kann
          sich ein Administrator auch einfach  mit dem Eigentümer
          einer anscheinend abgebrochenen Transaktion in Verbindung
          setzen (z.B. per E-Mail), um sicherzustellen, dass die
          Transaktion sich tatsächlich in einem Zombiezustand
          befindet.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.reposadmin.maint.diskspace.bdblogs"></a>5.4.3.3. Entfernen unbenutzter Protokolldateien von Berkeley DB</h4></div></div></div>
<p>Bis vor kurzer Zeit waren die größten
          Plattenplatzfresser bei BDB-basierten Subversion-Repositorys
          die Protokolldateien, in die Berkeley DB zunächst alle
          Schritte hineinschreibt, bevor es die eigentlichen
          Datenbankdateien verändert. Diese Dateien halten alle
          Aktionen der Datenbank auf dem Weg von einem Zustand zum
          nächsten fest &#8211; während die Datenbankdateien zu jeder
          Zeit einen bestimmten Zustand widerspiegeln, beinhalten die
          Protokolldateien all die vielen Änderungen auf dem Weg
          <span class="emphasis"><em>zwischen</em></span> den Zuständen. Somit können
          sie sehr schnell wachsen und sich anhäufen.</p>
<p>Glücklicherweise hat die Datenbankumgebung beginnend mit
          der Version 4.2 der Berkeley DB die Fähigkeit, ihre eigenen
          unbenutzten Protokolldateien automatisch zu entfernen. Alle
          Repositorys, die mit einem <span class="command"><strong>svnadmin</strong></span>
          angelegt wurden, das mit Berkeley DB Version 4.2 oder später
          übersetzt wurde, werden mit automatischer
          Protokolldateientfernung konfiguriert. Wenn Sie diese
          Funktion nicht möchten, geben Sie dem Befehl
          <span class="command"><strong>svnadmin create</strong></span> einfach die Option
          <code class="option">--bdb-log-keep</code> mit. Sollten Sie das
          vergessen oder es sich später anders überlegen, editieren
          Sie einfach die Datei <code class="filename">DB_CONFIG</code> im
          Verzeichnis <code class="filename">db</code> Ihres Repositorys indem
          Sie die Zeile mit der Direktive <code class="literal">set_flags
          DB_LOG_AUTOREMOVE</code> auskommentieren und starten dann
          <span class="command"><strong>svnadmin recover</strong></span> auf Ihrem Repository, um
          die Konfigurationsänderung zu aktivieren.  Siehe <a class="xref" href="svn.reposadmin.html#svn.reposadmin.create.bdb" title="5.3.3. Konfiguration von Berkeley DB">Abschnitt 5.3.3, &#8222;Konfiguration von Berkeley DB&#8220;</a> für weitere
          Informationen zur Datenbankkonfiguration.</p>
<p>Ohne eine Art automatische Protokolldateientfernung
          aktiviert zu haben, häufen sich die Protokolldateien während
          der Nutzung des Repositorys an. Es ist eigentlich ein
          Merkmal des Datenbanksystems &#8211; Sie sollten
          ausschließlich  mit Hilfe der Protokolldateien in der Lage
          sein, Ihre gesamte Datenbank zu rekonstruieren, so dass
          diese Protokolldateien sehr nützlich für eine
          Wiederherstellung im Katastrophenfall sein können. Jedoch
          möchten Sie normalerweise die nicht mehr von Berkeley DB
          verwendeten Protokolldateien archivieren und sie zur
          Platzersparnis von der Platte entfernen. Verwenden Sie den
          Befehl <span class="command"><strong>svnadmin list-unused-dblogs</strong></span>, um
          die unbenutzten Protokolldateien anzuzeigen:</p>
<pre class="screen">
$ svnadmin list-unused-dblogs /var/svn/repos
/var/svn/repos/log.0000000031
/var/svn/repos/log.0000000032
/var/svn/repos/log.0000000033
&#8230;
$ rm `svnadmin list-unused-dblogs /var/svn/repos`
## Pattenplatz zurückgewonnen!
</pre>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warnung]" src="images/warning.png"></td>
<th align="left">Warnung</th>
</tr>
<tr><td align="left" valign="top"><p>BDB-basierte Repositorys, deren Protokolldateien ein
            Bestandteil eines Sicherungs- oder Notfallplans sind,
            sollten <span class="emphasis"><em>nicht</em></span> die automatische
            Entfernung verwenden. Die Wiederherstellung der Daten
            eines Repositorys kann nur gewährleistet werden, wenn
            <span class="emphasis"><em>alle</em></span> Protokolldateien verfügbar sind.
            Falls einige der Protokolldateien von der Platte entfernt
            werden, bevor das Sicherungssystem die Gelegenheit
            bekommt, sie woandershin zu kopieren, ist die
            unvollständige Menge gesicherter Protokolldateien
            tatsächlich nutzlos.</p></td></tr>
</table></div>
</div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.maint.recovery"></a>5.4.4. Berkeley DB Recovery</h3></div></div></div>
<p>As mentioned in <a class="xref" href="svn.reposadmin.html#svn.reposadmin.basics.backends.bdb" title="5.2.3.1. Berkeley DB">Abschnitt 5.2.3.1, &#8222;Berkeley DB&#8220;</a>, a Berkeley DB
        repository can sometimes be left in a frozen state if not closed
        properly.  When this happens, an administrator needs to rewind
        the database back into a consistent state.  This is unique to
        BDB-backed repositories, though&#8212;if you are using
        FSFS-backed ones instead, this won't apply to you.  And for
        those of you using Subversion 1.4 with Berkeley DB 4.4 or
        later, you should find that Subversion has become much more
        resilient in these types of situations.  Still, wedged
        Berkeley DB repositories do occur, and an administrator needs
        to know how to safely deal with this circumstance.</p>
<p>To protect the data in your repository, Berkeley
        DB uses a locking mechanism.  This mechanism ensures that
        portions of the database are not simultaneously modified by
        multiple database accessors, and that each process sees the
        data in the correct state when that data is being read from
        the database.  When a process needs to change something in the
        database, it first checks for the existence of a lock on the
        target data.  If the data is not locked, the process locks the
        data, makes the change it wants to make, and then unlocks the
        data.  Other processes are forced to wait until that lock is
        removed before they are permitted to continue accessing that
        section of the database.  (This has nothing to do with the
        locks that you, as a user, can apply to versioned files within
        the repository; we try to clear up the confusion caused by
        this terminology collision in the sidebar <a class="xref" href="svn.advanced.html#svn.advanced.locking.meanings" title="The Three Meanings of &#8222;Lock&#8220;">The Three Meanings of &#8222;<span class="quote">Lock</span>&#8220;</a>.)</p>
<p>In the course of using your Subversion repository, fatal
        errors or interruptions can prevent a process from having the
        chance to remove the locks it has placed in the database.  The
        result is that the backend database system gets
        &#8222;<span class="quote">wedged.</span>&#8220;  When this happens, any attempts to
        access the repository hang indefinitely (since each new
        accessor is waiting for a lock to go away&#8212;which isn't
        going to happen).</p>
<p>If this happens to your repository, don't panic.  The
        Berkeley DB filesystem takes advantage of database
        transactions, checkpoints, and prewrite journaling to
        ensure that only the most catastrophic of events
        <sup>[<a name="id396907" href="#ftn.id396907" class="footnote">32</a>]</sup>
        can permanently destroy a database environment.  A
        sufficiently paranoid repository administrator will have made
        off-site backups of the repository data in some fashion, but
        don't head off to the tape backup storage closet just yet.</p>
<p>Instead, use the following recipe to attempt to
        &#8222;<span class="quote">unwedge</span>&#8220; your repository:</p>
<div class="orderedlist"><ol type="1">
<li><p>Make sure no processes are accessing (or
            attempting to access) the repository.  For networked
            repositories, this also means shutting down the Apache HTTP
            Server or svnserve daemon.</p></li>
<li><p>Become the user who owns and manages the repository.
            This is important, as recovering a repository while
            running as the wrong user can tweak the permissions of the
            repository's files in such a way that your repository will
            still be inaccessible even after it is 
            &#8222;<span class="quote">unwedged.</span>&#8220;</p></li>
<li>
<p>Run the command <strong class="userinput"><code>svnadmin recover
            /var/svn/repos</code></strong>.  You should see output such as
            this:</p>
<pre class="screen">
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</pre>
<p>This command may take many minutes to complete.</p>
</li>
<li><p>Restart the server process.</p></li>
</ol></div>
<p>This procedure fixes almost every case of repository
        wedging.  Make sure that you run this command as the user that
        owns and manages the database, not just as
        <code class="literal">root</code>.  Part of the recovery process might
        involve re-creating from scratch various database files (shared
        memory regions, e.g.).  Recovering as
        <code class="literal">root</code> will create those files such that they
        are owned by <code class="literal">root</code>, which means that even
        after you restore connectivity to your repository, regular
        users will be unable to access it.</p>
<p>If the previous procedure, for some reason, does not
        successfully unwedge your repository, you should do two
        things.  First, move your broken repository directory aside
        (perhaps by renaming it to something like
        <code class="filename">repos.BROKEN</code>) and then restore your
        latest backup of it.  Then, send an email to the Subversion
        users mailing list (at <code class="email">&lt;<a class="email" href="mailto:users@subversion.tigris.org">users@subversion.tigris.org</a>&gt;</code>)
        describing your problem in detail.  Data integrity is an
        extremely high priority to the Subversion developers.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.maint.migrate"></a>5.4.5. Migrating Repository Data Elsewhere</h3></div></div></div>
<p>A Subversion filesystem has its data spread throughout
        files in the repository, in a fashion generally
        understood by (and of interest to) only the Subversion
        developers themselves.  However, circumstances may arise that
        call for all, or some subset, of that data to be copied or
        moved into another repository.</p>
<p>Subversion provides such functionality by way of
        <em class="firstterm">repository dump streams</em>.  A repository
        dump stream (often referred to as a &#8222;<span class="quote">dump file</span>&#8220;
        when stored as a file on disk) is a portable, flat file format
        that describes the various revisions in your
        repository&#8212;what was changed, by whom, when, and so on.
        This dump stream is the primary mechanism used to marshal
        versioned history&#8212;in whole or in part, with or without
        modification&#8212;between repositories.  And Subversion
        provides the tools necessary for creating and loading these
        dump streams: the <span class="command"><strong>svnadmin dump</strong></span> and
        <span class="command"><strong>svnadmin load</strong></span> subcommands,
        respectively.</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warnung]" src="images/warning.png"></td>
<th align="left">Warnung</th>
</tr>
<tr><td align="left" valign="top"><p>While the Subversion repository dump format contains
          human-readable portions and a familiar structure (it
          resembles an RFC 822 format, the same type of format used
          for most email), it is <span class="emphasis"><em>not</em></span> a plain-text
          file format.  It is a binary file format, highly sensitive
          to meddling.  For example, many text editors will corrupt
          the file by automatically converting line endings.</p></td></tr>
</table></div>
<p>There are many reasons for dumping and loading Subversion
        repository data.  Early in Subversion's life, the most common
        reason was due to the evolution of Subversion itself.  As
        Subversion matured, there were times when changes made to the
        backend database schema caused compatibility issues with
        previous versions of the repository, so users had to dump
        their repository data using the previous version of
        Subversion and load it into a freshly created repository with
        the new version of Subversion.  Now, these types of schema
        changes haven't occurred since Subversion's 1.0 release, and
        the Subversion developers promise not to force users to dump
        and load their repositories when upgrading between minor
        versions (such as from 1.3 to 1.4) of Subversion.  But there
        are still other reasons for dumping and loading, including
        re-deploying a Berkeley DB repository on a new OS or CPU
        architecture, switching between the Berkeley DB and FSFS
        backends, or (as we'll cover later in this chapter in <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.filtering" title="5.4.6. Filtering Repository History">Abschnitt 5.4.6, &#8222;Filtering Repository History&#8220;</a>) purging versioned
        data from repository history.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">Anmerkung</th>
</tr>
<tr><td align="left" valign="top"><p>The Subversion repository dump format describes
          versioned repository changes only.  It will not carry any
          information about uncommitted transactions, user locks on
          filesystem paths, repository or server configuration
          customizations (including hook scripts), and so on.</p></td></tr>
</table></div>
<p>Whatever your reason for migrating repository history,
        using the <span class="command"><strong>svnadmin dump</strong></span> and
        <span class="command"><strong>svnadmin load</strong></span> subcommands is
        straightforward.  <span class="command"><strong>svnadmin dump</strong></span> will output
        a range of repository revisions that are formatted using
        Subversion's custom filesystem dump format.  The dump format
        is printed to the standard output stream, while informative
        messages are printed to the standard error stream.  This
        allows you to redirect the output stream to a file while
        watching the status output in your terminal window.  For
        example:</p>
<pre class="screen">
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&#8230;
* Dumped revision 25.
* Dumped revision 26.
</pre>
<p>At the end of the process, you will have a single file
        (<code class="filename">dumpfile</code> in the previous example) that
        contains all the data stored in your repository in the
        requested range of revisions.  Note that <span class="command"><strong>svnadmin
        dump</strong></span> is reading revision trees from the repository
        just like any other &#8222;<span class="quote">reader</span>&#8220; process would
        (e.g., <span class="command"><strong>svn checkout</strong></span>), so it's safe
        to run this command at any time.</p>
<p>The other subcommand in the pair, <span class="command"><strong>svnadmin
        load</strong></span>, parses the standard input stream as a
        Subversion repository dump file and effectively replays those
        dumped revisions into the target repository for that
        operation.  It also gives informative feedback, this time
        using the standard output stream:</p>
<pre class="screen">
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &#8230;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&#8230;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</pre>
<p>The result of a load is new revisions added to a
        repository&#8212;the same thing you get by making commits
        against that repository from a regular Subversion client.
        Just as in a commit, you can use hook programs to perform
        actions before and after each of the commits made during a
        load process.  By passing the
        <code class="option">--use-pre-commit-hook</code> and
        <code class="option">--use-post-commit-hook</code> options to
        <span class="command"><strong>svnadmin load</strong></span>, you can instruct Subversion
        to execute the pre-commit and post-commit hook programs,
        respectively, for each loaded revision.  You might use these,
        for example, to ensure that loaded revisions pass through the
        same validation steps that regular commits pass through.  Of
        course, you should use these options with care&#8212;if your
        post-commit hook sends emails to a mailing list for each new
        commit, you might not want to spew hundreds or thousands of
        commit emails in rapid succession at that list!  You can read more about the use of hook
        scripts in <a class="xref" href="svn.reposadmin.html#svn.reposadmin.create.hooks" title="5.3.2. Erstellen von Repository-Hooks">Abschnitt 5.3.2, &#8222;Erstellen von Repository-Hooks&#8220;</a>.</p>
<p>Note that because <span class="command"><strong>svnadmin</strong></span> uses
        standard input and output streams for the repository dump and
        load processes, people who are feeling especially saucy can try
        things such as this (perhaps even using different versions of
        <span class="command"><strong>svnadmin</strong></span> on each side of the pipe):</p>
<pre class="screen">
$ svnadmin create newrepos
$ svnadmin dump oldrepos | svnadmin load newrepos
</pre>
<p>By default, the dump file will be quite large&#8212;much
        larger than the repository itself.  That's because by default
        every version of every file is expressed as a full text in the
        dump file.  This is the fastest and simplest behavior, and
        it's nice if you're piping the dump data directly into some other
        process (such as a compression program, filtering program, or
        loading process).  But if you're creating a dump file
        for longer-term storage, you'll likely want to save disk space
        by using the <code class="option">--deltas</code> option.  With this
        option, successive revisions of files will be output as
        compressed, binary differences&#8212;just as file revisions
        are stored in a repository.  This option is slower, but it
        results in a dump file much closer in size to the original
        repository.</p>
<p>We mentioned previously that <span class="command"><strong>svnadmin
        dump</strong></span> outputs a range of revisions.  Use the
        <code class="option">--revision</code> (<code class="option">-r</code>) option to
        specify a single revision, or a range of revisions, to dump.
        If you omit this option, all the existing repository revisions
        will be dumped.</p>
<pre class="screen">
$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile
</pre>
<p>As Subversion dumps each new revision, it outputs only
        enough information to allow a future loader to re-create that
        revision based on the previous one.  In other words, for any
        given revision in the dump file, only the items that were
        changed in that revision will appear in the dump.  The only
        exception to this rule is the first revision that is dumped
        with the current <span class="command"><strong>svnadmin dump</strong></span>
        command.</p>
<p>By default, Subversion will not express the first dumped
        revision as merely differences to be applied to the previous
        revision.  For one thing, there is no previous revision in the
        dump file!  And second, Subversion cannot know the state of
        the repository into which the dump data will be loaded (if it
        ever is).  To ensure that the output of each
        execution of <span class="command"><strong>svnadmin dump</strong></span> is
        self-sufficient, the first dumped revision is, by default, a
        full representation of every directory, file, and property in
        that revision of the repository.</p>
<p>However, you can change this default behavior.  If you add
        the <code class="option">--incremental</code> option when you dump your
        repository, <span class="command"><strong>svnadmin</strong></span> will compare the first
        dumped revision against the previous revision in the
        repository&#8212;the same way it treats every other revision that
        gets dumped.  It will then output the first revision exactly
        as it does the rest of the revisions in the dump
        range&#8212;mentioning only the changes that occurred in that
        revision.  The benefit of this is that you can create several
        small dump files that can be loaded in succession, instead of
        one large one, like so:</p>
<pre class="screen">
$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3
</pre>
<p>These dump files could be loaded into a new repository
        with the following command sequence:</p>
<pre class="screen">
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</pre>
<p>Another neat trick you can perform with this
        <code class="option">--incremental</code> option involves appending to an
        existing dump file a new range of dumped revisions.  For
        example, you might have a <code class="literal">post-commit</code> hook
        that simply appends the repository dump of the single revision
        that triggered the hook.  Or you might have a script that runs
        nightly to append dump file data for all the revisions that
        were added to the repository since the last time the script
        ran.  Used like this, <span class="command"><strong>svnadmin dump</strong></span> can be
        one way to back up changes to your repository over time in case
        of a system crash or some other catastrophic event.</p>
<p>The dump format can also be used to merge the contents of
        several different repositories into a single repository.  By
        using the <code class="option">--parent-dir</code> option of
        <span class="command"><strong>svnadmin load</strong></span>, you can specify a new
        virtual root directory for the load process.  That means if
        you have dump files for three repositories&#8212;say
        <code class="filename">calc-dumpfile</code>,
        <code class="filename">cal-dumpfile</code>, and
        <code class="filename">ss-dumpfile</code>&#8212;you can first create a new
        repository to hold them all:</p>
<pre class="screen">
$ svnadmin create /var/svn/projects
$
</pre>
<p>Then, make new directories in the repository that will
        encapsulate the contents of each of the three previous
        repositories:</p>
<pre class="screen">
$ svn mkdir -m "Initial project roots" \
      file:///var/svn/projects/calc \
      file:///var/svn/projects/calendar \
      file:///var/svn/projects/spreadsheet
Committed revision 1.
$ 
</pre>
<p>Lastly, load the individual dump files into their
        respective locations in the new repository:</p>
<pre class="screen">
$ svnadmin load /var/svn/projects --parent-dir calc &lt; calc-dumpfile
&#8230;
$ svnadmin load /var/svn/projects --parent-dir calendar &lt; cal-dumpfile
&#8230;
$ svnadmin load /var/svn/projects --parent-dir spreadsheet &lt; ss-dumpfile
&#8230;
$
</pre>
<p>We'll mention one final way to use the Subversion
        repository dump format&#8212;conversion from a different
        storage mechanism or version control system altogether.
        Because the dump file format is, for the most part,
        human-readable, it should be relatively easy to describe
        generic sets of changes&#8212;each of which should be treated
        as a new revision&#8212;using this file format.  In fact, the
        <span class="command"><strong>cvs2svn</strong></span> utility (see <a class="xref" href="svn.forcvs.html#svn.forcvs.convert" title="B.11. Converting a Repository from CVS to Subversion">Abschnitt B.11, &#8222;Converting a Repository from CVS to Subversion&#8220;</a>) uses the dump format to
        represent the contents of a CVS repository so that those
        contents can be copied into a Subversion repository.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.maint.filtering"></a>5.4.6. Filtering Repository History</h3></div></div></div>
<p>Since Subversion stores your versioned history using, at
        the very least, binary differencing algorithms and data
        compression (optionally in a completely opaque database
        system), attempting manual tweaks is unwise if not quite
        difficult, and at any rate strongly discouraged.  And once
        data has been stored in your repository, Subversion
        generally doesn't provide an easy way to remove that data.
        <sup>[<a name="id397513" href="#ftn.id397513" class="footnote">33</a>]</sup>
        But inevitably, there will be times when you would like to
        manipulate the history of your repository.  You might need
        to strip out all instances of a file that was accidentally
        added to the repository (and shouldn't be there for whatever
        reason).
        <sup>[<a name="id397523" href="#ftn.id397523" class="footnote">34</a>]</sup>
        Or, perhaps you have multiple projects sharing a
        single repository, and you decide to split them up into
        their own repositories.  To accomplish tasks such as these,
        administrators need a more manageable and malleable
        representation of the data in their repositories&#8212;the
        Subversion repository dump format.</p>
<p>As we described earlier in <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.migrate" title="5.4.5. Migrating Repository Data Elsewhere">Abschnitt 5.4.5, &#8222;Migrating Repository Data Elsewhere&#8220;</a>, the Subversion
        repository dump format is a human-readable representation of
        the changes that you've made to your versioned data over time.
        Use the <span class="command"><strong>svnadmin dump</strong></span> command to generate
        the dump data, and <span class="command"><strong>svnadmin load</strong></span> to
        populate a new repository with it.  The great thing about the
        human-readability aspect of the dump format is that, if you
        aren't careless about it, you can manually inspect and modify
        it.  Of course, the downside is that if you have three years'
        worth of repository activity encapsulated in what is likely to
        be a very large dump file, it could take you a long, long time
        to manually inspect and modify it.</p>
<p>That's where <span class="command"><strong>svndumpfilter</strong></span> becomes
        useful.  This program acts as a path-based filter for
        repository dump streams.  Simply give it either a list of
        paths you wish to keep or a list of paths you wish to not
        keep, and then pipe your repository dump data through this
        filter.  The result will be a modified stream of dump data
        that contains only the versioned paths you (explicitly or
        implicitly) requested.</p>
<p>Let's look at a realistic example of how you might use this
        program.  Earlier in this chapter (see <a class="xref" href="svn.reposadmin.html#svn.reposadmin.projects.chooselayout" title="5.2.1. Planung der Organisation Ihres Repositorys">Abschnitt 5.2.1, &#8222;Planung der Organisation Ihres Repositorys&#8220;</a>), we discussed the
        process of deciding how to choose a layout for the data in
        your repositories&#8212;using one repository per project or
        combining them, arranging stuff within your repository, and
        so on.  But sometimes after new revisions start flying in,
        you rethink your layout and would like to make some changes.
        A common change is the decision to move multiple projects
        that are sharing a single repository into separate
        repositories for each project.</p>
<p>Our imaginary repository contains three projects:
        <code class="literal">calc</code>, <code class="literal">calendar</code>, and
        <code class="literal">spreadsheet</code>.  They have been living
        side-by-side in a layout like this:</p>
<pre class="screen">
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</pre>
<p>To get these three projects into their own repositories,
        we first dump the whole repository:</p>
<pre class="screen">
$ svnadmin dump /var/svn/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&#8230;
$
</pre>
<p>Next, run that dump file through the filter, each time
        including only one of our top-level directories.  This results
        in three new dump files:</p>
<pre class="screen">
$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile
&#8230;
$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile
&#8230;
$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile
&#8230;
$
</pre>
<p>At this point, you have to make a decision.  Each of your
        dump files will create a valid repository, but will preserve
        the paths exactly as they were in the original repository.
        This means that even though you would have a repository solely
        for your <code class="literal">calc</code> project, that repository
        would still have a top-level directory named
        <code class="filename">calc</code>.  If you want your
        <code class="filename">trunk</code>, <code class="filename">tags</code>, and
        <code class="filename">branches</code> directories to live in the root
        of your repository, you might wish to edit your dump files,
        tweaking the <code class="literal">Node-path</code> and
        <code class="literal">Node-copyfrom-path</code> headers so that they no
        longer have that first <code class="filename">calc/</code> path
        component.  Also, you'll want to remove the section of dump
        data that creates the <code class="filename">calc</code> directory.  It
        will look something like the following:</p>
<pre class="screen">
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0
  
</pre>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warnung]" src="images/warning.png"></td>
<th align="left">Warnung</th>
</tr>
<tr><td align="left" valign="top"><p>If you do plan on manually editing the dump file to
          remove a top-level directory, make sure your editor is
          not set to automatically convert end-of-line characters to
          the native format (e.g., <code class="literal">\r\n</code> to
          <code class="literal">\n</code>), as the content will then not agree
          with the metadata.  This will render the dump file
          useless.</p></td></tr>
</table></div>
<p>All that remains now is to create your three new
        repositories, and load each dump file into the right
        repository, ignoring the UUID found in the dump stream:</p>
<pre class="screen">
$ svnadmin create calc
$ svnadmin load --ignore-uuid calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&#8230;
$ svnadmin create calendar
$ svnadmin load --ignore-uuid calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&#8230;
$ svnadmin create spreadsheet
$ svnadmin load --ignore-uuid spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&#8230;
$
</pre>
<p>Both of <span class="command"><strong>svndumpfilter</strong></span>'s subcommands
        accept options for deciding how to deal with
        &#8222;<span class="quote">empty</span>&#8220; revisions.  If a given revision
        contains only changes to paths that were filtered out, that
        now-empty revision could be considered uninteresting or even
        unwanted.  So to give the user control over what to do with
        those revisions, <span class="command"><strong>svndumpfilter</strong></span> provides
        the following command-line options:</p>
<div class="variablelist"><dl>
<dt><span class="term"><code class="option">--drop-empty-revs</code></span></dt>
<dd><p>Do not generate empty revisions at all&#8212;just
              omit them.</p></dd>
<dt><span class="term"><code class="option">--renumber-revs</code></span></dt>
<dd><p>If empty revisions are dropped (using the
              <code class="option">--drop-empty-revs</code> option), change the
              revision numbers of the remaining revisions so that
              there are no gaps in the numeric sequence.</p></dd>
<dt><span class="term"><code class="option">--preserve-revprops</code></span></dt>
<dd><p>If empty revisions are not dropped, preserve the
              revision properties (log message, author, date, custom
              properties, etc.) for those empty revisions.
              Otherwise, empty revisions will contain only the
              original datestamp, and a generated log message that
              indicates that this revision was emptied by
              <span class="command"><strong>svndumpfilter</strong></span>.</p></dd>
</dl></div>
<p>While <span class="command"><strong>svndumpfilter</strong></span> can be very
        useful and a huge timesaver, there are unfortunately a
        couple of gotchas.  First, this utility is overly sensitive
        to path semantics.  Pay attention to whether paths in your
        dump file are specified with or without leading slashes.
        You'll want to look at the <code class="literal">Node-path</code> and
        <code class="literal">Node-copyfrom-path</code> headers.</p>
<pre class="screen">
&#8230;
Node-path: spreadsheet/Makefile
&#8230;
</pre>
<p>If the paths have leading slashes, you should
        include leading slashes in the paths you pass to
        <span class="command"><strong>svndumpfilter include</strong></span> and
        <span class="command"><strong>svndumpfilter exclude</strong></span> (and if they don't,
        you shouldn't).  Further, if your dump file has an inconsistent
        usage of leading slashes for some reason,
        <sup>[<a name="id397895" href="#ftn.id397895" class="footnote">35</a>]</sup>
        you should probably normalize those paths so that they all
        have, or all lack, leading slashes.</p>
<p>Also, copied paths can give you some trouble.
        Subversion supports copy operations in the repository, where
        a new path is created by copying some already existing path.
        It is possible that at some point in the lifetime of your
        repository, you might have copied a file or directory from
        some location that <span class="command"><strong>svndumpfilter</strong></span> is
        excluding, to a location that it is including.  To
        make the dump data self-sufficient,
        <span class="command"><strong>svndumpfilter</strong></span> needs to still show the
        addition of the new path&#8212;including the contents of any
        files created by the copy&#8212;and not represent that
        addition as a copy from a source that won't exist in your
        filtered dump data stream.  But because the Subversion
        repository dump format shows only what was changed in each
        revision, the contents of the copy source might not be
        readily available.  If you suspect that you have any copies
        of this sort in your repository, you might want to rethink
        your set of included/excluded paths, perhaps including the
        paths that served as sources of your troublesome copy
        operations, too.</p>
<p>Finally, <span class="command"><strong>svndumpfilter</strong></span> takes path
        filtering quite literally.  If you are trying to copy the
        history of a project rooted at
        <code class="filename">trunk/my-project</code> and move it into a
        repository of its own, you would, of course, use the
        <span class="command"><strong>svndumpfilter include</strong></span> command to keep all
        the changes in and under
        <code class="filename">trunk/my-project</code>.  But the resultant
        dump file makes no assumptions about the repository into
        which you plan to load this data.  Specifically, the dump
        data might begin with the revision that added the
        <code class="filename">trunk/my-project</code> directory, but it will
        <span class="emphasis"><em>not</em></span> contain directives that would
        create the <code class="filename">trunk</code> directory itself
        (because <code class="filename">trunk</code> doesn't match the
        include filter).  You'll need to make sure that any
        directories that the new dump stream expects to exist
        actually do exist in the target repository before trying to
        load the stream into that repository.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.maint.replication"></a>5.4.7. Repository Replication</h3></div></div></div>
<p>There are several scenarios in which it is quite handy to
        have a Subversion repository whose version history is exactly
        the same as some other repository's.  Perhaps the most obvious
        one is the maintenance of a simple backup repository, used
        when the primary repository has become inaccessible due to a
        hardware failure, network outage, or other such annoyance.
        Other scenarios include deploying mirror repositories to
        distribute heavy Subversion load across multiple servers, use
        as a soft-upgrade mechanism, and so on.</p>
<p>As of version 1.4, Subversion provides a program for
        managing scenarios such as
        these&#8212;<span class="command"><strong>svnsync</strong></span>.  This works by
        essentially asking the Subversion server to
        &#8222;<span class="quote">replay</span>&#8220; revisions, one at a time.  It then uses
        that revision information to mimic a commit of the same to
        another repository.  Neither repository needs to be locally
        accessible to the machine on which <span class="command"><strong>svnsync</strong></span> is
        running&#8212;its parameters are repository URLs, and it does
        all its work through Subversion's Repository Access (RA)
        interfaces.  All it requires is read access to the source
        repository and read/write access to the destination
        repository.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">Anmerkung</th>
</tr>
<tr><td align="left" valign="top"><p>When using <span class="command"><strong>svnsync</strong></span> against a remote
          source repository, the Subversion server for that repository
          must be running Subversion version 1.4 or later.</p></td></tr>
</table></div>
<p>Assuming you already have a source repository that you'd
        like to mirror, the next thing you need is an empty target
        repository that will actually serve as that mirror.  This
        target repository can use either of the available filesystem
        data-store backends (see <a class="xref" href="svn.reposadmin.html#svn.reposadmin.basics.backends" title="5.2.3. Auswahl der Datenspeicherung">Abschnitt 5.2.3, &#8222;Auswahl der Datenspeicherung&#8220;</a>), but it must not
        yet have any version history in it.  The protocol that
        <span class="command"><strong>svnsync</strong></span> uses to communicate revision information
        is highly sensitive to mismatches between the versioned
        histories contained in the source and target repositories.
        For this reason, while <span class="command"><strong>svnsync</strong></span> cannot
        <span class="emphasis"><em>demand</em></span> that the target repository be
        read-only,
        <sup>[<a name="id398094" href="#ftn.id398094" class="footnote">36</a>]</sup>
        allowing the revision history in the target repository to
        change by any mechanism other than the mirroring process is a
        recipe for disaster.</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warnung]" src="images/warning.png"></td>
<th align="left">Warnung</th>
</tr>
<tr><td align="left" valign="top"><p>Do <span class="emphasis"><em>not</em></span> modify a mirror repository
          in such a way as to cause its version history to deviate
          from that of the repository it mirrors.  The only commits
          and revision property modifications that ever occur on that
          mirror repository should be those performed by the
          <span class="command"><strong>svnsync</strong></span> tool.</p></td></tr>
</table></div>
<p>Another requirement of the target repository is that the
        <span class="command"><strong>svnsync</strong></span> process be allowed to modify
        revision properties.  Because <span class="command"><strong>svnsync</strong></span> works
        within the framework of that repository's hook system, the
        default state of the repository (which is to disallow revision
        property changes; see <a class="xref" href="svn.ref.reposhooks.pre-revprop-change.html" title="pre-revprop-change">pre-revprop-change</a>) is
        insufficient.  You'll need to explicitly implement the
        pre-revprop-change hook, and your script must allow
        <span class="command"><strong>svnsync</strong></span> to set and change revision
        properties.  With those provisions in place, you are ready to
        start mirroring repository revisions.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tipp]" src="images/tip.png"></td>
<th align="left">Tipp</th>
</tr>
<tr><td align="left" valign="top"><p>It's a good idea to implement authorization measures
          that allow your repository replication process to perform
          its tasks while preventing other users from modifying the
          contents of your mirror repository at all.</p></td></tr>
</table></div>
<p>Let's walk through the use of <span class="command"><strong>svnsync</strong></span>
        in a somewhat typical mirroring scenario.  We'll pepper this
        discourse with practical recommendations, which you are free to
        disregard if they aren't required by or suitable for your
        environment.</p>
<p>As a service to the fine developers of our favorite
        version control system, we will be mirroring the public
        Subversion source code repository and exposing that mirror
        publicly on the Internet, hosted on a different machine than
        the one on which the original Subversion source code
        repository lives.  This remote host has a global configuration
        that permits anonymous users to read the contents of
        repositories on the host, but requires users to authenticate
        to modify those repositories.  (Please forgive us for
        glossing over the details of Subversion server configuration
        for the moment&#8212;those are covered thoroughly in <a class="xref" href="svn.serverconfig.html" title="Kapitel 6. Die Administration eines Subversion-Servers">Kapitel 6, <i>Die Administration eines Subversion-Servers</i></a>.)  And for no other reason than
        that it makes for a more interesting example, we'll be driving
        the replication process from a third machine&#8212;the one that
        we currently find ourselves using.</p>
<p>First, we'll create the repository which will be our
        mirror.  This and the next couple of steps do require shell
        access to the machine on which the mirror repository will
        live.  Once the repository is all configured, though, we
        shouldn't need to touch it directly again.</p>
<pre class="screen">
$ ssh admin@svn.example.com \
      "svnadmin create /var/svn/svn-mirror"
admin@svn.example.com's password: ********
$
</pre>
<p>At this point, we have our repository, and due to our
        server's configuration, that repository is now
        &#8222;<span class="quote">live</span>&#8220; on the Internet.  Now, because we don't
        want anything modifying the repository except our replication
        process, we need a way to distinguish that process from other
        would-be committers.  To do so, we use a dedicated username
        for our process.  Only commits and revision property
        modifications performed by the special username
        <code class="literal">syncuser</code> will be allowed.</p>
<p>We'll use the repository's hook system both to allow the
        replication process to do what it needs to do and to enforce
        that only it is doing those things.  We accomplish this by
        implementing two of the repository event
        hooks&#8212;pre-revprop-change and start-commit.  Our
        <code class="filename">pre-revprop-change</code> hook script is found
        in <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.replication.pre-revprop-change" title="Beispiel 5.2. Mirror repository's pre-revprop-change hook script">Beispiel 5.2, &#8222;Mirror repository's pre-revprop-change hook script&#8220;</a>, and basically verifies that the user attempting the
        property changes is our <code class="literal">syncuser</code> user.  If
        so, the change is allowed; otherwise, it is denied.</p>
<div class="example">
<a name="svn.reposadmin.maint.replication.pre-revprop-change"></a><p class="title"><b>Beispiel 5.2. Mirror repository's pre-revprop-change hook script</b></p>
<div class="example-contents"><pre class="programlisting">
#!/bin/sh 

USER="$3"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may change revision properties" &gt;&amp;2
exit 1
</pre></div>
</div>
<br class="example-break"><p>That covers revision property changes.  Now we need to
        ensure that only the <code class="literal">syncuser</code> user is
        permitted to commit new revisions to the repository.  We do
        this using a <code class="filename">start-commit</code> hook scripts
        such as the one in <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.replication.start-commit" title="Beispiel 5.3. Mirror repository's start-commit hook script">Beispiel 5.3, &#8222;Mirror repository's start-commit hook script&#8220;</a>.</p>
<div class="example">
<a name="svn.reposadmin.maint.replication.start-commit"></a><p class="title"><b>Beispiel 5.3. Mirror repository's start-commit hook script</b></p>
<div class="example-contents"><pre class="programlisting">
#!/bin/sh 

USER="$2"

if [ "$USER" = "syncuser" ]; then exit 0; fi

echo "Only the syncuser user may commit new revisions" &gt;&amp;2
exit 1
</pre></div>
</div>
<br class="example-break"><p>After installing our hook scripts and ensuring that they
        are executable by the Subversion server, we're finished with
        the setup of the mirror repository.  Now, we get to actually
        do the mirroring.</p>
<p>The first thing we need to do with
        <span class="command"><strong>svnsync</strong></span> is to register in our target
        repository the fact that it will be a mirror of the source
        repository.  We do this using the <span class="command"><strong>svnsync
        initialize</strong></span> subcommand.  The URLs we provide point to
        the root directories of the target and source repositories,
        respectively.  In Subversion 1.4, this is required&#8212;only
        full mirroring of repositories is permitted.  In Subversion
        1.5, though, you can use <span class="command"><strong>svnsync</strong></span> to mirror
        only some subtree of the repository, too.</p>
<pre class="screen">
$ svnsync help init
initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL

Initialize a destination repository for synchronization from
another repository.
&#8230;
$ svnsync initialize http://svn.example.com/svn-mirror \
                     http://svn.collab.net/repos/svn \
                     --sync-username syncuser --sync-password syncpass
Copied properties for revision 0.
$
</pre>
<p>Our target repository will now remember that it is a
        mirror of the public Subversion source code repository.
        Notice that we provided a username and password as arguments
        to <span class="command"><strong>svnsync</strong></span>&#8212;that was required by the
        pre-revprop-change hook on our mirror repository.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">Anmerkung</th>
</tr>
<tr><td align="left" valign="top">
<p>In Subversion 1.4, the values given to
          <span class="command"><strong>svnsync</strong></span>'s <code class="option">--username</code> and
          <code class="option">--password</code> command-line options were used
          for authentication against both the source and destination
          repositories.  This caused problems when a user's
          credentials weren't exactly the same for both repositories,
          especially when running in noninteractive mode (with the
          <code class="option">--non-interactive</code> option).</p>
<p>This has been fixed in Subversion 1.5 with the
          introduction of two new pairs of options.  Use
          <code class="option">--source-username</code> and
          <code class="option">--source-password</code> to provide authentication
          credentials for the source repository; use
          <code class="option">--sync-username</code> and
          <code class="option">--sync-password</code> to provide credentials for
          the destination repository.  (The old
          <code class="option">--username</code> and <code class="option">--password</code>
          options still exist for compatibility, but we advise against
          using them.)</p>
</td></tr>
</table></div>
<p>And now comes the fun part.  With a single subcommand, we
        can tell <span class="command"><strong>svnsync</strong></span> to copy all the
        as-yet-unmirrored revisions from the source repository to the
        target.
        <sup>[<a name="id398445" href="#ftn.id398445" class="footnote">37</a>]</sup>
        The <span class="command"><strong>svnsync synchronize</strong></span> subcommand will
        peek into the special revision properties previously stored on
        the target repository, and determine both what repository it
        is mirroring as well as that the most recently mirrored
        revision was revision 0.  Then it will query the source
        repository and determine what the latest revision in that
        repository is.  Finally, it asks the source repository's
        server to start replaying all the revisions between 0 and that
        latest revision.  As <span class="command"><strong>svnsync</strong></span> get the
        resultant response from the source repository's server, it
        begins forwarding those revisions to the target repository's
        server as new commits.</p>
<pre class="screen">
$ svnsync help synchronize
synchronize (sync): usage: svnsync synchronize DEST_URL

Transfer all pending revisions to the destination from the source
with which it was initialized.
&#8230;
$ svnsync synchronize http://svn.example.com/svn-mirror
Transmitting file data ........................................
Committed revision 1.
Copied properties for revision 1.
Transmitting file data ..
Committed revision 2.
Copied properties for revision 2.
Transmitting file data .....
Committed revision 3.
Copied properties for revision 3.
&#8230;
Transmitting file data ..
Committed revision 23406.
Copied properties for revision 23406.
Transmitting file data .
Committed revision 23407.
Copied properties for revision 23407.
Transmitting file data ....
Committed revision 23408.
Copied properties for revision 23408.
$
</pre>
<p>Of particular interest here is that for each mirrored
        revision, there is first a commit of that revision to the
        target repository, and then property changes follow.  This is
        because the initial commit is performed by (and attributed to)
        the user <code class="literal">syncuser</code>, and it is datestamped
        with the time as of that revision's creation.  Also,
        Subversion's underlying repository access interfaces don't
        provide a mechanism for setting arbitrary revision properties
        as part of a commit.  So <span class="command"><strong>svnsync</strong></span> follows up
        with an immediate series of property modifications that copy
        into the target repository all the revision properties found
        for that revision in the source repository.  This also has the
        effect of fixing the author and datestamp of the revision to
        match that of the source repository.</p>
<p>Also noteworthy is that <span class="command"><strong>svnsync</strong></span>
        performs careful bookkeeping that allows it to be safely
        interrupted and restarted without ruining the integrity of the
        mirrored data.  If a network glitch occurs while mirroring a
        repository, simply repeat the <span class="command"><strong>svnsync
        synchronize</strong></span> command, and it will happily pick up
        right where it left off.  In fact, as new revisions appear in
        the source repository, this is exactly what you to do
        to keep your mirror up to date.</p>
<div class="sidebar">
<p class="title"><b>svnsync Bookkeeping</b></p>
<p><span class="command"><strong>svnsync</strong></span> needs to be able to set and
          modify revision properties on the mirror repository because
          those properties are part of the data it is tasked with
          mirroring.  As those properties change in the source
          repository, those changes need to be reflected in the mirror
          repository, too.  But <span class="command"><strong>svnsync</strong></span> also uses a
          set of custom revision properties&#8212;stored in revision 0
          of the mirror repository&#8212;for its own internal
          bookkeeping.  These properties contain information such as
          the URL and UUID of the source repository, plus some
          additional state-tracking information.</p>
<p>One of those pieces of state-tracking information is a
          flag that essentially just means &#8222;<span class="quote">there's a
          synchronization in progress right now.</span>&#8220;  This is used
          to prevent multiple <span class="command"><strong>svnsync</strong></span> processes
          from colliding with each other while trying to mirror data
          to the same destination repository.  Now, generally you
          won't need to pay any attention whatsoever to
          <span class="emphasis"><em>any</em></span> of these special properties (all of
          which begin with the prefix <code class="literal">svn:sync-</code>).
          Occasionally, though, if a synchronization fails
          unexpectedly, Subversion never has a chance to remove this
          particular state flag.  This causes all future
          synchronization attempts to fail because it appears that a
          synchronization is still in progress when, in fact, none is.
          Fortunately, recovering from this situation is as simple as
          removing the <code class="literal">svn:sync-lock</code> property which
          serves as this flag from revision 0 of the mirror
          repository:</p>
<pre class="screen">
$ svn propdel --revprop -r0 svn:sync-lock http://svn.example.com/svn-mirror
property 'svn:sync-lock' deleted from repository revision 0
$
</pre>
<p>That <span class="command"><strong>svnsync</strong></span> stores the source
          repository URL in a bookkeeping property on the mirror
          repository is the reason why you have to specify that
          URL only once, during <span class="command"><strong>svnsync init</strong></span>.  Future
          synchronization operations against that mirror simply
          consult the special <code class="literal">svn:sync-from-url</code>
          property stored on the mirror itself to know where
          to synchronize from.  This value is used literally by the
          synchronization process, though.  So while from within
          CollabNet's network you can perhaps access our example
          source URL as <code class="literal">http://svn/repos/svn</code>
          (because that first <code class="literal">svn</code> magically gets
          <code class="literal">.collab.net</code> appended to it by DNS
          voodoo), if you later need to update that mirror from
          another machine outside CollabNet's network, the
          synchronization might fail (because the hostname
          <code class="literal">svn</code> is ambiguous).  For this reason, it's
          best to use fully qualified source repository URLs when
          initializing a mirror repository rather than those that
          refer to only hostnames or IP addresses (which can change
          over time).  But here again, if you need an existing mirror
          to start referring to a different URL for the same source
          repository, you can change the bookkeeping property which
          houses that information:</p>
<pre class="screen">
$ svn propset --revprop -r0 svn:sync-from-url <em class="replaceable"><code>NEW-SOURCE-URL</code></em> \
      http://svn.example.com/svn-mirror
property 'svn:sync-from-url' set on repository revision 0
$
</pre>
<p>Another interesting thing about these special
          bookkeeping properties is that <span class="command"><strong>svnsync</strong></span>
          will not attempt to mirror any of those properties when they
          are found in the source repository.  The reason is probably
          obvious, but basically boils down to
          <span class="command"><strong>svnsync</strong></span> not being able to distinguish the
          special properties it has merely copied from the source
          repository from those it needs to consult and maintain for
          its own bookkeeping needs.  This situation could occur if,
          for example, you were maintaining a mirror of a mirror of a
          third repository.  When <span class="command"><strong>svnsync</strong></span> sees its
          own special properties in revision 0 of the source
          repository, it simply ignores them.</p>
</div>
<p>There is, however, one bit of inelegance in the process.
        Because Subversion revision properties can be changed at any
        time throughout the lifetime of the repository, and because
        they don't leave an audit trail that indicates when they were
        changed, replication processes have to pay special attention
        to them.  If you've already mirrored the first 15 revisions of
        a repository and someone then changes a revision property on
        revision 12, <span class="command"><strong>svnsync</strong></span> won't know to go back
        and patch up its copy of revision 12.  You'll need to tell it
        to do so manually by using (or with some additional tooling
        around) the <span class="command"><strong>svnsync copy-revprops</strong></span>
        subcommand, which simply rereplicates all the revision
        properties for a particular revision or range thereof.</p>
<pre class="screen">
$ svnsync help copy-revprops
copy-revprops: usage: svnsync copy-revprops DEST_URL [REV[:REV2]]

Copy the revision properties in a given range of revisions to the
destination from the source with which it was initialized.
&#8230;
$ svnsync copy-revprops http://svn.example.com/svn-mirror 12
Copied properties for revision 12.
$
</pre>
<p>That's repository replication in a nutshell.  You'll
        likely want some automation around such a process.  For
        example, while our example was a pull-and-push setup, you
        might wish to have your primary repository push changes to one
        or more blessed mirrors as part of its post-commit and
        post-revprop-change hook implementations.  This would enable
        the mirror to be up to date in as near to real time as is
        likely possible.</p>
<p>Also, while it isn't very commonplace to do so,
        <span class="command"><strong>svnsync</strong></span> does gracefully mirror repositories
        in which the user as whom it authenticates has only partial
        read access.  It simply copies only the bits of the repository
        that it is permitted to see.  Obviously, such a mirror is not
        useful as a backup solution.</p>
<p>In Subversion 1.5, <span class="command"><strong>svnsync</strong></span> grew the
        ability to also mirror a subset of a repository rather than
        the whole thing.  The process of setting up and maintaining
        such a mirror is exactly the same as when mirroring a whole
        repository, except that instead of specifying the source
        repository's root URL when running <span class="command"><strong>svnsync
        init</strong></span>, you specify the URL of some subdirectory
        within that repository.  Synchronization to that mirror will
        now copy only the bits that changed under that source
        repository subdirectory.  There are some limitations to this
        support, though.  First, you can't mirror multiple disjoint
        subdirectories of the source repository into a single mirror
        repository&#8212;you'd need to instead mirror some parent
        directory that is common to both.  Second, the filtering
        logic is entirely path-based, so if the subdirectory you are
        mirroring was renamed at some point in the past, your mirror
        would contain only the revisions since the directory appeared
        at the URL you specified.  And likewise, if the source
        subdirectory is renamed in the future, your synchronization
        processes will stop mirroring data at the point that the
        source URL you specified is no longer valid.</p>
<p>As far as user interaction with repositories and mirrors
        goes, it <span class="emphasis"><em>is</em></span> possible to have a single
        working copy that interacts with both, but you'll have to jump
        through some hoops to make it happen.  First, you need to
        ensure that both the primary and mirror repositories have the
        same repository UUID (which is not the case by default).  See
        <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.uuids" title="5.4.9. Managing Repository UUIDs">Abschnitt 5.4.9, &#8222;Managing Repository UUIDs&#8220;</a> later in this
        chapter for more about this.</p>
<p>Once the two repositories have the same UUID, you can use
        <span class="command"><strong>svn switch</strong></span> with the <code class="option">--relocate</code> option to point your working
        copy to whichever of the repositories you wish to operate
        against, a process that is described in <a class="xref" href="svn.ref.svn.c.switch.html" title="svn switch">svn switch</a>.  There is a possible danger
        here, though, in that if the primary and mirror repositories
        aren't in close synchronization, a working copy up to date
        with, and pointing to, the primary repository will, if
        relocated to point to an out-of-date mirror, become confused
        about the apparent sudden loss of revisions it fully expects
        to be present, and it will throw errors to that effect.  If
        this occurs, you can relocate your working copy back to the
        primary repository and then either wait until the mirror
        repository is up to date, or backdate your working copy to a
        revision you know is present in the sync repository, and then
        retry the relocation.</p>
<p>Finally, be aware that the revision-based replication
        provided by <span class="command"><strong>svnsync</strong></span> is only
        that&#8212;replication of revisions.  Only information carried
        by the Subversion repository dump file format is available for
        replication.  As such, <span class="command"><strong>svnsync</strong></span> has the same
        sorts of limitations that the repository dump stream has, and
        does not include such things as the hook implementations,
        repository or server configuration data, uncommitted
        transactions, or information about user locks on repository
        paths.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.maint.backup"></a>5.4.8. Repository Backup</h3></div></div></div>
<p>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&#8212;sometimes things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM, and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&#8212;how to make backup copies of your repository
        data.</p>
<p>There are two types of backup methods available for
        Subversion repository administrators&#8212;full and
        incremental.  A full backup of the repository involves
        squirreling away in one sweeping action all the information
        required to fully reconstruct that repository in the event of
        a catastrophe.  Usually, it means, quite literally, the
        duplication of the entire repository directory (which includes
        either a Berkeley DB or FSFS environment).  Incremental
        backups are lesser things:  backups of only the portion of the
        repository data that has changed since the previous
        backup.</p>
<p>As far as full backups go, the naïve approach might seem
        like a sane one, but unless you temporarily disable all other
        access to your repository, simply doing a recursive directory
        copy runs the risk of generating a faulty backup.  In the case
        of Berkeley DB, the documentation describes a certain order in
        which database files can be copied that will guarantee a valid
        backup copy.  A similar ordering exists for FSFS data.  But
        you don't have to implement these algorithms yourself, because
        the Subversion development team has already done so.  The
        <span class="command"><strong>svnadmin hotcopy</strong></span> command takes care of the
        minutia involved in making a hot backup of your repository.
        And its invocation is as trivial as the Unix
        <span class="command"><strong>cp</strong></span> or Windows <span class="command"><strong>copy</strong></span>
        operations:</p>
<pre class="screen">
$ svnadmin hotcopy /var/svn/repos /var/svn/repos-backup
</pre>
<p>The resultant backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</p>
<p>When making copies of a Berkeley DB repository, you can
        even instruct <span class="command"><strong>svnadmin hotcopy</strong></span> to purge any
        unused Berkeley DB logfiles (see <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.diskspace.bdblogs" title="5.4.3.3. Entfernen unbenutzter Protokolldateien von Berkeley DB">Abschnitt 5.4.3.3, &#8222;Entfernen unbenutzter Protokolldateien von Berkeley DB&#8220;</a>) from the
        original repository upon completion of the copy.  Simply
        provide the <code class="option">--clean-logs</code> option on the
        command line.</p>
<pre class="screen">
$ svnadmin hotcopy --clean-logs /var/svn/bdb-repos /var/svn/bdb-repos-backup
</pre>
<p>Additional tooling around this command is available, too.
        The <code class="filename">tools/backup/</code> directory of the
        Subversion source distribution holds the
        <span class="command"><strong>hot-backup.py</strong></span> script.  This script adds a
        bit of backup management atop <span class="command"><strong>svnadmin
        hotcopy</strong></span>, allowing you to keep only the most recent
        configured number of backups of each repository.  It will
        automatically manage the names of the backed-up repository
        directories to avoid collisions with previous backups and
        will &#8222;<span class="quote">rotate off</span>&#8220; older backups, deleting them so
        that only the most recent ones remain.  Even if you also have an
        incremental backup, you might want to run this program on a
        regular basis.  For example, you might consider using
        <span class="command"><strong>hot-backup.py</strong></span> from a program scheduler
        (such as <span class="command"><strong>cron</strong></span> on Unix systems), which can
        cause it to run nightly (or at whatever granularity of time
        you deem safe).</p>
<p>Some administrators use a different backup mechanism built
        around generating and storing repository dump data.  We
        described in <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.migrate" title="5.4.5. Migrating Repository Data Elsewhere">Abschnitt 5.4.5, &#8222;Migrating Repository Data Elsewhere&#8220;</a>
        how to use <span class="command"><strong>svnadmin dump</strong></span> with the <code class="option">--incremental</code> option to
        perform an incremental backup of a given revision or range of
        revisions.  And of course, you can achieve a full backup variation of
        this by omitting the <code class="option">--incremental</code>
        option to that command.  There is some value in these methods,
        in that the format of your backed-up information is
        flexible&#8212;it's not tied to a particular platform,
        versioned filesystem type, or release of Subversion or
        Berkeley DB.  But that flexibility comes at a cost, namely
        that restoring that data can take a long time&#8212;longer
        with each new revision committed to your repository.  Also, as
        is the case with so many of the various backup methods,
        revision property changes that are made to already backed-up
        revisions won't get picked up by a nonoverlapping,
        incremental dump generation.  For these reasons, we recommend
        against relying solely on dump-based backup approaches.</p>
<p>As you can see, each of the various backup types and
        methods has its advantages and disadvantages.  The easiest is
        by far the full hot backup, which will always result in a
        perfect working replica of your repository.  Should something
        bad happen to your live repository, you can restore from the
        backup with a simple recursive directory copy.  Unfortunately,
        if you are maintaining multiple backups of your repository,
        these full copies will each eat up just as much disk space as
        your live repository.  Incremental backups, by contrast, tend
        to be quicker to generate and smaller to store.  But the
        restoration process can be a pain, often involving applying
        multiple incremental backups.  And other methods have their
        own peculiarities.  Administrators need to find the balance
        between the cost of making the backup and the cost of
        restoring it.</p>
<p>The <span class="command"><strong>svnsync</strong></span> program (see <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.replication" title="5.4.7. Repository Replication">Abschnitt 5.4.7, &#8222;Repository Replication&#8220;</a>) actually
        provides a rather handy middle-ground approach.  If you are
        regularly synchronizing a read-only mirror with your main
        repository, in a pinch your read-only mirror is probably
        a good candidate for replacing that main repository if it
        falls over.  The primary disadvantage of this method is that
        only the versioned repository data gets
        synchronized&#8212;repository configuration files,
        user-specified repository path locks, and other items that
        might live in the physical repository directory but not
        <span class="emphasis"><em>inside</em></span> the repository's virtual versioned
        filesystem are not handled by <span class="command"><strong>svnsync</strong></span>.</p>
<p>In any backup scenario, repository administrators need
        to be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change hooks.
        <sup>[<a name="id399094" href="#ftn.id399094" class="footnote">38</a>]</sup>  
        And since you can change revision properties without respect
        to chronological order&#8212;you can change any revision's
        properties at any time&#8212;an incremental backup of the
        latest few revisions might not catch a property modification
        to a revision that was included as part of a previous 
        backup.</p>
<p>Generally speaking, only the truly paranoid would need to
        back up their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (such as per-commit emails or incremental dumps), a
        hot backup of the database might be something that a
        repository administrator would want to include as part of a
        system-wide nightly backup.  It's your data&#8212;protect it
        as much as you'd like.</p>
<p>Often, the best approach to repository backups is a
        diversified one that leverages combinations of the methods
        described here.  The Subversion developers, for example, back
        up the Subversion source code repository nightly using
        <span class="command"><strong>hot-backup.py</strong></span> and an off-site
        <span class="command"><strong>rsync</strong></span> of those full backups; keep multiple
        archives of all the commit and property change notification
        emails; and have repository mirrors maintained by various
        volunteers using <span class="command"><strong>svnsync</strong></span>.  Your solution
        might be similar, but should be catered to your needs and that
        delicate balance of convenience with paranoia.  And whatever
        you do, validate your backups from time to time&#8212;what
        good is a spare tire that has a hole in it?  While all of this
        might not save your hardware from the iron fist of Fate,
        <sup>[<a name="id399152" href="#ftn.id399152" class="footnote">39</a>]</sup>
        it should certainly help you recover from those trying 
        times.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.reposadmin.maint.uuids"></a>5.4.9. Managing Repository UUIDs</h3></div></div></div>
<p>Subversion repositories have a universally unique
        identifier (UUID) associated with them.  This is used by
        Subversion clients to verify the identity of a repository when
        other forms of verification aren't good enough (such as
        checking the repository URL, which can change over time).
        Most Subversion repository administrators rarely, if ever,
        need to think about repository UUIDs as anything more than a
        trivial implementation detail of Subversion.  Sometimes,
        however, there is cause for attention to this detail.</p>
<p>As a general rule, you want the UUIDs of your live
        repositories to be unique.  That is, after all, the point of
        having UUIDs.  But there are times when you want the
        repository UUIDs of two repositories to be exactly the same.
        For example, if you make a copy of a repository for backup
        purposes, you want the backup to be a perfect replica of the
        original so that, in the event that you have to restore that
        backup and replace the live repository, users don't suddenly
        see what looks like a different repository.  When dumping and
        loading repository history (as described earlier in <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.migrate" title="5.4.5. Migrating Repository Data Elsewhere">Abschnitt 5.4.5, &#8222;Migrating Repository Data Elsewhere&#8220;</a>), you get to decide
        whether to apply the UUID encapsulated in the data dump
        stream to the repository in which you are loading the data.  The
        particular circumstance will dictate the correct
        behavior.</p>
<p>There are a couple of ways to set (or reset) a
        repository's UUID, should you need to.  As of Subversion 1.5,
        this is as simple as using the <span class="command"><strong>svnadmin
        setuuid</strong></span> command.  If you provide this subcommand
        with an explicit UUID, it will validate that the UUID is
        well-formed and then set the repository UUID to that value.
        If you omit the UUID, a brand-new UUID will be generated for
        your repository.</p>
<pre class="screen">
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$ svnadmin setuuid /var/svn/repos   # generate a new UUID
$ svnlook uuid /var/svn/repos
3c3c38fe-acc0-11dc-acbc-1b37ff1c8e7c
$ svnadmin setuuid /var/svn/repos \
           cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec  # restore the old UUID
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</pre>
<p>For folks using versions of Subversion earlier than 1.5,
        these tasks are a little more complicated.  You can explicitly
        set a repository's UUID by piping a repository dump file stub
        that carries the new UUID specification through
        <strong class="userinput"><code>svnadmin load --force-uuid <em class="replaceable"><code>REPOS-PATH</code></em></code></strong>.</p>
<pre class="screen">
$ svnadmin load --force-uuid /var/svn/repos &lt;&lt;EOF
SVN-fs-dump-format-version: 2

UUID: cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
EOF
$ svnlook uuid /var/svn/repos
cf2b9d22-acb5-11dc-bc8c-05e83ce5dbec
$
</pre>
<p>Having older versions of Subversion generate a brand-new
        UUID is not quite as simple to do, though.  Your best bet here
        is to find some other way to generate a UUID, and then
        explicitly set the repository's UUID to that value.</p>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.reposadmin.maint.moving-and-removing"></a>5.5. Moving and Removing Repositories</h2></div></div></div>
<p>Subversion repository data is wholly contained within the
      repository directory.  As such, you can move a Subversion
      repository to some other location on disk, rename a repository,
      copy a repository, or delete a repository altogether using the
      tools provided by your operating system for manipulating
      directories&#8212;<span class="command"><strong>mv</strong></span>, <span class="command"><strong>cp
      -a</strong></span>, and <span class="command"><strong>rm -r</strong></span> on Unix platforms;
      <span class="command"><strong>copy</strong></span>, <span class="command"><strong>move</strong></span>, and
      <span class="command"><strong>rmdir /s /q</strong></span> on Windows; vast numbers of mouse
      and menu gyrations in various graphical file explorer
      applications, and so on.</p>
<p>Of course, there's often still more to be done when trying
      to cleanly affect changes such as this.  For example, you might
      need to update your Subversion server configuration to point to
      the new location of a relocated repository or to remove
      configuration bits for a now-deleted repository.  If you have
      automated processes that publish information from or about your
      repositories, they may need to be updated.  Hook scripts might
      need to be reconfigured.  Users may need to be notified.  The list
      can go on indefinitely, or at least to the extent that you've
      built processes and procedures around your Subversion
      repository.</p>
<p>In the case of a copied repository, you should also consider
      the fact that Subversion uses repository UUIDs to distinguish
      repositories.  If you copy a Subversion repository using a
      typical shell recursive copy command, you'll wind up with two
      repositories that are identical in every way&#8212;including their UUIDs.
      In some circumstances, this might be desirable.  But in the
      instances where it is not, you'll need to generate a new UUID
      for one of these identical repositories.  See <a class="xref" href="svn.reposadmin.html#svn.reposadmin.maint.uuids" title="5.4.9. Managing Repository UUIDs">Abschnitt 5.4.9, &#8222;Managing Repository UUIDs&#8220;</a> for more about managing
      repository UUIDs.</p>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.reposadmin.summary"></a>5.6. Summary</h2></div></div></div>
<p>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we noted common
      administration pitfalls and offered suggestions for avoiding
      them.</p>
<p>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</p>
</div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.id392720" href="#id392720" class="para">26</a>] </sup>Das hört sich vielleicht prestigeträchtig und hochmütig
        an, doch wir meinen lediglich jeden, der an diesem mysteriösen
        Bereich hinter der Arbeitskopie interessiert ist, wo sich alle
        Daten befinden.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id393188" href="#id393188" class="para">27</a>] </sup>Ob es an Ignoranz oder an schlecht überlegten
            Konzepten zur Erstellung berechtigter Metriken für die
            Software-Entwicklung liegt,  ist es dumm, Angst vor
            globalen Revisionsnummern zu haben, und es ist deshalb
            <span class="emphasis"><em>kein</em></span> Kriterium, das Sie heranziehen
            sollten, wenn Sie abwägen, wie Sie Ihre Projekte und
            Repositorys anlegen wollen.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id393291" href="#id393291" class="para">28</a>] </sup>Das Trio <code class="filename">trunk</code>,
          <code class="filename">tags</code>, and <code class="filename">branches</code>
          wird manchmal als &#8222;<span class="quote">die TTB-Verzeichnisse</span>&#8220;
          bezeichnet.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id393572" href="#id393572" class="para">29</a>] </sup>Wenn Jack Repenning gefragt wird, ist die Aussprache
            oft &#8222;<span class="quote">fass-fass</span>&#8220;. (Jedoch geht dieses Buch
            davon aus, dass der Leser &#8222;<span class="quote">eff-ess-eff-ess</span>&#8220;
            denkt)</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id394078" href="#id394078" class="para">30</a>] </sup>Berkeley DB setzt voraus, dass das zugrundeliegende
              Dateisystem strenge POSIX-Sperrmechanismen implementiert
              und, noch wichtiger, die Fähigkeit mitbringt, Dateien
              direkt in den Prozessspeicher abzubilden.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id394368" href="#id394368" class="para">31</a>] </sup>Oracle kaufte Sleepycat und sein Vorzeigeprogramm,
              Berkeley DB, am Valentinstag 2006.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id396907" href="#id396907" class="para">32</a>] </sup>For example, hard drive + huge electromagnet = disaster.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id397513" href="#id397513" class="para">33</a>] </sup>That's rather the reason you use version control at
            all, right?</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id397523" href="#id397523" class="para">34</a>] </sup>Conscious, cautious removal of certain bits of
            versioned data is actually supported by real use cases.
            That's why an &#8222;<span class="quote">obliterate</span>&#8220; feature has been
            one of the most highly requested Subversion features,
            and one which the Subversion developers hope to soon
            provide.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id397895" href="#id397895" class="para">35</a>] </sup>While <span class="command"><strong>svnadmin dump</strong></span> has a
            consistent leading slash policy (to not include
            them), other programs that generate dump data might
            not be so consistent.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id398094" href="#id398094" class="para">36</a>] </sup>In fact, it can't truly be read-only, or
            <span class="command"><strong>svnsync</strong></span> itself would have a tough time
            copying revision history into it.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id398445" href="#id398445" class="para">37</a>] </sup>Be forewarned that while it will take only a few
            seconds for the average reader to parse this paragraph and
            the sample output that follows it, the actual time
            required to complete such a mirroring operation is, shall
            we say, quite a bit longer.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id399094" href="#id399094" class="para">38</a>] </sup><span class="command"><strong>svnadmin setlog</strong></span> can be called in a
            way that bypasses the hook interface altogether.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id399152" href="#id399152" class="para">39</a>] </sup>You know&#8212;the collective term for all of her
            &#8222;<span class="quote">fickle fingers.</span>&#8220;</p></div>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="svn.branchmerge.html">Zurück</a> </td>
<td width="20%" align="center"> </td>
<td width="40%" align="right"> <a accesskey="n" href="svn.serverconfig.html">Weiter</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Kapitel 4. Verzweigen und Zusammenführen </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td>
<td width="40%" align="right" valign="top"> Kapitel 6. Die Administration eines Subversion-Servers</td>
</tr>
</table>
</div>
</body>
</html>
