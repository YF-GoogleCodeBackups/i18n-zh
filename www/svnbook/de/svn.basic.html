<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Kapitel 1. Grundlegende Konzepte</title>
<link rel="stylesheet" href="styles.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="index.html" title="Versionskontrolle mit Subversion">
<link rel="up" href="index.html" title="Versionskontrolle mit Subversion">
<link rel="prev" href="svn.preface.html" title="Vorwort">
<link rel="next" href="svn.tour.html" title="Kapitel 2. Grundlegende Benutzung">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Kapitel 1. Grundlegende Konzepte</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="svn.preface.html">Zurück</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a accesskey="n" href="svn.tour.html">Weiter</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="chapter" lang="de">
<div class="titlepage"><div><div><h2 class="title">
<a name="svn.basic"></a>Kapitel 1. Grundlegende Konzepte</h2></div></div></div>
<div class="toc">
<p><b>Inhaltsverzeichnis</b></p>
<dl>
<dt><span class="sect1"><a href="svn.basic.html#svn.basic.repository">1.1. Das Repository</a></span></dt>
<dt><span class="sect1"><a href="svn.basic.html#svn.basic.vsn-models">1.2. Versionierungsmodelle</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.basic.html#svn.basic.vsn-models.problem-sharing">1.2.1. Das Problem ??The Problem of File Sharing</a></span></dt>
<dt><span class="sect2"><a href="svn.basic.html#svn.basic.vsn-models.lock-unlock">1.2.2. The Lock-Modify-Unlock Solution</a></span></dt>
<dt><span class="sect2"><a href="svn.basic.html#svn.basic.vsn-models.copy-merge">1.2.3. Die &#8222;Kopieren &#8211; Ändern &#8211; Zusammenfassen&#8220; - Lösung</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.basic.html#svn.basic.in-action">1.3. Subversion in Action</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="svn.basic.html#svn.advanced.reposurls">1.3.1. Subversion-Repository-URLs</a></span></dt>
<dt><span class="sect2"><a href="svn.basic.html#svn.basic.in-action.wc">1.3.2. Arbeitskopien</a></span></dt>
<dt><span class="sect2"><a href="svn.basic.html#svn.basic.in-action.revs">1.3.3. Revisionen</a></span></dt>
<dt><span class="sect2"><a href="svn.basic.html#svn.basic.in-action.track-repos">1.3.4. Wie Arbeitskopien das Repository verfolgen</a></span></dt>
<dt><span class="sect2"><a href="svn.basic.html#svn.basic.in-action.mixedrevs">1.3.5. Arbeitskopien mit gemischten Revisionen</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="svn.basic.html#svn.basic.summary">1.4. Zusammenfassung</a></span></dt>
</dl>
</div>
<p>Das Kapitel ist eine kurze, lockere Einführung in Subversion.
    Wenn Sie noch nicht mit Versionskontrolle zu tun hatten, dann ist
    dieses Kapitel genau für Sie. Wir besprechen die grundlegenden
    Konzepte von Versionskontrolle und arbeiten uns in die Richtung von
    Subversion und dessen spezifischen Ideen und zeigen einfache Beispiele
    zur Anwendung.</p>
<p>Obwohl die Beispiele in diesem Kapitel Leute zeigen, die
    gemeinsam an Quellcode arbeiten, sei daran erinnert, dass
    Subversion alle möglichen Arten von Datensammlungen verwalten
    kann &#8211; es beschränkt sich nicht darauf, Entwicklern zu
    helfen.</p>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.basic.repository"></a>1.1. Das Repository</h2></div></div></div>
<p>Subversion ist ein zentralisiertes System zur gemeinsamen
      Nutzung von Informationen. In seinem Kern ist ein Repository ein
      zentraler Speicher von Daten. Das Repository speichert Informationen
      in Form eines <em class="firstterm">Dateisystembaumes</em>, typischerweise
      eine Hierarchie von Dateien und Verzeichnissen. Eine beliebige Anzahl
      von <em class="firstterm">Clients</em> verbinden sich mit dem Repository
      und lesen oder schreiben diese Dateien. Durch den Schreibvorgang,
      macht ein Client Informationen für andere verfügbar. Durch den
      Lesevorgang bekommt der Client Informationen von anderen zur Verfügung
      gestellt.  <a class="xref" href="svn.basic.html#svn.basic.repository.dia-1" title="Abbildung 1.1. Ein typisches Client/Server System">Abbildung 1.1, &#8222;Ein typisches Client/Server System&#8220;</a>
      verdeutlicht das.</p>
<div class="figure">
<a name="svn.basic.repository.dia-1"></a><p class="title"><b>Abbildung 1.1. Ein typisches Client/Server System</b></p>
<div class="figure-contents"><div><img src="images/ch02dia1.png" alt="Ein typisches Client/Server System"></div></div>
</div>
<br class="figure-break"><p>So, warum ist das interessant? Bis zu diesem Punkt hört sich
      das wie die Definition eines typischen File-Servers an. Und
      tatsächlich, das Repository <span class="emphasis"><em>ist</em></span> eine Art von
      File-Server, aber nicht von der Art, die Sie kennen.  Was das
      Subversion-Repository so speziell macht ist, dass es sich
      <span class="emphasis"><em>jede Änderung merkt</em></span>, die jemals
      hineingeschrieben wurde. Jede Änderung an jeder Datei und auch
      Änderungen am Verzeichnisbaum selbst, wie z.B. das Hinzufügen, Löschen und
      Umstrukturieren von Dateien und Verzeichnissen.</p>
<p>Wenn ein Client Daten vom Repository liest, bekommt der Client
      üblicherweise nur die letzte Version des Dateisystem-Baumes zu sehen.
      Der Client hat aber auch die Möglichkeit, <span class="emphasis"><em>vorherige</em></span>
      Zustände des Dateibaumes anzuschauen.
      Zum Beispiel kann ein Client somit die Frage stellen:
      &#8222;<span class="quote">Was beinhaltete das Verzeichnis am letzten Mittwoch?</span>&#8220; und
      &#8222;<span class="quote">Wer war die Person, die als letztes die Datei geändert hat und welche
      Änderungen hat sie gemacht?</span>&#8220;. Diese Art von Fragen sind
      die Grundlage eines
      <em class="firstterm">Versionskontrollsystems</em>, Systeme, die
      dazu entwickelt wurden, um die Änderungen an Daten über die Zeit
      hin aufzuzeichnen.
    </p>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.basic.vsn-models"></a>1.2. Versionierungsmodelle</h2></div></div></div>
<p>Die zentrale Aufgabe eines Versionskontrollsystems ist es,
      die Zusammenarbeit beim Editieren gemeinsam benutzter Daten zu
      ermöglichen. Jedoch verwenden unterschiedliche Systeme auch
      unterschiedliche Strategien, um dies zu ermöglichen. Aus einer
      Reihe von Gründen ist es wichtig, diese Unterschiede zu
      verstehen. Erstmal hilft es dabei, bestehende
      Versionskontrollsysteme zu vergleichen und gegenüberzustellen,
      falls Ihnen andere Systeme begegnen, die Subversion ähneln.
      Darüber hinaus wird es Ihnen helfen, Subversion effektiver zu
      benutzen, da Subversion selbst eine Reihe unterschiedlicher
      Arbeitsweisen unterstützt.</p>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.basic.vsn-models.problem-sharing"></a>1.2.1. Das Problem ??The Problem of File Sharing</h3></div></div></div>
<p>Alle Versionskontrollsysteme haben alle die gleichen 
        fundamentalen Probleme zu lösen: Wie soll es Anwendern
        erlaubt werden Informationen zu teilen aber Sie davor
        bewahren, sich gegenseitig auf die Fße zu treten?
        Es ist allzu einfach die Änderungen eines anderen 
        im Repository zu überschreiben?</p>
<p>Stellen Sie sich einmal folgendes <a class="xref" href="svn.basic.html#svn.basic.vsn-models.problem-sharing.dia-1" title="Abbildung 1.2. The problem to avoid">Abbildung 1.2, &#8222;The problem to avoid&#8220;</a>Szenario vor:
        Zwei Kollegen, Harry und Sally, haben sich entschieden, 
        die gleiche Datei zur gleichen Zeit zu bearbeiten. 
        Harry speichert seine Änderungen zuerst im Repository, 
        es ist aber möglich, dass Sally nur einige Augenblicke 
        später mit ihrer Datei seine überschreibt.
        Harrys Änderungen der Datei sind zwar nicht für immer 
        verloren (da das System jede Änderung aufzeichnet), aber 
        alle seine Änderungen sind in Sallys später gespeicherter 
        Version der Datei nicht vorhanden, da Sally diese Änderungen 
        noch gar nicht kannte. Das heißt, dass Harrys Arbeit 
        doch verloren ist, zumindest in der neuesten Version der 
        Datei und das nur durch einen Zufall. 
        Eine solche Situation wollen wir auf alle Fälle vermeiden.		
      </p>
<div class="figure">
<a name="svn.basic.vsn-models.problem-sharing.dia-1"></a><p class="title"><b>Abbildung 1.2. The problem to avoid</b></p>
<div class="figure-contents"><div><img src="images/ch02dia2.png" alt="The problem to avoid"></div></div>
</div>
<br class="figure-break">
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.basic.vsn-models.lock-unlock"></a>1.2.2. The Lock-Modify-Unlock Solution</h3></div></div></div>
<p>Viele Versionskontrollsysteme verwenden ein
        <em class="firstterm">Sperren - Ändern - Entsperren</em>-Modell
        um zu verhindern, dass verschiedene Autoren sich gegenseitig die 
        Änderungen löschen. Bei diesem Modell erlaubt das Repository nur 
        jeweils einem Programmierer den Zugriff auf eine Datei. 
        Harry müsste also die Datei sperren, ehe er anfängt, seine 
        Änderungen einzugeben. Wenn Harry die Datei gesperrt hat, 
        kann Sally sie nicht ebenfalls sperren und daher auch nichts 
        ändern. Sie kann die Datei in der Zeit nur lesen und darauf 
        warten, dass Harry mit seiner Arbeit fertig ist und die Datei 
        entsperrt. <a class="xref" href="svn.basic.html#svn.basic.vsn-models.lock-unlock.dia-1" title="Abbildung 1.3. Die Sperren - Ändern - Entsperren - Lösung veranschaulicht diese einfache Möglichkeit">Abbildung 1.3, &#8222;Die Sperren - Ändern - Entsperren - Lösung veranschaulicht diese einfache Möglichkeit&#8220;</a></p>
<div class="figure">
<a name="svn.basic.vsn-models.lock-unlock.dia-1"></a><p class="title"><b>Abbildung 1.3. Die Sperren - Ändern - Entsperren - Lösung veranschaulicht diese einfache Möglichkeit</b></p>
<div class="figure-contents"><div><img src="images/ch02dia3.png" alt="Die Sperren - Ändern - Entsperren - Lösung veranschaulicht diese einfache Möglichkeit"></div></div>
</div>
<br class="figure-break"><p>Das Problem bei einem Sperren - Ändern - Entsperren - Modell liegt
        in seinen Beschränkungen, die oft zu schier unüberwindlichen Hindernissen führen können.</p>
<div class="itemizedlist"><ul type="disc">
<li><p><span class="emphasis"><em>Das Sperren kann zu administrativen Problemen führen.</em></span>
            Vielleicht sperrt Harry eine Datei und vergisst dann, 
            sie zu entsperren. In der Zwischenzeit sind Sally, 
            die ebenfalls Änderungen an dieser Datei durchführen will, 
            die Hände gebunden. Und dann geht Harry in Urlaub. 
            Nun muss Sally sich an einen Administrator wenden,
            um die Datei entsperrt zu bekommen. Das Ergebnis 
            sind unnötige Verzögerungen und vergeudete Zeit.</p></li>
<li><p><span class="emphasis"><em>Das Sperren kann zu einer unnötigen Serialisierung
            führen.</em></span>

            Was ist, wenn Harry z. B. den Anfang einer Textdatei 
            bearbeiten will, während Sally einfach nur das Ende 
            ändern möchte? Diese Änderungen würden sich überhaupt 
            nicht gegenseitig beeinflussen und könnten problemlos 
            gleichzeitig durchgeführt werden, vorausgesetzt, sie 
            würden anschließend vernünftig zusammengefasst. 
            Es gibt in dieser Situation keinen Grund, der Reihe 
            nach zu arbeiten.</p></li>
<li><p><span class="emphasis"><em>Das Sperren kann zu einem falschen Gefühl von
            Sicherheit führen.</em></span>

           Angenommen Harry sperrt und bearbeitet Datei A, 
           während Sally gleichzeitig Änderungen an Datei B 
           durchführt. Was ist, wenn A und B voneinander abhängig 
           sind und die jeweiligen Änderungen nicht kompatibel sind? 
           Plötzlich funktioniert das Zusammenspiel zwischen A 
           und B nicht mehr. Das System des Sperrens hat dieses 
           Problem nicht verhindert, doch hat es fälschlicherweise 
           zu einem Gefühl der Sicherheit geführt. Es ist leicht, 
           sich vorzustellen, dass Harry und Sally der Meinung 
           waren, dass jeder von ihnen eine eigenständige, 
           voneinander unabhängige Änderung durchgeführt hat 
           und dass das Sperren dazu geführt hat, dass sie ihre 
           inkompatiblen Änderungen nicht vorher miteinander 
           besprochen haben. Sperren ist oft ein Ersatz für 
           echte Kommunikation.</p></li>
</ul></div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.basic.vsn-models.copy-merge"></a>1.2.3. Die &#8222;Kopieren &#8211; Ändern &#8211; Zusammenfassen&#8220; - Lösung</h3></div></div></div>
<p>Subversion, CVS und viele andere Versionskontrollsysteme 
        benutzen eine &#8222;Kopieren &#8211; Ändern &#8211; Zusammenfassen&#8220; &#8212; 
        Version als Alternative zum Sperren. In diesem Modell erschafft 
        jeder User sich eine eigene Arbeitskopie der im Repository 
        vorhandenen Dateien und Verzeichnisse. Dann können die User 
        gleichzeitig und unabhängig voneinander ihre jeweiligen 
        Änderungen eingeben und speichern. Am Ende werden dann alle 
        Einzelkopien zu einer neuen, aktuellen Version zusammengefasst. 
        Das Versionskontrollsystem hilft oft bei dieser Zusammenfassung, 
        aber letztlich ist der Mensch dafür verantwortlich, das es 
        korrekt abläuft.</p>
<p>Hier ist ein Beispiel: Harry und Sally haben sich 
        jeweils eine eigene Arbeitskopie des im Repository vorhandenen 
        Projektes geschaffen. Beide arbeiten nun am selben File A 
        innerhalb ihrer jeweiligen Kopien. Sally speichert ihre Version 
        zuerst im Repository ab. Wenn Harry später ebenfalls versucht, 
        seine Änderungen zu speichern, informiert ihn das Repository, 
        das sein File A nicht mehr aktuell ist. Das bedeutet, dass 
        seitdem er sich seine Kopie erschaffen hat, sind irgendwelche 
        Änderungen aufgetreten. Also bittet Harry seinen Client darum, 
        diese neuen Änderungen in seine Arbeitskopie des File A 
        einzuarbeiten. Die Möglichkeit besteht, dass Sallys Änderungen 
        mit seinen nicht überlappen, wenn er also alle Änderungen 
        eingearbeitet hat, kann er seine Arbeitskopie zurück in das 
        Repository speichern. Die Abbildungen 
        <a class="xref" href="svn.basic.html#svn.basic.vsn-models.copy-merge.dia-1" title="Abbildung 1.4. &#8222;Kopieren &#8211; Ändern &#8211; Zusammenfassen&#8220; - Lösung">Abbildung 1.4, &#8222;&#8222;Kopieren &#8211; Ändern &#8211; Zusammenfassen&#8220; - Lösung&#8220;</a> und <a class="xref" href="svn.basic.html#svn.basic.vsn-models.copy-merge.dia-2" title="Abbildung 1.5. &#8222;Kopieren &#8211; Ändern &#8211; Zusammenfassen&#8220; - Lösung (Fortsetzung)">Abbildung 1.5, &#8222;&#8222;Kopieren &#8211; Ändern &#8211; Zusammenfassen&#8220; - Lösung (Fortsetzung)&#8220;</a> zeigen diesen
        Proczess.</p>
<div class="figure">
<a name="svn.basic.vsn-models.copy-merge.dia-1"></a><p class="title"><b>Abbildung 1.4. &#8222;Kopieren &#8211; Ändern &#8211; Zusammenfassen&#8220; - Lösung</b></p>
<div class="figure-contents"><div><img src="images/ch02dia4.png" alt="&#8222;Kopieren &#8211; Ändern &#8211; Zusammenfassen&#8220; - Lösung"></div></div>
</div>
<br class="figure-break"><div class="figure">
<a name="svn.basic.vsn-models.copy-merge.dia-2"></a><p class="title"><b>Abbildung 1.5. &#8222;Kopieren &#8211; Ändern &#8211; Zusammenfassen&#8220; - Lösung (Fortsetzung)</b></p>
<div class="figure-contents"><div><img src="images/ch02dia5.png" alt="&#8222;Kopieren &#8211; Ändern &#8211; Zusammenfassen&#8220; - Lösung (Fortsetzung)"></div></div>
</div>
<br class="figure-break"><p>
         Was aber passiert, <span class="emphasis"><em>wenn</em></span> Sallys Änderungen
         mit Harrys kollidieren? Diese Situation wird 
         <em class="firstterm">Konflikt</em> genannt und ist normalerweise
         kein allzugroßes Problem. Wenn Harry Sallys Änderungen in seine 
         Datei einpflegen lassen will, werden in seiner Datei die 
         miteinander in Konflikt stehenden Änderungen gekennzeichnet, 
         er kann sämtliche Änderungen sehen und manuell zwischen ihnen 
         wählen. Das Programm löst solche Konfliktsituationen nicht 
         automatisch, nur Menschen sind in der Lage, die Probleme zu 
         erkennnen und die nötigen intelligenten Änderungen durchzuführen. 
         Wenn Harry die Konfliktsituationen &#8212; vielleicht nach 
         einer kurzen Diskussion mit Sally &#8212; gelöst hat, 
         kann er seine Datei problemlos ins Repository speichern.</p>
<p>
        Dieses <span class="emphasis"><em>Kopieren &#8211; Ändern &#8211; Zusammenfassen</em></span> - Modell
        (engl. copy-modify-merge model) klingt vielleicht ein wenig 
        chaotisch, in der Praxis aber läuft es völlig glatt. Die 
        einzelnen User können parallel arbeiten, ohne einander in die 
        Quere zu kommen oder unnötig warten zu müsssen. Wenn sie an den 
        selben Dateien arbeiten, zeigt es sich meistens, dass ihre 
        jeweiligen Änderungen einander überhaupt nicht stören, wirkliche 
        Konflikte sind selten. Und die Zeit, die es beansprucht, eine 
        solche Konfliktsituation zu lösen, ist meist wesentlich kürzer 
        als der Zeitverlust, der durch das Sperren auftritt.</p>
<p>Am Ende läuft alles auf einen kritischen Faktor hinaus. 
        Die Kommunikation zwischen den Usern. Wenn diese Kommunikation 
        eher spärlich abläuft, häufen sich sowohl semantische als 
        auch syntaktische Konflikte. Kein System kann User dazu zwingen, 
        vernünftig miteinander zu kommnunizieren und kein System kann 
        semantische Konflikte erkennen. Also hat es auch keinen Sinn, 
        sich in dem falschen Gefühl von Sicherheit zu wiegen, dass das 
        Sperren Konflikte irgendwie vermeiden könnte. In der Praxis 
        verringert das System des Sperrens mehr als andere die 
        Produktivität.</p>
<div class="sidebar">
<a name="svn.basic.vsn-models.copy-merge.sb-1"></a><p class="title"><b>When Locking Is Necessary</b></p>
<p>While the lock-modify-unlock model is considered
          generally harmful to collaboration, sometimes
          locking is appropriate.</p>
<p>The copy-modify-merge model is based on the assumption
          that files are contextually mergeable&#8212;that is, that the
          majority of the files in the repository are line-based text
          files (such as program source code).  But for files with
          binary formats, such as artwork or sound, it's often
          impossible to merge conflicting changes.  In these
          situations, it really is necessary for users to take strict
          turns when changing the file.  Without serialized access,
          somebody ends up wasting time on changes that are ultimately
          discarded.</p>
<p>While Subversion is primarily a copy-modify-merge
          system, it still recognizes the need to lock an occasional
          file, and thus provides mechanisms for this.  We discuss
          this feature in <a class="xref" href="svn.advanced.html#svn.advanced.locking" title="3.7. Locking">Abschnitt 3.7, &#8222;Locking&#8220;</a>.</p>
</div>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.basic.in-action"></a>1.3. Subversion in Action</h2></div></div></div>
<p>Es ist an der Zeit, sich vom Abstrakten zum Konkreten zu
      bewegen. In diesem Abschnitt werden wir echte Beispiele zur
      Benutzung von Subversion zeigen.</p>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.advanced.reposurls"></a>1.3.1. Subversion-Repository-URLs</h3></div></div></div>
<p>Das ganze Buch hindurch verwendet Subversion URLs, um
        Dateien und Verzeichnisse in Subversion-Repositorys zu
        identifizieren. Meistens benutzen diese URLs die
        Standardsyntax, die es erlaubt, Servernamen und Portnummern
        als Teil des URL zu spezifizieren:</p>
<pre class="screen">
$ svn checkout http://svn.example.com:9834/repos
&#8230;
</pre>
<p>Allerdings gibt es einige bemerkenswerte Feinheiten, wie
        Subversion mit URLs umgeht. Beispielsweise dürfen URLs, die
        die <code class="literal">file://</code>-Zugriffsmethode enthalten (für
        lokale Repositorys verwendet), gemäß Konvention entweder
        den Servernamen <code class="literal">localhost</code> oder gar keinen
        Servernamen enthalten:</p>
<pre class="screen">
$ svn checkout file:///var/svn/repos
&#8230;
$ svn checkout file://localhost/var/svn/repos
&#8230;
</pre>
<p>Darüber hinaus müssen Benutzer des
        <code class="literal">file://</code> Schemas auf Windows-Plattformen
        eine inoffizielle &#8222;<span class="quote">Standard</span>&#8220;-Syntax verwenden
        falls auf Repositorys auf derselben Maschine aber auf einem
        anderen Laufwerk zugegriffen werden soll.  Beide  der
        folgenden URL-Pfad-Syntaxen funktionieren, wobei
        <code class="literal">X</code> das Laufwerk ist, wo das Repository
        liegt:</p>
<pre class="screen">
C:\&gt; svn checkout file:///X:/var/svn/repos
&#8230;
C:\&gt; svn checkout "file:///X|/var/svn/repos"
&#8230;
</pre>
<p>Bei der zweiten Syntax muss der URL in Anführungsstriche
        eingeschlossen werden, damit der senkrechte Strich nicht als
        Pipe-Symbol interpretiert wird. Beachten Sie auch, dass in
        einem URL Schrägstriche verwendet werden, obwohl es unter
        Windows üblich ist, für Pfade umgekehrte Schrägstriche zu
        verwenden.</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Anmerkung]" src="images/note.png"></td>
<th align="left">Anmerkung</th>
</tr>
<tr><td align="left" valign="top"><p>Sie können die <code class="literal">file://</code> URLs von Subversion
          nicht in einem normalen Web-Browser auf die Art und
          Weise verwenden wie andere <code class="literal">file://</code>
          URLs. Falls Sie versuchen, einen <code class="literal">file://</code>
          URL in einem gewöhnlichen Web-Browser anzusehen, wird der
          Inhalt der Datei von der angegebenen Stelle direkt aus dem
          Dateisystem gelesen und angezeigt. Allerdings befinden sich
          die Daten von Subversion in einem virtuellen Dateisystem
          (siehe <a class="xref" href="svn.developer.html#svn.developer.layerlib.repos" title="8.1.1. Repository Layer">Abschnitt 8.1.1, &#8222;Repository Layer&#8220;</a>), und
          der Browser wird nicht mit diesem Dateisystem umzugehen
          wissen.</p></td></tr>
</table></div>
<p>Zuletzt sei noch angemerkt, dass der Subversion-Client,
        wie ein Web-Browser, nötigenfalls automatisch URLs umwandelt.
        Falls zum Beispiel in einem URL Leerzeichen oder
        Großbuchstaben vorkommen wie hier:</p>
<pre class="screen">
$ svn checkout "http://host/path with space/project/españa"
</pre>
<p>wird Subversion die unsicheren Zeichen umwandeln, als ob
        Sie</p>
<pre class="screen">
$ svn checkout http://host/path%20with%20space/project/espa%C3%B1a
</pre>
<p>geschrieben hätten.</p>
<p>Falls ein URL Leerzeichen beinhalten sollte, stellen Sie
        sicher, das der URL in Anführungszeichen gesetzt wird, damit
        die Shell alles als ein Argument für das
        <span class="command"><strong>svn</strong></span> Programm behandelt.</p>
<div class="sidebar">
<a name="svn.basic.in-action.wc.sb-1"></a><p class="title"><b>Repository URLs</b></p>
<p>Sie können auf Subversion-Repositorys über viele
          unterschiedliche Methoden zugreifen &#8211; auf der
          lokalen Festplatte oder über verschiedene Protokolle, je
          nachdem, wie Ihr Administrator es eingerichtet hat. Ein Ort
          im Repository ist jedenfalls immer ein URL.
          <a class="xref" href="svn.basic.html#svn.basic.in-action.wc.tbl-1" title="Tabelle 1.1. Repository-Zugriffs-URLs">Tabelle 1.1, &#8222;Repository-Zugriffs-URLs&#8220;</a> beschreibt,
          wie unterschiedliche URL Schemata auf die verfügbaren
          Zugriffsmethoden abgebildet werden.</p>
<div class="table">
<a name="svn.basic.in-action.wc.tbl-1"></a><p class="title"><b>Tabelle 1.1. Repository-Zugriffs-URLs</b></p>
<div class="table-contents"><table summary="Repository-Zugriffs-URLs" border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>Schema</th>
<th>Zugriffsmethode</th>
</tr></thead>
<tbody>
<tr>
<td><code class="literal">file:///</code></td>
<td>Direkter Repository-Zugriff (auf lokaler
                  Festplatte)</td>
</tr>
<tr>
<td><code class="literal">http://</code></td>
<td>Zugriff über das WebDAV-Protokoll auf
                  Apache-Server, die Subversion unterstützen</td>
</tr>
<tr>
<td><code class="literal">https://</code></td>
<td>Wie <code class="literal">http://</code>, jedoch mit
                  SSL-Verschlüsselung.</td>
</tr>
<tr>
<td><code class="literal">svn://</code></td>
<td>Zugriff über eigenes Protokoll auf einen
                  <code class="literal">svnserve</code>-Server</td>
</tr>
<tr>
<td><code class="literal">svn+ssh://</code></td>
<td>Wie <code class="literal">svn://</code>, jedoch über
                  SSH getunnelt.</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>Für mehr Informationen darüber, wie Subversion URLs
          parst, siehe <a class="xref" href="svn.basic.html#svn.advanced.reposurls" title="1.3.1. Subversion-Repository-URLs">Abschnitt 1.3.1, &#8222;Subversion-Repository-URLs&#8220;</a>.  Für
          weitergehende Informationen zu den unterschiedlichen Typen
          verfügbarer Netzwerk-Servern für Subversion, siehe <a class="xref" href="svn.serverconfig.html" title="Kapitel 6. Die Administration eines Subversion-Servers">Kapitel 6, <i>Die Administration eines Subversion-Servers</i></a>.</p>
</div>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.basic.in-action.wc"></a>1.3.2. Arbeitskopien</h3></div></div></div>
<p>Sie haben schon über Arbeitskopien gelesen; nun werden wir
        zeigen, wie der Subversion-Client sie erzeugt und
        benutzt.</p>
<p>Eine Subversion-Arbeitskopie ist ein gewöhnlicher
        Verzeichnisbaum auf Ihrem lokalen System, der eine Ansammlung
        von Dateien enthält. Sie können diese Dateien nach belieben
        bearbeiten, und wenn es sich um Quelltexte handelt, können Sie
        hieraus Ihr Programm auf die übliche Weise compilieren. Ihre
        Arbeitskopie ist Ihr privater Arbeitsbereich: nie wird
        Subversion weder die Änderungen von anderen einpflegen, noch
        Ihre eigenen Änderungen anderen zur Verfügung stellen, bis Sie
        es ausdrücklich dazu auffordern. Sie können sogar mehrere
        Arbeitskopien desselben Projektes haben.</p>
<p>Nachdem Sie einige Änderungen an den Dateien Ihrer
        Arbeitskopie gemacht und sichergestellt haben, dass sie
        funktionieren, stellt Ihnen Subversion Befehle zur Verfügung,
        um Ihre Änderungen den anderen, die an Ihrem Projekt
        mitarbeiten, &#8222;<span class="quote">publik</span>&#8220; zu machen (indem es ins
        Repository schreibt). Wenn die anderen ihre Änderungen
        veröffentlichen, stellt Ihnen Subversion Befehle zur
        Verfügung, um diese Änderungen in Ihr Arbeitsverzeichnis
        einzupflegen (indem es aus dem Repository liest).</p>
<p>Eine Arbeitskopie verfügt darüber hinaus über einige
        zusätzliche Dateien, die von Subversion erzeugt und gepflegt
        werden, um es bei diesen Befehlen zu unterstützen.
        Insbesondere enthält jedes Verzeichnis Ihrer Arbeitskopie ein
        Unterverzeichnis namens <code class="filename">.svn</code>, auch
        bekannt als das <em class="firstterm">Verwaltungsverzeichnis</em>
        der Arbeitskopie. Die Dateien in jedem Verwaltungsverzeichnis
        helfen Subversion dabei, zu erkennen, welche Dateien
        unveröffentlichte Änderungen enthalten und welche Dateien
        hinsichtlich der Arbeit anderer veraltet sind.</p>
<p>Oft enthält ein typisches Subversion-Repository die
        Dateien (oder den Quelltext) für verschiedene Projekte; für
        gewöhnlich ist jedes Projekt ein Unterverzeichnis im
        Dateisystembaum des Repositorys.  Bei dieser Anordnung
        entspricht die Arbeitskopie eines Benutzers gewöhnlich einem
        bestimmten Unterverzeichnis des Repositorys.</p>
<p>Nehmen wir zum Beispiel an, Sie haben ein Repository, das
        zwei Software-Projekte beinhaltet, <code class="literal">paint</code> und
        <code class="literal">calc</code>.  Jedes Projekt ist in einem eigenen
        Hauptverzeichnis abgelegt, wie in <a class="xref" href="svn.basic.html#svn.basic.in-action.wc.dia-1" title="Abbildung 1.6. Das Dateisystem des Repositorys">Abbildung 1.6, &#8222;Das Dateisystem des Repositorys&#8220;</a> dargestellt.</p>
<div class="figure">
<a name="svn.basic.in-action.wc.dia-1"></a><p class="title"><b>Abbildung 1.6. Das Dateisystem des Repositorys</b></p>
<div class="figure-contents"><div><img src="images/ch02dia6.png" alt="Das Dateisystem des Repositorys"></div></div>
</div>
<br class="figure-break"><p>Um eine Arbeitskopie zu erhalten, muss zunächst irgendein
        Teilbaum des Repositorys <em class="firstterm">ausgecheckt</em>
        werden(check out).  (Der Begriff <span class="emphasis"><em>check
          out</em></span> hört sich an, als habe es etwas mit dem
        Sperren oder Reservieren von Ressourcen zu tun, hat es aber
        nicht; es erzeugt lediglich eine private Kopie des Projektes
        für Sie.) Wenn Sie zum Beispiel <code class="filename">/calc</code>
        auschecken, bekommen Sie eine Arbeitskopie wie diese:</p>
<pre class="screen">
$ svn checkout http://svn.example.com/repos/calc
A    calc/Makefile
A    calc/integer.c
A    calc/button.c
Ausgecheckt, Revision 56.

$ ls -A calc
Makefile  button.c integer.c .svn/
</pre>
<p>Die Liste der <code class="literal">A</code>s am linken Rand zeigt
        an, dass Subversion Ihrer Arbeitskopie eine Anzahl von
        Objekten hinzufügt (Add).  Sie haben nun eine persönliche
        Kopie des Verzeichnisses <code class="filename">/calc</code> im
        Repository, mit einem zusätzlichen
        Eintrag &#8211; <code class="filename">.svn</code> &#8211; das, wie bereits
        erwähnt, die besonderen Informationen enthält, die Subversion
        benötigt.</p>
<p>Angenommen, Sie nehmen Änderungen an
        <code class="filename">button.c</code> vor. Da sich das Verzeichnis
        <code class="filename">.svn</code> den ursprünglichen
        Änderungszeitpunkt und den Inhalt der Datei merkt, kann
        Subversion erkennen, dass Sie die Datei verändert haben.
        Trotzdem veröffentlicht Subversion Ihre Änderungen solange
        nicht, bis Sie es ausdrücklich hierzu auffordern. Der Vorgang
        des Veröffentlichens von Änderungen über das Repository ist
        gemeinhin bekannter als <em class="firstterm">commit</em> (oder
        <em class="firstterm">check in</em>).</p>
<p>Um Ihre Änderungen anderen gegenüber zu veröffentlichen,
        können Sie den Subversion-Befehl <span class="command"><strong>svn commit</strong></span>
        verwenden:</p>
<pre class="screen">
$ svn commit button.c -m "Tippfehler in button.c korrigiert"
Sende          button.c
Übertrage Daten .
Revision 6 übertragen.
</pre>
<p>Nun sind Ihre Änderungen an <code class="filename">button.c</code> dem
        Repository überstellt, mitsamt einer Notiz, die Ihre Änderung
        beschreibt (nämlich, dass Sie einen Tippfehler beseitigt
        haben). Wenn eine andere Benutzerin eine Arbeitskopie von
        <code class="filename">/calc</code> auscheckt, wird sie Ihre
        Änderungen in der letzten Version der Datei sehen
        können.</p>
<p>angenommen, Sie haben eine Mitarbeiterin, Sally, die eine
        Arbeitskopie von <code class="filename">/calc</code> gleichzeitig mit
        Ihnen ausgecheckt hat. Wenn Sie Ihre Änderung an
        <code class="filename">button.c</code> committen, bleibt Sallys
        Arbeitskopie unverändert; Subversion ändert Arbeitskopien nur
        auf Wunsch des Benutzers.</p>
<p>Um ihr Projekt auf den neuesten Stand zu bringen, kann
        Sally Subversion dazu auffordern, ihre Arbeitskopie zu
        aktualisieren, indem sie den Befehl <span class="command"><strong>svn update</strong></span>
        verwendet. Das bringt sowohl Ihre als auch alle anderen
        Änderungen die committet wurden seit sie ausgecheckt hatte in
        ihre Arbeitskopie.</p>
<pre class="screen">
$ pwd
/home/sally/calc

$ ls -A
Makefile button.c integer.c .svn/

$ svn update
U    button.c
Aktualisiert zu Revision 57.
</pre>
<p>Die Ausgabe des <span class="command"><strong>svn update</strong></span> Befehls
        zeigt, dass Subversion den Inhalt von
        <code class="filename">button.c</code> aktualisiert hat (Update).
        Beachten Sie, dass Sally nicht angeben musste, welche Dateien
        zu aktualisieren sind; Subversion benutzt die Informationen
        aus dem <code class="filename">.svn</code> Verzeichnis und
        darüber hinaus weitere Informationen im Repository, um zu
        entscheiden, welche Dateien auf den neuesten Stand gebracht
        werden müssen.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.basic.in-action.revs"></a>1.3.3. Revisionen</h3></div></div></div>
<p>Ein <span class="command"><strong>svn commit</strong></span> veröffentlicht
        Änderungen an einer beliebigen Anzahl von Dateien und
        Verzeichnissen als eine einzige atomare Transaktion. In Ihrer
        Arbeitskopie können Sie Dateiinhalte ändern, Dateien und
        Verzeichnisse erzeugen, löschen, umbenennen und kopieren und
        dann den gesamten Umfang der Änderungen als atomare
        Transaktion durch ein <span class="command"><strong>svn commit</strong></span> in das
        Repository einbringen.</p>
<p>Eine atomare Transaktion bedeutet: entweder es gehen alle
        Änderungen in das Repository oder keine. Angesichts von
        Programmabstürzen, Systemabstürzen, Netzproblemen oder anderer
        Benutzeraktionen hält Subversion an dieser Atomizität
        fest.</p>
<p>Jedes Mal wenn das Repository ein Commit annimmt, wird ein
        neuer Zustand des Dateisystem-Baums erzeugt, der
        <em class="firstterm">Revision</em> genannt wird. Jeder Revision
        wird eine einmalige natürliche Zahl zugewiesen, die um eins
        größer ist als die Vorgänger-Revision. Die anfängliche
        Revision eines frisch erzeugten Repositorys bekommt die Nummer
        0 und besteht lediglich aus einem leeren
        Wurzelverzeichnis.</p>
<p><a class="xref" href="svn.basic.html#svn.basic.in-action.revs.dia-1" title="Abbildung 1.7. Das Repository">Abbildung 1.7, &#8222;Das Repository&#8220;</a> zeigt,
        wie man sich das Repository vorstellen kann. Stellen Sie sich
        eine Reihe von Revisionsnummern vor, die bei 0 startet und von
        links nach rechts wächst. Jede Revisionsnummer hat einen
        Dateisystem-Baum unter sich hängen, der ein
        &#8222;<span class="quote">Schnappschuss</span>&#8220; des Repositorys nach einem Commit
        ist.</p>
<div class="figure">
<a name="svn.basic.in-action.revs.dia-1"></a><p class="title"><b>Abbildung 1.7. Das Repository</b></p>
<div class="figure-contents"><div><img src="images/ch02dia7.png" alt="Das Repository"></div></div>
</div>
<br class="figure-break"><div class="sidebar">
<p class="title"><b>Globale Revisionsnummern</b></p>
<p>Anders als die meisten Versionskontrollsysteme werden
          die Revisionsnummern von Subversion auf
          <span class="emphasis"><em>komplette Bäume</em></span> anstatt auf einzelne
          Dateien angewendet. Jede Revisionsnummer wählt einen
          kompletten Baum aus; ein besonderer Zustand nach dem Commit
          einer Änderung. Man kann sich auch vorstellen, dass Revision
          N den Zustand des Repository-Dateisystems nach dem N-ten
          Commit repräsentiert. Wenn Subversion-Benutzer von
          &#8222;<span class="quote">Revision 5 von <code class="filename">foo.c</code></span>&#8220;
          sprechen, meinen sie tatsächlich
          &#8222;<span class="quote"><code class="filename">foo.c</code> so wie es in Revision 5
            aussieht</span>&#8220;. Beachten Sie, dass sich im Allgemeinen die
          Revisionen N und M einer Datei <span class="emphasis"><em>nicht</em></span>
          notwendigerweise unterscheiden! Viele andere
          Versionskontrollsysteme verwenden dateibezogene
          Revisionsnummern, so dass dieses Konzept zunächst
          ungewöhnlich aussieht. (Ehemalige CVS-Benutzer sollten sich
          für weitergehende Informationen <a class="xref" href="svn.forcvs.html" title="Anhang B. Subversion for CVS Users">Anhang B, <i>Subversion for CVS Users</i></a>
          ansehen.)</p>
</div>
<p>Es ist wichtig zu beachten, dass eine Arbeitskopie nicht
        immer genau einer Revision im Repository zugeordnet werden
        kann; sie kann Dateien aus verschiedenen Revisionen
        beinhalten. Nehmen wir z.B. an, Sie checken sich eine
        Arbeitskopie einer Datei aus einem Repository aus, deren
        neueste Revision 4 ist:</p>
<pre class="screen">
calc/Makefile:4
     integer.c:4
     button.c:4
</pre>
<p>In diesem Augenblick entspricht Ihre Arbeitskopie exakt
        der Revision im Repository. Sie machen jetzt allerdings eine
        Änderung an <code class="filename">button.c</code> und bringen diese
        Änderung mit einem Commit ins Repository. Angenommen, dass
        keine weiteren Commits vorgenommen wurden, wird Ihr Commit die
        Revision 5 im Repository erzeugen, und Ihre Arbeitskopie sieht
        so aus:</p>
<pre class="screen">
calc/Makefile:4
     integer.c:4
     button.c:5
</pre>
<p>Angenommen, zu diesem Zeitpunkt macht Sally einen Commit
        für eine Änderung an <code class="filename">integer.c</code> und
        erzeugt Revision 6. Wenn Sie <span class="command"><strong>svn update</strong></span>
        verwenden, um Ihre Arbeitskopie zu aktualisieren, sieht sie so
        aus:</p>
<pre class="screen">
calc/Makefile:6
     integer.c:6
     button.c:6
</pre>
<p>Sallys Änderung an <code class="filename">integer.c</code>
        erscheint in Ihrer Arbeitskopie, und Ihre Änderung ist immer
        noch in <code class="filename">button.c</code>.  In diesem Beispiel ist
        der Text von <code class="filename">Makefile</code> in den Revisionen
        4, 5 und 6 identisch, jedoch markiert Subversion die
        Arbeitskopie von <code class="filename">Makefile</code> mit Revision 6,
        um zu zeigen, dass es noch aktuell ist. Wenn Sie also ein
        sauberes Update von der Wurzel Ihrer Arbeitskopie her machen,
        sollte sie im Allgemeinen genau einer Revision im Repository
        entsprechen.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.basic.in-action.track-repos"></a>1.3.4. Wie Arbeitskopien das Repository verfolgen</h3></div></div></div>
<p>Für jede Datei eines Arbeitsverzeichnis merkt sich
        Subversion zwei essentielle Informationen im
        <code class="filename">.svn/</code>-Verwaltungsbereich:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Auf welcher Revision Ihre Arbeitsdatei aufbaut (das
            wird die <em class="firstterm">Arbeitsrevision</em> der Datei
            genannt)</p></li>
<li><p>Ein Zeitstempel, der festhält, wann die lokale Kopie
            das letzte Mal vom Repository aktualisiert wurde.</p></li>
</ul></div>
<p>Mit diesen Informationen kann Subversion durch
        Kommunikation mit dem Repository feststellen, in
        welchem der folgenden Zustände sich eine Arbeitsdatei
        befindet:</p>
<div class="variablelist"><dl>
<dt><span class="term">Unverändert und aktuell</span></dt>
<dd><p>Die Datei im Arbeitsverzeichnis ist unverändert, und
              keinerlei Änderungen an der Datei sind seit der
              Arbeitsrevision an das Repository übergeben worden. Ein
              <span class="command"><strong>svn commit</strong></span> der Datei würde nichts
              machen, und ein <span class="command"><strong>svn update</strong></span> der Datei
              auch nicht.</p></dd>
<dt><span class="term">Lokal geändert und aktuell</span></dt>
<dd><p>Die Datei wurde im Arbeitsverzeichnis geändert, und
              keinerlei Änderungen an der Datei sind seit der letzten
              Aktualisierung an das Repository übergeben worden. Es
              gibt lokale Änderungen, die noch nicht an das Repository
              übergeben worden sind, so dass ein <span class="command"><strong>svn
                commit</strong></span> der Datei Ihre Änderungen erfolgreich
              veröffentlichen würde, und ein <span class="command"><strong>svn
                update</strong></span> der Datei nichts tun würde.</p></dd>
<dt><span class="term">Unverändert und veraltet</span></dt>
<dd><p>Die Datei wurde im Arbeitsverzeichnis nicht
              geändert, jedoch im Repository. Die Datei sollte
              aktualisiert werden, damit sie bezüglich der letzten
              öffentlichen Revision aktuell ist. Ein <span class="command"><strong>svn
                commit</strong></span> der Datei würde nichts machen, und
              ein <span class="command"><strong>svn update</strong></span> der Datei würde die
              letzten Änderungen in Ihre Arbeitskopie
              einbringen.</p></dd>
<dt><span class="term">Lokal geändert und veraltet</span></dt>
<dd><p>Die Datei wurde sowohl im Arbeitsverzeichnis als
              auch im Repository geändert. Ein <span class="command"><strong>svn
              commit</strong></span> der Datei würde mit einem
            &#8222;<span class="quote">out-of-date</span>&#8220; Fehler abbrechen. Die Datei
            sollte erst aktualisiert werden; ein <span class="command"><strong>svn
              update</strong></span> Befehl würde versuchen, die
            öffentlichen mit den lokalen Änderungen zusammenzuführen.
            Wenn Subversion diese Zusammenführung nicht plausibel
            automatisch durchführen kann, wird die Auflösung des
            Konflikts dem Benutzer überlassen.</p></dd>
</dl></div>
<p>Das hört sich an, als müsse man jede Menge mitverfolgen,
        aber der <span class="command"><strong>svn status</strong></span> Befehl zeigt Ihnen den
        Zustand jedes Objektes in Ihrer Arbeitskopie. Weitergehende
        Informationen zu diesem Befehl finden Sie unter
        <a class="xref" href="svn.tour.html#svn.tour.cycle.examine.status" title="2.4.3.1. Verschaffen Sie sich einen Überblick über Ihre Änderungen">Abschnitt 2.4.3.1, &#8222;Verschaffen Sie sich einen Überblick über Ihre
          Änderungen&#8220;</a>.</p>
</div>
<div class="sect2" lang="de">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.basic.in-action.mixedrevs"></a>1.3.5. Arbeitskopien mit gemischten Revisionen</h3></div></div></div>
<p>Als allgemeingültiges Prinzip versucht Subversion, so
        flexibel wie möglich zu sein. Eine besondere Ausprägung der
        Flexibilität ist die Fähigkeit, eine Arbeitskopie bestehend
        aus Dateien und Verzeichnissen mit einer Mischung
        unterschiedlicher Revisionsnummern zu haben.
        Unglücklicherweise neigt diese Flexibilität dazu, eine Anzahl
        neuer Benutzer zu verwirren. Wenn Sie das vorangegangene Beispiel,
        das gemischte Revisionen vorgestellt hat, verwirrte, zeigen
        wir hier eine Einführung warum es diese Möglichkeit gibt und
        wie sie verwendet wird.</p>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.basic.in-action.mixedrevs.update-commit"></a>1.3.5.1. Updates und Commits sind getrennt</h4></div></div></div>
<p>Eine der grundlegenden Regeln von Subversion ist, dass
          eine Aktion, die in das Repository schreibt keine Aktion zur
          Folge hat, die aus dem Repository liest und umgekehrt. Wenn
          Sie bereit sind, neue Änderungen an das Repository zu
          übergeben, heißt das noch lange nicht, dass Sie auch die
          Änderungen anderer haben möchten. Und wenn Sie noch an
          Änderungen arbeiten, sollte <span class="command"><strong>svn update</strong></span>
          elegant die Änderungen aus dem Repository mit Ihren
          Änderungen zusammenführen anstatt Sie dazu zu zwingen, Ihre
          Änderungen zu veröffentlichen.</p>
<p>Der hauptsächliche Nebeneffekt dieser Regel ist, dass
          eine Arbeitskopie zusätzlich buchhalten muss, um sowohl
          gemischte Revisionen zu verfolgen als auch diese Mischung
          vertragen zu können. Die Tatsache, dass auch Verzeichnisse
          selbst versioniert sind, verkompliziert die Sache
          nur.</p>
<p>Nehmen wir zum Beispiel an, Ihre Arbeitskopie besteht
          komplett aus Revision 10. Sie bearbeiten die Datei
          <code class="filename">foo.html</code> und führen ein <span class="command"><strong>svn
            commit</strong></span> aus, das die Revision 15 im Repository
          erzeugt. Nach dem erfolgreichen Commit würden viele neue
          Benutzer erwarten, dass die gesamte Arbeitskopie auf
          Revision 15 stehe, was aber nicht der Fall ist! Alle
          möglichen Änderungen können sich zwischen Revision 10 und 15
          im Repository zugetragen haben. Der Client weiß nichts über
          diese Änderungen im Repository, da Sie noch nicht
          <span class="command"><strong>svn update</strong></span> aufgerufen haben, und
          <span class="command"><strong>svn commit</strong></span> zieht keine Änderungen herein.
          Wenn andererseits <span class="command"><strong>svn commit</strong></span> automatisch
          Änderungen hereinziehen würde, könnte die gesamte
          Arbeitskopie auf Revision 15 gebracht werden &#8211; doch dann
          wäre die grundlegende Regel verletzt, dass Lesen und
          Schreiben getrennte Aktionen sind. Deshalb ist das einzig
          Sichere, das der Subversion-Client tun kann, die eine
          Datei &#8211; <code class="filename">foo.html</code> &#8211; als zur
          Revision 15 gehörig zu kennzeichnen. Der Rest der
          Arbeitskopie verbleibt bei Revision 10. Nur durch
          <span class="command"><strong>svn update</strong></span> können die neuesten Änderungen
          hereingezogen und die gesamte Arbeitskopie als
          Revision 15 gekennzeichnet werden.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.basic.in-action.mixedrevs.normal"></a>1.3.5.2. Gemischte Revisionen sind normal</h4></div></div></div>
<p>Tatsache ist, dass <span class="emphasis"><em>jedes Mal</em></span> wenn
          Sie <span class="command"><strong>svn commit</strong></span> aufgerufen haben, die
          Arbeitskopie aus irgendeiner Mischung von Revisionen
          besteht. Die Sachen, die Sie eben ins Repository gebracht
          haben, werden mit höheren Revisionsnummern gekennzeichnet
          als alles andere. Nach einigen Commits (ohne
          zwischenzeitliche Updates) ist Ihre Arbeitskopie eine
          Riesenmischung von Revisionen. Selbst wenn Sie die einzige
          Person sind, die das Repository benutzt, werden sie dieses
          Phänomen bemerken. Um Ihre Mischung aus Arbeitsrevisionen
          untersuchen zu können, verwenden Sie den Befehl <span class="command"><strong>svn
            status</strong></span> mit der <code class="option">--verbose</code>-Option
          (siehe <a class="xref" href="svn.tour.html#svn.tour.cycle.examine.status" title="2.4.3.1. Verschaffen Sie sich einen Überblick über Ihre Änderungen">Abschnitt 2.4.3.1, &#8222;Verschaffen Sie sich einen Überblick über Ihre
          Änderungen&#8220;</a> für
          weitergehende Informationen).</p>
<p>Oft ist neuen Benutzern überhaupt nicht bewusst, das
          ihre Arbeitskopie gemischte Revisionen beinhaltet. Das kann
          zur Verwirrung führen, weil viele Client-Programme
          empfindlich auf die Revision des Objektes reagieren, das sie
          untersuchen. Beispielsweise wird der <span class="command"><strong>svn
            log</strong></span>-Befehl verwendet, um die Historie der
          Änderungen einer Datei oder eines Verzeichnisses
          darzustellen (siehe <a class="xref" href="svn.tour.html#svn.tour.history.log" title="2.5.1. Erzeugung einer Liste der Änderungsgeschichte">Abschnitt 2.5.1, &#8222;Erzeugung einer Liste der Änderungsgeschichte&#8220;</a>).
          Wenn der Benutzer diesen Befehl auf ein Objekt in der
          Arbeitskopie anwendet, erwartet er, die gesamte Historie des
          Objektes zu sehen. Wenn jedoch die Arbeitsrevision des
          Objektes ziemlich alt ist (oftmals weil lange Zeit kein
          <span class="command"><strong>svn update</strong></span> aufgerufen wurde), wird die
          Historie der <span class="emphasis"><em>älteren</em></span> Version des
          Objekts angezeigt.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.basic.in-action.mixedrevs.useful"></a>1.3.5.3. Gemischte Revisionen sind nützlich</h4></div></div></div>
<p>Wenn Ihr Projekt hinreichend komplex ist, werden Sie
          entdecken, dass es manchmal ganz nett sein kann, Teile Ihrer
          Arbeitskopie <em class="firstterm">zurückzudatieren</em> (oder
          auf eine ältere Version als die vorliegende zu
          aktualisieren); wie das gemacht wird, wird in <a class="xref" href="svn.tour.html" title="Kapitel 2. Grundlegende Benutzung">Kapitel 2, <i>Grundlegende Benutzung</i></a> gezeigt.  Vielleicht möchten Sie eine
          ältere Version eines Teilmoduls in einem Unterverzeichnis
          testen, oder Sie möchten herausbekommen, wann ein Fehler das
          erste Mal in einer Datei auftauchte. Dies ist der
          &#8222;<span class="quote">Zeitmaschinen</span>&#8220;-Aspekt eines
          Versionskontrollsystems &#8211; die Eigenschaft, die es
          ermöglicht, irgendeinen Teil Ihrer Arbeitskopie zeitlich nach
          vorne oder nach hinten zu verschieben.</p>
</div>
<div class="sect3" lang="de">
<div class="titlepage"><div><div><h4 class="title">
<a name="svn.basic.in-action.mixedrevs.limits"></a>1.3.5.4. Gemischte Revisionen haben ihre Grenzen</h4></div></div></div>
<p>Wie auch immer Sie gemischte Revisionen in Ihrer
          Arbeitskopie verwenden, diese Flexibilität hat ihre
          Grenzen.</p>
<p>Erstens kann die Löschung einer Datei oder eines
          Verzeichnisses nicht an das Repository übergeben werden,
          wenn die Datei oder das Verzeichnis nicht ganz aktuell ist.
          Falls eine neuere Version im Repository existiert, wird Ihr
          Löschversuch abgelehnt, um zu vermeiden, dass Sie
          versehentlich Änderungen löschen, die Sie noch nicht gesehen
          haben.</p>
<p>Zweitens können Sie keine Änderungen an Metadaten eines
          Verzeichnisses an das Repository übergeben, wenn das
          Verzeichnis nicht ganz aktuell ist. In <a class="xref" href="svn.advanced.html" title="Kapitel 3. Advanced Topics">Kapitel 3, <i>Advanced Topics</i></a> werden Sie lernen, wie man
          &#8222;<span class="quote">Propertys</span>&#8220; an Objekte hängt. Die Arbeitskopie
          eines Verzeichnisses definiert eine bestimmte Menge von
          Einträgen und Propertys, so dass eine Property-Änderung an
          einem veralteten Verzeichnis Propertys zerstören kann, die
          Sie noch nicht gesehen haben.</p>
</div>
</div>
</div>
<div class="sect1" lang="de">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.basic.summary"></a>1.4. Zusammenfassung</h2></div></div></div>
<p>In diesem Kapitel haben wir eine Anzahl fundamentaler
      Konzepte von Subversion behandelt:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Wir haben die Begriffe zentrales Repository,
          Arbeitskopie und Reihe von Revisionsbäumen des Repositorys
          eingeführt.</p></li>
<li><p>Wir haben einige einfache Beispiele gesehen, wie zwei
          Mitarbeiter Subversion verwenden können, um gegenseitig
          Änderungen auszutauschen, indem das
          &#8222;<span class="quote">kopieren-verändern-zusammenführen</span>&#8220;-Modell
          benutzt wird.</p></li>
<li><p>Wir haben ein wenig darüber geredet, wie Subversion
          Informationen in einer Arbeitskopie verfolgt und
          verwaltet.</p></li>
</ul></div>
<p>An dieser Stelle sollten Sie eine gute Vorstellung haben,
      wie Subversion ganz allgemein arbeitet. Mit diesem Kenntnisstand
      sollten Sie in der Lage sein, das nächste Kapitel anzugehen,
      das ein detaillierter Rundgang durch die Befehle und
      Eigenschaften von Subversion ist.</p>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="svn.preface.html">Zurück</a> </td>
<td width="20%" align="center"> </td>
<td width="40%" align="right"> <a accesskey="n" href="svn.tour.html">Weiter</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Vorwort </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Zum Anfang</a></td>
<td width="40%" align="right" valign="top"> Kapitel 2. Grundlegende Benutzung</td>
</tr>
</table>
</div>
</body>
</html>
