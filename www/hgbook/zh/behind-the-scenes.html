<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>第 3 章 Mercurial 内幕</title>
<link rel="stylesheet" href="hgbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.74.3">
<link rel="home" href="index.html" title="Mercurial 权威指南">
<link rel="up" href="index.html" title="Mercurial 权威指南">
<link rel="prev" href="a-tour-of-mercurial-merging-work.html" title="第 2 章 Mercurial 教程: 合并工作">
<link rel="next" href="mercurial-in-daily-use.html" title="第 4 章 Mercurial 的日常使用">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">第 3 章 Mercurial 内幕</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="a-tour-of-mercurial-merging-work.html">上一页</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a accesskey="n" href="mercurial-in-daily-use.html">下一页</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="chapter" lang="zh">
<div class="titlepage"><div><div><h2 class="title">
<a name="chap:concepts"></a>第 3 章 Mercurial 内幕</h2></div></div></div>
<div class="toc">
<p><b>目录</b></p>
<dl>
<dt><span class="sect1"><a href="behind-the-scenes.html#id511272">3.1. Mercurial 的历史记录</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="behind-the-scenes.html#id511278">3.1.1. 跟踪单一文件的历史</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id511359">3.1.2. 管理跟踪的文件</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id511376">3.1.3. 记录修改集信息</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id511393">3.1.4. 版本之间的关系</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="behind-the-scenes.html#id511460">3.2. 安全，高效的存储</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="behind-the-scenes.html#id511475">3.2.1. 高效存储</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#sec:concepts:txn">3.2.2. 安全操作</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id511541">3.2.3. 快速检索</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id511642">3.2.4. 鉴别和强完整性</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="behind-the-scenes.html#id511680">3.3. 修订历史，分支与合并</a></span></dt>
<dt><span class="sect1"><a href="behind-the-scenes.html#id511749">3.4. 工作目录</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="behind-the-scenes.html#id511818">3.4.1. 当你提交时发生的事情</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id511914">3.4.2. 创建新顶点</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id512052">3.4.3. 合并顶点</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="behind-the-scenes.html#id512199">3.5. 其它有趣的设计特性</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="behind-the-scenes.html#id512217">3.5.1. 智能压缩</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id512322">3.5.2. 读写顺序与原子性</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id512356">3.5.3. 并发访问</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id512430">3.5.4. 避免查找</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id512483">3.5.5. 目录状态的其它内容</a></span></dt>
</dl></dd>
</dl>
</div>
<p><a name="x_2e8"></a>Unlike many revision control systems, the concepts upon which Mercurial is
built are simple enough that it's easy to understand how the software really
works.  Knowing this certainly isn't necessary, but I find it useful to have
a “<span class="quote">mental model</span>” of what's going on.</p>
<p><a name="x_2e9"></a>This understanding gives me confidence that Mercurial has been carefully
designed to be both <span class="emphasis"><em>safe</em></span> and
<span class="emphasis"><em>efficient</em></span>.  And just as importantly, if it's easy for
me to retain a good idea of what the software is doing when I perform a
revision control task, I'm less likely to be surprised by its behaviour.</p>
<p><a name="x_2ea"></a>In this chapter, we'll initially cover the core concepts behind Mercurial's
design, then continue to discuss some of the interesting details of its
implementation.</p>
<div class="sect1" lang="zh">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id511272"></a>3.1. Mercurial 的历史记录</h2></div></div></div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id511278"></a>3.1.1. 跟踪单一文件的历史</h3></div></div></div>
<p><a name="x_2eb"></a>When Mercurial tracks modifications to a file, it stores the history of that
file in a metadata object called a <span class="emphasis"><em>filelog</em></span>.  Each entry
in the filelog contains enough information to reconstruct one revision of
the file that is being tracked.  Filelogs are stored as files in the
<code class="filename">.hg/store/data</code>
directory.  A filelog contains two kinds of information: revision data, and
an index to help Mercurial to find a revision efficiently.</p>
<p><a name="x_2ec"></a>A file that is large, or has a lot of history, has its filelog stored in
separate data (“<span class="quote"><code class="literal">.d</code></span>” suffix) and index
(“<span class="quote"><code class="literal">.i</code></span>” suffix) files.  For small files
without much history, the revision data and index are combined in a single
“<span class="quote"><code class="literal">.i</code></span>” file.  The correspondence between a
file in the working directory and the filelog that tracks its history in the
repository is illustrated in <a class="xref" href="behind-the-scenes.html#fig:concepts:filelog" title="图 3.1. 工作目录中的文件与版本库中的文件日志之间的关系">图 3.1 “工作目录中的文件与版本库中的文件日志之间的关系”</a>.</p>
<div class="figure">
<a name="fig:concepts:filelog"></a><p class="title"><b>图 3.1. 工作目录中的文件与版本库中的文件日志之间的关系</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/filelog.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break">
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id511359"></a>3.1.2. 管理跟踪的文件</h3></div></div></div>
<p><a name="x_2ee"></a>Mercurial uses a structure called a <span class="emphasis"><em>manifest</em></span> to collect
together information about the files that it tracks.  Each entry in the
manifest contains information about the files present in a single
changeset.  An entry records which files are present in the changeset, the
revision of each file, and a few other pieces of file metadata.</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id511376"></a>3.1.3. 记录修改集信息</h3></div></div></div>
<p><a name="x_2ef"></a>The <span class="emphasis"><em>changelog</em></span> contains information about each
changeset.  Each revision records who committed a change, the changeset
comment, other pieces of changeset-related information, and the revision of
the manifest to use.</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id511393"></a>3.1.4. 版本之间的关系</h3></div></div></div>
<p><a name="x_2f0"></a>Within a changelog, a manifest, or a filelog, each revision stores a pointer
to its immediate parent (or to its two parents, if it's a merge revision).
As I mentioned above, there are also relationships between revisions
<span class="emphasis"><em>across</em></span> these structures, and they are hierarchical in
nature.</p>
<p><a name="x_2f1"></a>For every changeset in a repository, there is exactly one revision stored in
the changelog.  Each revision of the changelog contains a pointer to a
single revision of the manifest.  A revision of the manifest stores a
pointer to a single revision of each filelog tracked when that changeset was
created.  These relationships are illustrated in <a class="xref" href="behind-the-scenes.html#fig:concepts:metadata" title="图 3.2. 元数据之间的关系">图 3.2 “元数据之间的关系”</a>.</p>
<div class="figure">
<a name="fig:concepts:metadata"></a><p class="title"><b>图 3.2. 元数据之间的关系</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/metadata.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break"><p><a name="x_2f3"></a>As the illustration shows, there is <span class="emphasis"><em>not</em></span> a “<span class="quote">one to
one</span>” relationship between revisions in the changelog, manifest, or
filelog. If the manifest hasn't changed between two changesets, the
changelog entries for those changesets will point to the same revision of
the manifest.  If a file that Mercurial tracks hasn't changed between two
changesets, the entry for that file in the two revisions of the manifest
will point to the same revision of its filelog.</p>
</div>
</div>
<div class="sect1" lang="zh">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id511460"></a>3.2. 安全，高效的存储</h2></div></div></div>
<p><a name="x_2f4"></a>The underpinnings of changelogs, manifests, and filelogs are provided by a
single structure called the <span class="emphasis"><em>revlog</em></span>.</p>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id511475"></a>3.2.1. 高效存储</h3></div></div></div>
<p><a name="x_2f5"></a>The revlog provides efficient storage of revisions using a
<span class="emphasis"><em>delta</em></span> mechanism.  Instead of storing a complete copy of
a file for each revision, it stores the changes needed to transform an older
revision into the new revision.  For many kinds of file data, these deltas
are typically a fraction of a percent of the size of a full copy of a file.</p>
<p><a name="x_2f6"></a>Some obsolete revision control systems can only work with deltas of text
files.  They must either store binary files as complete snapshots or encoded
into a text representation, both of which are wasteful approaches.
Mercurial can efficiently handle deltas of files with arbitrary binary
contents; it doesn't need to treat text as special.</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec:concepts:txn"></a>3.2.2. 安全操作</h3></div></div></div>
<p><a name="x_2f7"></a>Mercurial only ever <span class="emphasis"><em>appends</em></span> data to the end of a revlog
file. It never modifies a section of a file after it has written it.  This
is both more robust and efficient than schemes that need to modify or
rewrite data.</p>
<p><a name="x_2f8"></a>In addition, Mercurial treats every write as part of a
<span class="emphasis"><em>transaction</em></span> that can span a number of files.  A
transaction is <span class="emphasis"><em>atomic</em></span>: either the entire transaction
succeeds and its effects are all visible to readers in one go, or the whole
thing is undone.  This guarantee of atomicity means that if you're running
two copies of Mercurial, where one is reading data and one is writing it,
the reader will never see a partially written result that might confuse it.</p>
<p><a name="x_2f9"></a>The fact that Mercurial only appends to files makes it easier to provide
this transactional guarantee.  The easier it is to do stuff like this, the
more confident you should be that it's done correctly.</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id511541"></a>3.2.3. 快速检索</h3></div></div></div>
<p><a name="x_2fa"></a>Mercurial cleverly avoids a pitfall common to all earlier revision control
systems: the problem of <span class="emphasis"><em>inefficient retrieval</em></span>. Most
revision control systems store the contents of a revision as an incremental
series of modifications against a “<span class="quote">snapshot</span>”.  To reconstruct a
specific revision, you must first read the snapshot, and then every one of
the revisions between the snapshot and your target revision.  The more
history that a file accumulates, the more revisions you must read, hence the
longer it takes to reconstruct a particular revision.</p>
<div class="figure">
<a name="fig:concepts:snapshot"></a><p class="title"><b>图 3.3. 版本日志的快照，以及增量差异</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/snapshot.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break"><p><a name="x_2fc"></a>The innovation that Mercurial applies to this problem is simple but
effective.  Once the cumulative amount of delta information stored since the
last snapshot exceeds a fixed threshold, it stores a new snapshot
(compressed, of course), instead of another delta.  This makes it possible
to reconstruct <span class="emphasis"><em>any</em></span> revision of a file quickly.  This
approach works so well that it has since been copied by several other
revision control systems.</p>
<p><a name="x_2fd"></a><a class="xref" href="behind-the-scenes.html#fig:concepts:snapshot" title="图 3.3. 版本日志的快照，以及增量差异">图 3.3 “版本日志的快照，以及增量差异”</a> illustrates the idea.  In an entry
in a revlog's index file, Mercurial stores the range of entries from the
data file that it must read to reconstruct a particular revision.</p>
<div class="sect3" lang="zh">
<div class="titlepage"><div><div><h4 class="title">
<a name="id511607"></a>3.2.3.1. 旁白: 视频压缩的影响</h4></div></div></div>
<p><a name="x_2fe"></a>If you're familiar with video compression or have ever watched a TV feed
through a digital cable or satellite service, you may know that most video
compression schemes store each frame of video as a delta against its
predecessor frame.  In addition, these schemes use “<span class="quote">lossy</span>”
compression techniques to increase the compression ratio, so visual errors
accumulate over the course of a number of inter-frame deltas.</p>
<p><a name="x_2ff"></a>Because it's possible for a video stream to “<span class="quote">drop out</span>”
occasionally due to signal glitches, and to limit the accumulation of
artefacts introduced by the lossy compression process, video encoders
periodically insert a complete frame (called a “<span class="quote">key frame</span>”)
into the video stream; the next delta is generated against that frame.  This
means that if the video signal gets interrupted, it will resume once the
next key frame is received.  Also, the accumulation of encoding errors
restarts anew with each key frame.</p>
</div>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id511642"></a>3.2.4. 鉴别和强完整性</h3></div></div></div>
<p><a name="x_300"></a>Along with delta or snapshot information, a revlog entry contains a
cryptographic hash of the data that it represents.  This makes it difficult
to forge the contents of a revision, and easy to detect accidental
corruption.</p>
<p><a name="x_301"></a>Hashes provide more than a mere check against corruption; they are used as
the identifiers for revisions.  The changeset identification hashes that you
see as an end user are from revisions of the changelog.  Although filelogs
and the manifest also use hashes, Mercurial only uses these behind the
scenes.</p>
<p><a name="x_302"></a>Mercurial verifies that hashes are correct when it retrieves file revisions
and when it pulls changes from another repository.  If it encounters an
integrity problem, it will complain and stop whatever it's doing.</p>
<p><a name="x_303"></a>In addition to the effect it has on retrieval efficiency, Mercurial's use of
periodic snapshots makes it more robust against partial data corruption.  If
a revlog becomes partly corrupted due to a hardware error or system bug,
it's often possible to reconstruct some or most revisions from the
uncorrupted sections of the revlog, both before and after the corrupted
section.  This would not be possible with a delta-only storage model.</p>
</div>
</div>
<div class="sect1" lang="zh">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id511680"></a>3.3. 修订历史，分支与合并</h2></div></div></div>
<p><a name="x_304"></a>Every entry in a Mercurial revlog knows the identity of its immediate
ancestor revision, usually referred to as its <span class="emphasis"><em>parent</em></span>.
In fact, a revision contains room for not one parent, but two.  Mercurial
uses a special hash, called the “<span class="quote">null ID</span>”, to represent the
idea “<span class="quote">there is no parent here</span>”.  This hash is simply a string
of zeroes.</p>
<p><a name="x_305"></a>In <a class="xref" href="behind-the-scenes.html#fig:concepts:revlog" title="图 3.4. 版本日志的设计结构">图 3.4 “版本日志的设计结构”</a>, you can see an example of the
conceptual structure of a revlog.  Filelogs, manifests, and changelogs all
have this same structure; they differ only in the kind of data stored in
each delta or snapshot.</p>
<p><a name="x_306"></a>The first revision in a revlog (at the bottom of the image)  has the null ID
in both of its parent slots.  For a “<span class="quote">normal</span>” revision, its
first parent slot contains the ID of its parent revision, and its second
contains the null ID, indicating that the revision has only one real
parent.  Any two revisions that have the same parent ID are branches.  A
revision that represents a merge between branches has two normal revision
IDs in its parent slots.</p>
<div class="figure">
<a name="fig:concepts:revlog"></a><p class="title"><b>图 3.4. 版本日志的设计结构</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/revlog.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break">
</div>
<div class="sect1" lang="zh">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id511749"></a>3.4. 工作目录</h2></div></div></div>
<p><a name="x_307"></a>In the working directory, Mercurial stores a snapshot of the files from the
repository as of a particular changeset.</p>
<p><a name="x_308"></a>The working directory “<span class="quote">knows</span>” which changeset it contains.
When you update the working directory to contain a particular changeset,
Mercurial looks up the appropriate revision of the manifest to find out
which files it was tracking at the time that changeset was committed, and
which revision of each file was then current.  It then recreates a copy of
each of those files, with the same contents it had when the changeset was
committed.</p>
<p><a name="x_309"></a>The <span class="emphasis"><em>dirstate</em></span> contains Mercurial's knowledge of the
working directory.  This details which changeset the working directory is
updated to, and all of the files that Mercurial is tracking in the working
directory.</p>
<p><a name="x_30a"></a>Just as a revision of a revlog has room for two parents, so that it can
represent either a normal revision (with one parent)  or a merge of two
earlier revisions, the dirstate has slots for two parents.  When you use the
<span class="command"><strong>hg update</strong></span> command, the changeset that you
update to is stored in the “<span class="quote">first parent</span>” slot, and the null ID
in the second. When you <span class="command"><strong>hg merge</strong></span> with
another changeset, the first parent remains unchanged, and the second parent
is filled in with the changeset you're merging with.  The <span class="command"><strong>hg parents</strong></span> command tells you what the parents of the
dirstate are.</p>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id511818"></a>3.4.1. 当你提交时发生的事情</h3></div></div></div>
<p><a name="x_30b"></a>The dirstate stores parent information for more than just book-keeping
purposes.  Mercurial uses the parents of the dirstate as <span class="emphasis"><em>the
parents of a new changeset</em></span> when you perform a commit.</p>
<div class="figure">
<a name="fig:concepts:wdir"></a><p class="title"><b>图 3.5. 工作目录可以有两个父亲</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/wdir.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break"><p><a name="x_30d"></a><a class="xref" href="behind-the-scenes.html#fig:concepts:wdir" title="图 3.5. 工作目录可以有两个父亲">图 3.5 “工作目录可以有两个父亲”</a> shows the normal state of the working
directory, where it has a single changeset as parent.  That changeset is the
<span class="emphasis"><em>tip</em></span>, the newest changeset in the repository that has no
children.</p>
<div class="figure">
<a name="fig:concepts:wdir-after-commit"></a><p class="title"><b>图 3.6. 提交之后，工作目录的父亲就改变了</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/wdir-after-commit.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break"><p><a name="x_30f"></a>It's useful to think of the working directory as “<span class="quote">the changeset I'm
about to commit</span>”.  Any files that you tell Mercurial that you've
added, removed, renamed, or copied will be reflected in that changeset, as
will modifications to any files that Mercurial is already tracking; the new
changeset will have the parents of the working directory as its parents.</p>
<p><a name="x_310"></a>After a commit, Mercurial will update the parents of the working directory,
so that the first parent is the ID of the new changeset, and the second is
the null ID.  This is shown in <a class="xref" href="behind-the-scenes.html#fig:concepts:wdir-after-commit" title="图 3.6. 提交之后，工作目录的父亲就改变了">图 3.6 “提交之后，工作目录的父亲就改变了”</a>. Mercurial doesn't touch any of
the files in the working directory when you commit; it just modifies the
dirstate to note its new parents.</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id511914"></a>3.4.2. 创建新顶点</h3></div></div></div>
<p><a name="x_311"></a>It's perfectly normal to update the working directory to a changeset other
than the current tip.  For example, you might want to know what your project
looked like last Tuesday, or you could be looking through changesets to see
which one introduced a bug.  In cases like this, the natural thing to do is
update the working directory to the changeset you're interested in, and then
examine the files in the working directory directly to see their contents as
they were when you committed that changeset.  The effect of this is shown in
<a class="xref" href="behind-the-scenes.html#fig:concepts:wdir-pre-branch" title="图 3.7. 同步到旧修改集的工作目录">图 3.7 “同步到旧修改集的工作目录”</a>.</p>
<div class="figure">
<a name="fig:concepts:wdir-pre-branch"></a><p class="title"><b>图 3.7. 同步到旧修改集的工作目录</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/wdir-pre-branch.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break"><p><a name="x_313"></a>Having updated the working directory to an older changeset, what happens if
you make some changes, and then commit? Mercurial behaves in the same way as
I outlined above.  The parents of the working directory become the parents
of the new changeset.  This new changeset has no children, so it becomes the
new tip.  And the repository now contains two changesets that have no
children; we call these <span class="emphasis"><em>heads</em></span>.  You can see the
structure that this creates in <a class="xref" href="behind-the-scenes.html#fig:concepts:wdir-branch" title="图 3.8. 对同步到旧修改集的工作目录提交之后">图 3.8 “对同步到旧修改集的工作目录提交之后”</a>.</p>
<div class="figure">
<a name="fig:concepts:wdir-branch"></a><p class="title"><b>图 3.8. 对同步到旧修改集的工作目录提交之后</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/wdir-branch.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="figs/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top">
<p><a name="x_315"></a>  If you're new to Mercurial, you should keep in mind a common
“<span class="quote">error</span>”, which is to use the <span class="command"><strong>hg
pull</strong></span> command without any options.  By default, the <span class="command"><strong>hg pull</strong></span> command <span class="emphasis"><em>does not</em></span> update
the working directory, so you'll bring new changesets into your repository,
but the working directory will stay synced at the same changeset as before
the pull.  If you make some changes and commit afterwards, you'll thus
create a new head, because your working directory isn't synced to whatever
the current tip is.</p>
<p><a name="x_316"></a>  I put the word “<span class="quote">error</span>” in quotes because all that you need to
do to rectify this situation is <span class="command"><strong>hg merge</strong></span>,
then <span class="command"><strong>hg commit</strong></span>.  In other words, this
almost never has negative consequences; it just surprises people.  I'll
discuss other ways to avoid this behaviour, and why Mercurial behaves in
this initially surprising way, later on.</p>
</td></tr>
</table></div>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id512052"></a>3.4.3. 合并顶点</h3></div></div></div>
<p><a name="x_317"></a>When you run the <span class="command"><strong>hg merge</strong></span> command,
Mercurial leaves the first parent of the working directory unchanged, and
sets the second parent to the changeset you're merging with, as shown in
<a class="xref" href="behind-the-scenes.html#fig:concepts:wdir-merge" title="图 3.9. 合并两个顶点">图 3.9 “合并两个顶点”</a>.</p>
<div class="figure">
<a name="fig:concepts:wdir-merge"></a><p class="title"><b>图 3.9. 合并两个顶点</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/wdir-merge.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break"><p><a name="x_319"></a>Mercurial also has to modify the working directory, to merge the files
managed in the two changesets.  Simplified a little, the merging process
goes like this, for every file in the manifests of both changesets.</p>
<div class="itemizedlist"><ul type="disc">
<li><p><a name="x_31a"></a>If neither changeset has modified a file, do nothing with that file.</p></li>
<li><p><a name="x_31b"></a>If one changeset has modified a file, and the other hasn't, create the
modified copy of the file in the working directory.</p></li>
<li><p><a name="x_31c"></a>If one changeset has removed a file, and the other hasn't (or has also
deleted it), delete the file from the working directory.</p></li>
<li><p><a name="x_31d"></a>If one changeset has removed a file, but the other has modified the file,
ask the user what to do: keep the modified file, or remove it?</p></li>
<li><p><a name="x_31e"></a>If both changesets have modified a file, invoke an external merge program to
choose the new contents for the merged file.  This may require input from
the user.</p></li>
<li><p><a name="x_31f"></a>If one changeset has modified a file, and the other has renamed or copied
the file, make sure that the changes follow the new name of the file.</p></li>
</ul></div>
<p><a name="x_320"></a>There are more details—merging has plenty of corner cases—but these are the
most common choices that are involved in a merge.  As you can see, most
cases are completely automatic, and indeed most merges finish automatically,
without requiring your input to resolve any conflicts.</p>
<p><a name="x_321"></a>When you're thinking about what happens when you commit after a merge, once
again the working directory is “<span class="quote">the changeset I'm about to
commit</span>”.  After the <span class="command"><strong>hg merge</strong></span> command
completes, the working directory has two parents; these will become the
parents of the new changeset.</p>
<p><a name="x_322"></a>Mercurial lets you perform multiple merges, but you must commit the results
of each individual merge as you go.  This is necessary because Mercurial
only tracks two parents for both revisions and the working directory.  While
it would be technically possible to merge multiple changesets at once, the
prospect of user confusion and making a terrible mess of a merge immediately
becomes overwhelming.</p>
</div>
</div>
<div class="sect1" lang="zh">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id512199"></a>3.5. 其它有趣的设计特性</h2></div></div></div>
<p><a name="x_323"></a>In the sections above, I've tried to highlight some of the most important
aspects of Mercurial's design, to illustrate that it pays careful attention
to reliability and performance.  However, the attention to detail doesn't
stop there.  There are a number of other aspects of Mercurial's construction
that I personally find interesting.  I'll detail a few of them here,
separate from the “<span class="quote">big ticket</span>” items above, so that if you're
interested, you can gain a better idea of the amount of thinking that goes
into a well-designed system.</p>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id512217"></a>3.5.1. 智能压缩</h3></div></div></div>
<p><a name="x_324"></a>When appropriate, Mercurial will store both snapshots and deltas in
compressed form.  It does this by always <span class="emphasis"><em>trying to</em></span>
compress a snapshot or delta, but only storing the compressed version if
it's smaller than the uncompressed version.</p>
<p><a name="x_325"></a>This means that Mercurial does “<span class="quote">the right thing</span>” when storing a
file whose native form is compressed, such as a <code class="literal">zip</code>
archive or a JPEG image.  When these types of files are compressed a second
time, the resulting file is usually bigger than the once-compressed form,
and so Mercurial will store the plain <code class="literal">zip</code> or JPEG.</p>
<p><a name="x_326"></a>Deltas between revisions of a compressed file are usually larger than
snapshots of the file, and Mercurial again does “<span class="quote">the right
thing</span>” in these cases.  It finds that such a delta exceeds the
threshold at which it should store a complete snapshot of the file, so it
stores the snapshot, again saving space compared to a naive delta-only
approach.</p>
<div class="sect3" lang="zh">
<div class="titlepage"><div><div><h4 class="title">
<a name="id512265"></a>3.5.1.1. 网络重新压缩</h4></div></div></div>
<p><a name="x_327"></a>When storing revisions on disk, Mercurial uses the “<span class="quote">deflate</span>”
compression algorithm (the same one used by the popular
<code class="literal">zip</code> archive format), which balances good speed with a
respectable compression ratio.  However, when transmitting revision data
over a network connection, Mercurial uncompresses the compressed revision
data.</p>
<p><a name="x_328"></a>If the connection is over HTTP, Mercurial recompresses the entire stream of
data using a compression algorithm that gives a better compression ratio
(the Burrows-Wheeler algorithm from the widely used <code class="literal">bzip2</code>
compression package).  This combination of algorithm and compression of the
entire stream (instead of a revision at a time) substantially reduces the
number of bytes to be transferred, yielding better network performance over
almost all kinds of network.</p>
<p><a name="x_329"></a>(If the connection is over <span class="command"><strong>ssh</strong></span>, Mercurial
<span class="emphasis"><em>doesn't</em></span> recompress the stream, because
<span class="command"><strong>ssh</strong></span> can already do this itself.)</p>
</div>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id512322"></a>3.5.2. 读写顺序与原子性</h3></div></div></div>
<p><a name="x_32a"></a>Appending to files isn't the whole story when it comes to guaranteeing that
a reader won't see a partial write.  If you recall <a class="xref" href="behind-the-scenes.html#fig:concepts:metadata" title="图 3.2. 元数据之间的关系">图 3.2 “元数据之间的关系”</a>, revisions in the changelog point to
revisions in the manifest, and revisions in the manifest point to revisions
in filelogs.  This hierarchy is deliberate.</p>
<p><a name="x_32b"></a>A writer starts a transaction by writing filelog and manifest data, and
doesn't write any changelog data until those are finished.  A reader starts
by reading changelog data, then manifest data, followed by filelog data.</p>
<p><a name="x_32c"></a>Since the writer has always finished writing filelog and manifest data
before it writes to the changelog, a reader will never read a pointer to a
partially written manifest revision from the changelog, and it will never
read a pointer to a partially written filelog revision from the manifest.</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id512356"></a>3.5.3. 并发访问</h3></div></div></div>
<p><a name="x_32d"></a>The read/write ordering and atomicity guarantees mean that Mercurial never
needs to <span class="emphasis"><em>lock</em></span> a repository when it's reading data, even
if the repository is being written to while the read is occurring. This has
a big effect on scalability; you can have an arbitrary number of Mercurial
processes safely reading data from a repository safely all at once, no
matter whether it's being written to or not.</p>
<p><a name="x_32e"></a>The lockless nature of reading means that if you're sharing a repository on
a multi-user system, you don't need to grant other local users permission to
<span class="emphasis"><em>write</em></span> to your repository in order for them to be able
to clone it or pull changes from it; they only need
<span class="emphasis"><em>read</em></span> permission.  (This is <span class="emphasis"><em>not</em></span> a
common feature among revision control systems, so don't take it for granted!
Most require readers to be able to lock a repository to access it safely,
and this requires write permission on at least one directory, which of
course makes for all kinds of nasty and annoying security and administrative
problems.)</p>
<p><a name="x_32f"></a>Mercurial uses locks to ensure that only one process can write to a
repository at a time (the locking mechanism is safe even over filesystems
that are notoriously hostile to locking, such as NFS).  If a repository is
locked, a writer will wait for a while to retry if the repository becomes
unlocked, but if the repository remains locked for too long, the process
attempting to write will time out after a while. This means that your daily
automated scripts won't get stuck forever and pile up if a system crashes
unnoticed, for example.  (Yes, the timeout is configurable, from zero to
infinity.)</p>
<div class="sect3" lang="zh">
<div class="titlepage"><div><div><h4 class="title">
<a name="id512403"></a>3.5.3.1. 安全的目录状态访问</h4></div></div></div>
<p><a name="x_330"></a>As with revision data, Mercurial doesn't take a lock to read the dirstate
file; it does acquire a lock to write it.  To avoid the possibility of
reading a partially written copy of the dirstate file, Mercurial writes to a
file with a unique name in the same directory as the dirstate file, then
renames the temporary file atomically to <code class="filename">dirstate</code>.  The
file named <code class="filename">dirstate</code> is thus guaranteed to be complete,
not partially written.</p>
</div>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id512430"></a>3.5.4. 避免查找</h3></div></div></div>
<p><a name="x_331"></a>Critical to Mercurial's performance is the avoidance of seeks of the disk
head, since any seek is far more expensive than even a comparatively large
read operation.</p>
<p><a name="x_332"></a>This is why, for example, the dirstate is stored in a single file.  If there
were a dirstate file per directory that Mercurial tracked, the disk would
seek once per directory.  Instead, Mercurial reads the entire single
dirstate file in one step.</p>
<p><a name="x_333"></a>Mercurial also uses a “<span class="quote">copy on write</span>” scheme when cloning a
repository on local storage.  Instead of copying every revlog file from the
old repository into the new repository, it makes a “<span class="quote">hard link</span>”,
which is a shorthand way to say “<span class="quote">these two names point to the same
file</span>”.  When Mercurial is about to write to one of a revlog's files,
it checks to see if the number of names pointing at the file is greater than
one.  If it is, more than one repository is using the file, so Mercurial
makes a new copy of the file that is private to this repository.</p>
<p><a name="x_334"></a>A few revision control developers have pointed out that this idea of making
a complete private copy of a file is not very efficient in its use of
storage.  While this is true, storage is cheap, and this method gives the
highest performance while deferring most book-keeping to the operating
system.  An alternative scheme would most likely reduce performance and
increase the complexity of the software, each of which is much more
important to the “<span class="quote">feel</span>” of day-to-day use.</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="id512483"></a>3.5.5. 目录状态的其它内容</h3></div></div></div>
<p><a name="x_335"></a>Because Mercurial doesn't force you to tell it when you're modifying a file,
it uses the dirstate to store some extra information so it can determine
efficiently whether you have modified a file.  For each file in the working
directory, it stores the time that it last modified the file itself, and the
size of the file at that time.</p>
<p><a name="x_336"></a>When you explicitly <span class="command"><strong>hg add</strong></span>, <span class="command"><strong>hg remove</strong></span>, <span class="command"><strong>hg
rename</strong></span> or <span class="command"><strong>hg copy</strong></span> files,
Mercurial updates the dirstate so that it knows what to do with those files
when you commit.</p>
<p><a name="x_337"></a>When Mercurial is checking the states of files in the working directory, it
first checks a file's modification time.  If that has not changed, the file
must not have been modified.  If the file's size has changed, the file must
have been modified.  If the modification time has changed, but the size has
not, only then does Mercurial need to read the actual contents of the file
to see if they've changed. Storing these few extra pieces of information
dramatically reduces the amount of data that Mercurial needs to read, which
yields large performance improvements compared to other revision control
systems.</p>
</div>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="a-tour-of-mercurial-merging-work.html">上一页</a> </td>
<td width="20%" align="center"> </td>
<td width="40%" align="right"> <a accesskey="n" href="mercurial-in-daily-use.html">下一页</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">第 2 章 Mercurial 教程: 合并工作 </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td>
<td width="40%" align="right" valign="top"> 第 4 章 Mercurial 的日常使用</td>
</tr>
</table>
</div>
</body>
</html>
