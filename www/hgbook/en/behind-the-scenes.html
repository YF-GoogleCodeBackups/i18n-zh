<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Chapter 3. Behind the scenes</title>
<link rel="stylesheet" href="hgbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.74.3">
<link rel="home" href="index.html" title="Mercurial: The Definitive Guide">
<link rel="up" href="index.html" title="Mercurial: The Definitive Guide">
<link rel="prev" href="a-tour-of-mercurial-merging-work.html" title="Chapter 2. A tour of Mercurial: merging work">
<link rel="next" href="mercurial-in-daily-use.html" title="Chapter 4. Mercurial in daily use">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">Chapter 3. Behind the scenes</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="a-tour-of-mercurial-merging-work.html">Prev</a> </td>
<th width="60%" align="center"> </th>
<td width="20%" align="right"> <a accesskey="n" href="mercurial-in-daily-use.html">Next</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="chapter" lang="en">
<div class="titlepage"><div><div><h2 class="title">
<a name="chap:concepts"></a>Chapter 3. Behind the scenes</h2></div></div></div>
<div class="toc">
<p><b>Table of Contents</b></p>
<dl>
<dt><span class="sect1"><a href="behind-the-scenes.html#id517580">3.1. Mercurial's historical record</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="behind-the-scenes.html#id517586">3.1.1. Tracking the history of a single file</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id517669">3.1.2. Managing tracked files</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id517686">3.1.3. Recording changeset information</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id517703">3.1.4. Relationships between revisions</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="behind-the-scenes.html#id517771">3.2. Safe, efficient storage</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="behind-the-scenes.html#id517786">3.2.1. Efficient storage</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#sec:concepts:txn">3.2.2. Safe operation</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id517853">3.2.3. Fast retrieval</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id517956">3.2.4. Identification and strong integrity</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="behind-the-scenes.html#id517994">3.3. Revision history, branching, and merging</a></span></dt>
<dt><span class="sect1"><a href="behind-the-scenes.html#id518065">3.4. The working directory</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="behind-the-scenes.html#id518134">3.4.1. What happens when you commit</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id518234">3.4.2. Creating a new head</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id518380">3.4.3. Merging heads</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="behind-the-scenes.html#id518528">3.5. Other interesting design features</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="behind-the-scenes.html#id518546">3.5.1. Clever compression</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id518652">3.5.2. Read/write ordering and atomicity</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id518686">3.5.3. Concurrent access</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id518760">3.5.4. Avoiding seeks</a></span></dt>
<dt><span class="sect2"><a href="behind-the-scenes.html#id518812">3.5.5. Other contents of the dirstate</a></span></dt>
</dl></dd>
</dl>
</div>
<p><a name="x_2e8"></a>Unlike many revision control systems, the concepts upon which
    Mercurial is built are simple enough that it's easy to understand
    how the software really works.  Knowing this certainly isn't
    necessary, but I find it useful to have a “<span class="quote">mental
      model</span>” of what's going on.</p>
<p><a name="x_2e9"></a>This understanding gives me confidence that Mercurial has been
    carefully designed to be both <span class="emphasis"><em>safe</em></span> and
    <span class="emphasis"><em>efficient</em></span>.  And just as importantly, if it's
    easy for me to retain a good idea of what the software is doing
    when I perform a revision control task, I'm less likely to be
    surprised by its behaviour.</p>
<p><a name="x_2ea"></a>In this chapter, we'll initially cover the core concepts
    behind Mercurial's design, then continue to discuss some of the
    interesting details of its implementation.</p>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id517580"></a>3.1. Mercurial's historical record</h2></div></div></div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id517586"></a>3.1.1. Tracking the history of a single file</h3></div></div></div>
<p><a name="x_2eb"></a>When Mercurial tracks modifications to a file, it stores
	the history of that file in a metadata object called a
	<span class="emphasis"><em>filelog</em></span>.  Each entry in the filelog
	contains enough information to reconstruct one revision of the
	file that is being tracked.  Filelogs are stored as files in
	the <code class="filename">.hg/store/data</code> directory.  A
	filelog contains two kinds of information: revision data, and
	an index to help Mercurial to find a revision
	efficiently.</p>
<p><a name="x_2ec"></a>A file that is large, or has a lot of history, has its
	filelog stored in separate data
	(“<span class="quote"><code class="literal">.d</code></span>” suffix) and index
	(“<span class="quote"><code class="literal">.i</code></span>” suffix) files.  For
	small files without much history, the revision data and index
	are combined in a single “<span class="quote"><code class="literal">.i</code></span>”
	file.  The correspondence between a file in the working
	directory and the filelog that tracks its history in the
	repository is illustrated in <a class="xref" href="behind-the-scenes.html#fig:concepts:filelog" title="Figure 3.1. Relationships between files in working directory and filelogs in repository">Figure 3.1, “Relationships between files in working directory and
	  filelogs in repository”</a>.</p>
<div class="figure">
<a name="fig:concepts:filelog"></a><p class="title"><b>Figure 3.1. Relationships between files in working directory and
	  filelogs in repository</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/filelog.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break">
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id517669"></a>3.1.2. Managing tracked files</h3></div></div></div>
<p><a name="x_2ee"></a>Mercurial uses a structure called a
	<span class="emphasis"><em>manifest</em></span> to collect together information
	about the files that it tracks.  Each entry in the manifest
	contains information about the files present in a single
	changeset.  An entry records which files are present in the
	changeset, the revision of each file, and a few other pieces
	of file metadata.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id517686"></a>3.1.3. Recording changeset information</h3></div></div></div>
<p><a name="x_2ef"></a>The <span class="emphasis"><em>changelog</em></span> contains information
	about each changeset.  Each revision records who committed a
	change, the changeset comment, other pieces of
	changeset-related information, and the revision of the
	manifest to use.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id517703"></a>3.1.4. Relationships between revisions</h3></div></div></div>
<p><a name="x_2f0"></a>Within a changelog, a manifest, or a filelog, each
	revision stores a pointer to its immediate parent (or to its
	two parents, if it's a merge revision).  As I mentioned above,
	there are also relationships between revisions
	<span class="emphasis"><em>across</em></span> these structures, and they are
	hierarchical in nature.</p>
<p><a name="x_2f1"></a>For every changeset in a repository, there is exactly one
	revision stored in the changelog.  Each revision of the
	changelog contains a pointer to a single revision of the
	manifest.  A revision of the manifest stores a pointer to a
	single revision of each filelog tracked when that changeset
	was created.  These relationships are illustrated in
	<a class="xref" href="behind-the-scenes.html#fig:concepts:metadata" title="Figure 3.2. Metadata relationships">Figure 3.2, “Metadata relationships”</a>.</p>
<div class="figure">
<a name="fig:concepts:metadata"></a><p class="title"><b>Figure 3.2. Metadata relationships</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/metadata.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break"><p><a name="x_2f3"></a>As the illustration shows, there is
	<span class="emphasis"><em>not</em></span> a “<span class="quote">one to one</span>”
	relationship between revisions in the changelog, manifest, or
	filelog. If the manifest hasn't changed between two
	changesets, the changelog entries for those changesets will
	point to the same revision of the manifest.  If a file that
	Mercurial tracks hasn't changed between two changesets, the
	entry for that file in the two revisions of the manifest will
	point to the same revision of its filelog.</p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id517771"></a>3.2. Safe, efficient storage</h2></div></div></div>
<p><a name="x_2f4"></a>The underpinnings of changelogs, manifests, and filelogs are
      provided by a single structure called the
      <span class="emphasis"><em>revlog</em></span>.</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id517786"></a>3.2.1. Efficient storage</h3></div></div></div>
<p><a name="x_2f5"></a>The revlog provides efficient storage of revisions using a
	<span class="emphasis"><em>delta</em></span> mechanism.  Instead of storing a
	complete copy of a file for each revision, it stores the
	changes needed to transform an older revision into the new
	revision.  For many kinds of file data, these deltas are
	typically a fraction of a percent of the size of a full copy
	of a file.</p>
<p><a name="x_2f6"></a>Some obsolete revision control systems can only work with
	deltas of text files.  They must either store binary files as
	complete snapshots or encoded into a text representation, both
	of which are wasteful approaches.  Mercurial can efficiently
	handle deltas of files with arbitrary binary contents; it
	doesn't need to treat text as special.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="sec:concepts:txn"></a>3.2.2. Safe operation</h3></div></div></div>
<p><a name="x_2f7"></a>Mercurial only ever <span class="emphasis"><em>appends</em></span> data to
	the end of a revlog file. It never modifies a section of a
	file after it has written it.  This is both more robust and
	efficient than schemes that need to modify or rewrite
	data.</p>
<p><a name="x_2f8"></a>In addition, Mercurial treats every write as part of a
	<span class="emphasis"><em>transaction</em></span> that can span a number of
	files.  A transaction is <span class="emphasis"><em>atomic</em></span>: either
	the entire transaction succeeds and its effects are all
	visible to readers in one go, or the whole thing is undone.
	This guarantee of atomicity means that if you're running two
	copies of Mercurial, where one is reading data and one is
	writing it, the reader will never see a partially written
	result that might confuse it.</p>
<p><a name="x_2f9"></a>The fact that Mercurial only appends to files makes it
	easier to provide this transactional guarantee.  The easier it
	is to do stuff like this, the more confident you should be
	that it's done correctly.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id517853"></a>3.2.3. Fast retrieval</h3></div></div></div>
<p><a name="x_2fa"></a>Mercurial cleverly avoids a pitfall common to all earlier
	revision control systems: the problem of <span class="emphasis"><em>inefficient
	  retrieval</em></span>. Most revision control systems store
	the contents of a revision as an incremental series of
	modifications against a “<span class="quote">snapshot</span>”.  To
	reconstruct a specific revision, you must first read the
	snapshot, and then every one of the revisions between the
	snapshot and your target revision.  The more history that a
	file accumulates, the more revisions you must read, hence the
	longer it takes to reconstruct a particular revision.</p>
<div class="figure">
<a name="fig:concepts:snapshot"></a><p class="title"><b>Figure 3.3. Snapshot of a revlog, with incremental deltas</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/snapshot.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break"><p><a name="x_2fc"></a>The innovation that Mercurial applies to this problem is
	simple but effective.  Once the cumulative amount of delta
	information stored since the last snapshot exceeds a fixed
	threshold, it stores a new snapshot (compressed, of course),
	instead of another delta.  This makes it possible to
	reconstruct <span class="emphasis"><em>any</em></span> revision of a file
	quickly.  This approach works so well that it has since been
	copied by several other revision control systems.</p>
<p><a name="x_2fd"></a><a class="xref" href="behind-the-scenes.html#fig:concepts:snapshot" title="Figure 3.3. Snapshot of a revlog, with incremental deltas">Figure 3.3, “Snapshot of a revlog, with incremental deltas”</a> illustrates
	the idea.  In an entry in a revlog's index file, Mercurial
	stores the range of entries from the data file that it must
	read to reconstruct a particular revision.</p>
<div class="sect3" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id517920"></a>3.2.3.1. Aside: the influence of video compression</h4></div></div></div>
<p><a name="x_2fe"></a>If you're familiar with video compression or have ever
	  watched a TV feed through a digital cable or satellite
	  service, you may know that most video compression schemes
	  store each frame of video as a delta against its predecessor
	  frame.  In addition, these schemes use “<span class="quote">lossy</span>”
	  compression techniques to increase the compression ratio, so
	  visual errors accumulate over the course of a number of
	  inter-frame deltas.</p>
<p><a name="x_2ff"></a>Because it's possible for a video stream to “<span class="quote">drop
	    out</span>” occasionally due to signal glitches, and to
	  limit the accumulation of artefacts introduced by the lossy
	  compression process, video encoders periodically insert a
	  complete frame (called a “<span class="quote">key frame</span>”) into the
	  video stream; the next delta is generated against that
	  frame.  This means that if the video signal gets
	  interrupted, it will resume once the next key frame is
	  received.  Also, the accumulation of encoding errors
	  restarts anew with each key frame.</p>
</div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id517956"></a>3.2.4. Identification and strong integrity</h3></div></div></div>
<p><a name="x_300"></a>Along with delta or snapshot information, a revlog entry
	contains a cryptographic hash of the data that it represents.
	This makes it difficult to forge the contents of a revision,
	and easy to detect accidental corruption.</p>
<p><a name="x_301"></a>Hashes provide more than a mere check against corruption;
	they are used as the identifiers for revisions.  The changeset
	identification hashes that you see as an end user are from
	revisions of the changelog.  Although filelogs and the
	manifest also use hashes, Mercurial only uses these behind the
	scenes.</p>
<p><a name="x_302"></a>Mercurial verifies that hashes are correct when it
	retrieves file revisions and when it pulls changes from
	another repository.  If it encounters an integrity problem, it
	will complain and stop whatever it's doing.</p>
<p><a name="x_303"></a>In addition to the effect it has on retrieval efficiency,
	Mercurial's use of periodic snapshots makes it more robust
	against partial data corruption.  If a revlog becomes partly
	corrupted due to a hardware error or system bug, it's often
	possible to reconstruct some or most revisions from the
	uncorrupted sections of the revlog, both before and after the
	corrupted section.  This would not be possible with a
	delta-only storage model.</p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id517994"></a>3.3. Revision history, branching, and merging</h2></div></div></div>
<p><a name="x_304"></a>Every entry in a Mercurial revlog knows the identity of its
      immediate ancestor revision, usually referred to as its
      <span class="emphasis"><em>parent</em></span>.  In fact, a revision contains room
      for not one parent, but two.  Mercurial uses a special hash,
      called the “<span class="quote">null ID</span>”, to represent the idea
      “<span class="quote">there is no parent here</span>”.  This hash is simply a
      string of zeroes.</p>
<p><a name="x_305"></a>In <a class="xref" href="behind-the-scenes.html#fig:concepts:revlog" title="Figure 3.4. The conceptual structure of a revlog">Figure 3.4, “The conceptual structure of a revlog”</a>, you can see
      an example of the conceptual structure of a revlog.  Filelogs,
      manifests, and changelogs all have this same structure; they
      differ only in the kind of data stored in each delta or
      snapshot.</p>
<p><a name="x_306"></a>The first revision in a revlog (at the bottom of the image)
      has the null ID in both of its parent slots.  For a
      “<span class="quote">normal</span>” revision, its first parent slot contains
      the ID of its parent revision, and its second contains the null
      ID, indicating that the revision has only one real parent.  Any
      two revisions that have the same parent ID are branches.  A
      revision that represents a merge between branches has two normal
      revision IDs in its parent slots.</p>
<div class="figure">
<a name="fig:concepts:revlog"></a><p class="title"><b>Figure 3.4. The conceptual structure of a revlog</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/revlog.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break">
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id518065"></a>3.4. The working directory</h2></div></div></div>
<p><a name="x_307"></a>In the working directory, Mercurial stores a snapshot of the
      files from the repository as of a particular changeset.</p>
<p><a name="x_308"></a>The working directory “<span class="quote">knows</span>” which changeset
      it contains.  When you update the working directory to contain a
      particular changeset, Mercurial looks up the appropriate
      revision of the manifest to find out which files it was tracking
      at the time that changeset was committed, and which revision of
      each file was then current.  It then recreates a copy of each of
      those files, with the same contents it had when the changeset
      was committed.</p>
<p><a name="x_309"></a>The <span class="emphasis"><em>dirstate</em></span> contains Mercurial's
      knowledge of the working directory.  This details which
      changeset the working directory is updated to, and all of the
      files that Mercurial is tracking in the working
      directory.</p>
<p><a name="x_30a"></a>Just as a revision of a revlog has room for two parents, so
      that it can represent either a normal revision (with one parent)
      or a merge of two earlier revisions, the dirstate has slots for
      two parents.  When you use the <span class="command"><strong>hg
	update</strong></span> command, the changeset that you update to is
      stored in the “<span class="quote">first parent</span>” slot, and the null ID
      in the second. When you <span class="command"><strong>hg
	merge</strong></span> with another changeset, the first parent
      remains unchanged, and the second parent is filled in with the
      changeset you're merging with.  The <span class="command"><strong>hg
	parents</strong></span> command tells you what the parents of the
      dirstate are.</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id518134"></a>3.4.1. What happens when you commit</h3></div></div></div>
<p><a name="x_30b"></a>The dirstate stores parent information for more than just
	book-keeping purposes.  Mercurial uses the parents of the
	dirstate as <span class="emphasis"><em>the parents of a new
	  changeset</em></span> when you perform a commit.</p>
<div class="figure">
<a name="fig:concepts:wdir"></a><p class="title"><b>Figure 3.5. The working directory can have two parents</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/wdir.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break"><p><a name="x_30d"></a><a class="xref" href="behind-the-scenes.html#fig:concepts:wdir" title="Figure 3.5. The working directory can have two parents">Figure 3.5, “The working directory can have two parents”</a> shows the
	normal state of the working directory, where it has a single
	changeset as parent.  That changeset is the
	<span class="emphasis"><em>tip</em></span>, the newest changeset in the
	repository that has no children.</p>
<div class="figure">
<a name="fig:concepts:wdir-after-commit"></a><p class="title"><b>Figure 3.6. The working directory gains new parents after a
	  commit</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/wdir-after-commit.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break"><p><a name="x_30f"></a>It's useful to think of the working directory as
	“<span class="quote">the changeset I'm about to commit</span>”.  Any files
	that you tell Mercurial that you've added, removed, renamed,
	or copied will be reflected in that changeset, as will
	modifications to any files that Mercurial is already tracking;
	the new changeset will have the parents of the working
	directory as its parents.</p>
<p><a name="x_310"></a>After a commit, Mercurial will update the
	parents of the working directory, so that the first parent is
	the ID of the new changeset, and the second is the null ID.
	This is shown in <a class="xref" href="behind-the-scenes.html#fig:concepts:wdir-after-commit" title="Figure 3.6. The working directory gains new parents after a commit">Figure 3.6, “The working directory gains new parents after a
	  commit”</a>. Mercurial
	doesn't touch any of the files in the working directory when
	you commit; it just modifies the dirstate to note its new
	parents.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id518234"></a>3.4.2. Creating a new head</h3></div></div></div>
<p><a name="x_311"></a>It's perfectly normal to update the working directory to a
	changeset other than the current tip.  For example, you might
	want to know what your project looked like last Tuesday, or
	you could be looking through changesets to see which one
	introduced a bug.  In cases like this, the natural thing to do
	is update the working directory to the changeset you're
	interested in, and then examine the files in the working
	directory directly to see their contents as they were when you
	committed that changeset.  The effect of this is shown in
	<a class="xref" href="behind-the-scenes.html#fig:concepts:wdir-pre-branch" title="Figure 3.7. The working directory, updated to an older changeset">Figure 3.7, “The working directory, updated to an older
	  changeset”</a>.</p>
<div class="figure">
<a name="fig:concepts:wdir-pre-branch"></a><p class="title"><b>Figure 3.7. The working directory, updated to an older
	  changeset</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/wdir-pre-branch.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break"><p><a name="x_313"></a>Having updated the working directory to an
	older changeset, what happens if you make some changes, and
	then commit?  Mercurial behaves in the same way as I outlined
	above.  The parents of the working directory become the
	parents of the new changeset.  This new changeset has no
	children, so it becomes the new tip.  And the repository now
	contains two changesets that have no children; we call these
	<span class="emphasis"><em>heads</em></span>.  You can see the structure that
	this creates in <a class="xref" href="behind-the-scenes.html#fig:concepts:wdir-branch" title="Figure 3.8. After a commit made while synced to an older changeset">Figure 3.8, “After a commit made while synced to an older
	  changeset”</a>.</p>
<div class="figure">
<a name="fig:concepts:wdir-branch"></a><p class="title"><b>Figure 3.8. After a commit made while synced to an older
	  changeset</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/wdir-branch.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="figs/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p><a name="x_315"></a>  If you're new to Mercurial, you should keep in mind a
	  common “<span class="quote">error</span>”, which is to use the <span class="command"><strong>hg pull</strong></span> command without any
	  options.  By default, the <span class="command"><strong>hg
	    pull</strong></span> command <span class="emphasis"><em>does not</em></span>
	  update the working directory, so you'll bring new changesets
	  into your repository, but the working directory will stay
	  synced at the same changeset as before the pull.  If you
	  make some changes and commit afterwards, you'll thus create
	  a new head, because your working directory isn't synced to
	  whatever the current tip is.</p>
<p><a name="x_316"></a>  I put the word “<span class="quote">error</span>” in quotes because
	  all that you need to do to rectify this situation is
	  <span class="command"><strong>hg merge</strong></span>, then <span class="command"><strong>hg commit</strong></span>.  In other words, this
	  almost never has negative consequences; it just surprises
	  people.  I'll discuss other ways to avoid this behaviour,
	  and why Mercurial behaves in this initially surprising way,
	  later on.</p>
</td></tr>
</table></div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id518380"></a>3.4.3. Merging heads</h3></div></div></div>
<p><a name="x_317"></a>When you run the <span class="command"><strong>hg
	  merge</strong></span> command, Mercurial leaves the first parent
	of the working directory unchanged, and sets the second parent
	to the changeset you're merging with, as shown in <a class="xref" href="behind-the-scenes.html#fig:concepts:wdir-merge" title="Figure 3.9. Merging two heads">Figure 3.9, “Merging two heads”</a>.</p>
<div class="figure">
<a name="fig:concepts:wdir-merge"></a><p class="title"><b>Figure 3.9. Merging two heads</b></p>
<div class="figure-contents"><div class="mediaobject"><img src="figs/wdir-merge.png" alt="XXX add text"></div></div>
</div>
<br class="figure-break"><p><a name="x_319"></a>Mercurial also has to modify the working directory, to
	merge the files managed in the two changesets.  Simplified a
	little, the merging process goes like this, for every file in
	the manifests of both changesets.</p>
<div class="itemizedlist"><ul type="disc">
<li><p><a name="x_31a"></a>If neither changeset has modified a file, do
	    nothing with that file.</p></li>
<li><p><a name="x_31b"></a>If one changeset has modified a file, and the
	    other hasn't, create the modified copy of the file in the
	    working directory.</p></li>
<li><p><a name="x_31c"></a>If one changeset has removed a file, and the
	    other hasn't (or has also deleted it), delete the file
	    from the working directory.</p></li>
<li><p><a name="x_31d"></a>If one changeset has removed a file, but the
	    other has modified the file, ask the user what to do: keep
	    the modified file, or remove it?</p></li>
<li><p><a name="x_31e"></a>If both changesets have modified a file,
	    invoke an external merge program to choose the new
	    contents for the merged file.  This may require input from
	    the user.</p></li>
<li><p><a name="x_31f"></a>If one changeset has modified a file, and the
	    other has renamed or copied the file, make sure that the
	    changes follow the new name of the file.</p></li>
</ul></div>
<p><a name="x_320"></a>There are more details—merging has plenty of corner
	cases—but these are the most common choices that are
	involved in a merge.  As you can see, most cases are
	completely automatic, and indeed most merges finish
	automatically, without requiring your input to resolve any
	conflicts.</p>
<p><a name="x_321"></a>When you're thinking about what happens when you commit
	after a merge, once again the working directory is “<span class="quote">the
	  changeset I'm about to commit</span>”.  After the <span class="command"><strong>hg merge</strong></span> command completes, the
	working directory has two parents; these will become the
	parents of the new changeset.</p>
<p><a name="x_322"></a>Mercurial lets you perform multiple merges, but you must
	commit the results of each individual merge as you go.  This
	is necessary because Mercurial only tracks two parents for
	both revisions and the working directory.  While it would be
	technically possible to merge multiple changesets at once, the
	prospect of user confusion and making a terrible mess of a
	merge immediately becomes overwhelming.</p>
</div>
</div>
<div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id518528"></a>3.5. Other interesting design features</h2></div></div></div>
<p><a name="x_323"></a>In the sections above, I've tried to highlight some of the
      most important aspects of Mercurial's design, to illustrate that
      it pays careful attention to reliability and performance.
      However, the attention to detail doesn't stop there.  There are
      a number of other aspects of Mercurial's construction that I
      personally find interesting.  I'll detail a few of them here,
      separate from the “<span class="quote">big ticket</span>” items above, so that
      if you're interested, you can gain a better idea of the amount
      of thinking that goes into a well-designed system.</p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id518546"></a>3.5.1. Clever compression</h3></div></div></div>
<p><a name="x_324"></a>When appropriate, Mercurial will store both snapshots and
	deltas in compressed form.  It does this by always
	<span class="emphasis"><em>trying to</em></span> compress a snapshot or delta,
	but only storing the compressed version if it's smaller than
	the uncompressed version.</p>
<p><a name="x_325"></a>This means that Mercurial does “<span class="quote">the right
	  thing</span>” when storing a file whose native form is
	compressed, such as a <code class="literal">zip</code> archive or a JPEG
	image.  When these types of files are compressed a second
	time, the resulting file is usually bigger than the
	once-compressed form, and so Mercurial will store the plain
	<code class="literal">zip</code> or JPEG.</p>
<p><a name="x_326"></a>Deltas between revisions of a compressed file are usually
	larger than snapshots of the file, and Mercurial again does
	“<span class="quote">the right thing</span>” in these cases.  It finds that
	such a delta exceeds the threshold at which it should store a
	complete snapshot of the file, so it stores the snapshot,
	again saving space compared to a naive delta-only
	approach.</p>
<div class="sect3" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id518595"></a>3.5.1.1. Network recompression</h4></div></div></div>
<p><a name="x_327"></a>When storing revisions on disk, Mercurial uses the
	  “<span class="quote">deflate</span>” compression algorithm (the same one
	  used by the popular <code class="literal">zip</code> archive format),
	  which balances good speed with a respectable compression
	  ratio.  However, when transmitting revision data over a
	  network connection, Mercurial uncompresses the compressed
	  revision data.</p>
<p><a name="x_328"></a>If the connection is over HTTP, Mercurial recompresses
	  the entire stream of data using a compression algorithm that
	  gives a better compression ratio (the Burrows-Wheeler
	  algorithm from the widely used <code class="literal">bzip2</code>
	  compression package).  This combination of algorithm and
	  compression of the entire stream (instead of a revision at a
	  time) substantially reduces the number of bytes to be
	  transferred, yielding better network performance over almost
	  all kinds of network.</p>
<p><a name="x_329"></a>(If the connection is over <span class="command"><strong>ssh</strong></span>,
	  Mercurial <span class="emphasis"><em>doesn't</em></span> recompress the
	  stream, because <span class="command"><strong>ssh</strong></span> can already do this
	  itself.)</p>
</div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id518652"></a>3.5.2. Read/write ordering and atomicity</h3></div></div></div>
<p><a name="x_32a"></a>Appending to files isn't the whole story when
	it comes to guaranteeing that a reader won't see a partial
	write.  If you recall <a class="xref" href="behind-the-scenes.html#fig:concepts:metadata" title="Figure 3.2. Metadata relationships">Figure 3.2, “Metadata relationships”</a>,
	revisions in
	the changelog point to revisions in the manifest, and
	revisions in the manifest point to revisions in filelogs.
	This hierarchy is deliberate.</p>
<p><a name="x_32b"></a>A writer starts a transaction by writing filelog and
	manifest data, and doesn't write any changelog data until
	those are finished.  A reader starts by reading changelog
	data, then manifest data, followed by filelog data.</p>
<p><a name="x_32c"></a>Since the writer has always finished writing filelog and
	manifest data before it writes to the changelog, a reader will
	never read a pointer to a partially written manifest revision
	from the changelog, and it will never read a pointer to a
	partially written filelog revision from the manifest.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id518686"></a>3.5.3. Concurrent access</h3></div></div></div>
<p><a name="x_32d"></a>The read/write ordering and atomicity guarantees mean that
	Mercurial never needs to <span class="emphasis"><em>lock</em></span> a
	repository when it's reading data, even if the repository is
	being written to while the read is occurring. This has a big
	effect on scalability; you can have an arbitrary number of
	Mercurial processes safely reading data from a repository
	safely all at once, no matter whether it's being written to or
	not.</p>
<p><a name="x_32e"></a>The lockless nature of reading means that if you're
	sharing a repository on a multi-user system, you don't need to
	grant other local users permission to
	<span class="emphasis"><em>write</em></span> to your repository in order for
	them to be able to clone it or pull changes from it; they only
	need <span class="emphasis"><em>read</em></span> permission.  (This is
	<span class="emphasis"><em>not</em></span> a common feature among revision
	control systems, so don't take it for granted!  Most require
	readers to be able to lock a repository to access it safely,
	and this requires write permission on at least one directory,
	which of course makes for all kinds of nasty and annoying
	security and administrative problems.)</p>
<p><a name="x_32f"></a>Mercurial uses locks to ensure that only one process can
	write to a repository at a time (the locking mechanism is safe
	even over filesystems that are notoriously hostile to locking,
	such as NFS).  If a repository is locked, a writer will wait
	for a while to retry if the repository becomes unlocked, but
	if the repository remains locked for too long, the process
	attempting to write will time out after a while. This means
	that your daily automated scripts won't get stuck forever and
	pile up if a system crashes unnoticed, for example.  (Yes, the
	timeout is configurable, from zero to infinity.)</p>
<div class="sect3" lang="en">
<div class="titlepage"><div><div><h4 class="title">
<a name="id518733"></a>3.5.3.1. Safe dirstate access</h4></div></div></div>
<p><a name="x_330"></a>As with revision data, Mercurial doesn't take a lock to
	  read the dirstate file; it does acquire a lock to write it.
	  To avoid the possibility of reading a partially written copy
	  of the dirstate file, Mercurial writes to a file with a
	  unique name in the same directory as the dirstate file, then
	  renames the temporary file atomically to
	  <code class="filename">dirstate</code>.  The file named
	  <code class="filename">dirstate</code> is thus guaranteed to be
	  complete, not partially written.</p>
</div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id518760"></a>3.5.4. Avoiding seeks</h3></div></div></div>
<p><a name="x_331"></a>Critical to Mercurial's performance is the avoidance of
	seeks of the disk head, since any seek is far more expensive
	than even a comparatively large read operation.</p>
<p><a name="x_332"></a>This is why, for example, the dirstate is stored in a
	single file.  If there were a dirstate file per directory that
	Mercurial tracked, the disk would seek once per directory.
	Instead, Mercurial reads the entire single dirstate file in
	one step.</p>
<p><a name="x_333"></a>Mercurial also uses a “<span class="quote">copy on write</span>” scheme
	when cloning a repository on local storage.  Instead of
	copying every revlog file from the old repository into the new
	repository, it makes a “<span class="quote">hard link</span>”, which is a
	shorthand way to say “<span class="quote">these two names point to the same
	  file</span>”.  When Mercurial is about to write to one of a
	revlog's files, it checks to see if the number of names
	pointing at the file is greater than one.  If it is, more than
	one repository is using the file, so Mercurial makes a new
	copy of the file that is private to this repository.</p>
<p><a name="x_334"></a>A few revision control developers have pointed out that
	this idea of making a complete private copy of a file is not
	very efficient in its use of storage.  While this is true,
	storage is cheap, and this method gives the highest
	performance while deferring most book-keeping to the operating
	system.  An alternative scheme would most likely reduce
	performance and increase the complexity of the software, each
	of which is much more important to the “<span class="quote">feel</span>” of
	day-to-day use.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="id518812"></a>3.5.5. Other contents of the dirstate</h3></div></div></div>
<p><a name="x_335"></a>Because Mercurial doesn't force you to tell it when you're
	modifying a file, it uses the dirstate to store some extra
	information so it can determine efficiently whether you have
	modified a file.  For each file in the working directory, it
	stores the time that it last modified the file itself, and the
	size of the file at that time.</p>
<p><a name="x_336"></a>When you explicitly <span class="command"><strong>hg
	  add</strong></span>, <span class="command"><strong>hg remove</strong></span>,
	<span class="command"><strong>hg rename</strong></span> or <span class="command"><strong>hg copy</strong></span> files, Mercurial updates the
	dirstate so that it knows what to do with those files when you
	commit.</p>
<p><a name="x_337"></a>When Mercurial is checking the states of files in the
	working directory, it first checks a file's modification time.
	If that has not changed, the file must not have been modified.
	If the file's size has changed, the file must have been
	modified.  If the modification time has changed, but the size
	has not, only then does Mercurial need to read the actual
	contents of the file to see if they've changed. Storing these
	few extra pieces of information dramatically reduces the
	amount of data that Mercurial needs to read, which yields
	large performance improvements compared to other revision
	control systems.</p>
</div>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="a-tour-of-mercurial-merging-work.html">Prev</a> </td>
<td width="20%" align="center"> </td>
<td width="40%" align="right"> <a accesskey="n" href="mercurial-in-daily-use.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Chapter 2. A tour of Mercurial: merging work </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> Chapter 4. Mercurial in daily use</td>
</tr>
</table>
</div>
</body>
</html>
