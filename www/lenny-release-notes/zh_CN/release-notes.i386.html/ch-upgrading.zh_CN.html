<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>第 4 章 从以前的发行版升级</title><link rel="stylesheet" href="debian.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><style type="text/css">
body { background-image: url('images/draft.png');
       background-repeat: no-repeat;
       background-position: top left;
       /* The following properties make the watermark "fixed" on the page. */
       /* I think that's just a bit too distracting for the reader... */
       /* background-attachment: fixed; */
       /* background-position: center center; */
     }</style><link rel="start" href="index.zh_CN.html" title="Debian GNU/Linux 5.0 (&quot;lenny&quot;), Intel x86 的发行说明" /><link rel="up" href="index.zh_CN.html" title="Debian GNU/Linux 5.0 (&quot;lenny&quot;), Intel x86 的发行说明" /><link rel="prev" href="ch-installing.zh_CN.html" title="第 3 章 安装系统" /><link rel="next" href="ch-information.zh_CN.html" title="第 5 章 lenny 中需要注意的问题" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 4 章 从以前的发行版升级</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch-installing.zh_CN.html">上一页</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch-information.zh_CN.html">下一页</a></td></tr></table><hr /></div><div class="chapter" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="ch-upgrading"></a>第 4 章 从以前的发行版升级</h2></div></div></div><div class="toc"><p><b>目录</b></p><dl><dt><span class="section"><a href="ch-upgrading.zh_CN.html#backup">4.1. 升级前的准备</a></span></dt><dd><dl><dt><span class="section"><a href="ch-upgrading.zh_CN.html#data-backup">4.1.1. 备份数据和配置文件</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#inform-users">4.1.2. 提前告知用户</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#recovery">4.1.3. 准备恢复</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#upgrade-preparations">4.1.4. 为升级准备安全环境</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#prepare-initramfs">4.1.5. 为 <acronym title="Linux 加载器">LILO</acronym> 准备
initramfs</a></span></dt></dl></dd><dt><span class="section"><a href="ch-upgrading.zh_CN.html#system-status">4.2. 检查系统状态</a></span></dt><dd><dl><dt><span class="section"><a href="ch-upgrading.zh_CN.html#review-actions">4.2.1. 复审包管理器中的未决操作</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#disable-apt-pinning">4.2.2. 禁用 APT pinning 操作</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#package-status">4.2.3. 检查包状态</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#userbackports">4.2.4. 非官方源和 backports</a></span></dt></dl></dd><dt><span class="section"><a href="ch-upgrading.zh_CN.html#handle-conflict">4.3. 手工删除软件包的标记</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#upgrade-process">4.4. 为 APT 准备源</a></span></dt><dd><dl><dt><span class="section"><a href="ch-upgrading.zh_CN.html#network">4.4.1. 添加互联网 APT 源</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#localmirror">4.4.2. 添加本地镜像 APT 源</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#cdroms">4.4.3. 从 CD-ROM 或 DVD 添加 APT 源</a></span></dt></dl></dd><dt><span class="section"><a href="ch-upgrading.zh_CN.html#upgradingpackages">4.5. 升级软件包</a></span></dt><dd><dl><dt><span class="section"><a href="ch-upgrading.zh_CN.html#record-session">4.5.1. 记录会话</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#updating-lists">4.5.2. 更新包列表</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#sufficient-space">4.5.3. 确保你有足够的空间升级</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#aptupgrade1st">4.5.4. 先升级 apt 和(或) aptitude</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#aptconvert">4.5.5. 使用 aptitudes 记录的 apt 自动安装的软件包列表</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#minimal-upgrade">4.5.6. 最小系统升级</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#upgrading-kernel">4.5.7. 升级内核</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#upgrading-other">4.5.8. 升级系统的其它部分</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#get-signatures">4.5.9. 取得包签名</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#trouble">4.5.10. 升级期间可能遇到的问题</a></span></dt></dl></dd><dt><span class="section"><a href="ch-upgrading.zh_CN.html#newkernel">4.6. 升级内核与相关包</a></span></dt><dd><dl><dt><span class="section"><a href="ch-upgrading.zh_CN.html#kernel-metapackage">4.6.1. 安装内核元数据包</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#upgrade-from-2.6">4.6.2. 从 2.6 内核升级</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#upgrade-from-2.4">4.6.3. 从 2.4 内核升级</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#device-reorder">4.6.4. 设备枚举的顺序</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#boot-timing">4.6.5. 引导期间的问题</a></span></dt></dl></dd><dt><span class="section"><a href="ch-upgrading.zh_CN.html#nownownow">4.7. 在重启之前要做的事情</a></span></dt><dd><dl><dt><span class="section"><a href="ch-upgrading.zh_CN.html#rerunlilo">4.7.1. 重新运行 lilo</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#mdadm">4.7.2. 升级 mdadm</a></span></dt></dl></dd><dt><span class="section"><a href="ch-upgrading.zh_CN.html#boot-hangs">4.8. 系统引导时在显示 <code class="literal">Waiting for root file system</code> 后挂起</a></span></dt><dd><dl><dt><span class="section"><a href="ch-upgrading.zh_CN.html#avoid-problems-before-upgrading">4.8.1. 如何在升级前避免此问题</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#how-to-recover">4.8.2. 如何在升级后解决此问题</a></span></dt></dl></dd><dt><span class="section"><a href="ch-upgrading.zh_CN.html#for-next">4.9. 为下个发行版做准备</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#deprecated">4.10. 不赞成地包</a></span></dt><dt><span class="section"><a href="ch-upgrading.zh_CN.html#obsolete">4.11. 过时的包</a></span></dt><dd><dl><dt><span class="section"><a href="ch-upgrading.zh_CN.html#dummy">4.11.1. 哑包</a></span></dt></dl></dd><dt><span class="section"><a href="ch-upgrading.zh_CN.html#plans-for-nigel">4.12. 下个 Debian 发行版的计划</a></span></dt></dl></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="backup"></a>4.1. 升级前的准备</h2></div></div></div><p>
我们建议您在升级前阅读<a class="xref" href="ch-information.zh_CN.html" title="第 5 章 lenny 中需要注意的问题">第 5 章 <i>lenny 中需要注意的问题</i></a>中的信息。它描述了与升级过程有间接联系的潜在问题，但在升级前了解这些信息对您来说还是很重要的。
</p><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="data-backup"></a>4.1.1. 备份数据和配置文件</h3></div></div></div><p>
在升级系统前，强烈建议你进行一次完整的备份，或者至少备份你不愿意丢失的数据和配置信息。升级工具和流程是非常可靠的，但升级过程中的硬件错误会对你的系统造成严重损害。
</p><p>
你需要备份的内容包括 <code class="filename">/etc</code>, <code class="filename">/var/lib/dpkg</code>,
<code class="filename">/var/lib/aptitude/pkgstates</code> 下的文件以及 <code class="literal">dpkg
--get-selections "*"</code> 命令的输出(命令行中的引号必须要有)。
</p><p>
升级过程本身不会修改 <code class="filename">/home</code> 下的任何内容。但某些程序(比如部分 Mozilla 套件，以及 GNOME
和 KDE
桌面环境)会在新版本的程序第一次启动时用新的默认值来覆盖现有的用户设置。做为一种预防措施，您也许想备份用户目录下的隐藏文件和目录(“<span class="quote">dotfiles</span>”)。该备份有助于您恢复或者重建原有设置。另外，您可能还需要把该事项通知给用户。
</p><p>
任何软件包安装操作都必须以超级用户权限执行，您可以以 <code class="literal">root</code> 身份登录, 或使用
<span class="command"><strong>su</strong></span> 或者 <span class="command"><strong>sudo</strong></span> 来获取必要的权限。
</p><p>
升级需要几个前提条件，您应当在实际升级前检查它们。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="inform-users"></a>4.1.2. 提前告知用户</h3></div></div></div><p>
提前通知所有用户您正在计划的任何升级将是明智的决定，但是通过 <span class="command"><strong>ssh</strong></span>
连接访问您系统的用户可能在升级过程中不会注意到什么东西，而且应该可以继续正常工作。
</p><p>
如果您希望采取更多的预防措施，请在升级前备份或者卸载用户的分区(<code class="filename">/home</code>)。
</p><p>
当升级到 lenny 时您可能需要进行内核升级，所以通常需要重启。一般说来，这将在升级完成后进行。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="recovery"></a>4.1.3. 准备恢复</h3></div></div></div><p>
由于 etch 和 lenny
的内核在驱动、硬件探测与命名以及设备文件的命名和排序等方面有着诸多变化，在更新后您可能会在重启系统时遇到很大的问题。本章和发行注记的下一章记录了很多已知的潜在问题。
</p><p>
由于这个原因，当您的系统重启失败(或对于远程管理系统来说，无法从网络唤醒)时，请确保您能够将其恢复。
</p><p>
如果您通过 <span class="command"><strong>ssh</strong></span>
远程连接进行升级，则强烈建议您采取必要的预防措施以便通过远程串行终端来访问该服务器。因为在升级内核并重启后，某些设备可能会被改名(如在<a class="xref" href="ch-upgrading.zh_CN.html#device-reorder" title="4.6.4. 设备枚举的顺序">第 4.6.4 节 “设备枚举的顺序”</a>中所描述的情况)，而您将不得不通过本地控制台修复系统配置。还有，如果系统在升级过程中意外重启您可能需要使用本地控制台进行修复。
</p><p>
很明显首先应尝试的就是以您原来的内核重启。然而，由于本文档其它地方所描述的各种各样的问题，并不保证可以成功重启。
</p><p>
如果重启失败了，您需要采取替代方案来启动您的系统以便访问和修复它。其中一种选择是使用特制的急救盘或者 Linux live
CD。以这些介质引导后，您应该可以挂载您的根文件系统并 <code class="literal">chroot</code> 到它里面来检查并修复问题。
</p><p>
我们推荐的另一种选择是使用 lenny Debian
安装程序的<span class="emphasis"><em>拯救模式</em></span>。使用安装程序的优点是，您可以从众多安装方式中选择最适合您情况的一种。更多信息请查询<a class="ulink" href="http://www.debian.org/releases/stable/installmanual" target="_top">安装手册</a>第 8 章的“<span class="quote">修复损坏的系统</span>”一节以及
<a class="ulink" href="http://wiki.debian.org/DebianInstaller/FAQ" target="_top">Debian 安装程序常见问题</a>。
</p><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="recovery-initrd"></a>4.1.3.1. initrd 引导时使用调试环境</h4></div></div></div><p>
<code class="systemitem">initramfs-tools</code> 在其生成的 initrd 中包含一个调试
shell<sup>[<a id="id357919" href="#ftn.id357919" class="footnote">3</a>]</sup> 。如果 initrd 无法挂载您的根文件系统，您将会进入此调试
shell，里面可以使用基本的命令以帮助跟踪问题甚至有可能解决之。
</p><p>
需要检查的几个基本项目：<code class="filename">/dev</code> 下是否存在正确的设备文件；加载了什么模块(<code class="literal">cat
/proc/modules</code>)；<span class="command"><strong>dmesg</strong></span>
的输出中有关驱动加载的错误信息。<span class="command"><strong>dmesg</strong></span> 的输出还会显示哪个设备文件被指定给哪个磁盘；您还应该检查
<code class="literal">echo $ROOT</code> 的输出，以确保根文件系统在预想的设备上。
</p><p>
如果您确实修复了问题，输入 <code class="literal">exit</code> 会退出调试
shell，并从先前失败的地方继续启动进程。当然您还需要修复更深层次的问题，并重新生成 initrd，以使下次引导不再失败。
</p></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="upgrade-preparations"></a>4.1.4. 为升级准备安全环境</h3></div></div></div><p>
发行版升级应该从本机的文本模式虚拟控制台(或者直连串行终端)，或者通过 <span class="command"><strong>ssh</strong></span> 远程连接进行。
</p><p>
为了在远程升级时获得额外的可靠性保障，我们建议您在由 <span class="command"><strong>screen</strong></span>
程序生成的虚拟控制台中执行升级过程。它能进行可靠的重新连接并确保，即使远程连接失败，升级过程也不会被打断。
</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[重要]" src="images/important.png" /></td><th align="left">重要</th></tr><tr><td align="left" valign="top"><p>
    您<span class="emphasis"><em>不应该</em></span>在您要升级的机器上使用
<span class="command"><strong>telnet</strong></span>、<span class="command"><strong>rlogin</strong></span>、<span class="command"><strong>rsh</strong></span>
之类的东西，或者从
<span class="command"><strong>xdm</strong></span>、<span class="command"><strong>gdm</strong></span>、<span class="command"><strong>kdm</strong></span> 之类管理的 X
会话中升级。因为那些服务中的任意一个在升级中都有可能被中止，进而导致出现一个<span class="emphasis"><em>不可访问</em></span>的，只升级了一半的系统。
  </p></td></tr></table></div><pre class="programlisting">
TODO: 你确认 gdm/kdm 没问题？
(vorlon) 哈哈，gdm 不是这样。我曾有过那个想法，并在我的活动会话中测试过 gdm 重启 ;)
</pre></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="prepare-initramfs"></a>4.1.5. 为 <acronym title="Linux 加载器">LILO</acronym><a id="id358095" class="indexterm"></a> 准备
initramfs</h3></div></div></div><p>
    使用 <acronym title="Linux 加载器">LILO</acronym> 启动管理器的用户应该注意，<code class="systemitem">initramfs-tools</code> 目前的默认设置生成的 initramfs 对于
<acronym title="Linux 加载器">LILO</acronym> 来说太大而无法加载。这些用户要么把启动管理器换成 <code class="systemitem">grub</code>，要么就编辑
<code class="filename">/etc/initramfs-tools/initramfs.conf</code> 文件，更改这行 </p><pre class="programlisting">MODULES=most</pre><p> 为
    </p><pre class="programlisting">MODULES=dep</pre><p>
    但是请注意，这么做会引起 <code class="systemitem">initramfs-tools</code>
仅安装那些它运行于特定硬件上的模块至
initramfs；如此说来，如果您想生成一个引导介质，让它可以在更多的硬件上运作，而不是只在与您拥有同样硬件的机器上运作时，您应该保留设置为
    </p><pre class="programlisting">MODULES=most</pre><p> 并确保不使用 <acronym title="Linux 加载器">LILO</acronym>。
  </p></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="system-status"></a>4.2. 检查系统状态</h2></div></div></div><p>
此章所述的升级过程是为了从“<span class="quote">纯粹的</span>” etch
升级而安排的，即系统中没有第三方的软件。为使升级过程最可靠，您可能会希望在升级前，从系统中移除第三方的软件包。
</p><p>
此过程也假定您的系统已经更新至 etch 的最新发行点。如果您还未做或是不确定，请按照<a class="xref" href="ap-old-stuff.zh_CN.html#old-upgrade" title="A.1. 升级您的 etch 系统">第 A.1 节 “升级您的 etch 系统”</a>中的说明做。
</p><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="review-actions"></a>4.2.1. 复审包管理器中的未决操作</h3></div></div></div><p>
在某些情况下，使用 <span class="command"><strong>apt-get</strong></span> 代替 <span class="command"><strong>aptitude</strong></span>
安装软件包时，可能会让 <span class="command"><strong>aptitude</strong></span>
认为包“<span class="quote">未被使用</span>”，并安排它被移除。一般来说，在正式升级前您应该确保系统是最新且“<span class="quote">干净的</span>”。
</p><p>
有鉴于此，您应该复查包管理器 <span class="command"><strong>aptitude</strong></span>
中是否有未决操作。如果包管理器中有软件包被安排为移除或更新，那么这可能对升级过程有负面影响。注意，要更正这一错误只可能是，您的
<code class="filename">sources.list</code> 仍然指向
<span class="emphasis"><em>etch</em></span>，而非 <span class="emphasis"><em>stable</em></span> 或是
<span class="emphasis"><em>lenny</em></span>。参看<a class="xref" href="ap-old-stuff.zh_CN.html#old-sources" title="A.2. 检查您的 sources list">第 A.2 节 “检查您的 sources list”</a>。
</p><p>
要复查的话，您必须以“<span class="quote">图形模式</span>”运行 <span class="command"><strong>aptitude</strong></span> 并按下
<span class="keycap"><strong>g</strong></span>(“<span class="quote">Go</span>”)。如果显示有任何未决操作，您都应该复查它们，然后要么修复，要么执行建议的操作。如果没有建议的操作，会有一条信息
“<span class="quote">没有软件包需要安装、删除或者升级</span>”出现。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="disable-apt-pinning"></a>4.2.2. 禁用 APT pinning 操作</h3></div></div></div><p>
如果已经设置 APT 从一个非 stable(如 testing)版安装特定软件包，您可能必须改变 APT pinning 设置(保存在
<code class="filename">/etc/apt/preferences</code> 中)以允许升级至新的 stable 版中的包。更多有关 APT
pinning 的信息可以在 <span class="citerefentry"><span class="refentrytitle">apt_preferences</span>(5)</span> 中找到。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="package-status"></a>4.2.3. 检查包状态</h3></div></div></div><p>
不管用什么方法升级，我们都建议您先检查所有软件包的状态，并验证所有包都处于可升级状态。以下命令会显示任何半安装或是配置失败的包，还有那些有任何错误状态的包。
</p><pre class="screen">
# dpkg --audit
</pre><p>
您也可以用 <span class="command"><strong>dselect</strong></span>、<span class="command"><strong>aptitude</strong></span>
来审查系统中的所有包的状态，也可以用如下的命令来审查
</p><pre class="screen">
# dpkg -l | pager
</pre><p>
或是
</p><pre class="screen">
# dpkg --get-selections "*" &gt; ~/curr-pkgs.txt
</pre><p>
在升级前移除所有的 hold 状态是很有必要的。如果有任何对升级而言有重大影响的包处于 hold 状态，升级会失败。
</p><p>
注意 <span class="command"><strong>aptitude</strong></span> 使用一种与 <span class="command"><strong>apt-get</strong></span> 及
<span class="command"><strong>dselect</strong></span> 不同的方法来注册 hold 状态的包。您可以用以下命令来确认
<span class="command"><strong>aptitude</strong></span> 中处于 hold 状态的包。
</p><pre class="screen">
# aptitude search "~ahold" | grep "^.h"
</pre><p>
如果您想检查 <span class="command"><strong>apt-get</strong></span> 中哪些包设置了 hold 状态，可以用
</p><pre class="screen">
# dpkg --get-selections | grep hold
</pre><p>
如果您在本地更改并重新编译了一个包，且并未重命名，或是在版本号中放入新的纪元号，您就必须将它设为 hold 状态，以防止它被升级。
</p><p>
<span class="command"><strong>aptitude</strong></span> 中的 “<span class="quote">hold</span>” 状态的包能用以下命令更改：
</p><pre class="screen">
# aptitude hold <em class="replaceable"><code>package_name</code></em>
</pre><p>
用 <code class="literal">unhold</code> 代替 <code class="literal">hold</code> 即可清除
“<span class="quote">hold</span>” 状态。
</p><p>
如果有任何需要修复的东西，您最好确保 <code class="filename">sources.list</code> 仍然指向 etch
，就像<a class="xref" href="ap-old-stuff.zh_CN.html#old-sources" title="A.2. 检查您的 sources list">第 A.2 节 “检查您的 sources list”</a>中所说的那样。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="userbackports"></a>4.2.4. 非官方源和 backports</h3></div></div></div><p>
如果有任何非 Debian 的软件包安装在您的系统中，您应该意识到它们可能会在升级期间因为依赖性冲突而被移除。如果这些包是通过在
<code class="filename">/etc/apt/source.list</code> 中添加一个额外的软件源而安装的，您应该检查那个软件源是否也提供
lenny 下编译好的包，并同时像您的 Debian 软件源那样更改相应的源。
</p><p>
某些用户可能有非官方的 backported “<span class="quote">较新的</span>” 包版本<span class="emphasis"><em>存在</em></span>于他们安装的
Debian etch 系统中。升级期间那样的包是最可能引起问题的，因为它们可能会导致文件冲突<sup>[<a id="id358554" href="#ftn.id358554" class="footnote">4</a>]</sup>。<a class="xref" href="ch-upgrading.zh_CN.html#trouble" title="4.5.10. 升级期间可能遇到的问题">第 4.5.10 节 “升级期间可能遇到的问题”</a>已经有一些关于如何处理将会出现的文件冲突的信息了。
</p></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="handle-conflict"></a>4.3. 手工删除软件包的标记</h2></div></div></div><p>
要防止 <span class="command"><strong>aptitude</strong></span> 移除某些因依赖关系而安装的包，您需要手工删除这些包上的
<span class="emphasis"><em>auto</em></span> 标记。对于桌面安装来说，包括 OpenOffice 和 Vim：
</p><pre class="screen">
# aptitude unmarkauto openoffice.org vim
</pre><p>
如果您已经用内核元数据包安装了 2.6 内核镜像，那还要包括它：
</p><pre class="screen">
# aptitude unmarkauto $(dpkg-query -W 'kernel-image-2.6.*' | cut -f1)
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png" /></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>
    您可以复查那些在 aptitude 中被标记为 <span class="emphasis"><em>auto</em></span> 的包，执行：
  </p><pre class="screen"># aptitude search 'i~M <em class="replaceable"><code>package_name</code></em>'</pre></td></tr></table></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="upgrade-process"></a>4.4. 为 APT 准备源</h2></div></div></div><p>
在开始升级前，您必须在软件包源列表 <code class="filename">/etc/apt/sources.list</code> 中设定 <code class="systemitem">apt</code> 的配置文件。
</p><p>
<code class="systemitem">apt</code> 会查找所有通过任意
“<span class="quote"><code class="literal">deb</code></span>”
行找到的包，并安装带最高版本号的包，给予第一个引用到的行以优先权(所以，如果有多个镜像地址，您最好先命名本地硬盘，然后是 CD-ROM，最后是
HTTP/FTP 镜像)。
</p><p>
一个发行版通常既能通过它的代号(如：<code class="literal">etch</code>,
<code class="literal">lenny</code>)引用，也可以用它的状态名引用(如：<code class="literal">oldstable</code>,
<code class="literal">stable</code>, <code class="literal">testing</code>,
<code class="literal">unstable</code>)。引用发行版的代号的好处在于，您绝对不会被新的发行版问题困扰且被带至此处。当然，这也意味着您不得不自己关注新版的发行。如果转而使用状态名，一旦有新版发行，您将只会看到一堆可用的软件包的更新。
</p><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="network"></a>4.4.1. 添加互联网 APT 源</h3></div></div></div><p>
默认配置用于从主 Debian 网络服务器上安装，但您可能希望修改 <code class="filename">/etc/apt/sources.list</code>
以使用其它的镜像，离您最近的网络镜像是一种更好的选择。
</p><p>
Debian HTTP 或 FTP 镜像地址能在 <a class="ulink" href="http://www.debian.org/distrib/ftplist" target="_top">http://www.debian.org/distrib/ftplist</a>
找到(参看“<span class="quote"> Debian 镜像列表</span>”一节)。HTTP 镜像通常比 FTP 镜像快。
</p><p>
例如，假设离您最近的 Debian 镜像是 <code class="literal">http://mirrors.kernel.org/debian</code>。当用网络浏览器或是
FTP 程序检查那个镜像时，您会注意到主目录被组织成了如下情况：
</p><pre class="programlisting">
http://mirrors.kernel.org/debian/dists/lenny/main/binary-i386/...
http://mirrors.kernel.org/debian/dists/lenny/contrib/binary-i386/...
</pre><p>
要让 <code class="systemitem">apt</code> 使用这个镜像，您将此行添加至
<code class="filename">sources.list</code> 文件：
</p><pre class="programlisting">
deb http://mirrors.kernel.org/debian lenny main contrib
</pre><p>
注意明显加上去的‘<code class="literal">dists</code>’，这个发行版名字后的参数用于将路径扩展成多个目录。
</p><p>
添加新源后，在 <code class="filename">sources.list</code> 中通过在以前存在的
“<span class="quote"><code class="literal">deb</code></span>” 行前加上一个井号(<code class="literal">#</code>)来禁用它们。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="localmirror"></a>4.4.2. 添加本地镜像 APT 源</h3></div></div></div><p>
您可能希望通过修改 <code class="filename">/etc/apt/sources.list</code> 来使用一个本地磁盘上的镜像(也许是通过
<acronym title="网络文件系统">NFS</acronym> 挂载的)，来代替 HTTP 或 FTP 软件源镜像。
</p><p>
例如，假设您的镜像位于 <code class="filename">/var/ftp/devian/</code> 下，并且有如下的主目录：
</p><pre class="programlisting">
/var/ftp/debian/dists/lenny/main/binary-i386/...
/var/ftp/debian/dists/lenny/contrib/binary-i386/...
</pre><p>
要让 <code class="systemitem">apt</code> 使用它，需要把这一行添加至
<code class="filename">sources.list</code> 文件：
</p><pre class="programlisting">
deb file:/var/ftp/debian lenny main contrib
</pre><p>
注意明显加上去的‘<code class="literal">dists</code>’，这个发行版名字后的参数用于将路径扩展成多个目录。
</p><p>
添加新源后，在 <code class="filename">sources.list</code> 中通过在以前存在的
“<span class="quote"><code class="literal">deb</code></span>” 行前加上一个井号(<code class="literal">#</code>)来禁用它们。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="cdroms"></a>4.4.3. 从 CD-ROM 或 DVD 添加 APT 源</h3></div></div></div><p>
如果您<span class="emphasis"><em>只</em></span>想用 CD 安装，在
<code class="filename">/etc/apt/sources.list</code> 中的
“<span class="quote"><code class="literal">deb</code></span>” 行前放上井号(<code class="literal">#</code>)注释掉它们。
</p><p>
确保在 <code class="filename">/etc/fstab</code> 中有一行允许您挂载 CD-ROM 于
<code class="filename">/cdrom</code> 挂载点(<span class="command"><strong>apt-cdrom</strong></span> 必须指定挂载点为
<code class="filename">/cdrom</code> )。例如，假设 <code class="filename">/dev/hdc</code> 就是您的
CD-ROM，<code class="filename">/etc/fstab</code> 中应该带有一行：
</p><pre class="programlisting">
/dev/hdc /cdrom auto defaults,noauto,ro 0 0
</pre><p>
注意在第四段 <code class="literal">defaults,noauto,ro</code> 之间必须<span class="emphasis"><em>无空格</em></span>。
</p><p>
要验证设置是否有效，插入一片 CD，尝试运行
</p><pre class="screen">
# mount /cdrom    # 挂载 CD 至挂载点
# ls -alF /cdrom  # 显示 CD 的根目录
# umount /cdrom   # 卸载 CD
</pre><p>
下一步，运行：
</p><pre class="screen">
# apt-cdrom add
</pre><p>
每片您所拥有的 Debian 二进制 CD-ROM 都要这么做，以便将每片 CD 的数据添加至 APT 的数据库。
</p></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="upgradingpackages"></a>4.5. 升级软件包</h2></div></div></div><p>
推荐的从以前 Debian <acronym title="GNU's Not Unix 的递归缩写">GNU</acronym>/Linux 发行版升级的方法是使用包管理器 <span class="command"><strong>aptitude</strong></span>。此程序会对安装包采取比直接运行
<span class="command"><strong>apt-get</strong></span> 更保守的选择。
</p><p>
不要忘记挂载所有必需的分区（尤其是根分区和 <code class="filename">/usr</code> 分区）为可读写状态，用以下命令：
</p><pre class="screen">
# mount -o remount,rw /<em class="replaceable"><code>mountpoint</code></em>
</pre><p>
下一步您应该详细检查 APT 源记录 (<code class="filename">/etc/apt/source.list</code>) 要么指向
“<span class="quote"><code class="literal">lenny</code></span>” 又或指向
“<span class="quote"><code class="literal">stable</code></span>”。不应该有任何指向 etch 的源记录。
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png" /></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>
    CD-ROM 的源通常会指向
“<span class="quote"><code class="literal">unstable</code></span>”。尽管这令人困惑，但您<span class="emphasis"><em>不应该</em></span>改变它。
  </p></td></tr></table></div><p>
</p><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="record-session"></a>4.5.1. 记录会话</h3></div></div></div><p>
强烈推荐您使用 <span class="command"><strong>/usr/bin/script</strong></span>
程序来记录升级会话中的交互信息。这样如果有问题了，您就有一份问题报告。而且需要的话，您也可以在错误报告中提供额外信息。要开始记录，输入：
</p><pre class="screen">
# script -t 2&gt;~/upgrade-lenny.time -a ~/upgrade-lenny.script
</pre><p>
或是类似命令。不要将输出文件放在临时目录下，如 <code class="filename">/tmp</code> 或
<code class="filename">/var/tmp</code> (这些目录下的文件可能会在升级或重启时被删除)
</p><p>
输出文件也可让您复查屏幕上滚动过去的信息。只要切换至虚拟终端 2 (使用 <span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>F2</strong></span>)，在登入后，用
<code class="literal">less -R ~root/upgrade-lenny.script</code> 查看文件。
</p><p>
在完成升级后，您可以在提示符下输入 <code class="literal">exit</code> 停止 <span class="command"><strong>script</strong></span>。
</p><pre class="programlisting">
TODO：可以提一下我在错误报告 #400725 中提到的脚本，如果您还未输出 timing 文件的话它是很有用的
</pre><p>
如果已经对 <span class="command"><strong>script</strong></span> 使用了 <span class="emphasis"><em>-t</em></span> 选项，您就可以用
<span class="command"><strong>scriptplay</strong></span> 程序来回放整个过程：
</p><pre class="screen">
# scriptreplay ~/upgrade-lenny.time ~/upgrade-lenny.script
</pre></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="updating-lists"></a>4.5.2. 更新包列表</h3></div></div></div><p>
首先，需要获取新发行版的可用包列表。执行：
</p><pre class="screen">
# aptitude update
</pre><p>
首次执行此命令，会更新新源并打印出一些有关源可用性的警告信息。这些警告没关系，而且在您下一次执行时就没有了。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="sufficient-space"></a>4.5.3. 确保你有足够的空间升级</h3></div></div></div><p>
在升级系统前必须确保在进行如<a class="xref" href="ch-upgrading.zh_CN.html#upgrading-other" title="4.5.8. 升级系统的其它部分">第 4.5.8 节 “升级系统的其它部分”</a>中所述的完全系统升级时，您有足够的磁盘空间。首先，安装过程所需的任何从网上下载的包都被保存在
<code class="filename">/var/cache/apt/archives</code> (下载期间还会放在
<code class="filename">partial/</code> 子目录下)，因此您必须确保在文件系统分区
<code class="filename">/var/</code>
下有足够的空间存放临时下载包，这些包将会安装在系统中。下载之后，您可能在其它文件系统分区中需要更多的空间来同时安装升级包(可能会包含更大的二进制程序或更多数据)和升级中带入的新包。如果系统中没有足够的空间，您可能以一个未完成的升级结束，而这可能难以恢复。
</p><p>
<span class="command"><strong>aptitude</strong></span> 和 <code class="systemitem">apt</code>
都会显示给您安装所需磁盘空间的详细信息。在执行升级操作前，您可以运行以下命令来看到这个估计值：
</p><pre class="screen">
# aptitude -y -s -f --with-recommends dist-upgrade
[ ... ]
XXX 个已升级，XXX 个刚装上，XXX 个待删除以及 XXX 个未升级。
需要获取 xx.xMB/yyyMB。解开后，将占用 AAAMB。
会下载/安装/删除包。
</pre><p>
<sup>[<a id="id359549" href="#ftn.id359549" class="footnote">5</a>]</sup>
</p><p>
如果没有足够空间来升级，确保您预先释放了空间。可以这样：
</p><div class="itemizedlist"><ul type="disc"><li><p>
删除以前安装时下载的包 (位于 <code class="filename">/var/cache/apt/archives</code>)。用
<span class="command"><strong>apt-get clean</strong></span> 或 <span class="command"><strong>aptitude clean</strong></span>
来清理包缓存，这会删除所有以前下载过的包文件。
</p></li><li><p>
删除您从来不用的旧包。如果您安装过 <code class="systemitem">popularity-contest</code>，可以用
<span class="command"><strong>popcon-largest-unused</strong></span> 来列出系统中占用大量空间而又不用的那些包。您也可以用
<span class="command"><strong>deborphan</strong></span> 或是 <span class="command"><strong>debfoster</strong></span> 来找出过时的包(参看<a class="xref" href="ch-upgrading.zh_CN.html#obsolete" title="4.11. 过时的包">第 4.11 节 “过时的包”</a>)。另一种可选方案是，您以“<span class="quote">图形模式</span>”运行
<span class="command"><strong>aptitude</strong></span> 在“<span class="quote">过时的且由本机创建的包</span>”下找到过时的包。
</p></li><li><p>
删除占用太多空间，目前不需要的包(您总是可以在升级后重装它们的)。您可以用 <span class="command"><strong>dpigs</strong></span> (可在
<code class="systemitem">debian-goodies</code> 包中找到)或是用
<span class="command"><strong>wajig</strong></span> (运行 <code class="literal">wajig size</code>) 列出占用大量空间的包。
</p><pre class="programlisting">
TODO: 在 lenny 下可考虑以下操作
您可以用 <code class="systemitem">aptitude</code> 列出占用大量磁盘空间
的包。以<span class="emphasis"><em>可视模式</em></span>运行 <span class="command"><strong>aptitude</strong></span>，选择
<span class="guimenu">Views</span> 和 <span class="guimenu">New Flat Package List</span>(此菜单项仅
在 etch 发行版后才可用)，按 <span class="keycap"><strong>l</strong></span> 并输入 <span class="keycap"><strong>~</strong></span> <span class="keycap"><strong>i</strong></span>，按 <span class="keycap"><strong>S</strong></span> 并输入 
<code class="literal">~installsize</code>，然后就会显示漂亮的列表。在升级 <code class="systemitem">aptitude</code> 之后，您就可以使用此新特性。
</pre></li><li><p>
将 <code class="filename">/var/log/</code> 下的系统日志临时放到其它系统，或是永久删除。
</p></li><li><p>
    使用临时目录
<code class="filename">/var/cache/apt/archives</code>：您可以使用来自另一个系统的临时缓存目录(<acronym title="通用串行总线">USB</acronym>
存储设备，临时硬盘，使用中的文件系统……)
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png" /></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>
      不要使用 <acronym title="网络文件系统">NFS</acronym>，这是因为网络连接可能在升级期间断开。
    </p></td></tr></table></div><p>
  例如，假设您将 <acronym title="通用串行总线">USB</acronym> 盘挂在 <code class="filename">/media/usbkey</code> 下：
  </p><div class="orderedlist"><ol type="1"><li><p>
	删除以前安装时下载的包：

	</p><pre class="screen"># apt-get clean</pre><p>
      </p></li><li><p>
	将 <code class="filename">/var/cache/apt/archives</code> 目录复制到 <acronym title="通用串行总线">USB</acronym>
磁盘：

	</p><pre class="screen"># cp -ax /var/cache/apt/archives /media/usbkey/</pre><p>
      </p></li><li><p>
	将临时缓存目录挂载至当前目录：

	</p><pre class="screen"># mount --bind /media/usbkey/archives /var/cache/apt/archives</pre><p>
      </p></li><li><p>
	升级后，还原 <code class="filename">/var/cache/apt/archives</code> 目录：

	</p><pre class="screen"># umount /media/usbkey/archives</pre><p>
      </p></li><li><p>
	删除留下的 <code class="filename">/media/usbkey/archives</code>。
      </p></li></ol></div><p>
  您可以在挂载于系统中的任何文件系统上创建临时缓存目录。
  </p></li></ul></div><p>
注意为了安全地移除软件包，建议您换回 etch 的
<code class="filename">sources.list</code>，就像<a class="xref" href="ap-old-stuff.zh_CN.html#old-sources" title="A.2. 检查您的 sources list">第 A.2 节 “检查您的 sources list”</a>中描述的那样。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="aptupgrade1st"></a>4.5.4. 先升级 apt 和(或) aptitude</h3></div></div></div><p>
    已经有几个错误报告说，etch 中的 <code class="systemitem">aptitude</code> 和
<code class="systemitem">apt</code> 版本通常无法处理升级至 lenny。在
lenny 中，<code class="systemitem">apt</code>
会更好的处理需要即时配置的复杂的安装包链，而 <code class="systemitem">aptitude</code>
在搜索满足依赖关系的方案方面更智能。由于这两个程序在完全升级至 lenny
时会深深地绞在一起，因此在升级其它任何东西之前，都有必要先升级这两个包。对于 <code class="systemitem">apt</code>，执行：
    </p><pre class="screen"># apt-get install apt</pre><p>
    对于 <code class="systemitem">aptitude</code> (如果您安装过的话)要执行：
    </p><pre class="screen"># aptitude install aptitude</pre><p>
  </p><p>
    此步将自动升级 <code class="systemitem">libc6</code> 和 <code class="systemitem">locales</code>，并将引入 SELinux 支持库(<code class="systemitem">libselinux1</code>)。此时，某些正在运行的服务会重启。这些服务包括
<span class="command"><strong>xdm</strong></span>，<span class="command"><strong>gdm</strong></span> 和 <span class="command"><strong>kdm</strong></span>。因此，本地
X11 会话可能会断开。
  </p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="aptconvert"></a>4.5.5. 使用 aptitudes 记录的 apt 自动安装的软件包列表</h3></div></div></div><p>
    <code class="systemitem">aptitude</code>
维护了一个自动安装的包列表(就像另一个包的依赖一样)。在 lenny 中，<code class="systemitem">apt</code> 现在也有这个功能了。
  </p><p>
    首次运行 lenny 版本的 <code class="systemitem">aptitude</code>
时，它会先自动读入安装包的列表，然后再转换成 lenny <code class="systemitem">apt</code> 可用的版本。如果您安装了 <code class="systemitem">aptitude</code>，您至少应该先发出一条 <span class="command"><strong>aptitude</strong></span>
指令以便转换。一种方法是搜索一个不存在的包：
    </p><pre class="screen"># aptitude search "?false"</pre><p>
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="minimal-upgrade"></a>4.5.6. 最小系统升级</h3></div></div></div><p>
由于在 etch 和 lenny 间有某些必需包存在冲突，因此直接运行 <code class="literal">aptitude
dist-upgrade</code>
通常会删除大量您想要保留的包。因此我们推荐一种两步升级过程，首先做一次最小升级来解决这些冲突，然后做一次完整的
<code class="literal">dist-upgrade</code> 升级。
</p><p>
首先，运行：
</p><pre class="screen">
# aptitude upgrade
</pre><p>
这会升级那些不需要删除或安装其它任何包的软件。
</p><p>
下一步会相当依赖您安装过的包。发行注记会给出所用方法的通用建议，但如有疑问，推荐您在继续操作前检查每种方法建议的需要删除的包。
</p><p>
某些通用包要被删除，包括 <code class="systemitem">base-config</code>，<code class="systemitem">hotplug</code>，<code class="systemitem">xlibs</code>，<code class="systemitem">netkit-inetd</code>，<code class="systemitem">python2.3</code>，<code class="systemitem">xfree86-common</code> 和 <code class="systemitem">xserver-common</code>。要看 lenny
中的更完整的废弃包列表，想参看<a class="xref" href="ch-upgrading.zh_CN.html#obsolete" title="4.11. 过时的包">第 4.11 节 “过时的包”</a>。
</p><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="minimal-upgrade-desktop"></a>4.5.6.1. 升级桌面系统</h4></div></div></div><p>
这种升级方法已经被运行于 etch
中安装的<code class="literal">桌面</code>环境验证过了。这可能是安装有<code class="literal">桌面</code>环境或是
<code class="literal">gnome</code> 或 <code class="literal">kde</code> 包的系统所能给出的最佳方法。
</p><p>
如果您还未安装 <code class="systemitem">libfam0c102</code> 和 <code class="systemitem">xlibmesa-glu</code>
包的话，这可能<span class="emphasis"><em>不是</em></span>正确的用法：
</p><pre class="screen">
# dpkg -l libfam0c102 | grep ^ii
# dpkg -l xlibmesa-glu | grep ^ii
</pre><p>
如果您确实已经安装了完整的桌面系统，那就运行：
</p><pre class="screen">
# aptitude install libfam0 xlibmesa-glu
</pre></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="minimal-upgrade-x-server"></a>4.5.6.2. 升级安装了部分 X 包的系统</h4></div></div></div><p>
装有某些 X 包但没有完整<code class="literal">桌面</code>环境的系统需要不同的方法。这种方法通常应用于装有 <code class="systemitem">xfree86-common</code> 的系统，包括某些服务器系统，它们装有 <code class="systemitem">tasksel</code> 管理组件，其中的一些带有图形管理工具。这可能是正确的方法，它适用于运行 X
的，不带完整<code class="literal">桌面</code>环境的系统。
</p><pre class="screen">
# dpkg -l xfree86-common | grep ^ii
</pre><p>
首先，检查您是否安装有 <code class="systemitem">libfam0c102</code> 和
<code class="systemitem">xlibmesa-glu</code> 包。
</p><pre class="screen">
# dpkg -l libfam0c102 | grep ^ii
# dpkg -l xlibmesa-glu | grep ^ii
</pre><p>
如果您还没有安装 <code class="systemitem">libfam0c102</code>，下面命令行中的
<code class="systemitem">libfam0</code> 要删除。如果您还没有安装 <code class="systemitem">xlibmesa-glu</code>，不要将它包含在下面的命令行中。<sup>[<a id="id360434" href="#ftn.id360434" class="footnote">6</a>]</sup>
</p><pre class="screen">
# aptitude install x11-common <em class="replaceable"><code>libfam0</code></em> <em class="replaceable"><code>xlibmesa-glu</code></em>
</pre><p>
注意，如果您的系统还没有 fam 和 protmap 的话，安装 <code class="systemitem">libfam0</code> 也会安装文件变化监视器(<code class="systemitem">fam</code>)，以及 RPC 端口映射器(<code class="systemitem">portmap</code>)。尽管它们都能被绑定至(内部)回环 (loopback)
网络设备，但这两个包还是会在系统中开启一个新的网络服务。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="minimal-upgrade-server"></a>4.5.6.3. 升级没有 X 支持的系统</h4></div></div></div><p>
在不带 X 的系统上，不需要额外的 <code class="literal">aptitude install</code> 命令，您可以转入下一步。
</p></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="upgrading-kernel"></a>4.5.7. 升级内核</h3></div></div></div><p>
lenny 中的 <code class="systemitem">udev</code> 版本不支持早于
2.6.15(包括 etch 2.6.8 内核)版本的内核，且 etch 中的 <code class="systemitem">udev</code> 版本无法在最新内核中正常运作。而且，安装 lenny 版的
<code class="systemitem">udev</code> 会强制删除 Linux 2.4 内核所用的
<code class="systemitem">hotplug</code>。
</p><p>
结果，以前的内核在此次升级后无法正常启动。类似的，在升级期间， <code class="systemitem">udev</code>
已经升级过而未安装最新内核时，会有一个 time
window。假如系统要在此处重启的话(升级过程中)，以后可能无法引导，因为未正确检测并载入驱动。(如果您正在远程升级，参看<a class="xref" href="ch-upgrading.zh_CN.html#upgrade-preparations" title="4.1.4. 为升级准备安全环境">第 4.1.4 节 “为升级准备安全环境”</a>找到用于处理此种可能情况的推荐做法。)
</p><p>
除非您的系统中装有<code class="literal">桌面</code>环境，或是其它能引发大量不可接受的包移除的软件，在此我们推荐您升级内核本身。
</p><p>
要进行此次内核升级，执行：
</p><pre class="screen">
# aptitude install linux-image-2.6-<em class="replaceable"><code>flavor</code></em>
</pre><p>
参看<a class="xref" href="ch-upgrading.zh_CN.html#kernel-metapackage" title="4.6.1. 安装内核元数据包">第 4.6.1 节 “安装内核元数据包”</a>来帮助您决定应该安装哪个修订号的内核包。
</p><p>
在桌面环境下，很不幸地我们不可能保证在新 <code class="systemitem">udev</code>
安装后，立即安装新内核包，因此有一段未知的时间您的系统没有安装带完整 hotplug 支持的内核。参看<a class="xref" href="ch-upgrading.zh_CN.html#newkernel" title="4.6. 升级内核与相关包">第 4.6 节 “升级内核与相关包”</a>来获取有关配置不依赖于 hotplug 就能引导的系统的信息。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="upgrading-other"></a>4.5.8. 升级系统的其它部分</h3></div></div></div><p>
现在，您要准备继续升级重要部分。执行：
</p><pre class="screen">
# aptitude dist-upgrade
</pre><p>
这将对系统进行一次全面的升级，比如：安装所有包的最新可用版本，解决不同发行版的包之间所有潜在的依赖性变动。如有必要，它会安装一些新包(通常是新库，或是重命名的包)，并删除任何有冲突的过时包。
</p><p>
当从一叠 CD-ROM 升级时，您会在升级期间的某几个地方被要求插入指定的 CD
盘片。您可能不得不多次插入相同的盘片，这是因为互相依赖的包已经被分散到整个 CD 套件中去了。
</p><p>
如果不改变被指定在当前状态(显示为 “<span class="quote">held back</span>”) 的另一个包，当前安装包的新版本就无法升级。这个问题可以通过使用
<span class="command"><strong>aptitude</strong></span> 选择这些包来安装或是用 <code class="literal">aptitude -f install
<em class="replaceable"><code>package</code></em></code> 来解决。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="get-signatures"></a>4.5.9. 取得包签名</h3></div></div></div><p>
升级后，您可以用新版的 <code class="systemitem">apt</code>
来更新您的包信息，它含有新包的签名验证机制：
</p><pre class="screen">
# aptitude update
</pre><p>
升级时已经取得并使用了 Debian 包的签名密钥。如果您添加其它(非官方)的软件包源， <code class="systemitem">apt</code>
会打印出无法确认从其它源下载的包是合法的且尚未被窜改过的警告信息。要想了解更多信息请参看<a class="xref" href="ch-whats-new.zh_CN.html#pkgmgmt" title="2.1.1. 包管理">第 2.1.1 节 “包管理”</a>。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="trouble"></a>4.5.10. 升级期间可能遇到的问题</h3></div></div></div><p>
如果使用 <span class="command"><strong>aptitude</strong></span>, <span class="command"><strong>apt-get</strong></span> 或
<span class="command"><strong>dpkg</strong></span> 操作时出现错误
</p><pre class="screen">
E: Dynamic MMap ran out of room
</pre><p>
默认的缓存区空间不足。您可以通过删除或注释掉 <code class="filename">/etc/apt/sources.list</code>
中不需要的行，或是增加缓存大小来解决这个问题。缓存大小能通过在 <code class="filename">/etc/apt/apt.conf</code> 中设置
<code class="literal">APT::Cache-Limit</code> 来增加。下面的命令会为它设置一个足够升级值：
</p><pre class="screen">
# echo 'APT::Cache-Limit "12500000";' &gt;&gt; /etc/apt/apt.conf
</pre><p>
这里假设您还未在那个文件中对该变量进行过设置。
</p><p>
有时有必要在 APT 中开启 <code class="literal">APT::Force-LoopBreak</code>
选项使之能够临时移除一个重要的包，这是为了满足冲突或是预依赖循环。 <span class="command"><strong>aptitude</strong></span>
会警告您这一点并退出升级。您可以通过在 <span class="command"><strong>aptitude</strong></span> 命令行上指定 <code class="literal">-o
APT::Force-LoopBreak=1</code> 选项来绕过这个问题。
</p><p>
有可能系统的依赖关系太乱了以至于需要手工干预。通常这意味着使用 <span class="command"><strong>aptitude</strong></span> 或是
</p><pre class="screen">
# dpkg --remove <em class="replaceable"><code>package_name</code></em>
</pre><p>
来消除某些引起问题的包，或是
</p><pre class="screen">
# aptitude -f install
# dpkg --configure --pending
</pre><p>
在极端情况下，您可能不得不像以下命令一样强制重新安装某个包
</p><pre class="screen">
# dpkg --install <em class="replaceable"><code>/path/to/package_name.deb</code></em>
</pre><p>
如果您从“<span class="quote">纯粹的</span>” etch 系统升级就不会出现文件冲突，但如果您装有非官方的 backport
包就可能出现冲突。文件冲突会导致类似以下这样的错误：
</p><pre class="screen">
Unpacking <em class="replaceable"><code>&lt;package-foo&gt;</code></em> (from <em class="replaceable"><code>&lt;package-foo-file&gt;</code></em>) ...
dpkg: error processing <em class="replaceable"><code>&lt;package-foo&gt;</code></em> (--install):
 trying to overwrite `<em class="replaceable"><code>&lt;some-file-name&gt;</code></em>',
 which is also in package <em class="replaceable"><code>&lt;package-bar&gt;</code></em>
dpkg-deb: subprocess paste killed by signal (Broken pipe)
 Errors were encountered while processing:
 <em class="replaceable"><code>&lt;package-foo&gt;</code></em>
</pre><p>
您可以尝试用错误信息中的<span class="emphasis"><em>最后</em></span>一行提示，强制删除包来解决文件冲突：
</p><pre class="screen">
# dpkg -r --force-depends <em class="replaceable"><code>package_name</code></em>
</pre><p>
在修复这些问题后，您应该可以通过重复前述的 <span class="command"><strong>aptitude</strong></span> 命令来继续升级。
</p><p>
升级期间，您会被问到有关配置或是重新配置几个包的问题。如果您被问到是否任何存在于 <code class="filename">/etc/init.d</code> 或
<code class="filename">/etc/terminfo</code> 目录，或是
<code class="filename">/etc/manpath.config</code>
目录下的文件应该被包维护者的版本所替换时，通常有必要回答‘yes’来确保系统一致性。由于它们会被以
<code class="literal">.dpkg-old</code> 为后缀的文件名保存，所以您总是可以恢复成老版本的配置文件。
</p><p>
如果您不确定该做什么，那就记下包或文件的名称，并稍后排出它们的顺序。您可以通过在 script
命令记录的输出文件中搜索来查看升级期间显示在屏幕上的信息。
</p></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="newkernel"></a>4.6. 升级内核与相关包</h2></div></div></div><p>
这一节解释了如何升级您的内核，以及明确有关此次升级的潜在问题。您可以安装由 Debian 提供的 <code class="systemitem">linux-image-*</code> 包，或者从源码编译一个自定义的内核。
</p><p>
注意本节的很多信息基于假设，即您会使用一个模块化的 Debian 内核，以及<code class="systemitem">initramfs-tools</code> 和 <code class="systemitem">udev</code>。如果您选择使用一个不需要 initrd 的自定义内核，或是您使用了一种不同的
initrd 生成器，对您来说某些信息可能会不一样。 
</p><p>
同时注意，如果您的系统中<span class="emphasis"><em>没有</em></span>安装 <code class="systemitem">udev</code>，仍然有可能使用 <code class="systemitem">hotplug</code> 进行硬件查找。
</p><p>
如果您目前正在使用 2.4 内核，您还应该仔细阅读<a class="xref" href="ch-information.zh_CN.html#upgrade-to-2.6" title="5.2. 升级到 2.6 内核">第 5.2 节 “升级到 2.6 内核”</a>。
</p><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="kernel-metapackage"></a>4.6.1. 安装内核元数据包</h3></div></div></div><p>
当您从 etch 全面升级至 lenny 时，强烈推荐您安装新的 linux-image-2.6-*
元数据包。此包可能由 dist-upgrade 自动安装了。您可以验证此步，执行：
</p><pre class="screen">
# dpkg -l "linux-image*" | grep ^ii
</pre><p>
如果您没有看到任何输出，那么您需要手工安装一个新的 linux-image 包。要查看可用的 linux-image-2.6 的元数据包列表，执行：
</p><pre class="screen">
# apt-cache search linux-image-2.6- | grep -v transition
</pre><p>
如果您不确定要选哪个包，那就运行 <code class="literal">uname -r</code>
并查找带有类似名称的包。例如，如果您看到‘<code class="literal">2.4.27-3-686</code>’，那推荐您安装 <code class="systemitem">linux-image-2.6-686</code>。(注意不再有 386 版本；如果您当前正在用 386
内核，您应该安装 486 内核代替。)您也可以使用 <span class="command"><strong>apt-cache</strong></span>
来查看每个包的详细描述，以帮助您选择最好用的那个。例如：
</p><pre class="screen">
# apt-cache show linux-image-2.6-686
</pre><p>
然后您应该使用 <code class="literal">aptitude install</code>
来安装。一旦安装了这个新内核，您应该在下一次可行时重启机器以获取新内核所提供的特性。
</p><p>
对于爱冒险的人，这里有个简单方法来编译您的自定义 Debian <acronym title="GNU's Not Unix 的递归缩写">GNU</acronym>/Linux 内核。安装 <code class="systemitem">kernel-package</code> 工具，然后阅读
<code class="filename">/usr/share/doc/kernel-package</code> 下的文档。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="upgrade-from-2.6"></a>4.6.2. 从 2.6 内核升级</h3></div></div></div><p>
如果您目前运行来自 etch 的 2.6 系列的内核，在您做了一次完整的系统包升级后，会自动发生这个升级(就像<a class="xref" href="ch-upgrading.zh_CN.html#upgradingpackages" title="4.5. 升级软件包">第 4.5 节 “升级软件包”</a>所描述的那样)。
</p><p>
如果有可能，把内核包的升级从主 <code class="literal">dist-upgrade</code>
中独立出来是有利的，这能减少出现一个不可引导的系统的机会。参看<a class="xref" href="ch-upgrading.zh_CN.html#upgrading-kernel" title="4.5.7. 升级内核">第 4.5.7 节 “升级内核”</a>获取此过程的描述。注意，这只能在最小升级<a class="xref" href="ch-upgrading.zh_CN.html#minimal-upgrade" title="4.5.6. 最小系统升级">第 4.5.6 节 “最小系统升级”</a>结束后才能做。
</p><p>
如果您正使用您自定义的内核并想使用 lenny 中可用的内核，您也可以进行此步操作。如果 <code class="systemitem">udev</code> 不支持您的内核，建议您在最小升级后再升级内核。如果 <code class="systemitem">udev</code> 支持您的内核，您就可以安稳地等着，直到整个系统升级完成。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="upgrade-from-2.4"></a>4.6.3. 从 2.4 内核升级</h3></div></div></div><p>
如果您装有 2.4 内核，且您的系统依赖于 <code class="systemitem">hotplug</code>
探测硬件，那在您尝试升级前应该先从 etch 升级至 2.6 系列的内核。确保 2.6
系列内核可引导您的系统，且您所有的硬件都能在进行升级前被正常检测到。
</p><p>
如您的系统不依赖于 <code class="systemitem">hotplug</code><sup>[<a id="id361304" href="#ftn.id361304" class="footnote">7</a>]</sup>，按<a class="xref" href="ch-upgrading.zh_CN.html#upgrading-other" title="4.5.8. 升级系统的其它部分">第 4.5.8 节 “升级系统的其它部分”</a>中所说，您可以在系统全面升级后再升级内核。一旦系统已经升级，您就可以做以下事情(通过替换
<code class="varname">flavor</code> 将内核包的名字改成最适合您系统的那个)：
</p><pre class="screen">
# aptitude install linux-image-2.6-<em class="replaceable"><code>flavor</code></em>
</pre></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="device-reorder"></a>4.6.4. 设备枚举的顺序</h3></div></div></div><p>
lenny
带来一个比上一发行版更健全的硬件探测机制。但是，这会引起系统中所探测到的设备顺序变化，即影响设备名的分配顺序。例如，如果您有两张驱动不同的网卡，eth0
和 eth1 设备名可能被互换了。请注意，新机制意味着假设您在运行着的 lenny
系统中互换以太网适配器，新的适配器也会获得一个新的接口名。
</p><p>
对于网络设备，您可以通过使用 <code class="systemitem">udev</code> 机制避免此重排，更明确点，通过在
<code class="filename">/etc/udev/rules.d/z25_persistent-net.rules</code>
中指定<sup>[<a id="id355282" href="#ftn.id355282" class="footnote">8</a>]</sup>。另一种方法，您可以在引导时用 <span class="command"><strong>ifrename</strong></span> 工具将物理设备绑定至指定的名字。参看
<span class="citerefentry"><span class="refentrytitle">ifrename</span>(8)</span> 和 <span class="citerefentry"><span class="refentrytitle">iftab</span>(5)</span> 获取更多信息。两个可选方法 (<code class="systemitem">udev</code>
和 <span class="command"><strong>ifrename</strong></span>) 不应该同时使用。
</p><p>
对于存储设备，通过使用 <code class="systemitem">initramfs-tools</code>
并配置它按当前的顺序载入存储设备，这样您就可以避免这个顺序重排。要这么做的话，通过查看 <span class="command"><strong>lsmod</strong></span>
命令的输出来明确您系统中载入的存储模块的顺序。<span class="command"><strong>lsmod</strong></span>
以它们载入的反序显示，即列表中的第一个模块是最后一个被载入的。注意这只对内核以固定顺序枚举出的设备有效(像 PCI 设备)。
</p><p>
但是，在首次引导后删除并重新载入模块会影响这个顺序。还有，您的内核可能有些静态链接的驱动，而且这些模块名称不会出现在
<span class="command"><strong>lsmod</strong></span> 的输出中。您可能会解读这些驱动名并从
<code class="filename">/var/log/kern.log</code> 或是 <span class="command"><strong>dmesg</strong></span>
的输出中载入引导顺序。
</p><p>
将这些模块名按它们引导时载入的顺序添加至
<code class="filename">/etc/initramfs-tools/modules</code>。某些模块名可能在 etch
和 lenny 有所变动。例如，sym53c8xx_2 已经变成了 sym53c8xx。
</p><p>
然后您需要运行 <code class="literal">update-initramfs -u -k all</code> 重新生成 initramfs 镜像。
</p><p>
一旦您正运行一个 lenny 内核和 <code class="systemitem">udev</code>，您可以重新配置系统以通过一个不依赖于驱动载入顺序的别名来访问磁盘。这些别名存在于
<code class="filename">/dev/disk/</code> 目录结构下。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="boot-timing"></a>4.6.5. 引导期间的问题</h3></div></div></div><p>
如果用 <code class="systemitem">initramfs-tools</code> 创建的 initrd
引导系统，在某些情况下由 <code class="systemitem">udev</code>
创建的设备文件可能对于启动脚本的执行来讲太慢了点。
</p><p>
这通常表现为引导失败，由于根文件系统无法挂载，您会进入调试环境。但当您回头检查时，所需的所有设备都存在于
<code class="filename">/dev</code> 下。只要根文件系统存在于 <acronym title="通用串行总线">USB</acronym> 磁盘或是
<acronym title="独立冗余磁盘阵列">RAID</acronym>上，尤其是使用了
<acronym title="Linux 加载器">LILO</acronym><a id="id361659" class="indexterm"></a>
时，就会出现这种问题。
</p><p>
绕过此问题的方法就是用引导参数
<code class="literal">rootdelay=<em class="replaceable"><code>9</code></em></code>。这个超时值(秒)可能需要调整一下。
</p></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="nownownow"></a>4.7. 在重启之前要做的事情</h2></div></div></div><p>
当 <code class="literal">aptitude dist-upgrade</code>
完成时，“<span class="quote">正式的</span>”升级就算结束了。但在下一次重启<span class="emphasis"><em>之前</em></span>，还有一些其它的事情需要关注一下。
</p><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="rerunlilo"></a>4.7.1. 重新运行 lilo</h3></div></div></div><p>
如果您正在用 <code class="systemitem">lilo</code> 作为您的启动管理器(这是某些
etch 安装的默认引导器)，强烈建议您在升级后重新运行 <span class="command"><strong>lilo</strong></span>：
</p><pre class="screen">
# /sbin/lilo
</pre><p>
注意，即使您不升级系统内核也需要这一步，这是由于包的升级 <span class="command"><strong>lilo</strong></span> 的 second stage 会改变。
</p><p>
还有，检查 <code class="filename">/etc/kernel-img.conf</code> 中的内容并确保其中有
<code class="literal">do_bootloader = Yes</code> 这一行。这样，在内核升级后，启动管理器总会重新运行一下。
</p><p>
如果您在运行 <span class="command"><strong>lilo</strong></span> 时遇到任何问题，请检查 <code class="filename">/</code> 下至
<code class="filename">vmlinuz</code> 和 <code class="filename">initrd</code> 的符号链接，以及
<code class="filename">/etc/lilo.conf</code> 中内容不一致的地方。
</p><p>
如果您在重启前或是在您未手工重启系统就偶然重启前，忘记重新运行 <span class="command"><strong>lilo</strong></span>
的话，您的系统可能会无法引导。当系统引导时您将只会看到 <code class="literal">LI</code> 而不是 lilo 提示符<sup>[<a id="id361821" href="#ftn.id361821" class="footnote">9</a>]</sup>。有关如何从此处恢复的信息请参看<a class="xref" href="ch-upgrading.zh_CN.html#recovery" title="4.1.3. 准备恢复">第 4.1.3 节 “准备恢复”</a>。
</p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mdadm"></a>4.7.2. 升级 mdadm</h3></div></div></div><p>
mdadm 现在需要一个配置文件用来在引导 ramdisk 和系统安装期间整合 MD 阵列
(<acronym title="独立冗余磁盘阵列">RAID</acronym>)。请确保在软件包升级后<span class="strong"><strong>并在您重启前</strong></span>仔细阅读并按
<code class="filename">/usr/share/doc/mdadm/README.upgrading-2.5.3.gz</code>
中所说的去做。此文件的最新版本可在 <a class="ulink" href="http://svn.debian.org/wsvn/pkg-mdadm/mdadm/trunk/debian/README.upgrading-2.5.3?op=file" target="_top">http://svn.debian.org/wsvn/pkg-mdadm/mdadm/trunk/debian/README.upgrading-2.5.3?op=file</a>
获得；如有问题请参考它。
</p></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="boot-hangs"></a>4.8. 系统引导时在显示 <code class="literal">Waiting for root file system</code> 后挂起</h2></div><div><h3 class="subtitle">从 <code class="filename">/dev/hda</code> 变成 <code class="filename">/dev/sda</code> 的补救方法</h3></div></div></div><p>
    某些用户已经报告升级可能引起内核无法在重启后找到系统根分区。
  </p><p>
    在那种情况下，系统引导会挂起并出现以下信息：
    </p><pre class="screen">Waiting for root file system ...</pre><p>
    且几秒钟后会只出现一个 busybox 提示符。
  </p><p>
    当内核升级使用新一代的 <acronym title="电子集成驱动器">IDE</acronym> 驱动程序时，就会出现这个问题。老的 <acronym title="电子集成驱动器">IDE</acronym>
磁盘的命名规则是 <code class="literal">hda</code>, <code class="literal">hdb</code>,
<code class="literal">hdc</code>, <code class="literal">hdd</code>。新的规则将分别命名为
<code class="literal">sda</code>, <code class="literal">sdb</code>, <code class="literal">sdc</code>,
<code class="literal">sdd</code>。当升级时未生成一个新的 <code class="filename">/boot/grub/menu.lst</code>
文件来产生新的命名规则时，就会出现这个问题。引导时，Grub 会传递给内核一个无法找到的系统根分区。
  </p><p>
    如果您在升级后已经遇到此问题，转至<a class="xref" href="ch-upgrading.zh_CN.html#how-to-recover" title="4.8.2. 如何在升级后解决此问题">第 4.8.2 节 “如何在升级后解决此问题”</a>。要在升级前避免此问题，就提前看一下。
  </p><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="avoid-problems-before-upgrading"></a>4.8.1. 如何在升级前避免此问题</h3></div></div></div><p>
      通过给根文件系统使用一个不会在引导时改变的标识符，您可以完全避免这个问题。要做到这点有两种可能的方案──给文件系统加标签，或是用文件系统的通用唯一标识符(<acronym title="通用惟一标识符">UUID</acronym>)。Debian
从‘etch’发行版起就已经支持这些方法了。
    </p><p>
      两种方法各有优缺点。文件系统标签可读性好，但如果您的系统中有另一个同名的文件系统时，就会带来问题。UUID 可读性较差，但极不可能出现两个互相冲突的
uuid。
    </p><p>
      以下范例中，我们假设根文件系统位于 <code class="filename">/dev/hda6</code>，同时再假设您的系统装有运行正常的 udev 和
ext2 或是 ext3 文件系统。
    </p><p>
      使用文件系统标签：
      </p><div class="orderedlist"><ol type="1"><li><p>
	    通过执行命令 <span class="command"><strong>e2label /dev/hda6 rootfilesys</strong></span> 来标记文件系统（名称必须小于 16
个字符）。
	  </p></li><li><p>
	    编辑 <code class="filename">/boot/grub/menu.lst</code> 并更改以下这行：
	    </p><pre class="programlisting"># kopt=root=/dev/hda6 ro</pre><p>
	    为
	    </p><pre class="programlisting"># kopt=root=LABEL=rootfilesys ro</pre><p>
	    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png" /></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>
		不要删除行首的 <code class="literal">#</code>，那个要的。
	      </p></td></tr></table></div><p>
	  </p></li><li><p>
	    通过运行 <span class="command"><strong>update-grub</strong></span> 更新 <code class="filename">menu.lst</code> 中的
<code class="literal">kernel</code> 行。
	  </p></li><li><p>
	    编辑 <code class="filename">/etc/fstab</code> 并改变挂载 <code class="filename">/</code> 分区的那行，如：

	    </p><pre class="programlisting">/dev/hda6     /     ext3  defaults,errors=remount-ro 0 1</pre><p>

	    为

	    </p><pre class="programlisting">LABEL=rootfilesys     /     ext3  defaults,errors=remount-ro 0 1</pre><p>

	    在这里改变的是第一栏，您不必修改此行的其它栏目。
	  </p></li></ol></div><p>
    </p><p>
      如果要用 UUID 方式：
      </p><div class="orderedlist"><ol type="1"><li><p>
	    通过 <span class="command"><strong>ls -l /dev/disk/by-uuid | grep hda6</strong></span> 找出您文件系统的通用唯一标识符。
	  </p><p>
	    您应该得到类似于以下内容的一行：
	    </p><pre class="screen">lrwxrwxrwx 1 root root 24 2008-09-25 08:16 d0dfcc8a-417a-41e3-ad2e-9736317f2d8a -&gt; ../../hda6</pre><p>

	    <acronym title="通用惟一标识符">UUID</acronym> 是指向 <code class="filename">/dev/hda6</code> 的符号链接的名字，如
<code class="literal">d0dfcc8a-417a-41e3-ad2e-9736317f2d8a</code>。
	    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png" /></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>
		您文件系统的 <acronym title="通用惟一标识符">UUID</acronym> 可能是不同的字符串。
	      </p></td></tr></table></div><p>
	  </p></li><li><p>
	    编辑 <code class="filename">/boot/grub/menu.lst</code> 并更改以下这行：
	    </p><pre class="programlisting"># kopt=root=/dev/hda6 ro</pre><p>
	    为
	    </p><pre class="programlisting"># kopt=root=UUID=d0dfcc8a-417a-41e3-ad2e-9736317f2d8 ro</pre><p>
	    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png" /></td><th align="left">注意</th></tr><tr><td align="left" valign="top"><p>
		不要删除行首的 <code class="literal">#</code>，那个要的。
	      </p></td></tr></table></div><p>
	  </p></li><li><p>
	    通过运行 <span class="command"><strong>update-grub</strong></span> 更新 <code class="filename">menu.lst</code> 中的
<code class="literal">kernel</code> 行。
	  </p></li><li><p>
	    编辑 <code class="filename">/etc/fstab</code> 并改变挂载 <code class="filename">/</code> 分区的那行，如：

	    </p><pre class="programlisting">/dev/hda6     /     ext3  defaults,errors=remount-ro 0 1</pre><p>

	    为

	    </p><pre class="programlisting">UUID=d0dfcc8a-417a-41e3-ad2e-9736317f2d8  /  ext3  defaults,errors=remount-ro 0 1</pre><p>

	    在这里改变的是第一栏，您不必修改此行的其它栏目。
	  </p></li></ol></div><p>
    </p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="how-to-recover"></a>4.8.2. 如何在升级后解决此问题</h3></div></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="solution1"></a>4.8.2.1. 方案一</h4></div></div></div><p>
	当 Grub 显示菜单界面让您选择您想启动的菜单项时，可以做这步操作。如果没出现那样的菜单，尝试在内核引导显示它之前，按下
<span class="keycap"><strong>Esc</strong></span> 键。如果您还是无法进入此菜单，尝试<a class="xref" href="ch-upgrading.zh_CN.html#solution2" title="4.8.2.2. 方案二">第 4.8.2.2 节 “方案二”</a>或是<a class="xref" href="ch-upgrading.zh_CN.html#solution3" title="4.8.2.3. 方案三">第 4.8.2.3 节 “方案三”</a>。
      </p><div class="orderedlist"><ol type="1"><li><p>
	    在 Grub 菜单中，高亮您想启动的菜单项。按下 <span class="keycap"><strong>e</strong></span> 键来编辑有关此条目的选项。您将会看到一些东西，类似于：

	    </p><pre class="screen">root (hd0,0)
kernel /vmlinuz-2.6.26-1-686 root=/dev/hda6 ro
initrd /initrd.img-2.6.26-1-686</pre><p>
	  </p></li><li><p>
	    高亮此行

	    </p><pre class="screen">kernel /vmlinuz-2.6.26-1-686 root=/dev/hda6 ro</pre><p>

	    按下 <span class="keycap"><strong>e</strong></span> 键并用 <code class="literal">sd<em class="replaceable"><code>X</code></em></code>
代替 <code class="literal">hdX</code> (<code class="varname">X</code> 可以是字符 <code class="literal">a</code>,
<code class="literal">b</code>, <code class="literal">c</code> 或
<code class="literal">d</code>，这依赖于您的系统）。在我的例子中这一行变为：

	    </p><pre class="screen">kernel /vmlinuz-2.6.26-1-686 root=/dev/sda6 ro</pre><p>

	    然后按下 <span class="keycap"><strong>Enter</strong></span> 来保存修改。如果还有其它带
<code class="literal">hd<em class="replaceable"><code>X</code></em></code> 字样的行，则一并修改。不要改变类似于
<code class="literal">root (hd0,0)</code> 这样的条目。一旦做好所有的修改，按下 <span class="keycap"><strong>b</strong></span>
键。然后您的系统现在应该能正常启动。
	  </p></li><li><p>
	    现在您的系统已经启动了，您需要永久修复这个问题。转至<a class="xref" href="ch-upgrading.zh_CN.html#avoid-problems-before-upgrading" title="4.8.1. 如何在升级前避免此问题">第 4.8.1 节 “如何在升级前避免此问题”</a>并使用两个方法中的一个。
	  </p></li></ol></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="solution2"></a>4.8.2.2. 方案二</h4></div></div></div><p>
	从 debian 安装介质(<acronym title="光盘">CD</acronym>/<acronym title="数字通用光盘">DVD</acronym>)引导，输入
<code class="literal">rescue</code>
来启动急救模式。选择您的语言、地区、键盘映射，无论是否成功都让它配置您的网络。过一会儿，您应该被要求选择一个您想让它作为根文件系统使用的分区。推荐的选择看起来类似：

	</p><pre class="screen">/dev/ide/host0/bus0/target0/lun0/part1
/dev/ide/host0/bus0/target0/lun0/part2
/dev/ide/host0/bus0/target0/lun0/part5
/dev/ide/host0/bus0/target0/lun0/part6</pre><p>
      </p><p>
	如果您知道哪个分区是您的根文件系统，就选择正确的那个。如果您不知道，只好试一下第一个。如果它报告说是无效的根文件系统分区，就试下一个，依次类推。一个接一个地尝试不会损伤您的分区，而且如果您仅在磁盘上装有一个系统，您应该很容易就找出正确的根文件系统分区。如果您在磁盘上装有多个系统，最好能准确地知道哪个是正确的分区。
      </p><p>
	一旦您已选中一个分区，建议您进行几个操作。在所选分区中选择一个 shell 环境执行。如果无法进行选择，那就试另一个分区。
      </p><p>
	现在您应该拥有挂载于 <code class="filename">/</code> 的根文件系统 shell 环境的 <code class="literal">root</code>
用户访问权。您需要访问 <code class="filename">/boot</code>、<code class="filename">/sbin</code> 和
<code class="filename">/usr</code> 目录中的内容。如果这些目录需要从其它分区挂载，那就先挂载它们。(如果您不知道挂载哪个分区，请参考
<code class="filename">/etc/fstab</code>)。
      </p><p>
	转至<a class="xref" href="ch-upgrading.zh_CN.html#avoid-problems-before-upgrading" title="4.8.1. 如何在升级前避免此问题">第 4.8.1 节 “如何在升级前避免此问题”</a>并使用两个方法中的一个来永久修复这个问题。然后输入
<code class="literal">exit</code> 退出急救 shell 环境，并选择 <code class="literal">reboot</code>
正常重启系统(别忘了拿走可引导介质)。
      </p></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="solution3"></a>4.8.2.3. 方案三</h4></div></div></div><div class="orderedlist"><ol type="1"><li><p>
	    从您最喜欢的 LiveCD 发行版 (Debian Live, Knoppix, Ubuntu Live 以及更多其它发行版)启动。
	  </p></li><li><p>
	    挂载 <code class="filename">/boot</code> 目录所在的分区。如果您不知道是哪个，利用 <span class="command"><strong>dmesg</strong></span>
的输出来找出是否您的磁盘是 <code class="literal">hda</code>, <code class="literal">hdb</code>,
<code class="literal">hdc</code>, <code class="literal">hdd</code> 或是 <code class="literal">sda</code>,
<code class="literal">sdb</code>, <code class="literal">sdc</code>,
<code class="literal">sdd</code>。一旦您知道是哪个磁盘，例如是 <code class="literal">sdb</code>，执行命令
<span class="command"><strong>fdisk -l /dev/sdb</strong></span> 来查看分区表并找出正确的分区。
	  </p></li><li><p>
	    假设，您已经在 <code class="filename">/mnt</code> 下挂载了正确的分区，而且此分区含有
<code class="filename">/boot</code> 目录及其内容，那就编辑
<code class="filename">/mnt/boot/grub/menu.lst</code> 文件。
	  </p><p>
	    找到类似于以下的这一段：
	    </p><pre class="programlisting">## ## End Default Options ##

title           Debian GNU/Linux, kernel 2.6.26-1-686
root            (hd0,0)
kernel          /vmlinuz-2.6.26-1-686 root=/dev/hda6 ro
initrd          /initrd.img-2.6.26-1-686

title           Debian GNU/Linux, kernel 2.6.26-1-686 (single-user mode)
root            (hd0,0)
kernel          /vmlinuz-2.6.26-1-686 root=/dev/hda6 ro single
initrd          /initrd.img-2.6.26-1-686

### END DEBIAN AUTOMAGIC KERNELS LIST</pre><p>

	    并将
<code class="literal">hda</code>，<code class="literal">hdb</code>，<code class="literal">hdc</code>，<code class="literal">hdd</code>
分别替换为
<code class="literal">sda</code>，<code class="literal">sdb</code>，<code class="literal">sdc</code>，<code class="literal">sdd</code>。不要修改类似于这样的行：

	    </p><pre class="programlisting">root            (hd0,0)</pre><p>
	  </p></li><li><p>
	    重启系统，弹出 LiveCD，您的系统应该能正确的启动了。
	  </p></li><li><p>
	    当系统引导时，使用<a class="xref" href="ch-upgrading.zh_CN.html#avoid-problems-before-upgrading" title="4.8.1. 如何在升级前避免此问题">第 4.8.1 节 “如何在升级前避免此问题”</a>中所建议的两种处理方法中的一个来永久修复这个问题。
	  </p></li></ol></div></div></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="for-next"></a>4.9. 为下个发行版做准备</h2></div></div></div><p>
升级完成后，您可以为下个发行版做点事。
</p><div class="itemizedlist"><ul type="disc"><li><p>
如果新的内核镜像元数据包被当作旧镜像的依赖包而安装，那新镜像将被标记为自动安装，这应该被更正一下：
</p><pre class="screen">
# aptitude unmarkauto $(dpkg-query -W 'linux-image-2.6-*' | cut -f1)
</pre></li><li><p>
像<a class="xref" href="ch-upgrading.zh_CN.html#obsolete" title="4.11. 过时的包">第 4.11 节 “过时的包”</a>中描述的那样移除过时的和未使用的包。您应该核查这些包所用的配置文件，并考虑完全删除这些软件包以移除它们的配置文件。
</p></li></ul></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="deprecated"></a>4.10. 不赞成地包</h2></div></div></div><p>
随着 Debian 下个版本(开发代号 <code class="literal">squeeze</code>)
的发行，大量的服务包都会被标记为过时，因此当升级至 <code class="literal">squeeze</code>
时，更新至这些软件包的新版本可以解决您的困扰。
</p><p>
包含以下这些包：
</p><div class="itemizedlist"><ul type="disc"><li><p>
对于 <code class="systemitem">uw-imapd</code>，尚没有定义继承者。
</p></li></ul></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="obsolete"></a>4.11. 过时的包</h2></div></div></div><p>
在带来几千个新软件包的同时，lenny 也清除了曾经存在于 etch
中超过两千个的旧软件包。lenny 不提供这些过时包的升级。当然，在您需要的地方没什么可以阻止您继续使用这些过时的包，Debian
计划通常会在 lenny 发行版后的一年间不断的提供安全更新<sup>[<a id="id362946" href="#ftn.id362946" class="footnote">10</a>]</sup>，且通常不会同时提供其它支持。推荐用可用的替代品代替它们。
</p><p>
为什么包会从发行版中移除？这有很多原因，如：它们不再被上游作者维护了；没有 Debian
开发者对维护这个包感兴趣；这些包提供的功能被不同的软件（或新版本）替代了；或者由于它们自身的问题，因而被认为不适用于 lenny。
最后一种情况下，这些包有可能仍然位于 “<span class="quote">unstable</span>” 版之下。
</p><p>
检测在已更新的系统中哪些包是“<span class="quote">过时</span>”的现在容易得很，因为包管理的前台程序会标记它们的。如果您使用的是
<span class="command"><strong>aptitude</strong></span>，您将在“<span class="quote">过时的且由本机创建的包</span>”条目中看到这些包。<span class="command"><strong>dselect</strong></span>
提供类似的条目，但它显示的列表有所不同。还有，如果您曾经用 <span class="command"><strong>aptitude</strong></span> 手工在
etch 中安装过包，aptitude
会保存那些您手工安装的记录。如果有某个包被移除并导致出现无依赖性，即不再需要那些包，aptitude 会将那些包标记为过时的包。还有
<span class="command"><strong>aptitude</strong></span>，不同于
<span class="command"><strong>deborphan</strong></span>。<span class="command"><strong>deborphan</strong></span>
不将您手工安装，而非那些通过依赖性自动安装的软件包，标记为过时的包。
</p><p>
您可以用其它的工具来找出过时的包，例如
<span class="command"><strong>deborphan</strong></span>，<span class="command"><strong>debfoster</strong></span> 或
<span class="command"><strong>cruft</strong></span>。推荐使用
<span class="command"><strong>deborphan</strong></span>，尽管它(默认情况下)只报告过时的库，即“<span class="quote"><code class="literal">libs</code></span>”或是“<span class="quote"><code class="literal">oldlibs</code></span>”部分中的未被其它包依赖的软件包。不要盲目的移除那些工具要用到的包，尤其是当您正在使用激进的非默认的选项，它们容易引起严重错误。极度推荐在您移除它们之前，手工核查那些建议移除的包(例如：它们的内容、大小以及描述信息)。
</p><p>
<a class="ulink" href="http://bugs.debian.org/" target="_top"> Debian
错误跟踪系统</a>通常会提供额外信息，这些都是有关这个包为什么要被移除的信息。您应该既查看此包自身的归档错误报告，同时也要看一下 <a class="ulink" href="http://bugs.debian.org/cgi-bin/pkgreport.cgi?pkg=ftp.debian.org&amp;archive=yes" target="_top">ftp.debian.org
pseudo-package</a> 中的归档错误报告。
</p><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="dummy"></a>4.11.1. 哑包</h3></div></div></div><p>
来自 etch 的某些包在 lenny
中已经被分为好几个包，通常这是为了改善系统的可维护性。在此情况下，为了能平滑升级，lenny
通常提供“<span class="quote">哑</span>”包(即空包)，它与 etch
中的旧包名称相同，但有依赖性，促使它们安装新包。这些“<span class="quote">哑</span>”包在升级成功后就会被认为是过时的包，且能够被安全地移除。
</p><p>
绝大多数(并非所有)哑包的描述信息会显示它们的用途。但哑包的描述信息并不统一，因此您可能会发现带上<code class="literal"> --guess
</code>选项的<span class="command"><strong> deborphan
</strong></span>命令对于找出您系统中的哑包是很有用的。注意，某些哑包在升级后是不打算被系统移除的，相反它们被用于长期跟踪某程序的当前可用版本这样的目的。
</p></div></div><div class="section" lang="zh-CN" xml:lang="zh-CN"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="plans-for-nigel"></a>4.12. 下个 Debian 发行版的计划</h2></div></div></div></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id357919" href="#id357919" class="para">3</a>] </sup> 此功能可以通过在您的启动参数中添加参数 <code class="literal">panic=0</code> 来禁用。  </p></div><div class="footnote"><p><sup>[<a id="ftn.id358554" href="#id358554" class="para">4</a>] </sup> Debian 的包管理系统正常情况下不允许一个软件包移除或是替换另一个软件包所拥有的文件，除非已经被设定为替换那个包。  </p></div><div class="footnote"><p><sup>[<a id="ftn.id359549" href="#id359549" class="para">5</a>] </sup> 由于下一节将要谈到的问题，在即将开始更新前执行这条命令可能会给出一个错误。如果那样的话，您需要等至已经如<a class="xref" href="ch-upgrading.zh_CN.html#minimal-upgrade" title="4.5.6. 最小系统升级">第 4.5.6 节 “最小系统升级”</a>所述的那样做过最小系统升级并且如<a class="xref" href="ch-upgrading.zh_CN.html#upgrading-kernel" title="4.5.7. 升级内核">第 4.5.7 节 “升级内核”</a>中所述的那样升级过内核，这样您就可以运行这条命令来预估所需的磁盘空间。  </p></div><div class="footnote"><p><sup>[<a id="ftn.id360434" href="#id360434" class="para">6</a>] </sup> 这个命令会检测您是否需要安装 <code class="systemitem">libfam0</code> 和 <code class="systemitem">xlibmesa-glu</code>，并且为您自动选择：
</p><pre class="screen"> # aptitude install x11-common \ $(dpkg-query --showformat
'${Package} ${Status}\n' -W libfam0c102 xlibmesa-glu \ | grep 'ok installed$' |
sed -e's/ .*//; s/c102//') </pre></div><div class="footnote"><p><sup>[<a id="ftn.id361304" href="#id361304" class="para">7</a>] </sup> 您可以通过合理地配置 <code class="filename">/etc/modules</code> 来静态载入系统所需的内核模块。</p></div><div class="footnote"><p><sup>[<a id="ftn.id355282" href="#id355282" class="para">8</a>] </sup>
脚本 <code class="filename">/etc/udev/rules.d/z45_persistent-net-generator.rules</code>
自动生成的规则让网卡拥有固定的名字。删除此符号链接可以关闭 <code class="systemitem">udev</code> 对
<acronym title="网卡">NIC</acronym> 设备的固定命名。  </p></div><div class="footnote"><p><sup>[<a id="ftn.id361821" href="#id361821" class="para">9</a>] </sup> 想知道更多有关 <span class="command"><strong>lilo</strong></span> 启动错误代码的信息，请参看 <a class="ulink" href="http://tldp.org/HOWTO/Bootdisk-HOWTO/a1483.html" target="_top">The Linux Bootdisk
HOWTO</a>。  </p></div><div class="footnote"><p><sup>[<a id="ftn.id362946" href="#id362946" class="para">10</a>] </sup> 只要在那段时间内没有另外的发行版释出。在任意给定时间内，一般仅提供两个 stable 发行版的安全更新。  </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch-installing.zh_CN.html">上一页</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch-information.zh_CN.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">第 3 章 安装系统 </td><td width="20%" align="center"><a accesskey="h" href="index.zh_CN.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 5 章 lenny 中需要注意的问题</td></tr></table></div></body></html>
