# Copyright (C) 2007 the Subversion Book team
# 
# Authors:
# Dongsheng Song <dongsheng.song@gmail.com>, 2007
# Xun Leasun <leasun@gmail.com>
# Daijun Sun <daijun@gmail.com>
msgid ""
msgstr ""
"Project-Id-Version: Subversion Book\n"
"POT-Creation-Date: 2007-05-06 12:52+0800\n"
"PO-Revision-Date: 2007-04-30 10:07+0800\n"
"Last-Translator: Dongsheng Song <dongsheng.song@gmail.com>\n"
"Language-Team: Subversion Book team <svnbook-dev@red-bean.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: build/en/book.xml:0(None)
msgid "translator-credits"
msgstr ""
"Dongsheng Song <dongsheng.song@gmail.com>\n"
"Xun Leasun <leasun@gmail.com>\n"
"Daijun Sun <daijun@gmail.com>\n"

#: build/en/book.xml:10017(para)
msgid "There's nothing particularly incorrect about such a layout, but it may or may not seem as intuitive for your users. Especially in large, multi-project situations with many users, those users may tend to be familiar with only one or two of the projects in the repository. But the projects-as-branch-siblings tends to de-emphasize project individuality and focus on the entire set of projects as a single entity. That's a social issue though. We like our originally suggested arrangement for purely practical reasons—it's easier to ask about (or modify, or migrate elsewhere) the entire history of a single project when there's a single repository path that holds the entire history—past, present, tagged, and branched—for that project and that project alone."
msgstr ""

#: build/en/book.xml:10036(title)
msgid "Deciding Where and How to Host Your Repository"
msgstr ""

#: build/en/book.xml:10038(para)
msgid "Before creating your Subversion repository, an obvious question you'll need to answer is where the thing is going to live. This is strongly connected to a myriad of other questions involving how the repository will be accessed (via a Subversion server or directly), by whom (users behind your corporate firewall or the whole world out on the open Internet), what other services you'll be providing around Subversion (repository browsing interfaces, e-mail based commit notification, etc.), your data backup strategy, and so on."
msgstr ""

#: build/en/book.xml:10049(para)
msgid "We cover server choice and configuration in <xref linkend=\"svn.serverconfig\"/>, but the point we'd like to briefly make here is simply that the answers to some of these other questions might have implications that force your hand when deciding where your repository will live. For example, certain deployment scenarios might require accessing the repository via a remote filesystem from multiple computers, in which case (as you'll read in the next section) your choice of a repository back-end data store turns out not to be a choice at all because only one of the available back-ends will work in this scenario."
msgstr ""

#: build/en/book.xml:10060(para)
msgid "To try to address each and every possible way to deploy Subversion is both not possible and outside the scope of this book. We simply encourage you to evaluate your options using these pages and other sources as your reference material, and plan ahead."
msgstr ""

#: build/en/book.xml:1007(title) build/en/book.xml:1014(title)
msgid "Subversion's Architecture"
msgstr "Subversion的架构"

#: build/en/book.xml:10070(title)
msgid "Choosing a Data Store"
msgstr "选择数据存储格式"

#: build/en/book.xml:10072(para)
#, fuzzy
msgid "As of version 1.1, Subversion provides two options for the type of underlying data store—often referred to as <quote>the back-end</quote> or, somewhat confusingly, <quote>the (versioned) filesystem</quote>—that each repository uses. One type of data store keeps everything in a Berkeley DB (or BDB) database environment; repositories that use this type are often referred to as being <quote>BDB-backed</quote>. The other type stores data in ordinary flat files, using a custom format. Subversion developers have adopted the habit of referring to this latter data storage mechanism as <firstterm>FSFS</firstterm><placeholder-1/> —a versioned filesystem implementation that uses the native OS filesystem to store data."
msgstr "在Subversion1.2中，版本库中存储数据有两种方式。一种是在Berkeley DB数据库中存储数据；另一种是使用普通的文件，使用自定义格式。因为Subversion的开发者称版本库为（版本化的）文件系统，他们接受了称后一种存储方式为FSFS<footnote><placeholder-1/></footnote>的习惯，也就是说，使用本地操作系统文件系统来存储数据的版本化文件的系统。"

#: build/en/book.xml:10084(para)
#, fuzzy
msgid "Often pronounced <quote>fuzz-fuzz</quote>, if Jack Repenning has anything to say about it. (This book, however, assumes that the reader is thinking <quote>eff-ess-eff-ess</quote>.)"
msgstr "读作<quote>fuzz-fuzz</quote>, 如果Jack Repenning说起这个问题。"

#: build/en/book.xml:1009(para)
#, fuzzy
msgid "<xref linkend=\"svn.intro.architecture.dia-1\"/> illustrates a <quote>mile-high</quote> view of Subversion's design."
msgstr "<xref linkend=\"svn.intro.architecture.dia-1\"/>给出了Subversion设计总体上的<quote>俯视图</quote>。"

#: build/en/book.xml:10092(para)
#, fuzzy
msgid "<xref linkend=\"svn.reposadmin.basics.backends.tbl-1\"/> gives a comparative overview of Berkeley DB and FSFS repositories."
msgstr "<xref linkend=\"svn.reposadmin.basics.backends.tbl-1\"/>从总体上比较了Berkeley DB和FSFS版本库，下一部分将会详细讲述细节。"

#: build/en/book.xml:10097(title)
msgid "Repository Data Store Comparison"
msgstr "版本库数据存储对照表"

#: build/en/book.xml:101(para)
msgid "The problem with such FAQs is that they are not, in a literal sense, FAQs at all. No one ever called the tech support line and asked, <quote>How can we maximize productivity?</quote>. Rather, people asked highly specific questions, like, <quote>How can we change the calendaring system to send reminders two days in advance instead of one?</quote> and so on. But it's a lot easier to make up imaginary Frequently Asked Questions than it is to discover the real ones. Compiling a true FAQ sheet requires a sustained, organized effort: over the lifetime of the software, incoming questions must be tracked, responses monitored, and all gathered into a coherent, searchable whole that reflects the collective experience of users in the wild. It calls for the patient, observant attitude of a field naturalist. No grand hypothesizing, no visionary pronouncements here—open eyes and accurate note-taking are what's needed most."
msgstr "类似的问题完全不符合FAQ的精神。没人会打电话给技术支援中心，询问<quote>怎样提高生产率？</quote>相反，人们经常询问一些非常具体的问题，像<quote>怎样让日程系统提前两天而不是一天提醒相关用户？</quote>等等。但是想象比发现真正的问题更容易。构建一个真实的问题列表需要持之以恒的、有组织的辛勤工作：跨越整个软件生命周期，追踪新提出的问题，监控反馈信息，所有的问题要整理成一个统一的、可查询的整体，并且能够真实的反映所有用户的感受。这需要耐心，如自然学家一样严谨的态度，没有浮华的假设，没有虚幻的断言—相反的，需要开放的视野和精确的记录。"

#: build/en/book.xml:10101(entry)
msgid "Category"
msgstr "分类"

#: build/en/book.xml:10102(entry) build/en/book.xml:12670(entry)
msgid "Feature"
msgstr "特性"

#: build/en/book.xml:10103(entry) build/en/book.xml:10207(title)
msgid "Berkeley DB"
msgstr "Berkeley DB"

#: build/en/book.xml:10104(entry) build/en/book.xml:10335(title)
msgid "FSFS"
msgstr "FSFS"

#: build/en/book.xml:10109(entry)
msgid "Reliability"
msgstr "可靠性"

#: build/en/book.xml:10110(entry)
msgid "Data integrity"
msgstr ""

#: build/en/book.xml:10111(entry)
msgid "when properly deployed, extremely reliable; Berkeley DB 4.4 brings auto-recovery"
msgstr ""

#: build/en/book.xml:10113(entry)
msgid "older versions had some rarely demonstrated, but data-destroying bugs"
msgstr ""

#: build/en/book.xml:10117(entry)
msgid "Sensitivity to interruptions"
msgstr "对操作中断的敏感"

#: build/en/book.xml:10118(entry)
#, fuzzy
msgid "very; crashes and permission problems can leave the database <placeholder-1/>, requiring journaled recovery procedures"
msgstr "很敏感；系统崩溃或者权限问题会导致数据库<placeholder-1/>，需要定期进行恢复。"

#: build/en/book.xml:10119(quote)
msgid "wedged"
msgstr "塞住"

#: build/en/book.xml:10121(entry)
msgid "quite insensitive"
msgstr "十分敏感"

#: build/en/book.xml:10124(entry)
msgid "Accessibility"
msgstr "可用性"

#: build/en/book.xml:10125(entry)
msgid "Usable from a read-only mount"
msgstr "可只读加载"

#: build/en/book.xml:10126(entry) build/en/book.xml:10131(entry)
msgid "no"
msgstr "不能"

#: build/en/book.xml:10127(entry) build/en/book.xml:10132(entry)
#: build/en/book.xml:10137(entry)
msgid "yes"
msgstr "可以"

#: build/en/book.xml:10130(entry)
msgid "Platform-independent storage"
msgstr "存储平台无关"

#: build/en/book.xml:10135(entry)
msgid "Usable over network filesystems"
msgstr "可从网络文件系统访问"

#: build/en/book.xml:10136(entry)
msgid "generally, no"
msgstr ""

#: build/en/book.xml:10140(entry)
msgid "Group permissions handling"
msgstr "组访问权处理"

#: build/en/book.xml:10141(entry)
#, fuzzy
msgid "sensitive to user umask problems; best if accessed by only one user"
msgstr "对于用户的umask设置十分敏感，最好只由一个用户访问。"

#: build/en/book.xml:10143(entry)
msgid "works around umask problems"
msgstr "对umask设置不敏感"

#: build/en/book.xml:10146(entry)
msgid "Scalability"
msgstr "伸缩性"

#: build/en/book.xml:10147(entry)
#, fuzzy
msgid "Repository disk usage"
msgstr "版本库大小"

#: build/en/book.xml:10148(entry)
msgid "larger (especially if logfiles aren't purged)"
msgstr ""

#: build/en/book.xml:10149(entry)
msgid "smaller"
msgstr "较小"

#: build/en/book.xml:10152(entry)
#, fuzzy
msgid "Number of revision trees"
msgstr "可扩展性：修订版本树的数量"

#: build/en/book.xml:10153(entry)
msgid "database; no problems"
msgstr "数据库，没有限制"

#: build/en/book.xml:10154(entry)
#, fuzzy
msgid "some older native filesystems don't scale well with thousands of entries in a single directory"
msgstr "许多古老的本地文件系统在处理单一目录包含上千个条目时出现问题。"

#: build/en/book.xml:10158(entry)
#, fuzzy
msgid "Directories with many files"
msgstr "可扩展性：文件较多的目录"

#: build/en/book.xml:10159(entry)
msgid "slower"
msgstr "较慢"

#: build/en/book.xml:10160(entry)
msgid "faster"
msgstr "较快"

#: build/en/book.xml:10163(entry)
msgid "Performance"
msgstr "性能"

#: build/en/book.xml:10164(entry)
msgid "Checking out latest revision"
msgstr "检出最新的代码"

#: build/en/book.xml:10165(entry) build/en/book.xml:10166(entry)
msgid "no meaningful difference"
msgstr ""

#: build/en/book.xml:10169(entry)
msgid "Large commits"
msgstr "大的提交"

#: build/en/book.xml:10170(entry)
msgid "slower overall, but cost is amortized across the lifetime of the commit"
msgstr ""

#: build/en/book.xml:10172(entry)
#, fuzzy
msgid "faster overall, but finalization delay may cause client timeouts"
msgstr "较快，但是最后较长的延时可能会导致客户端操作超时"

#: build/en/book.xml:10179(para)
msgid "There are advantages and disadvantages to each of these two back-end types. Neither of them is more <quote>official</quote> than the other, though the newer FSFS is the default data store as of Subversion 1.2. Both are reliable enough to trust with your versioned data. But as you can see in <xref linkend=\"svn.reposadmin.basics.backends.tbl-1\"/>, the FSFS backend provides quite a bit more flexibility in terms of its supported deployment scenarios. More flexibility means you have to work a little harder to find ways to deploy it incorrectly. Those reasons—plus the fact that not using Berkeley DB means there's one fewer component in the system—largely explain why today almost everyone uses the FSFS backend when creating new repositories."
msgstr ""

#: build/en/book.xml:1018(para)
msgid "On one end is a Subversion repository that holds all of your versioned data. On the other end is your Subversion client program, which manages local reflections of portions of that versioned data (called <quote>working copies</quote>). Between these extremes are multiple routes through various Repository Access (RA) layers. Some of these routes go across computer networks and through network servers which then access the repository. Others bypass the network altogether and access the repository directly."
msgstr "图中的一端是保存所有在版本控制下数据的Subversion版本库，另一端是Subvesion的客户端程序，管理着所有在版本控制下数据的本地影射（称为<quote>工作拷贝</quote>），在这两极之间是各种各样的版本库访问（RA）层，某些使用电脑网络通过网络服务器访问版本库，某些则绕过网络服务器直接访问版本库。"

#: build/en/book.xml:10193(para)
msgid "Fortunately, most programs which access Subversion repositories are blissfully ignorant of which back-end data store is in use. And you aren't even necessarily stuck with your first choice of a data store—in the event that you change your mind later, Subversion provides ways of migrating your repository's data into another repository that uses a different back-end data store. We talk more about that later in this chapter."
msgstr ""

#: build/en/book.xml:10202(para)
msgid "The following subsections provide a more detailed look at the available data store types."
msgstr ""

#: build/en/book.xml:10209(para)
msgid "When the initial design phase of Subversion was in progress, the developers decided to use Berkeley DB for a variety of reasons, including its open-source license, transaction support, reliability, performance, API simplicity, thread-safety, support for cursors, and so on."
msgstr "在Subversion的初始设计阶段，开发者因为多种原因而决定采用Berkeley DB，比如它的开源协议、事务支持、可靠性、性能、简单的API、线程安全、支持游标等。"

#: build/en/book.xml:10216(para)
msgid "Berkeley DB provides real transaction support—perhaps its most powerful feature. Multiple processes accessing your Subversion repositories don't have to worry about accidentally clobbering each other's data. The isolation provided by the transaction system is such that for any given operation, the Subversion repository code sees a static view of the database—not a database that is constantly changing at the hand of some other process—and can make decisions based on that view. If the decision made happens to conflict with what another process is doing, the entire operation is rolled back as if it never happened, and Subversion gracefully retries the operation against a new, updated (and yet still static) view of the database."
msgstr "Berkeley DB提供了真正的事务支持－这或许是它最强大的特性，访问你的Subversion版本库的多个进程不必担心偶尔会破坏其他进程的数据。事务系统提供的隔离对于任何给定的操作，Subversion版本库代码看到的只是数据库的静态视图－而不是一个在其他进程影响不断变化的数据库－并能够根据该视图作出决定。如果该决定正好同其他进程所做操作冲突，整个操作会回滚，就像什么都没有发生一样，并且Subversion会优雅的再次对更新的静态视图进行操作。"

#: build/en/book.xml:10231(para)
msgid "Another great feature of Berkeley DB is <firstterm>hot backups</firstterm>—the ability to backup the database environment without taking it <quote>offline</quote>. We'll discuss how to backup your repository in <xref linkend=\"svn.reposadmin.maint.backup\"/>, but the benefits of being able to make fully functional copies of your repositories without any downtime should be obvious."
msgstr "Berkeley DB另一个强大的特性是热备份－不必<quote>脱机</quote>就可以备份数据库环境的能力。我们将会在<xref linkend=\"svn.reposadmin.maint.backup\"/>讨论如何备份你的版本库，能够不停止系统对版本库做全面备份的好处是显而易见的。"

#: build/en/book.xml:10238(para)
#, fuzzy
msgid "Berkeley DB is also a very reliable database system when properly used. Subversion uses Berkeley DB's logging facilities, which means that the database first writes to on-disk log files a description of any modifications it is about to make, and then makes the modification itself. This is to ensure that if anything goes wrong, the database system can back up to a previous <firstterm>checkpoint</firstterm>—a location in the log files known not to be corrupt—and replay transactions until the data is restored to a usable state. See <xref linkend=\"svn.reposadmin.maint.diskspace\"/> for more about Berkeley DB log files."
msgstr "Berkeley DB同时是一个可信赖的数据库系统。Subversion利用了Berkeley DB可以记日志的便利，这意味着数据库先在磁盘上写一个日志文件，描述它将要做的修改，然后再做这些修改。这是为了确保如果如果任何地方出了差错，数据库系统能恢复到先前的检查点—一个日志文件认为没有错误的位置，重新开始事务直到数据恢复为一个可用的状态。关于Berkeley DB日志文件的更多信息请查看<xref linkend=\"svn.reposadmin.maint.diskspace\"/>。"

#: build/en/book.xml:10251(para)
#, fuzzy
msgid "But every rose has its thorn, and so we must note some known limitations of Berkeley DB. First, Berkeley DB environments are not portable. You cannot simply copy a Subversion repository that was created on a Unix system onto a Windows system and expect it to work. While much of the Berkeley DB database format is architecture independent, there are other aspects of the environment that are not. Secondly, Subversion uses Berkeley DB in a way that will not operate on Windows 95/98 systems—if you need to house a BDB-backed repository on a Windows machine, stick with Windows 2000 or newer."
msgstr "但是每朵玫瑰都有刺，我们也必须记录一些Berkeley DB已知的缺陷。首先，Berkeley DB环境不是跨平台的。你不能简单的拷贝一个在Unix上创建的Subversion版本库到一个Windows系统并期望它能够正常工作。尽管Berkeley DB数据库的大部分格式是不受架构约束的，但环境还是有一些方面没有独立出来。其次，使用Berkeley DB的Subversion不能在95/98系统上运行—如果你需要将版本库建在一个Windows机器上，请装到Windows2000或WindowsXP上。另外，Berkeley DB版本库不能放在网络共享文件夹中，尽管Berkeley DB承诺如果按照一套特定规范的话，可以在网络共享上正常运行，但实际上已知的共享类型几乎都不满足这套规范。"

#: build/en/book.xml:10263(para)
msgid "While Berkeley DB promises to behave correctly on network shares that meet a particular set of specifications, <placeholder-1/> most networked filesystem types and appliances do <emphasis>not</emphasis> actually meet those requirements. And in no case can you allow a BDB-backed repository that resides on a network share to be accessed by multiple clients of that share at once (which quite often is the whole point of having the repository live on a network share in the first place)."
msgstr ""

#: build/en/book.xml:10266(para)
msgid "Berkeley DB requires that the underlying filesystem implement strict POSIX locking semantics, and more importantly, the ability to map files directly into process memory."
msgstr ""

#: build/en/book.xml:10280(para)
msgid "If you attempt to use Berkeley DB on a non-compliant remote filesystem, the results are unpredictable—you may see mysterious errors right away, or it may be months before you discover that your repository database is subtly corrupted. You should strongly consider using the FSFS data store for repositories that need to live on a network share."
msgstr ""

#: build/en/book.xml:10289(para)
#, fuzzy
msgid "Finally, because Berkeley DB is a library linked directly into Subversion, it's more sensitive to interruptions than a typical relational database system. Most SQL systems, for example, have a dedicated server process that mediates all access to tables. If a program accessing the database crashes for some reason, the database daemon notices the lost connection and cleans up any mess left behind. And because the database daemon is the only process accessing the tables, applications don't need to worry about permission conflicts. These things are not the case with Berkeley DB, however. Subversion (and programs using Subversion libraries) access the database tables directly, which means that a program crash can leave the database in a temporarily inconsistent, inaccessible state. When this happens, an administrator needs to ask Berkeley DB to restore to a checkpoint, which is a bit of an annoyance. Other things can cause a repository to <quote>wedge</quote> besides crashed processes, such as programs conflicting over ownership and permissions on the database files."
msgstr "最后，因为Berkeley DB的库直接链接到了Subversion中，它对于中断比典型的关系型数据库系统更为敏感。大多数SQL系统，举例来说，有一个主服务进程来协调对数据库表的访问。如果一个访问数据库的程序因为某种原因出现问题，数据库守护进程察觉到连接中断会做一些清理。因为数据库守护进程是唯一访问数据库表的进程，应用程序不需要担心访问许可的冲突。但是，这些情况与Berkeley DB不同。Subversion（和使用Subversion库的程序）直接访问数据库的表，这意味着如果有一个程序崩溃，就会使数据库处于一个暂时的不一致、不可访问的状态。当这种情况发生时，管理员需要让Berkeley DB恢复到一个检查点，这的确有点讨厌。除了崩溃的进程，还有一些情况能让版本库出现异常，比如程序在数据库文件的所有权或访问权限上发生冲突。因为Berkeley DB版本库非常快，并且可以扩展，非常适合使用一个单独的服务进程，通过一个用户来访问—比如Apache的<command moreinfo=\"none\">httpd</command>或<command moreinfo=\"none\">svnserve</command>（参见<xref linkend=\"svn.serverconfig\"/>）—而不是多用户通过<literal moreinfo=\"none\">file:///</literal>或<literal moreinfo=\"none\">svn+ssh://</literal>URL的方式多用户访问。如果将Berkeley DB版本库直接用作多用户访问，请先阅读<xref linkend=\"svn.serverconfig.multimethod\"/>。"

#: build/en/book.xml:10310(para)
msgid "Berkeley DB 4.4 brings (to Subversion 1.4 and better) the ability for Subversion to automatically and transparently recover Berkeley DB environments in need of such recovery. When a Subversion process attaches to a repository's Berkeley DB environment, it uses some process accounting mechanisms to detect any unclean disconnections by previous processes, performs any necessary recovery, and then continues on as if nothing happened. This doesn't completely eliminate instances of repository wedging, but it does drastically reduce the amount of human interaction required to recover from them."
msgstr ""

#: build/en/book.xml:10323(para)
msgid "So while a Berkeley DB repository is quite fast and scalable, it's best used by a single server process running as one user—such as Apache's <command moreinfo=\"none\">httpd</command> or <command moreinfo=\"none\">svnserve</command> (see <xref linkend=\"svn.serverconfig\"/>)—rather than accessing it as many different users via <literal moreinfo=\"none\">file://</literal> or <literal moreinfo=\"none\">svn+ssh://</literal> URLs. If using a Berkeley DB repository directly as multiple users, be sure to read <xref linkend=\"svn.serverconfig.multimethod\"/>."
msgstr ""

#: build/en/book.xml:1033(title)
msgid "Subversion's Components"
msgstr "Subversion的组件"

#: build/en/book.xml:10337(para)
#, fuzzy
msgid "In mid-2004, a second type of repository storage system—one which doesn't use a database at all—came into being. An FSFS repository stores the changes associated with a revision in a single file, and so all of a repository's revisions can be found in a single subdirectory full of numbered files. Transactions are created in separate subdirectories as individual files. When complete, the transaction file is renamed and moved into the revisions directory, thus guaranteeing that commits are atomic. And because a revision file is permanent and unchanging, the repository also can be backed up while <quote>hot</quote>, just like a BDB-backed repository."
msgstr "在2004年中期，另一种版本库存储系统慢慢形成了：一种不需要数据库的存储系统。FSFS版本库在单一文件中存储修订版本树，所以版本库中所有的修订版本都在一个子文件夹中有限的几个文件里。事务在单独的子目录中被创建，创建完成后，一个单独的事务文件被创建并移动到修订版本目录，这保证提交是原子性的。因为一个修订版本文件是持久不可改变的，版本库也可以做到热备份，就象Berkeley DB版本库一样。"

#: build/en/book.xml:1035(para)
msgid "Subversion, once installed, has a number of different pieces. The following is a quick overview of what you get. Don't be alarmed if the brief descriptions leave you scratching your head—there are <emphasis>plenty</emphasis> more pages in this book devoted to alleviating that confusion."
msgstr "安装好的Subversion有几个几个部分组成，本节将简单的介绍一下这些组件。下文的描述或许过于简略，不易理解，不过不用担心，本书后面章节中会用<emphasis>更多的</emphasis>内容来详细阐述这些组件。"

#: build/en/book.xml:10351(para)
#, fuzzy
msgid "The FSFS revision files describe a revision's directory structure, file contents, and deltas against files in other revision trees. Unlike a Berkeley DB database, this storage format is portable across different operating systems and isn't sensitive to CPU architecture. Because there's no journaling or shared-memory files being used, the repository can be safely accessed over a network filesystem and examined in a read-only environment. The lack of database overhead also means that the overall repository size is a bit smaller."
msgstr "修订版本文件格式代表了一个修订版本的目录结构，文件内容，和其它修订版本树中相关信息。不像Berkeley DB数据库，这种存储格式可跨平台并且与CPU架构无关。因为没有日志或用到共享内存的文件，数据库能被网络文件系统安全的访问和在只读环境下检查。缺少数据库花消同时也意味着版本库的总体体积可以稍小一点。"

#: build/en/book.xml:10362(para)
#, fuzzy
msgid "FSFS has different performance characteristics too. When committing a directory with a huge number of files, FSFS is able to more quickly append directory entries. On the other hand, FSFS writes the latest version of a file as a delta against an earlier version, which means that checking out the latest tree is a bit slower than fetching the fulltexts stored in a Berkeley DB HEAD revision. FSFS also has a longer delay when finalizing a commit, which could in extreme cases cause clients to time out while waiting for a response."
msgstr "FSFS也有一种不同的性能特性。当提交大量文件时，FSFS使用O(N)算法来追加条目，而Berkeley DB则用(N^2)算法来重写整个目录。另一方面，FSFS通过写入与上一个版本比较的变化来记录新版本，这也意味着获取最新修订版本时会比Berkeley DB慢一点，提交时FSFS也会有一个更长的延迟，在某些极端情况下会导致客护端在等待回应时超时。"

#: build/en/book.xml:10373(para)
#, fuzzy
msgid "The most important distinction, however, is FSFS's inability to be <quote>wedged</quote> when something goes wrong. If a process using a Berkeley DB database runs into a permissions problem or suddenly crashes, the database can be left in an unusable state until an administrator recovers it. If the same scenarios happen to a process using an FSFS repository, the repository isn't affected at all. At worst, some transaction data is left behind."
msgstr "最重要的区别是当出现错误时FSFS不会楔住的能力。如果使用Berkeley DB的进程发生许可错误或突然崩溃，数据库会一直无法使用，直到管理员恢复。假如在应用FSFS版本库时发生同样的情况，版本库不会受到任何干扰，最坏情况下也就是会留下一些事务数据。"

#: build/en/book.xml:10382(para)
msgid "The only real argument against FSFS is its relative immaturity compared to Berkeley DB. Unlike Berkeley DB, which has years of history, its own dedicated development team and, now, Oracle's mighty name attached to it, <placeholder-1/> FSFS is a much newer bit of engineering. Prior to Subversion 1.4, it was still shaking out some pretty serious data integrity bugs which, while only triggered in very rare cases, nonetheless did occur. That said, FSFS has quickly become the back-end of choice for some of the largest public and private Subversion repositories, and promises a lower barrier to entry for Subversion across the board."
msgstr ""

#: build/en/book.xml:10387(para)
msgid "Oracle bought Sleepycat and its flagship software, Berkeley DB, on Valentine's Day in 2006."
msgstr ""

#: build/en/book.xml:10407(title)
#, fuzzy
msgid "Creating and Configuring Your Repository"
msgstr "创建一个新的Subversion版本库。"

#: build/en/book.xml:10409(para)
msgid "In <xref linkend=\"svn.reposadmin.planning\"/>, we looked at some of the important decisions that should be made before creating and configuring your Subversion repository. Now, we finally get to get our hands dirty! In this section, we'll see how to actually create a Subversion repository and configure it to perform custom actions when special repository events occur."
msgstr ""

#: build/en/book.xml:10419(title)
msgid "Creating the Repository"
msgstr "创建版本库"

#: build/en/book.xml:10421(para)
#, fuzzy
msgid "Subversion repository creation is an incredibly simple task. The <command moreinfo=\"none\">svnadmin</command> utility that comes with Subversion provides a subcommand (<literal moreinfo=\"none\">create</literal>) for doing just that."
msgstr "创建一个 Subversion 版本库出乎寻常的简单。 Subversion 提供的<command moreinfo=\"none\">svnadmin</command> 工具，有一个执行这个功能的子命令。要建立一个新的版本库，只需要运行："

#: build/en/book.xml:10426(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create /path/to/repos\n"
msgstr ""
"\n"
"$ svnadmin create /path/to/repos\n"

#: build/en/book.xml:1043(term) build/en/book.xml:18147(primary)
#: build/en/book.xml:18253(primary) build/en/book.xml:18323(primary)
#: build/en/book.xml:18408(primary) build/en/book.xml:18545(primary)
#: build/en/book.xml:18623(primary) build/en/book.xml:18761(primary)
#: build/en/book.xml:18936(primary) build/en/book.xml:19049(primary)
#: build/en/book.xml:19301(primary) build/en/book.xml:19415(primary)
#: build/en/book.xml:19467(primary) build/en/book.xml:19569(primary)
#: build/en/book.xml:19730(primary) build/en/book.xml:19842(primary)
#: build/en/book.xml:19942(primary) build/en/book.xml:20186(primary)
#: build/en/book.xml:20307(primary) build/en/book.xml:20393(primary)
#: build/en/book.xml:20507(primary) build/en/book.xml:20585(primary)
#: build/en/book.xml:20661(primary) build/en/book.xml:20743(primary)
#: build/en/book.xml:20830(primary) build/en/book.xml:20965(primary)
#: build/en/book.xml:21054(primary) build/en/book.xml:21158(primary)
#: build/en/book.xml:21563(primary) build/en/book.xml:21723(primary)
#: build/en/book.xml:21816(primary)
msgid "svn"
msgstr "svn"

#: build/en/book.xml:10430(para)
msgid "This creates a new repository in the directory <filename moreinfo=\"none\">/path/to/repos</filename>, and with the default filesystem data store. Prior to Subversion 1.2, the default was to use Berkeley DB; the default is now FSFS. You can explicitly choose the filesystem type using the <option>--fs-type</option> argument, which accepts as a parameter either <literal moreinfo=\"none\">fsfs</literal> or <literal moreinfo=\"none\">bdb</literal>."
msgstr ""

#: build/en/book.xml:10439(screen)
#, no-wrap
msgid ""
"\n"
"$ # Create an FSFS-backed repository\n"
"$ svnadmin create --fs-type fsfs /path/to/repos\n"
"$\n"
msgstr ""
"\n"
"$ # Create an FSFS-backed repository\n"
"$ svnadmin create --fs-type fsfs /path/to/repos\n"
"$\n"

#: build/en/book.xml:10445(screen)
#, no-wrap
msgid ""
"\n"
"# Create a Berkeley-DB-backed repository\n"
"$ svnadmin create --fs-type bdb /path/to/repos\n"
"$\n"
msgstr ""
"\n"
"# Create a Berkeley-DB-backed repository\n"
"$ svnadmin create --fs-type bdb /path/to/repos\n"
"$\n"

#: build/en/book.xml:1045(para)
msgid "The command-line client program."
msgstr "命令行客户端程序。"

#: build/en/book.xml:10451(para)
#, fuzzy
msgid "After running this simple command, you have a Subversion repository."
msgstr "目前Subversion有已实现了九种钩子："

#: build/en/book.xml:10455(para)
#, fuzzy
msgid "The path argument to <command moreinfo=\"none\">svnadmin</command> is just a regular filesystem path and not a URL like the <command moreinfo=\"none\">svn</command> client program uses when referring to repositories. Both <command moreinfo=\"none\">svnadmin</command> and <command moreinfo=\"none\">svnlook</command> are considered server-side utilities—they are used on the machine where the repository resides to examine or modify aspects of the repository, and are in fact unable to perform tasks across a network. A common mistake made by Subversion newcomers is trying to pass URLs (even <quote>local</quote><literal moreinfo=\"none\">file://</literal> ones) to these two programs."
msgstr "你可能已经注意到了，<command moreinfo=\"none\">svnadmin</command>命令的路径参数只是一个普通的文件系统路径，而不是一个<command moreinfo=\"none\">svn</command>客户端程序访问版本库时使用的URL。<command moreinfo=\"none\">svnadmin</command>和<command moreinfo=\"none\">svnlook</command>都被认为是服务器端工具—它们在版本库所在的机器上使用，用来检查或修改版本库，不能通过网络来执行任务。一个Subversion的新手通常会犯的错误，就是试图将URL（甚至<quote>本地</quote><literal moreinfo=\"none\">file:</literal>路径）传给这两个程序。"

#: build/en/book.xml:10468(para)
#, fuzzy
msgid "Present in the <filename moreinfo=\"none\">db/</filename> subdirectory of your repository is the implementation of the versioned filesystem. Your new repository's versioned filesystem begins life at revision 0, which is defined to consist of nothing but the top-level root (<filename moreinfo=\"none\">/</filename>) directory. Initially, revision 0 also has a single revision property, <literal moreinfo=\"none\">svn:date</literal>, set to the time at which the repository was created."
msgstr "这个命令在目录<filename moreinfo=\"none\">/path/to/repos</filename>创建了一个新的版本库。这个新的版本库会以修订版本版本0开始其生命周期，里面除了最上层的根目录(<filename moreinfo=\"none\">/</filename>)，什么都没有。刚开始，修订版本0有一个修订版本属性<literal moreinfo=\"none\">svn:date</literal>，设置为版本库创建的时间。"

#: build/en/book.xml:10477(para)
msgid "Now that you have a repository, it's time to customize it."
msgstr ""

#: build/en/book.xml:10481(para)
#, fuzzy
msgid "While some parts of a Subversion repository—such as the configuration files and hook scripts—are meant to be examined and modified manually, you shouldn't (and shouldn't need to) tamper with the other parts of the repository <quote>by hand</quote>. The <command moreinfo=\"none\">svnadmin</command> tool should be sufficient for any changes necessary to your repository, or you can look to third-party tools (such as Berkeley DB's tool suite) for tweaking relevant subsections of the repository. Do <emphasis>not</emphasis> attempt manual manipulation of your version control history by poking and prodding around in your repository's data store files!"
msgstr "一般来说，你不需要手动干预版本库。<command moreinfo=\"none\">svnadmin</command>工具应该足以用来处理对版本库的任何修改，或者你也可以使用第三方工具（比如Berkeley DB的工具包）来调整部分版本库。不过还是会有些例外情况，我们会在这里提到。"

#: build/en/book.xml:10499(title)
msgid "Implementing Repository Hooks"
msgstr "实现版本库钩子"

#: build/en/book.xml:1050(term) build/en/book.xml:24024(command)
#: build/en/book.xml:24029(primary) build/en/book.xml:24033(refname)
msgid "svnversion"
msgstr "svnversion"

#: build/en/book.xml:10501(para)
msgid "A <firstterm>hook</firstterm> is a program triggered by some repository event, such as the creation of a new revision or the modification of an unversioned property. Some hooks (the so-called <quote>pre hooks</quote>) run in advance of a repository operation and provide a means by which to both report what is about to happen and to prevent it from happening at all. Other hooks (the <quote>post hooks</quote>) run after the completion of a repository event, and are useful for reporting purposes only. Each hook is handed enough information to tell what that event is (or was), the specific repository changes proposed (or completed), and the username of the person who triggered the event."
msgstr ""

#: build/en/book.xml:10514(para)
msgid "The <filename moreinfo=\"none\">hooks</filename> subdirectory is, by default, filled with templates for various repository hooks."
msgstr "默认情况下，钩子的子目录中包含各种版本库钩子模板。"

#: build/en/book.xml:10518(screen)
#, no-wrap
msgid ""
"\n"
"$ ls repos/hooks/\n"
"post-commit.tmpl\t  post-unlock.tmpl  pre-revprop-change.tmpl\n"
"post-lock.tmpl\t\t  pre-commit.tmpl   pre-unlock.tmpl\n"
"post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl\n"
msgstr ""
"\n"
"$ ls repos/hooks/\n"
"post-commit.tmpl\t  post-unlock.tmpl  pre-revprop-change.tmpl\n"
"post-lock.tmpl\t\t  pre-commit.tmpl   pre-unlock.tmpl\n"
"post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl\n"

#: build/en/book.xml:1052(para)
msgid "A program for reporting the state (in terms of revisions of the items present) of a working copy."
msgstr "此工具用来显示工作副本的状态（用术语来说，就是当前项目的修订版本）。"

#: build/en/book.xml:10525(para)
#, fuzzy
msgid "There is one template for each hook that the Subversion repository supports, and by examining the contents of those template scripts, you can see what triggers each script to run and what data is passed to that script. Also present in many of these templates are examples of how one might use that script, in conjunction with other Subversion-supplied programs, to perform common useful tasks. To actually install a working hook, you need only place some executable program or script into the <filename moreinfo=\"none\">repos/hooks</filename> directory which can be executed as the name (like <command moreinfo=\"none\">start-commit</command> or <command moreinfo=\"none\">post-commit</command>) of the hook."
msgstr "对每种Subversion版本库支持的钩子的都有一个模板，通过查看这些脚本的内容，你能看到是什么事件触发了脚本及如何给传脚本传递数据。同时，这些模版也是如何使用这些脚本，结合Subversion支持的工具来完成有用任务的例子。要实际安装一个可用的钩子，你需要在<filename moreinfo=\"none\">repos/hooks</filename>目录下安装一些与钩子同名（如 <command moreinfo=\"none\">start-commit</command>或者<command moreinfo=\"none\">post-commit</command>）的可执行程序或脚本。"

#: build/en/book.xml:10538(para)
msgid "On Unix platforms, this means supplying a script or program (which could be a shell script, a Python program, a compiled C binary, or any number of other things) named exactly like the name of the hook. Of course, the template files are present for more than just informational purposes—the easiest way to install a hook on Unix platforms is to simply copy the appropriate template file to a new file that lacks the <literal moreinfo=\"none\">.tmpl</literal> extension, customize the hook's contents, and ensure that the script is executable. Windows, however, uses file extensions to determine whether or not a program is executable, so you would need to supply a program whose basename is the name of the hook, and whose extension is one of the special extensions recognized by Windows for executable programs, such as <filename moreinfo=\"none\">.exe</filename> or <filename moreinfo=\"none\">.com</filename> for programs, and <filename moreinfo=\"none\">.bat</filename> for batch files."
msgstr "在Unix平台上，这意味着要提供一个与钩子同名的脚本或程序（可能是shell 脚本，Python 程序，编译过的c语言二进制文件或其他东西）。当然，脚本模板文件不仅仅是展示了一些信息—在Unix下安装钩子最简单的办法就是拷贝这些模板，并且去掉.tmpl扩展名，然后自定义钩子的内容，确定脚本是可运行的。Windows用文件的扩展名来决定一个程序是否可运行，所以你要使程序的基本名与钩子同名，同时，它的扩展名是Windows系统所能辨认的，例如<filename moreinfo=\"none\">exe</filename>、<filename moreinfo=\"none\">com</filename>和批处理的<filename moreinfo=\"none\">bat</filename>。"

#: build/en/book.xml:10557(para)
#, fuzzy
msgid "For security reasons, the Subversion repository executes hook programs with an empty environment—that is, no environment variables are set at all, not even <literal moreinfo=\"none\">$PATH</literal> (or <literal moreinfo=\"none\">%PATH%</literal>, under Windows). Because of this, many administrators are baffled when their hook program runs fine by hand, but doesn't work when run by Subversion. Be sure to explicitly set any necessary environment variables in your hook program and/or use absolute paths to programs."
msgstr "由于安全原因，Subversion版本库在一个空环境中执行钩子脚本—就是没有任何环境变量，甚至没有<literal moreinfo=\"none\">$PATH</literal>或<literal moreinfo=\"none\">%PATH%</literal>。由于这个原因，许多管理员会感到很困惑，它们的钩子脚本手工运行时正常，可在Subversion中却不能运行。要注意，必须在你的钩子中设置好环境变量或为你的程序指定好绝对路径。"

#: build/en/book.xml:10568(para)
#, fuzzy
msgid "Subversion will attempt to execute hooks as the same user who owns the process which is accessing the Subversion repository. In most cases, the repository is being accessed via a Subversion server, so this user is the same user as which that server runs on the system. The hooks themselves will need to be configured with OS-level permissions that allow that user to execute them. Also, this means that any file or programs (including the Subversion repository itself) accessed directly or indirectly by the hook will be accessed as the same user. In other words, be alert to potential permission-related problems that could prevent the hook from performing the tasks it is designed to perform."
msgstr "Subversion会试图以当前访问版本库的用户身份执行钩子。通常，对版本库的访问总是通过Apache HTTP服务器和mod_dav_svn进行，因此，执行钩子的用户就是运行Apache的用户。钩子本身需要具有操作系统级的访问许可，用户可以运行它。另外，其它被钩子直接或间接使用的文件或程序（包括Subversion版本库本身）也要被同一个用户访问。换句话说，要注意潜在的访问控制问题，它可能会让你的钩子无法按照你的目的顺利执行。"

#: build/en/book.xml:1058(term) build/en/book.xml:10734(title)
#: build/en/book.xml:22908(command) build/en/book.xml:22998(primary)
#: build/en/book.xml:23044(primary) build/en/book.xml:23102(primary)
#: build/en/book.xml:23201(primary) build/en/book.xml:23247(primary)
#: build/en/book.xml:23318(primary) build/en/book.xml:23365(primary)
#: build/en/book.xml:23396(primary) build/en/book.xml:23461(primary)
#: build/en/book.xml:23512(primary) build/en/book.xml:23564(primary)
#: build/en/book.xml:23609(primary) build/en/book.xml:23664(primary)
#: build/en/book.xml:23730(primary) build/en/book.xml:23784(primary)
#: build/en/book.xml:23823(primary)
msgid "svnlook"
msgstr "svnlook"

#: build/en/book.xml:10581(para)
msgid "There are nine hooks implemented by the Subversion repository, and you can get details about each of them in <xref linkend=\"svn.ref.reposhooks\"/>. As a repository administrator, you'll need to decide which of hooks you wish to implement (by way of providing an appropriately named and permissioned hook program), and how. This decision needs to be made with the bigger picture of how repository is deployed in mind. For example, if you are using server configuration stuffs to determine which usernames are permitted to commit changes to your repository, then you don't need to do this sort of access control via the hook system."
msgstr ""

#: build/en/book.xml:10593(para)
msgid "There is no shortage of Subversion hook programs and scripts freely available either from the Subversion community itself or elsewhere. These scripts cover a wide range of utility—basic access control, policy adherence checking, issue tracker integration, email- or syndication-based commit notification, and beyond. See <xref linkend=\"svn.3rdparty\"/> for discussion of some of the most commonly used hook programs. Or, if you wish to write your own, see <xref linkend=\"svn.developer\"/>."
msgstr ""

#: build/en/book.xml:1060(para)
#, fuzzy
msgid "A tool for directly inspecting a Subversion repository."
msgstr "查看Subversion版本库的工具。"

#: build/en/book.xml:10603(para)
msgid "While hook scripts can be leveraged to do almost anything, there is one dimension in which hook script authors should show restraint: do <emphasis>not</emphasis> modify a commit transaction using hook scripts. While it might be tempting to use hook scripts to automatically correct errors or shortcomings or policy violations present in the files being committed, doing so can cause problems. Subversion keeps client-side caches of certain bits of repository data, and if you change a commit transaction in this way, those caches become indetectably stale. This inconsistency can lead to surprising and unexpected behavior. Instead of modifying the transaction, you should simply <emphasis>validate</emphasis> the transaction in the <filename moreinfo=\"none\">pre-commit</filename> hook and reject the commit if it does not meet the desired requirements. As an added bonus, your users will learn the value of careful, compliance-minded work habits."
msgstr ""

#: build/en/book.xml:10626(title)
msgid "Berkeley DB Configuration"
msgstr "Berkeley DB配置"

#: build/en/book.xml:10628(para)
#, fuzzy
msgid "A Berkeley DB environment is an encapsulation of one or more databases, log files, region files and configuration files. The Berkeley DB environment has its own set of default configuration values for things like the number of database locks allowed to be taken out at any given time, or the maximum size of the journaling log files, etc. Subversion's filesystem logic additionally chooses default values for some of the Berkeley DB configuration options. However, sometimes your particular repository, with its unique collection of data and access patterns, might require a different set of configuration option values."
msgstr "Berkeley DB环境是对一个或多个数据库、日志文件、区域文件和配置文件的封装。Berkeley DB环境对许多参数有自己的缺省值，例如任何时间里可用的数据库锁定数目、日志文件的最大值等。Subversion文件系统会使用Berkeley DB的默认值。 不过，有时候你的特定版本库与它独特的数据集合和访问类型，可能需要不同的配置选项。"

#: build/en/book.xml:10640(para)
#, fuzzy
msgid "The producers of Berkeley DB understand that different applications and database environments have different requirements, and so they have provided a mechanism for overriding at runtime many of the configuration values for the Berkeley DB environment. Berkeley checks for the presence of a file named <filename moreinfo=\"none\">DB_CONFIG</filename> in the environment directory, and parses the options found in that file for use with that particular Berkeley DB environment."
msgstr "Sleepycat（Berkeley DB的制造厂商）的人们清楚不同的数据库有不同的需求，所以他们提供了在运行中覆盖Berkeley DB环境配置参数的机制。Berkeley在每一个环境目录中检查是否存在一个名叫<filename moreinfo=\"none\">DB_CONFIG</filename>的文件，然后解析其中的参数成为Berkeley环境所用的选项。"

#: build/en/book.xml:10649(para)
#, fuzzy
msgid "The Berkeley DB configuration file for a BDB-backed repository is located in the repository's <filename moreinfo=\"none\">db</filename> subdirectory, at <filename moreinfo=\"none\">db/DB_CONFIG</filename>. Subversion itself creates this file when it creates the rest of the repository. The file initially contains some default options, as well as pointers to the Berkeley DB online documentation so you can read about what those options do. Of course, you are free to add any of the supported Berkeley DB options to your <filename moreinfo=\"none\">DB_CONFIG</filename> file. Just be aware that while Subversion never attempts to read or interpret the contents of the file, and makes no direct use of the option settings in it, you'll want to avoid any configuration changes that may cause Berkeley DB to behave in a fashion that is at odds with what Subversion might expect. Also, changes made to <filename moreinfo=\"none\">DB_CONFIG</filename> won't take effect until you recover the database environment (using <command moreinfo=\"none\">svnadmin recover</command>)."
msgstr "你的版本库的Berkeley配置文件位于<filename moreinfo=\"none\">db</filename>目录的<filename moreinfo=\"none\">repos/db/DB_CONFIG</filename>， Subversion在创建版本库时自己创建了这个文件。这个文件初始时包含了一些默认选项，也包含了Berkeley DB在线文档，使你能够了解这些选项是做什么的。当然，你也可以为你的<filename moreinfo=\"none\">DB_CONFIG</filename> 文件添加任何Berkeley DB支持的选项。需要注意到，虽然Subversion不会尝试读取并解析这个文件，或使用其中的设置，你一定要避免会导致Berkeley DB按照Subversion代码不习惯的方式工作的修改。另外，<filename moreinfo=\"none\">DB_CONFIG</filename>的修改在复原数据库环境（用<command moreinfo=\"none\">svnadmin recover</command>）之前不会产生任何效果。"

#: build/en/book.xml:1065(term) build/en/book.xml:10701(title)
#: build/en/book.xml:21967(command) build/en/book.xml:22102(primary)
#: build/en/book.xml:22165(primary) build/en/book.xml:22205(primary)
#: build/en/book.xml:22315(primary) build/en/book.xml:22347(primary)
#: build/en/book.xml:22389(primary) build/en/book.xml:22421(primary)
#: build/en/book.xml:22469(primary) build/en/book.xml:22535(primary)
#: build/en/book.xml:22583(primary) build/en/book.xml:22623(primary)
#: build/en/book.xml:22705(primary) build/en/book.xml:22751(primary)
#: build/en/book.xml:22805(primary) build/en/book.xml:22865(primary)
msgid "svnadmin"
msgstr "svnadmin"

#: build/en/book.xml:1067(para)
msgid "A tool for creating, tweaking or repairing a Subversion repository."
msgstr "建立、调整和修复Subversion版本库的工具。"

#: build/en/book.xml:10676(title)
msgid "Repository Maintenance"
msgstr "版本库维护"

#: build/en/book.xml:10678(para)
#, fuzzy
msgid "Maintaining a Subversion repository can be a daunting task, mostly due to the complexities inherent in systems which have a database backend. Doing the task well is all about knowing the tools—what they are, when to use them, and how to use them. This section will introduce you to the repository administration tools provided by Subversion, and how to wield them to accomplish tasks such as repository data migration, upgrades, backups and cleanups."
msgstr "维护一个Subversion版本库是一项令人沮丧的工作，主要因为有数据库后端与生俱来的复杂性。做好这项工作需要知道一些工具——它们是什么，什么时候用以及如何使用。这一节将会向你介绍Subversion自带的版本库管理工具，以及如何使用它们来完成诸如版本库移植、升级、备份和整理之类的任务。"

#: build/en/book.xml:10689(title)
msgid "An Administrator's Toolkit"
msgstr "管理员的工具箱"

#: build/en/book.xml:10691(para)
msgid "Subversion provides a handful of utilities useful for creating, inspecting, modifying and repairing your repository. Let's look more closely at each of those tools. Afterward, we'll briefly examine some of the utilities included in the Berkeley DB distribution that provide functionality specific to your repository's database backend not otherwise provided by Subversion's own tools."
msgstr "Subversion提供了一些用来创建、查看、修改和修复版本库的工具。让我们首先详细了解一下每个工具，然后，我们再看一下仅在Berkeley DB后端分发版本中提供的版本数据库工具。"

#: build/en/book.xml:10703(para)
#, fuzzy
msgid "The <command moreinfo=\"none\">svnadmin</command> program is the repository administrator's best friend. Besides providing the ability to create Subversion repositories, this program allows you to perform several maintenance operations on those repositories. The syntax of <command moreinfo=\"none\">svnadmin</command> is similar to that of other Subversion command-line programs:"
msgstr "<command moreinfo=\"none\">svnadmin</command>程序是版本库管理员最好的朋友。除了提供创建Subversion版本库的功能，这个程序使你可以维护这些版本库。<command moreinfo=\"none\">svnadmin</command>的语法跟<command moreinfo=\"none\">svnlook</command>类似："

#: build/en/book.xml:10711(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin help\n"
"general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnadmin --version' to see the program version and FS modules.\n"
"\n"
"Available subcommands:\n"
"   crashtest\n"
"   create\n"
"   deltify\n"
"…\n"
msgstr ""
"\n"
"$ svnadmin help\n"
"general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnadmin --version' to see the program version and FS modules.\n"
"\n"
"Available subcommands:\n"
"   crashtest\n"
"   create\n"
"   deltify\n"
"…\n"

#: build/en/book.xml:10724(para)
#, fuzzy
msgid "We've already mentioned <command moreinfo=\"none\">svnadmin</command>'s <literal moreinfo=\"none\">create</literal> subcommand (see <xref linkend=\"svn.reposadmin.basics.creating\"/>). Most of the others we will cover as they become topically relevant later in this chapter. And you can consult <xref linkend=\"svn.ref.svnadmin\"/> for a full rundown of subcommands and what each of them offers."
msgstr "我们已经提过<command moreinfo=\"none\">svnadmin</command>的<literal moreinfo=\"none\">create</literal>子命令（参照<xref linkend=\"svn.reposadmin.create\"/>）。本章中我们会详细讲解大多数其他的命令。现在，我们来简单的看一下每个可用的子命令提供了什么功能。"

#: build/en/book.xml:1073(term) build/en/book.xml:10859(title)
msgid "svndumpfilter"
msgstr "svndumpfilter"

#: build/en/book.xml:10736(para)
#, fuzzy
msgid "<command moreinfo=\"none\">svnlook</command> is a tool provided by Subversion for examining the various revisions and transactions in a repository. No part of this program attempts to change the repository. <command moreinfo=\"none\">svnlook</command> is typically used by the repository hooks for reporting the changes that are about to be committed (in the case of the <command moreinfo=\"none\">pre-commit</command> hook) or that were just committed (in the case of the <command moreinfo=\"none\">post-commit</command> hook) to the repository. A repository administrator may use this tool for diagnostic purposes."
msgstr "<command moreinfo=\"none\">svnlook</command>是Subversion提供的用来查看版本库中不同的修订版本和事务。这个程序不会修改版本库内容－这是个<quote>只读</quote>的工具。<command moreinfo=\"none\">svnlook</command>通常用在版本库钩子程序中，用来记录版本库即将提交（<command moreinfo=\"none\">用在pre-commit钩子时）</command>或者已经提交的（用在<command moreinfo=\"none\">post-commit</command>钩子时）修改。版本库管理员可以将这个工具用于诊断。"

#: build/en/book.xml:10747(para)
msgid "<command moreinfo=\"none\">svnlook</command> has a straightforward syntax:"
msgstr "<command moreinfo=\"none\">svnlook</command> 的语法很直接："

#: build/en/book.xml:1075(para)
msgid "A program for filtering Subversion repository dump streams."
msgstr "过滤Subversion版本库转储数据流的工具。"

#: build/en/book.xml:10750(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook help\n"
"general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]\n"
"Note: any subcommand which takes the '--revision' and '--transaction'\n"
"      options will, if invoked without one of those options, act on\n"
"      the repository's youngest revision.\n"
"Type 'svnlook help &lt;subcommand$gt;' for help on a specific subcommand.\n"
"Type 'svnlook --version' to see the program version and FS modules.\n"
"…\n"
msgstr ""
"\n"
"$ svnlook help\n"
"general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]\n"
"Note: any subcommand which takes the '--revision' and '--transaction'\n"
"      options will, if invoked without one of those options, act on\n"
"      the repository's youngest revision.\n"
"Type 'svnlook help &lt;subcommand$gt;' for help on a specific subcommand.\n"
"Type 'svnlook --version' to see the program version and FS modules.\n"
"…\n"

#: build/en/book.xml:10761(para)
#, fuzzy
msgid "Nearly every one of <command moreinfo=\"none\">svnlook</command>'s subcommands can operate on either a revision or a transaction tree, printing information about the tree itself, or how it differs from the previous revision of the repository. You use the <option>--revision (-r)</option> and <option>--transaction (-t)</option> options to specify which revision or transaction, respectively, to examine. In the absence of both the <option>--revision (-r)</option> and <option>--transaction (-t)</option> options, <command moreinfo=\"none\">svnlook</command> will examine the youngest (or <quote>HEAD</quote>) revision in the repository. So the following two commands do exactly the same thing when 19 is the youngest revision in the repository located at <filename moreinfo=\"none\">/path/to/repos</filename>:"
msgstr "几乎<command moreinfo=\"none\">svnlook</command>的每一个子命令都能操作修订版本或事务树，显示树本身的信息，或是它与版本库中上一个修订版本的不同。你可以用<option>--revision</option> 和 <option>--transaction</option>选项指定要查看的修订版本或事务。注意，虽然修订版本号看起来像自然数，但是事务名称是包含英文字母与数字的字符串。请记住文件系统只允许浏览未提交的事务（还没有形成一个新的修订版本的事务）。多数版本库没有这种事务，因为事务通常或者被提交了（这样便不能被查看），或者被中止并删除了。"

#: build/en/book.xml:10776(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook info /path/to/repos\n"
"$ svnlook info /path/to/repos -r 19\n"
msgstr ""
"\n"
"$ svnlook info /path/to/repos\n"
"$ svnlook info /path/to/repos -r 19\n"

#: build/en/book.xml:10781(para)
#, fuzzy
msgid "The only exception to these rules about subcommands is the <command moreinfo=\"none\">svnlook youngest</command> subcommand, which takes no options, and simply prints out the repository's youngest revision number."
msgstr "这些子命令的唯一例外，是<command moreinfo=\"none\">svnlook youngest</command>命令，它不需要选项，只会显示出<literal moreinfo=\"none\">HEAD</literal>的修订版本号。"

#: build/en/book.xml:10786(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook youngest /path/to/repos\n"
"19\n"
msgstr ""
"\n"
"$ svnlook youngest /path/to/repos\n"
"19\n"

#: build/en/book.xml:10792(para)
msgid "Keep in mind that the only transactions you can browse are uncommitted ones. Most repositories will have no such transactions, because transactions are usually either committed (in which case, you should access them as revision with the <option>--revision (-r)</option> option) or aborted and removed."
msgstr ""

#: build/en/book.xml:10800(para)
msgid "Output from <command moreinfo=\"none\">svnlook</command> is designed to be both human- and machine-parsable. Take as an example the output of the <literal moreinfo=\"none\">info</literal> subcommand:"
msgstr "<command moreinfo=\"none\">svnlook</command>的输出被设计为人和机器都易理解，拿<literal moreinfo=\"none\">info</literal>子命令举例来说："

#: build/en/book.xml:10804(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook info /path/to/repos\n"
"sally\n"
"2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)\n"
"27\n"
"Added the usual\n"
"Greek tree.\n"
msgstr ""
"\n"
"$ svnlook info /path/to/repos\n"
"sally\n"
"2002-11-04 09:29:13 -0600 (Mon， 04 Nov 2002)\n"
"27\n"
"Added the usual\n"
"Greek tree.\n"

#: build/en/book.xml:1081(term) build/en/book.xml:16483(term)
#: build/en/book.xml:24178(command) build/en/book.xml:24183(literal)
msgid "mod_dav_svn"
msgstr "mod_dav_svn"

#: build/en/book.xml:10813(para)
msgid "The output of the <literal moreinfo=\"none\">info</literal> subcommand is defined as:"
msgstr "<literal moreinfo=\"none\">info</literal>子命令的输出定义如下："

#: build/en/book.xml:10818(para)
msgid "The author, followed by a newline."
msgstr "作者，后接换行。"

#: build/en/book.xml:10821(para)
msgid "The date, followed by a newline."
msgstr "日期，后接换行。"

#: build/en/book.xml:10824(para)
msgid "The number of characters in the log message, followed by a newline."
msgstr "日志消息的字数，后接换行。"

#: build/en/book.xml:10828(para)
msgid "The log message itself, followed by a newline."
msgstr "日志信息本身， 后接换行。"

#: build/en/book.xml:1083(para)
msgid "A plug-in module for the Apache HTTP Server, used to make your repository available to others over a network."
msgstr "Apache HTTP服务器的一个插件，使版本库可以通过网络访问。"

#: build/en/book.xml:10832(para)
#, fuzzy
msgid "This output is human-readable, meaning items like the datestamp are displayed using a textual representation instead of something more obscure (such as the number of nanoseconds since the Tasty Freeze guy drove by). But the output is also machine-parsable—because the log message can contain multiple lines and be unbounded in length, <command moreinfo=\"none\">svnlook</command> provides the length of that message before the message itself. This allows scripts and other wrappers around this command to make intelligent decisions about the log message, such as how much memory to allocate for the message, or at least how many bytes to skip in the event that this output is not the last bit of data in the stream."
msgstr "这种输出是人可阅读的，像是时间戳这种有意义的条目，使用文本表示，而不是其他比较晦涩的方式（例如许多无聊的人推荐的十亿分之一秒的数量）。这种输出也是机器可读的—因为日志信息可以有多行，没有长度的限制，<command moreinfo=\"none\">svnlook</command>在日志消息之前提供了消息的长度，这使得脚本或者其他对这个命令进行的封装提供了更强的功能，比如日志消息使用了多少内存，或在这个输出成为最后一个字节之前应该略过多少字节。"

#: build/en/book.xml:10846(para)
#, fuzzy
msgid "<command moreinfo=\"none\">svnlook</command> can perform a variety of other queries: displaying subsets of bits of information we've mentioned previously, recursively listing versioned directory trees, reporting which paths were modified in a given revision or transaction, showing textual and property differences made to files and directories, and so on. See <xref linkend=\"svn.ref.svnlook\"/> for a full reference of <command moreinfo=\"none\">svnlook</command>'s features."
msgstr "<command moreinfo=\"none\">svnlook</command>还可以做很多别的查询，显示我们先前提到的信息的一些子集，报告指定的修订版本或事务中哪些路径曾经被修改过，显示对文件和目录做过的文本和属性的修改，等等。下面是<command moreinfo=\"none\">svnlook</command>命令能接受的子命令的介绍，以及这些子命令的输出："

#: build/en/book.xml:10861(para)
#, fuzzy
msgid "While it won't be the most commonly used tool at the administrator's disposal, <command moreinfo=\"none\">svndumpfilter</command> provides a very particular brand of useful functionality—the ability to quickly and easily modify streams of Subversion repository history data by acting as a path-based filter."
msgstr "虽然在管理员的日常工作中并不会经常使用，不过<command moreinfo=\"none\">svndumpfilter</command>可以对特定的路径进行过滤。这是一个独特而很有意义的用法，可以帮助你快速方便的修改转储的数据。使用时，只需提供一个你想要保留的（或者不想保留的）路径列表，然后把你的版本库转储文件送进这个过滤器。最后你就可以得到一个仅包含你想保留的路径的转储数据流。"

#: build/en/book.xml:10868(para)
msgid "The syntax of <command moreinfo=\"none\">svndumpfilter</command> is as follows:"
msgstr "<command moreinfo=\"none\">svndumpfilter</command>的语法如下："

#: build/en/book.xml:10871(screen)
#, no-wrap
msgid ""
"\n"
"$ svndumpfilter help\n"
"general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]\n"
"Type \"svndumpfilter help &lt;subcommand&gt;\" for help on a specific subcommand.\n"
"Type 'svndumpfilter --version' to see the program version.\n"
"  \n"
"Available subcommands:\n"
"   exclude\n"
"   include\n"
"   help (?, h)\n"
msgstr ""
"\n"
"$ svndumpfilter help\n"
"general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]\n"
"Type \"svndumpfilter help &lt;subcommand&gt;\" for help on a specific subcommand.\n"
"Type 'svndumpfilter --version' to see the program version.\n"
"  \n"
"Available subcommands:\n"
"   exclude\n"
"   include\n"
"   help (?, h)\n"

#: build/en/book.xml:10883(para)
msgid "There are only two interesting subcommands. They allow you to make the choice between explicit or implicit inclusion of paths in the stream:"
msgstr "有意义的子命令只有两个。你可以使用这两个子命令说明你希望保留和不希望保留的路径："

#: build/en/book.xml:10889(literal)
msgid "exclude"
msgstr "exclude"

#: build/en/book.xml:10891(para)
msgid "Filter out a set of paths from the dump data stream."
msgstr "将指定路径的数据从转储数据流中排除。"

#: build/en/book.xml:10897(literal)
msgid "include"
msgstr "include"

#: build/en/book.xml:10899(para)
msgid "Allow only the requested set of paths to pass through the dump data stream."
msgstr "将指定路径的数据添加到转储数据流中。"

#: build/en/book.xml:1090(term) build/en/book.xml:12672(entry)
#: build/en/book.xml:1624(literal) build/en/book.xml:23864(command)
msgid "svnserve"
msgstr "svnserve"

#: build/en/book.xml:10905(para)
#, fuzzy
msgid "You can learn more about these subcommands and <command moreinfo=\"none\">svndumpfilter</command>'s unique purpose in <xref linkend=\"svn.reposadmin.maint.filtering\"/>."
msgstr "关于<command moreinfo=\"none\">svn update</command>的详细讨论，见<xref linkend=\"svn.tour.cycle.update\"/>。"

#: build/en/book.xml:10912(title) build/en/book.xml:1099(term)
msgid "svnsync"
msgstr "svnsync"

#: build/en/book.xml:10914(para)
msgid "The <command moreinfo=\"none\">svnsync</command> program, which is new to the 1.4 release of Subversion, provides all the functionality required for maintaining a read-only mirror of a Subversion repository. The program really has one job—to transfer one repository's versioned history into another repository. And while there are few ways to do that, its primary strength is that it can operate remotely—the <quote>source</quote> and <quote>sink</quote><placeholder-1/> repositories may be on different computers from each other and from <command moreinfo=\"none\">svnsync</command> itself."
msgstr ""

#: build/en/book.xml:1092(para)
msgid "A custom standalone server program, runnable as a daemon process or invokable by SSH; another way to make your repository available to others over a network."
msgstr "一个单独运行的服务器程序，可以作为守护进程或由SSH调用。这是另一种使版本库可以通过网络访问的方式。"

#: build/en/book.xml:10924(para)
#, fuzzy
msgid "Or is that, the <quote>sync</quote>?"
msgstr "<quote>锁定</quote>的三种含义"

#: build/en/book.xml:10929(para)
msgid "As you might expect, <command moreinfo=\"none\">svnsync</command> has a syntax that looks very much like every other program we've mentioned in this chapter:"
msgstr ""

#: build/en/book.xml:10933(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help\n"
"general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnsync --version' to see the program version and RA modules.\n"
"\n"
"Available subcommands:\n"
"   initialize (init)\n"
"   synchronize (sync)\n"
"   copy-revprops\n"
"   help (?, h)\n"
"$\n"
msgstr ""
"\n"
"$ svnsync help\n"
"general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnsync --version' to see the program version and RA modules.\n"
"\n"
"Available subcommands:\n"
"   initialize (init)\n"
"   synchronize (sync)\n"
"   copy-revprops\n"
"   help (?, h)\n"
"$\n"

#: build/en/book.xml:10947(para)
#, fuzzy
msgid "We talk more about replication repositories with <command moreinfo=\"none\">svnsync</command> in <xref linkend=\"svn.reposadmin.maint.replication\"/>."
msgstr "关于<command moreinfo=\"none\">svn status</command>的详细讨论，见<xref linkend=\"svn.tour.cycle.examine.status\"/>。"

#: build/en/book.xml:10954(title)
msgid "Berkeley DB Utilities"
msgstr "Berkeley DB工具"

#: build/en/book.xml:10956(para)
#, fuzzy
msgid "If you're using a Berkeley DB repository, then all of your versioned filesystem's structure and data live in a set of database tables within the <filename moreinfo=\"none\">db/</filename> subdirectory of your repository. This subdirectory is a regular Berkeley DB environment directory, and can therefore be used in conjunction with any of the Berkeley database tools, typically provided as part of the Berkeley DB distribution."
msgstr "如果你使用Berkeley DB版本库，那么所有纳入版本控制的文件系统结构和数据都储存在一系列数据库的表中，而这个位于版本库的<filename moreinfo=\"none\">db</filename>子目录下。这个子目录是一个标准的Berkeley DB环境目录，可以应用任何Berkeley数据库工具进行操作（参考SleepyCat网站<ulink url=\"http://www.sleepycat.com/\"/>上关于这些工具的介绍）。"

#: build/en/book.xml:10965(para)
msgid "For day-to-day Subversion use, these tools are unnecessary. Most of the functionality typically needed for Subversion repositories has been duplicated in the <command moreinfo=\"none\">svnadmin</command> tool. For example, <command moreinfo=\"none\">svnadmin list-unused-dblogs</command> and <command moreinfo=\"none\">svnadmin list-dblogs</command> perform a subset of what is provided by the Berkeley <command moreinfo=\"none\">db_archive</command> command, and <command moreinfo=\"none\">svnadmin recover</command> reflects the common use cases of the <command moreinfo=\"none\">db_recover</command> utility."
msgstr "对于Subversion的日常使用来说，这些工具并没有什么用处。大多数Subversion版本库必须的数据库操作都集成到<command moreinfo=\"none\">svnadmin</command>工具中。比如，<command moreinfo=\"none\">svnadmin list-unused-dblogs</command>和<command moreinfo=\"none\">svnadmin list-dblogs</command>实现了Berkeley <command moreinfo=\"none\">db_archive</command>命令功能的一个子集，而<command moreinfo=\"none\">svnadmin recover</command>则起到了 <command moreinfo=\"none\">db_recover</command>工具的作用。"

#: build/en/book.xml:10976(para)
msgid "There are still a few Berkeley DB utilities that you might find useful. The <command moreinfo=\"none\">db_dump</command> and <command moreinfo=\"none\">db_load</command> programs write and read, respectively, a custom file format which describes the keys and values in a Berkeley DB database. Since Berkeley databases are not portable across machine architectures, this format is a useful way to transfer those databases from machine to machine, irrespective of architecture or operating system. Also, the <command moreinfo=\"none\">db_stat</command> utility can provide useful information about the status of your Berkeley DB environment, including detailed statistics about the locking and storage subsystems."
msgstr "当然，还有一些Berkeley DB工具有时是有用的。<command moreinfo=\"none\">db_dump</command>将Berkeley DB数据库中的键值对以特定的格式写入文件中，而<command moreinfo=\"none\">db_load</command>则可以将这些键值对注入到数据库中。Berkeley数据库本身不支持跨平台转移，这两个工具在这样的情况下就可以实现在平台间转移数据库的功能，而无需关心操作系统或机器架构。此外，<command moreinfo=\"none\">db_stat</command>工具能够提供关于Berkeley DB环境的许多有用信息，包括详细的锁定和存储子系统的统计信息。"

#: build/en/book.xml:10989(para)
msgid "For more information on the Berkeley DB tool chain, visit the documentation section of the Berkeley DB section of Oracle's website, located at <ulink url=\"http://www.oracle.com/technology/documentation/berkeley-db/db/\"/>."
msgstr ""

#: build/en/book.xml:10998(title)
#, fuzzy
msgid "Commit Log Message Correction"
msgstr "提交事务。"

#: build/en/book.xml:11000(para)
msgid "Sometimes a user will have an error in her log message (a misspelling or some misinformation, perhaps). If the repository is configured (using the <literal moreinfo=\"none\">pre-revprop-change</literal> and <literal moreinfo=\"none\">post-revprop-change</literal> hooks; see <xref linkend=\"svn.reposadmin.create.hooks\"/>) to accept changes to this log message after the commit is finished, then the user can <quote>fix</quote> her log message remotely using the <command moreinfo=\"none\">svn</command> program's <literal moreinfo=\"none\">propset</literal> command (see <xref linkend=\"svn.ref\"/>). However, because of the potential to lose information forever, Subversion repositories are not, by default, configured to allow changes to unversioned properties—except by an administrator."
msgstr "有时用户输入的日志信息有错误（比如拼写错误或者内容错误）。如果配置版本库时设置了（使用<literal moreinfo=\"none\">pre-revprop-change</literal>和 <literal moreinfo=\"none\">post-revprop-change</literal>钩子；参见<xref linkend=\"svn.reposadmin.create.hooks\"/>）允许用户在提交后修改日志信息的选项，那么用户可以使用<command moreinfo=\"none\">svn</command>程序的<literal moreinfo=\"none\">propset</literal>命令（参见<xref linkend=\"svn.ref\"/>）<quote>修正</quote>日志信息中的错误。不过为了避免永远丢失信息，Subversion版本库通常设置为仅能由管理员修改非版本化属性（这也是默认的选项）。"

#: build/en/book.xml:1101(para)
msgid "A program for incrementally mirroring one repository to another over a network."
msgstr ""

#: build/en/book.xml:11013(para)
msgid "If a log message needs to be changed by an administrator, this can be done using <command moreinfo=\"none\">svnadmin setlog</command>. This command changes the log message (the <literal moreinfo=\"none\">svn:log</literal> property) on a given revision of a repository, reading the new value from a provided file."
msgstr "如果管理员想要修改日志信息，那么可以使用<command moreinfo=\"none\">svnadmin setlog</command>命令。这个命令从指定的文件中读取信息，取代版本库中某个修订版本的日志信息（<literal moreinfo=\"none\">svn:log</literal>属性）。"

#: build/en/book.xml:11019(screen)
#, no-wrap
msgid ""
"\n"
"$ echo \"Here is the new, correct log message\" &gt; newlog.txt\n"
"$ svnadmin setlog myrepos newlog.txt -r 388\n"
msgstr ""
"\n"
"$ echo \"Here is the new， correct log message\" &gt; newlog.txt\n"
"$ svnadmin setlog myrepos newlog.txt -r 388\n"

#: build/en/book.xml:11024(para)
msgid "The <command moreinfo=\"none\">svnadmin setlog</command> command alone is still bound by the same protections against modifying unversioned properties as a remote client is—the <literal moreinfo=\"none\">pre-</literal> and <literal moreinfo=\"none\">post-revprop-change</literal> hooks are still triggered, and therefore must be setup to accept changes of this nature. But an administrator can get around these protections by passing the <option>--bypass-hooks</option> option to the <command moreinfo=\"none\">svnadmin setlog</command> command."
msgstr "即使是<command moreinfo=\"none\">svnadmin setlog</command>命令也受到限制。<literal moreinfo=\"none\">pre-</literal>和 <literal moreinfo=\"none\">post-revprop-change</literal>钩子同样会被触发，因此必须进行相应的设置才能允许修改非版本化属性。不过管理员可以使用<command moreinfo=\"none\">svnadmin setlog</command>命令的<option>--bypass-hooks</option>选项跳过钩子。"

#: build/en/book.xml:11035(para)
msgid "Remember, though, that by bypassing the hooks, you are likely avoiding such things as email notifications of property changes, backup systems which track unversioned property changes, and so on. In other words, be very careful about what you are changing, and how you change it."
msgstr "不过需要注意的是，一旦跳过钩子也就跳过了钩子所提供的所有功能，比如邮件通知（通知属性有改动）、系统备份（可以用来跟踪非版本化的属性变更）等等。换句话说，要留心你所作出的修改，以及你作出修改的方式。"

#: build/en/book.xml:11048(title)
msgid "Managing Disk Space"
msgstr "管理磁盘空间"

#: build/en/book.xml:11050(para)
#, fuzzy
msgid "While the cost of storage has dropped incredibly in the past few years, disk usage is still a valid concern for administrators seeking to version large amounts of data. Every bit of version history information stored in the live repository is information that needs to be backed up elsewhere, perhaps multiple times as part of rotating backup schedules. It is useful to know what pieces of Subversion's repository data need to remain on the live site, which need to be backed up, and which can be safely removed."
msgstr "虽然存储器的价格在过去的几年里以让人难以致信的速度滑落，但是对于那些需要对大量数据进行版本管理的管理员们来说，磁盘空间的消耗依然是一个重要的因素。版本库每增加一个字节都意味着需要多一个字节的磁盘空间进行备份，对于多重备份来说，就需要消耗更多的磁盘空间。Berkeley DB版本库的主要存储机制是基于一个复杂的数据库系统建立的，因此了解一些数据性质是有意义的，比如哪些数据必须保留。哪些数据需要备份、哪些数据可以安全的删除等等。本节的内容专注于Berkeley DB类型的版本库。FSFS类型的版本库不需要进行数据清理和回收。"

#: build/en/book.xml:11062(title)
msgid "How Subversion saves disk space"
msgstr ""

#: build/en/book.xml:11064(para)
#, fuzzy
msgid "To keep the size of the repository as small as possible, Subversion uses <firstterm>deltification</firstterm> (or, <quote>deltified storage</quote>) within the repository itself. Deltification involves encoding the representation of a chunk of data as a collection of differences against some other chunk of data. If the two pieces of data are very similar, this deltification results in storage savings for the deltified chunk—rather than taking up space equal to the size of the original data, it takes up only enough space to say, <quote>I look just like this other piece of data over here, except for the following couple of changes</quote>. The result is that most of the repository data that tends to be sizable—namely, the contents of versioned files—is stored at a much smaller size than the original <quote>fulltext</quote> representation of that data. And for repositories created with Subversion 1.4 or later, the space saving get even better—now those fulltext representations of file contents are themselves compressed."
msgstr "为了尽可能减小版本库的体积，Subversion在版本库中采用了<firstterm>增量化技术</firstterm>（或称为<quote>增量存储技术</quote>）。增量化技术可以将一组数据表示为相对于另一组数据的不同。如果这两组数据十分相似，增量化技术就可以仅保存其中一组数据以及两组数据的差别，而不需要同时保存两组数据，从而节省了磁盘空间。每次一个文件的新版本提交到版本库，版本库就会将之前的版本（之前的多个版本）相对于新版本做增量化处理。采用了这项技术，版本库的数据量大小基本上是可以估算出来的—主要是版本化的文件的大小—并且远小于<quote>全文</quote>保存所需的数据量。"

#: build/en/book.xml:1108(para)
msgid "Assuming you have Subversion installed correctly, you should be ready to start. The next two chapters will walk you through the use of <command moreinfo=\"none\">svn</command>, Subversion's command-line client program."
msgstr "如果已经正确完成了Subversion的安装，我们就可以开始我们的学习之旅了。在后面的两章中，我们将讲解如何使用Subversion的客户端程序<command moreinfo=\"none\">svn</command>。"

#: build/en/book.xml:11085(para)
#, fuzzy
msgid "Because all of the data that is subject to deltification in a BDB-backed repository is stored in a single Berkeley DB database file, reducing the size of the stored values will not immediately reduce the size of the database file itself. Berkeley DB will, however, keep internal records of unused areas of the database file, and consume those areas first before growing the size of the database file. So while deltification doesn't produce immediate space savings, it can drastically slow future growth of the database."
msgstr "由于Subversion版本库的增量化数据保存在单一Berkeley DB数据库文件中，减少数据的体积并不一定能够减小数据库文件的大小。但是，Berkeley DB会在内部记录未使用的数据库文件区域，并且在增加数据库文件大小之前会首先使用这些未使用的区域。因此，即使增量化技术不能立杆见影的节省磁盘空间，也可以极大的减慢数据库的膨胀速度。"

#: build/en/book.xml:11101(title)
#, fuzzy
msgid "Removing dead transactions"
msgstr "移除中止的事务，"

#: build/en/book.xml:11103(para)
#, fuzzy
msgid "Though they are uncommon, there are circumstances in which a Subversion commit process might fail, leaving behind in the repository the remnants of the revision-to-be that wasn't—an uncommitted transaction and all the file and directory changes associated with it. This could happen for several reasons: perhaps the client operation was inelegantly terminated by the user, or a network failure might have occurred in the middle of an operation, etc. Regardless of the reason, dead transactions can happen. They don't do any real harm, other than consuming disk space. A fastidious administrator may nonetheless wish to remove them."
msgstr "<command moreinfo=\"none\">svnadmin</command>的另一个常见用途是查询异常的—可能是已经死亡的—Subversion事务。通常提交操作失败时，与之相关的事务就会被清除。也就是说，事务本身及所有与该事务相关（且仅与该事务相关）的数据会从版本库中删除。不过偶尔也会出现操作失败而事务没有被清除的情况。出现这种情况可能有以下原因：客户端的用户粗暴的结束了操作，操作过程中出现网络故障，等等。不管是什么原因，死亡的事务总是有可能会出现。这类事务不会产生什么负面影响，仅仅是消耗了一点点磁盘空间。不过，严厉的管理员总是希望能够将它们清除出去。"

#: build/en/book.xml:11116(para)
msgid "You can use <command moreinfo=\"none\">svnadmin</command>'s <literal moreinfo=\"none\">lstxns</literal> command to list the names of the currently outstanding transactions."
msgstr "可以使用<command moreinfo=\"none\">svnadmin</command>的<literal moreinfo=\"none\">lstxns</literal> 命令列出当前的异常事务名。"

#: build/en/book.xml:11120(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin lstxns myrepos\n"
"19\n"
"3a1\n"
"a45\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin lstxns myrepos\n"
"19\n"
"3a1\n"
"a45\n"
"$\n"

#: build/en/book.xml:11128(para)
#, fuzzy
msgid "Each item in the resultant output can then be used with <command moreinfo=\"none\">svnlook</command> (and its <option>--transaction (-t)</option> option) to determine who created the transaction, when it was created, what types of changes were made in the transaction—information that is helpful in determining whether or not the transaction is a safe candidate for removal! If so, the transaction's name can be passed to <command moreinfo=\"none\">svnadmin rmtxns</command>, which will perform the cleanup of the transaction. In fact, the <literal moreinfo=\"none\">rmtxns</literal> subcommand can take its input directly from the output of <literal moreinfo=\"none\">lstxns</literal>!"
msgstr "将输出的结果条目作为<command moreinfo=\"none\">svnlook</command>（设置<option>--transaction</option>选项）的参数，就可以获得事务的详细信息，如事务的创建者、创建时间，事务已作出的更改类型，由这些信息可以判断出是否可以将这个事务安全的删除。如果可以安全删除，那么只需将事务名作为参数输入到<command moreinfo=\"none\">svnadmin rmtxns</command>，就可以将事务清除掉了。其实<literal moreinfo=\"none\">rmtxns</literal>子命令可以直接以<literal moreinfo=\"none\">lstxns</literal>的输出作为输入进行清理。"

#: build/en/book.xml:11141(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`\n"
"$\n"

#: build/en/book.xml:11146(para)
#, fuzzy
msgid "If you use these two subcommands like this, you should consider making your repository temporarily inaccessible to clients. That way, no one can begin a legitimate transaction before you start your cleanup. <xref linkend=\"svn.reposadmin.maint.diskspace.deadtxns.ex-1\"/> contains a bit of shell-scripting that can quickly generate information about each outstanding transaction in your repository."
msgstr "在按照上面例子中的方法清理版本库之前，你或许应该暂时关闭版本库和客户端的连接。这样在你开始清理之前，不会有正常的事务进入版本库。下面例子中的shell脚本可以用来迅速获得版本库中异常事务的信息："

#: build/en/book.xml:11155(title)
msgid "txn-info.sh (Reporting Outstanding Transactions)"
msgstr "txn-info.sh（异常事务报告）"

#: build/en/book.xml:11157(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh\n"
"\n"
"### Generate informational output for all outstanding transactions in\n"
"### a Subversion repository.\n"
"\n"
"REPOS=\"${1}\"\n"
"if [ \"x$REPOS\" = x ] ; then\n"
"  echo \"usage: $0 REPOS_PATH\"\n"
"  exit\n"
"fi\n"
"\n"
"for TXN in `svnadmin lstxns ${REPOS}`; do \n"
"  echo \"---[ Transaction ${TXN} ]-------------------------------------------\"\n"
"  svnlook info \"${REPOS}\" -t \"${TXN}\"\n"
"done\n"
msgstr ""
"\n"
"#!/bin/sh\n"
"\n"
"### Generate informational output for all outstanding transactions in\n"
"### a Subversion repository.\n"
"\n"
"REPOS=\"${1}\"\n"
"if [ \"x$REPOS\" = x ] ; then\n"
"  echo \"usage: $0 REPOS_PATH\"\n"
"  exit\n"
"fi\n"
"\n"
"for TXN in `svnadmin lstxns ${REPOS}`; do \n"
"  echo \"---[ Transaction ${TXN} ]-------------------------------------------\"\n"
"  svnlook info \"${REPOS}\" -t \"${TXN}\"\n"
"done\n"

#: build/en/book.xml:11176(para)
#, fuzzy
msgid "The output of the script is basically a concatenation of several chunks of <command moreinfo=\"none\">svnlook info</command> output (see <xref linkend=\"svn.reposadmin.maint.tk.svnlook\"/>), and will look something like:"
msgstr "可以用下面的命令使用上例中脚本： <command moreinfo=\"none\">/path/to/txn-info.sh /path/to/repos</command>。该命令的输出主要由多个<command moreinfo=\"none\">svnlook info</command>参见<xref linkend=\"svn.reposadmin.maint.tk.svnlook\"/>）的输出组成，类似于下面的例子："

#: build/en/book.xml:11181(screen)
#, no-wrap
msgid ""
"\n"
"$ txn-info.sh myrepos\n"
"---[ Transaction 19 ]-------------------------------------------\n"
"sally\n"
"2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)\n"
"0\n"
"---[ Transaction 3a1 ]-------------------------------------------\n"
"harry\n"
"2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)\n"
"39\n"
"Trying to commit over a faulty network.\n"
"---[ Transaction a45 ]-------------------------------------------\n"
"sally\n"
"2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)\n"
"0\n"
"$\n"
msgstr ""
"\n"
"$ txn-info.sh myrepos\n"
"---[ Transaction 19 ]-------------------------------------------\n"
"sally\n"
"2001-09-04 11:57:19 -0500 (Tue， 04 Sep 2001)\n"
"0\n"
"---[ Transaction 3a1 ]-------------------------------------------\n"
"harry\n"
"2001-09-10 16:50:30 -0500 (Mon， 10 Sep 2001)\n"
"39\n"
"Trying to commit over a faulty network.\n"
"---[ Transaction a45 ]-------------------------------------------\n"
"sally\n"
"2001-09-12 11:09:28 -0500 (Wed， 12 Sep 2001)\n"
"0\n"
"$\n"

#: build/en/book.xml:11199(para)
msgid "A long-abandoned transaction usually represents some sort of failed or interrupted commit. A transaction's datestamp can provide interesting information—for example, how likely is it that an operation begun nine months ago is still active?"
msgstr "一个废弃了很长时间的事务通常是提交错误或异常中断的结果。事务的时间戳可以提供给我们一些有趣的信息，比如一个进行了9个月的操作居然还是活动的等等。"

#: build/en/book.xml:11205(para)
#, fuzzy
msgid "In short, transaction cleanup decisions need not be made unwisely. Various sources of information—including Apache's error and access logs, Subversion's operational logs, Subversion revision history, and so on—can be employed in the decision-making process. And of course, an administrator can often simply communicate with a seemingly dead transaction's owner (via email, for example) to verify that the transaction is, in fact, in a zombie state."
msgstr "简言之，作出事务清理的决定前应该仔细考虑一下。许多信息源—比如Apache的错误和访问日志，已成功完成的Subversion提交日志等等—都可以作为决策的参考。管理员还可以直接和那些似乎已经死亡事务的提交者直接交流（比如通过邮件），来确认该事务确实已经死亡了。"

#: build/en/book.xml:11218(title)
#, fuzzy
msgid "Purging unused Berkeley DB logfiles"
msgstr "删除不使用的Berkeley DB日志。"

#: build/en/book.xml:11220(para)
#, fuzzy
msgid "Until recently, the largest offender of disk space usage with respect to BDB-backed Subversion repositories was the log files in which Berkeley DB performs its pre-writes before modifying the actual database files. These files capture all the actions taken along the route of changing the database from one state to another—while the database files reflect at any given time some state, the log files contain all the many changes along the way between states. As such, they can grow and accumulate quite rapidly."
msgstr "目前为止，Subversion版本库中耗费磁盘空间的最大凶手是日志文件，每次Berkeley DB在修改真正的数据文件之前都会进行预写入（pre-writes）操作。这些文件记录了数据库从一个状态变化到另一个状态的所有动作——数据库文件反应了特定时刻数据库的状态，而日志文件则记录了所有状态变化的信息。因此，日志文件会以很快的速度膨胀起来。"

#: build/en/book.xml:11231(para)
msgid "Fortunately, beginning with the 4.2 release of Berkeley DB, the database environment has the ability to remove its own unused log files without any external procedures. Any repositories created using an <command moreinfo=\"none\">svnadmin</command> which is compiled against Berkeley DB version 4.2 or greater will be configured for this automatic log file removal. If you don't want this feature enabled, simply pass the <option>--bdb-log-keep</option> option to the <command moreinfo=\"none\">svnadmin create</command> command. If you forget to do this, or change your mind at a later time, simple edit the <filename moreinfo=\"none\">DB_CONFIG</filename> file found in your repository's <filename moreinfo=\"none\">db</filename> directory, comment out the line which contains the <literal moreinfo=\"none\">set_flags DB_LOG_AUTOREMOVE</literal> directive, and then run <command moreinfo=\"none\">svnadmin recover</command> on your repository to force the configuration changes to take effect. See <xref linkend=\"svn.reposadmin.create.bdb\"/> for more information about database configuration."
msgstr "幸运的是，从版本4.2开始，Berkeley DB的数据库环境无需额外的操作即可删除无用的日志文件。如果编译<command moreinfo=\"none\">svnadmin</command>时使用了高于4.2版本的Berkeley DB，那么由此<command moreinfo=\"none\">svnadmin</command>程序创建的版本库就具备了自动清除日志文件的功能。如果想屏蔽这个功能，只需设置<command moreinfo=\"none\">svnadmin create</command>命令的<option>--bdb-log-keep</option>选项即可。如果创建版本库以后想要修改关于此功能的设置，只需编辑版本库中<filename moreinfo=\"none\">db</filename>目录下的<filename moreinfo=\"none\">DB_CONFIG</filename>文件，注释掉包含<literal moreinfo=\"none\">set_flags DB_LOG_AUTOREMOVE</literal>内容的这一行，然后运行<command moreinfo=\"none\">svnadmin recover</command>强制设置生效就行了。查阅<xref linkend=\"svn.reposadmin.create.bdb\"/>获得更多关于数据库配置的帮助信息。"

#: build/en/book.xml:11249(para)
msgid "Without some sort of automatic log file removal in place, log files will accumulate as you use your repository. This is actually somewhat of a feature of the database system—you should be able to recreate your entire database using nothing but the log files, so these files can be useful for catastrophic database recovery. But typically, you'll want to archive the log files that are no longer in use by Berkeley DB, and then remove them from disk to conserve space. Use the <command moreinfo=\"none\">svnadmin list-unused-dblogs</command> command to list the unused log files:"
msgstr "如果不自动删除日志文件，那么日志文件会随着版本库的使用逐渐增加。这多少应该算是数据库系统的特性，通过这些日志文件可以在数据库严重损坏时恢复整个数据库的内容。但是一般情况下，最好是能够将无用的日志文件收集起来并删除，这样就可以节省磁盘空间。使用<command moreinfo=\"none\">svnadmin list-unused-dblogs</command>命令可以列出无用的日志文件："

#: build/en/book.xml:1126(title)
msgid "Fundamental Concepts"
msgstr "基本概念"

#: build/en/book.xml:11261(screen) build/en/book.xml:22453(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos\n"
"/path/to/repos/log.0000000031\n"
"/path/to/repos/log.0000000032\n"
"/path/to/repos/log.0000000033\n"
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos | xargs rm\n"
"## disk space reclaimed!\n"
msgstr ""
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos\n"
"/path/to/repos/log.0000000031\n"
"/path/to/repos/log.0000000032\n"
"/path/to/repos/log.0000000033\n"
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos | xargs rm\n"
"## disk space reclaimed!\n"

#: build/en/book.xml:11272(para)
msgid "BDB-backed repositories whose log files are used as part of a backup or disaster recovery plan should <emphasis>not</emphasis> make use of the log file autoremoval feature. Reconstruction of a repository's data from log files can only be accomplished when the log files are all available. If some of the log files are removed from disk before the backup system has a chance to copy them elsewhere, the incomplete set of backed-up log files is essentially useless."
msgstr ""

#: build/en/book.xml:1128(para)
msgid "This chapter is a short, casual introduction to Subversion. If you're new to version control, this chapter is definitely for you. We begin with a discussion of general version control concepts, work our way into the specific ideas behind Subversion, and show some simple examples of Subversion in use."
msgstr "本章主要为那些不熟悉版本控制技术的入门者提供一个简单扼要的、非系统的介绍。我们将从版本控制的基本概念开始，随后阐述Subversion的独特理念，并演示一些使用Subversion的例子。"

#: build/en/book.xml:11289(title)
#, fuzzy
msgid "Berkeley DB Recovery"
msgstr "Berkeley DB"

#: build/en/book.xml:11291(para)
msgid "As mentioned in <xref linkend=\"svn.reposadmin.basics.backends.bdb\"/>, a Berkeley DB repository can sometimes be left in frozen state if not closed properly. When this happens, an administrator needs to rewind the database back into a consistent state. This is unique to BDB-backed repositories, though—if you are using FSFS-backed ones instead, this won't apply to you. And for those of you using Subversion 1.4 with Berkeley DB 4.4 or better, you should find that Subversion has become much more resilient in these types of situations. Still, wedged Berkeley DB repositories do occur, and an administrator needs to know how to safely deal with this circumstance."
msgstr ""

#: build/en/book.xml:11303(para)
#, fuzzy
msgid "In order to protect the data in your repository, Berkeley DB uses a locking mechanism. This mechanism ensures that portions of the database are not simultaneously modified by multiple database accessors, and that each process sees the data in the correct state when that data is being read from the database. When a process needs to change something in the database, it first checks for the existence of a lock on the target data. If the data is not locked, the process locks the data, makes the change it wants to make, and then unlocks the data. Other processes are forced to wait until that lock is removed before they are permitted to continue accessing that section of the database. (This has nothing to do with the locks that you, as a user, can apply to versioned files within the repository; we try to clear up the confusion caused by this terminology collision in <xref linkend=\"svn.advanced.locking.meanings\"/>.)"
msgstr "Berkeley DB使用一种锁机制保护版本库中的数据。锁机制确保数据库不会同时被多个访问进程修改，也就保证了从数据库中读取到的数据始终是稳定而且正确的。当一个进程需要修改数据库中的数据时，首先必须检查目标数据是否已经上锁。如果目标数据没有上锁，进程就将它锁上，然后作出修改，最后再将锁解除。而其它进程则必须等待锁解除后才能继续访问数据库中的相关内容。"

#: build/en/book.xml:11319(para)
#, fuzzy
msgid "In the course of using your Subversion repository, fatal errors or interruptions can prevent a process from having the chance to remove the locks it has placed in the database. The result is that the back-end database system gets <quote>wedged</quote>. When this happens, any attempts to access the repository hang indefinitely (since each new accessor is waiting for a lock to go away—which isn't going to happen)."
msgstr "在操作Subversion版本库的过程中，致命错误（如内存或硬盘空间不足）或异常中断可能会导致某个进程没能及时将锁解除。结果就是后端的数据库系统被<quote>塞住</quote>了。一旦发生这种情况，任何访问版本库的进程都会挂起（每个访问进程都在等待锁被解除，但是锁已经无法解除了）。"

#: build/en/book.xml:11328(para)
#, fuzzy
msgid "If this happens to your repository, don't panic. The Berkeley DB filesystem takes advantage of database transactions and checkpoints and pre-write journaling to ensure that only the most catastrophic of events <placeholder-1/> can permanently destroy a database environment. A sufficiently paranoid repository administrator will have made off-site backups of the repository data in some fashion, but head off to the tape backup storage closet just yet."
msgstr "首先，如果你的版本库出现这种情况，没什么好惊慌的。Berkeley DB的文件系统采用了数据库事务、检查点以及预写入日志等技术来取保只有灾难性的事件<footnote><placeholder-1/></footnote>才能永久性的破坏数据库环境。所以虽然一个过于稳重的版本库管理员通常都会按照某种方案进行大量的版本库离线备份，不过不要急着通知你的管理员进行恢复。"

#: build/en/book.xml:11333(para)
msgid "E.g.: hard drive + huge electromagnet = disaster."
msgstr "比如：硬盘 + 大号电磁铁 = 毁灭。"

#: build/en/book.xml:11340(para)
#, fuzzy
msgid "Instead, use the following recipe to attempt to <quote>unwedge</quote> your repository:"
msgstr "然后，使用下面的方法试着<quote>恢复</quote>你的版本库："

#: build/en/book.xml:11345(para)
#, fuzzy
msgid "Make sure that there are no processes accessing (or attempting to access) the repository. For networked repositories, this means shutting down the Apache HTTP Server or svnserve daemon, too."
msgstr "确保没有其它进程访问（或者试图访问）版本库。对于网络版本库，关闭Apache HTTP服务器是个好办法。"

#: build/en/book.xml:1135(para)
msgid "Even though the examples in this chapter show people sharing collections of program source code, keep in mind that Subversion can manage any sort of file collection—it's not limited to helping computer programmers."
msgstr "虽然我们在本章中以分享程序源代码作为例子，但是记住Subversion可以管理任何类型的文件集—它并非是程序员专用的。"

#: build/en/book.xml:11351(para)
msgid "Become the user who owns and manages the repository. This is important, as recovering a repository while running as the wrong user can tweak the permissions of the repository's files in such a way that your repository will still be inaccessible even after it is <quote>unwedged</quote>."
msgstr "成为版本库的拥有者和管理员。这一点很重要，如果以其它用户的身份恢复版本库，可能会改变版本库文件的访问权限，导致在版本库<quote>恢复</quote>后依旧无法访问。"

#: build/en/book.xml:11359(para)
msgid "Run the command <command moreinfo=\"none\">svnadmin recover /path/to/repos</command>. You should see output like this:"
msgstr "运行命令<command moreinfo=\"none\">svnadmin recover /path/to/repos</command>。 输出如下："

#: build/en/book.xml:11363(screen)
#, no-wrap
msgid ""
"\n"
"Repository lock acquired.\n"
"Please wait; recovering the repository may take some time...\n"
"\n"
"Recovery completed.\n"
"The latest repos revision is 19.\n"
msgstr ""
"\n"
"Repository lock acquired。\n"
"Please wait; recovering the repository may take some time...\n"
"\n"
"Recovery completed.\n"
"The latest repos revision is 19.\n"

#: build/en/book.xml:11370(para)
msgid "This command may take many minutes to complete."
msgstr "此命令可能需要数分钟才能完成。"

#: build/en/book.xml:11373(para)
#, fuzzy
msgid "Restart the server process."
msgstr "重新启动Subversion服务器。"

#: build/en/book.xml:11377(para)
msgid "This procedure fixes almost every case of repository lock-up. Make sure that you run this command as the user that owns and manages the database, not just as <literal moreinfo=\"none\">root</literal>. Part of the recovery process might involve recreating from scratch various database files (shared memory regions, for example). Recovering as <literal moreinfo=\"none\">root</literal> will create those files such that they are owned by <literal moreinfo=\"none\">root</literal>, which means that even after you restore connectivity to your repository, regular users will be unable to access it."
msgstr "这个方法能修复几乎所有版本库锁住的问题。记住，要以数据库的拥有者和管理员的身份运行这个命令，而不一定是<literal moreinfo=\"none\">root</literal>用户。恢复过程中可能会使用其它数据存储区（例如共享内存区）重建一些数据库文件。如果以<literal moreinfo=\"none\">root</literal>用户身份恢复版本库，这些重建的文件拥有者将变成<literal moreinfo=\"none\">root</literal>用户，也就是说，即使恢复了到版本库的连接，一般的用户也无权访问这些文件。"

#: build/en/book.xml:11388(para)
msgid "If the previous procedure, for some reason, does not successfully unwedge your repository, you should do two things. First, move your broken repository out of the way and restore your latest backup of it. Then, send an email to the Subversion user list (at <email>users@subversion.tigris.org</email>) describing your problem in detail. Data integrity is an extremely high priority to the Subversion developers."
msgstr "如果因为某些原因，上面的方法没能成功的恢复版本库，那么你可以做两件事。首先，将破损的版本库保存到其它地方，然后从最新的备份中恢复版本库。然后，发送一封邮件到Subversion用户列表（地址是：<email>users@subversion.tigris.org</email>），写清你所遇到的问题。对于Subversion的开发者来说，数据安全是最重要的问题。"

#: build/en/book.xml:11401(title)
#, fuzzy
msgid "Migrating Repository Data Elsewhere"
msgstr "版本库的移植"

#: build/en/book.xml:11403(para)
#, fuzzy
msgid "A Subversion filesystem has its data spread throughout various back-end data store files in a fashion generally understood by (and of interest to) only the Subversion developers themselves. However, circumstances may arise that call for all, or some subset, of that data to be copied or moved into another repository."
msgstr "Subversion文件系统将数据保存在许多数据库表中，而这些表的结构只有Subversion开发者们才了解（也只有他们才感兴趣）不过，有些时候我们会想到把所有的数据（或者一部分数据）保存在一个独立的、可移植的、普通格式的文件中。Subversion通过<command moreinfo=\"none\">svnadmin</command>的两个子命令<literal moreinfo=\"none\">dump</literal>和<literal moreinfo=\"none\">load</literal>提供了类似的功能。"

#: build/en/book.xml:11410(para)
msgid "Subversion provides such functionality by way of repository dump streams. A repository dump stream (often referred to as a <quote>dumpfile</quote> when stored as a file on disk) is a portable, flat file format that describes the various revisions in your repository—what was changed, by whom, when, and so on. This dump stream is the primary mechanism used to marshal versioned history—in whole or in part, with or without modification—between repositories. And Subversion provides the tools necessary for creating and loading these dump streams—the <command moreinfo=\"none\">svnadmin dump</command> and <command moreinfo=\"none\">svnadmin load</command> subcommands, respectively."
msgstr ""

#: build/en/book.xml:11424(para)
msgid "While the Subversion repository dump format contains human-readable portions and a familiar structure (it resembles an RFC-822 format, the same type of format used for most email), it is <emphasis>not</emphasis> a plaintext file format. The format should be treated as a binary file format, highly sensitive to meddling. Many text editor tools will corrupt the file's contents, often due to automatic line ending character conversion."
msgstr ""

#: build/en/book.xml:11434(para)
msgid "There are many reasons for dumping and loading Subversion repository data. Early in Subversion's life, the most common reason was due to the evolution of Subversion itself. As Subversion matured, there were times when changes made to the back-end database schema caused compatibility issues with previous versions of the repository, so users had to dump their repository data using the previous version of Subversion, and load it into a freshly created repository with the new version of Subversion. Now, these types of schema changes haven't occured since Subversion's 1.0 release, and the Subversion developers promise not to force users to dump and load their repositories when upgrading between minor versions (such as from 1.3 to 1.4) of Subversion. But there are still other reasons for dumping and loading, including re-deploying a Berkeley DB repository on a new OS or CPU architecture, switching between the Berkeley DB and FSFS back-ends, or (as we'll cover in <xref linkend=\"svn.reposadmin.maint.filtering\"/> purging versioned data from repository history."
msgstr ""

#: build/en/book.xml:1145(title)
msgid "The Repository"
msgstr "版本库"

#: build/en/book.xml:11453(para)
#, fuzzy
msgid "Whatever your reason for migration repository history, using the <command moreinfo=\"none\">svnadmin dump</command> and <command moreinfo=\"none\">svnadmin load</command> subcommands is straightforward. <command moreinfo=\"none\">svnadmin dump</command> will output a range of repository revisions that are formatted using Subversion's custom filesystem dump format. The dump format is printed to the standard output stream, while informative messages are printed to the standard error stream. This allows you to redirect the output stream to a file while watching the status output in your terminal window. For example:"
msgstr "<command moreinfo=\"none\">svnadmin dump</command>命令会将版本库中的修订版本数据按照特定的格式输出到转储流中。转储数据会输出到标准输出流，而提示信息会输出到标准错误流。这就是说，可以将转储数据存储到文件中，而同时在终端窗口中监视运行状态。例如："

#: build/en/book.xml:11465(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook youngest myrepos\n"
"26\n"
"$ svnadmin dump myrepos &gt; dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"…\n"
"* Dumped revision 25.\n"
"* Dumped revision 26.\n"
msgstr ""
"\n"
"$ svnlook youngest myrepos\n"
"26\n"
"$ svnadmin dump myrepos &gt; dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"…\n"
"* Dumped revision 25.\n"
"* Dumped revision 26.\n"

#: build/en/book.xml:1147(para)
msgid "Subversion is a centralized system for sharing information. At its core is a repository, which is a central store of data. The repository stores information in the form of a <firstterm>filesystem tree</firstterm>—a typical hierarchy of files and directories. Any number of <firstterm>clients</firstterm> connect to the repository, and then read or write to these files. By writing data, a client makes the information available to others; by reading data, the client receives information from others. <xref linkend=\"svn.basic.repository.dia-1\"/> illustrates this."
msgstr "Subversion是一个“中央集权式”的信息共享系统。版本库是Subversion的核心部分，是数据的中央仓库。版本库以文件和目录的典型结构形式—<firstterm>文件系统树</firstterm>来保存信息。此外，数个<firstterm>客户端</firstterm>（数量不限）连接到Subversion版本库，读取、修改这些文件。客户端之间通过修改数据实现与别人共享信息，通过读取数据实现获取别人共享的信息。<xref linkend=\"svn.basic.repository.dia-1\"/>展示了这种系统的概貌："

#: build/en/book.xml:11477(para)
msgid "At the end of the process, you will have a single file (<filename moreinfo=\"none\">dumpfile</filename> in the previous example) that contains all the data stored in your repository in the requested range of revisions. Note that <command moreinfo=\"none\">svnadmin dump</command> is reading revision trees from the repository just like any other <quote>reader</quote> process would (<command moreinfo=\"none\">svn checkout</command>, for example). So it's safe to run this command at any time."
msgstr "最后，版本库中的指定的修订版本数据被转储到一个独立的文件中（在上面的例子中是<filename moreinfo=\"none\">dumpfile</filename>）。注意，<command moreinfo=\"none\">svnadmin dump</command>从版本库中读取修订版本树与其它<quote>读者</quote>（比如<command moreinfo=\"none\">svn checkout</command>）的过程相同，所以可以在任何时候安全的运行这个命令。"

#: build/en/book.xml:11486(para)
msgid "The other subcommand in the pair, <command moreinfo=\"none\">svnadmin load</command>, parses the standard input stream as a Subversion repository dump file, and effectively replays those dumped revisions into the target repository for that operation. It also gives informative feedback, this time using the standard output stream:"
msgstr "另一个命令，<command moreinfo=\"none\">svnadmin load</command>，从标准输入流中读取Subversion转储数据，并且高效的将数据转载到目标版本库中。这个命令的提示信息输出到标准输出流中："

#: build/en/book.xml:11493(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile\n"
"&lt;&lt;&lt; Started new txn, based on original revision 1\n"
"     * adding path : A ... done.\n"
"     * adding path : A/B ... done.\n"
"     …\n"
"------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 2\n"
"     * editing path : A/mu ... done.\n"
"     * editing path : A/D/G/rho ... done.\n"
"\n"
"------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;\n"
"\n"
"…\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 25\n"
"     * editing path : A/D/gamma ... done.\n"
"\n"
"------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 26\n"
"     * adding path : A/Z/zeta ... done.\n"
"     * editing path : A/mu ... done.\n"
"\n"
"------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;\n"
"\n"
msgstr ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile\n"
"&lt;&lt;&lt; Started new txn, based on original revision 1\n"
"     * adding path : A ... done.\n"
"     * adding path : A/B ... done.\n"
"     …\n"
"------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 2\n"
"     * editing path : A/mu ... done.\n"
"     * editing path : A/D/G/rho ... done.\n"
"\n"
"------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;\n"
"\n"
"…\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 25\n"
"     * editing path : A/D/gamma ... done.\n"
"\n"
"------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 26\n"
"     * adding path : A/Z/zeta ... done.\n"
"     * editing path : A/mu ... done.\n"
"\n"
"------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;\n"
"\n"

#: build/en/book.xml:11522(para)
#, fuzzy
msgid "The result of a load is new revisions added to a repository—the same thing you get by making commits against that repository from a regular Subversion client. And just as in a commit, you can use hook programs to perform actions before and after each of the commits made during a load process. By passing the <option>--use-pre-commit-hook</option> and <option>--use-post-commit-hook</option> options to <command moreinfo=\"none\">svnadmin load</command>, you can instruct Subversion to execute the pre-commit and post-commit hook programs, respectively, for each loaded revision. You might use these, for example, to ensure that loaded revisions pass through the same validation steps that regular commits pass through. Of course, you should use these options with care—if your post-commit hook sends emails to a mailing list for each new commit, you might not want to spew hundreds or thousands of commit emails in rapid succession at that list for each of the loaded revisions! You can read more about the use of hook scripts in <xref linkend=\"svn.reposadmin.create.hooks\"/>."
msgstr "load命令的结果就是添加一些新的修订版本—与使用普通Subversion客户端直接提交到版本库相同。正像一次简单的提交，你也可以使用钩子脚本在每次load的开始和结束执行一些操作。通过传递<option>--use-pre-commit-hook</option>和<option>--use-post-commit-hook</option>选项给<command moreinfo=\"none\">svnadmin load</command>，你可以告诉Subversion的对每一个加载修订版本执行pre-commit和post-commit钩子脚本，可以利用这个选项确保这种提交也能通过一般提交的检验。当然，你要小心使用这个选项，你一定不像接受一大堆提交邮件。你可以查看<xref linkend=\"svn.reposadmin.create.hooks\"/>来得到更多相关信息。"

#: build/en/book.xml:11542(para)
msgid "Note that because <command moreinfo=\"none\">svnadmin</command> uses standard input and output streams for the repository dump and load process, people who are feeling especially saucy can try things like this (perhaps even using different versions of <command moreinfo=\"none\">svnadmin</command> on each side of the pipe):"
msgstr "既然<command moreinfo=\"none\">svnadmin</command>使用标准输入流和标准输出流作为转储和装载的输入和输出，那么更漂亮的用法是（管道两端可以是不同版本的<command moreinfo=\"none\">svnadmin</command>："

#: build/en/book.xml:11548(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create newrepos\n"
"$ svnadmin dump myrepos | svnadmin load newrepos\n"
msgstr ""
"\n"
"$ svnadmin create newrepos\n"
"$ svnadmin dump myrepos | svnadmin load newrepos\n"

#: build/en/book.xml:11553(para)
#, fuzzy
msgid "By default, the dump file will be quite large—much larger than the repository itself. That's because by default every version of every file is expressed as a full text in the dump file. This is the fastest and simplest behavior, and nice if you're piping the dump data directly into some other process (such as a compression program, filtering program, or into a loading process). But if you're creating a dump file for longer-term storage, you'll likely want to save disk space by using the <option>--deltas</option> switch. With this option, successive revisions of files will be output as compressed, binary differences—just as file revisions are stored in a repository. This option is slower, but results in a dump file much closer in size to the original repository."
msgstr "默认情况下，转储文件的体积可能会相当庞大——比版本库自身大很多。这是因为在转储文件中，每个文件的每个版本都以完整的文本形式保存下来。这种方法速度很快，而且很简单，尤其是直接将转储数据通过管道输入到其它进程中时（比如一个压缩程序，过滤程序，或者一个装载进程）。不过如果要长期保存转储文件，那么可以使用<option>--deltas</option>选项来节省磁盘空间。设置这个选项，同一个文件的数个连续修订版本会以增量式的方式保存—就像储存在版本库中一样。这个方法较慢，但是转储文件的体积则基本上与版本库的体积相当。"

#: build/en/book.xml:11568(para)
#, fuzzy
msgid "We mentioned previously that <command moreinfo=\"none\">svnadmin dump</command> outputs a range of revisions. Use the <option>--revision (-r)</option> option to specify a single revision to dump, or a range of revisions. If you omit this option, all the existing repository revisions will be dumped."
msgstr "之前我们提到<command moreinfo=\"none\">svnadmin dump</command>输出指定的修订版本。使用<option>--revision</option>选项可以指定一个单独的修订版本，或者一个修订版本的范围。如果忽略这个选项，所有版本库中的修订版本都会被转储。"

#: build/en/book.xml:11575(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile\n"
"$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile\n"
msgstr ""
"\n"
"$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile\n"
"$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile\n"

#: build/en/book.xml:1158(title)
msgid "A typical client/server system"
msgstr "一个典型的客户/服务器系统"

#: build/en/book.xml:11580(para)
msgid "As Subversion dumps each new revision, it outputs only enough information to allow a future loader to re-create that revision based on the previous one. In other words, for any given revision in the dump file, only the items that were changed in that revision will appear in the dump. The only exception to this rule is the first revision that is dumped with the current <command moreinfo=\"none\">svnadmin dump</command> command."
msgstr "Subversion在转储修订版本时，仅会输出与前一个修订版本之间的差异，通过这些差异足以从前一个修订版本中重建当前的修订版本。换句话说，在转储文件中的每一个修订版本仅包含这个修订版本作出的修改。这个规则的唯一一个例外是当前<command moreinfo=\"none\">svnadmin dump</command>转储的第一个修订版本。"

#: build/en/book.xml:11589(para)
msgid "By default, Subversion will not express the first dumped revision as merely differences to be applied to the previous revision. For one thing, there is no previous revision in the dump file! And secondly, Subversion cannot know the state of the repository into which the dump data will be loaded (if it ever, in fact, occurs). To ensure that the output of each execution of <command moreinfo=\"none\">svnadmin dump</command> is self-sufficient, the first dumped revision is by default a full representation of every directory, file, and property in that revision of the repository."
msgstr "默认情况下，Subversion不会把转储的第一个修订版本看作对前一个修订版本的更改。 首先，转储文件中没有比第一个修订版本更靠前的修订版本了！其次，Subversion不知道装载转储数据时（如果真的需要装载的话）的版本库是什么样的情况。为了保证每次运行<command moreinfo=\"none\">svnadmin dump</command>都能得到一个独立的结果，第一个转储的修订版本默认情况下会完整的保存目录、文件以及属性等数据。"

#: build/en/book.xml:11600(para)
msgid "However, you can change this default behavior. If you add the <option>--incremental</option> option when you dump your repository, <command moreinfo=\"none\">svnadmin</command> will compare the first dumped revision against the previous revision in the repository, the same way it treats every other revision that gets dumped. It will then output the first revision exactly as it does the rest of the revisions in the dump range—mentioning only the changes that occurred in that revision. The benefit of this is that you can create several small dump files that can be loaded in succession, instead of one large one, like so:"
msgstr "不过，这些都是可以改变的。如果转储时设置了<option>--incremental</option>选项，<command moreinfo=\"none\">svnadmin</command>会比较第一个转储的修订版本和版本库中前一个修订版本，就像对待其它转储的修订版本一样。转储时也是一样，转储文件中将仅包含第一个转储的修订版本的增量信息。这样的好处是，可以创建几个连续的小体积的转储文件代替一个大文件，比如："

#: build/en/book.xml:11612(screen)
#, fuzzy, no-wrap
msgid ""
"\n"
"$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1\n"
"$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2\n"
"$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3\n"
msgstr ""
"\n"
"$ svnadmin dump myrepos --revision 0:1000 &gt; dumpfile1\n"
"$ svnadmin dump myrepos --revision 1001:2000 --incremental &gt; dumpfile2\n"
"$ svnadmin dump myrepos --revision 2001:3000 --incremental &gt; dumpfile3\n"

#: build/en/book.xml:11618(para)
msgid "These dump files could be loaded into a new repository with the following command sequence:"
msgstr "这些转储文件可以使用下列命令装载到一个新的版本库中："

#: build/en/book.xml:1162(para)
msgid "So why is this interesting? So far, this sounds like the definition of a typical file server. And indeed, the repository <emphasis>is</emphasis> a kind of file server, but it's not your usual breed. What makes the Subversion repository special is that <emphasis>it remembers every change</emphasis> ever written to it: every change to every file, and even changes to the directory tree itself, such as the addition, deletion, and rearrangement of files and directories."
msgstr "这有什么意义吗？说了这么多，Subversion听起来和一般的文件服务器没什么不同。事实上，Subversion的版本库的确<emphasis>是</emphasis>一种文件服务器，但不是“一般”的文件服务器。Subversion版本库的特别之处在于，<emphasis>它会记录每一次改变</emphasis>，每一次文件和目录结构的改变，（比如增加、删除和重新布置文件和目录）它都不会放过。"

#: build/en/book.xml:11621(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile1\n"
"$ svnadmin load newrepos &lt; dumpfile2\n"
"$ svnadmin load newrepos &lt; dumpfile3\n"
msgstr ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile1\n"
"$ svnadmin load newrepos &lt; dumpfile2\n"
"$ svnadmin load newrepos &lt; dumpfile3\n"

#: build/en/book.xml:11627(para)
#, fuzzy
msgid "Another neat trick you can perform with this <option>--incremental</option> option involves appending to an existing dump file a new range of dumped revisions. For example, you might have a <literal moreinfo=\"none\">post-commit</literal> hook that simply appends the repository dump of the single revision that triggered the hook. Or you might have a script that runs nightly to append dump file data for all the revisions that were added to the repository since the last time the script ran. Used like this, <command moreinfo=\"none\">svnadmin dump</command> can be one way to backup changes to your repository over time in case of a system crash or some other catastrophic event."
msgstr "另一个有关的技巧是，可以使用<option>--incremental</option>选项在一个转储文件中增加新的转储修订版本。举个例子，可以使用<literal moreinfo=\"none\">post-commit</literal>钩子在每次新的修订版本提交后将其转储到文件中。或者，可以编写一个脚本，在每天夜里将所有新增的修订版本转储到文件中。这样，<command moreinfo=\"none\">svnadmin</command>的<literal moreinfo=\"none\">dump</literal>和<literal moreinfo=\"none\">load</literal>命令就变成了很好的版本库备份工具，万一出现系统崩溃或其它灾难性事件，它的价值就体现出来了。"

#: build/en/book.xml:11639(para)
msgid "The dump format can also be used to merge the contents of several different repositories into a single repository. By using the <option>--parent-dir</option> option of <command moreinfo=\"none\">svnadmin load</command>, you can specify a new virtual root directory for the load process. That means if you have dump files for three repositories, say <filename moreinfo=\"none\">calc-dumpfile</filename>, <filename moreinfo=\"none\">cal-dumpfile</filename>, and <filename moreinfo=\"none\">ss-dumpfile</filename>, you can first create a new repository to hold them all:"
msgstr "转储还可以用来将几个独立的版本库合并为一个版本库。使用<command moreinfo=\"none\">svnadmin load</command>的<option>--parent-dir</option>选项，可以在装载的时候指定根目录。也就是说，如果有三个不同版本库的转储文件，比如<filename moreinfo=\"none\">calc-dumpfile</filename>，<filename moreinfo=\"none\">cal-dumpfile</filename>，和<filename moreinfo=\"none\">ss-dumpfile</filename>，可以在一个新的版本库中保存所有三个转储文件中的数据："

#: build/en/book.xml:11650(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create /path/to/projects\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin create /path/to/projects\n"
"$\n"

#: build/en/book.xml:11655(para)
msgid "Then, make new directories in the repository which will encapsulate the contents of each of the three previous repositories:"
msgstr "然后在版本库中创建三个目录分别保存来自三个不同版本库的数据："

#: build/en/book.xml:11659(screen)
#, no-wrap
msgid ""
"\n"
"$ svn mkdir -m \"Initial project roots\" \\\n"
"      file:///path/to/projects/calc \\\n"
"      file:///path/to/projects/calendar \\\n"
"      file:///path/to/projects/spreadsheet\n"
"Committed revision 1.\n"
"$ \n"
msgstr ""
"\n"
"$ svn mkdir -m \"Initial project roots\" \\\n"
"      file:///path/to/projects/calc \\\n"
"      file:///path/to/projects/calendar \\\n"
"      file:///path/to/projects/spreadsheet\n"
"Committed revision 1.\n"
"$ \n"

#: build/en/book.xml:11668(para)
msgid "Lastly, load the individual dump files into their respective locations in the new repository:"
msgstr "最后，将转储文件分别装载到各自的目录中："

#: build/en/book.xml:11671(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile\n"
"…\n"
"$\n"

#: build/en/book.xml:11681(para)
#, fuzzy
msgid "We'll mention one final way to use the Subversion repository dump format—conversion from a different storage mechanism or version control system altogether. Because the dump file format is, for the most part, human-readable, it should be relatively easy to describe generic sets of changes—each of which should be treated as a new revision—using this file format. In fact, the <command moreinfo=\"none\">cvs2svn</command> utility (see <xref linkend=\"svn.forcvs.convert\"/>) uses the dump format to represent the contents of a CVS repository so that those contents can be copied into a Subversion repository."
msgstr "我们再介绍一下Subversion版本库转储数据的最后一种用途——在不同的存储机制或版本控制系统之间转换。因为转储数据的格式的大部分是可以阅读的，<footnote><placeholder-1/></footnote>所以使用这种格式描述变更集（每个变更集对应一个新的修订版本）会相对容易一些。事实上，<command moreinfo=\"none\">cvs2svn</command>工具（参见 <xref linkend=\"svn.forcvs.convert\"/>）正是将CVS版本库的内容转换为转储数据格式，如此才能将CVS版本库的数据导入Subversion版本库之中。"

#: build/en/book.xml:11696(title)
#, fuzzy
msgid "Filtering Repository History"
msgstr "比较版本库与版本库"

#: build/en/book.xml:11698(para)
#, fuzzy
msgid "Since Subversion stores your versioned history using, at the very least, binary differencing algorithms and data compression (optionally in a completely opaque database system), attempting manual tweaks is unwise, if not quite difficult, and at any rate strongly discouraged. And once data has been stored in your repository, Subversion generally doesn't provide an easy way to remove that data. <placeholder-1/> But inevitably, there will be times when you would like to manipulate the history of your repository. You might need to strip out all instances of a file that was accidentally added to the repository (and shouldn't be there for whatever reason). <placeholder-2/> Or, perhaps you have multiple projects sharing a single repository, and you decide to split them up into their own repositories. To accomplish tasks like this, administrators need a more manageable and malleable representation of the data in their repositories—the Subversion repository dump format."
msgstr "因为Subversion使用底层的数据库储存各类数据，手工调整是不明智的，即使这样做并不困难。何况，一旦你的数据存进了版本库，通常很难再将它们从版本库中删除。<footnote><placeholder-1/></footnote>但是不可避免的，总会有些时候你需要处理版本库的历史数据。你也许想把一个不应该出现的文件从版本库中彻底清除。或者，你曾经用一个版本库管理多个工程，现在又想把它们分开。要完成这样的工作，管理员们需要更易于管理和扩展的方法表示版本库中的数据，Subversion版本库转储文件格式就是一个很好的选择。"

#: build/en/book.xml:11706(para)
msgid "That's rather the reason you use version control at all, right?"
msgstr ""

#: build/en/book.xml:1171(para)
msgid "When a client reads data from the repository, it normally sees only the latest version of the filesystem tree. But the client also has the ability to view <emphasis>previous</emphasis> states of the filesystem. For example, a client can ask historical questions like, <quote>What did this directory contain last Wednesday?</quote> or <quote>Who was the last person to change this file, and what changes did he make?</quote> These are the sorts of questions that are at the heart of any <firstterm>version control system</firstterm>: systems that are designed to record and track changes to data over time."
msgstr "一般情况下，客户端从版本库中获取的数据是文件系统树中的最新数据。但是客户端也具备查看文件系统树<emphasis>以前</emphasis>任何一个状态的能力。举个例子，客户端有时会对一些历史性问题感兴趣，比如<quote>上星期三时的目录结构是什么样的？</quote>或者<quote>谁最后一个修改了这个文件，都修改了什么？</quote>为了回答类似的问题，<firstterm>版本控制系统</firstterm>产生了。它的主要设计目的即是记录和跟踪数据的变化。"

#: build/en/book.xml:11715(para)
msgid "Conscious, cautious removal of certain bits of versioned data is actually supported by real use-cases. That's why an <quote>obliterate</quote> feature has been one of the most highly requested Subversion features, and one which the Subversion developers hope to soon provide."
msgstr ""

#: build/en/book.xml:11729(para)
#, fuzzy
msgid "As we described in <xref linkend=\"svn.reposadmin.maint.migrate\"/>, the Subversion repository dump format is a human-readable representation of the changes that you've made to your versioned data over time. You use the <command moreinfo=\"none\">svnadmin dump</command> command to generate the dump data, and <command moreinfo=\"none\">svnadmin load</command> to populate a new repository with it (see <xref linkend=\"svn.reposadmin.maint.migrate\"/>). The great thing about the human-readability aspect of the dump format is that, if you aren't careless about it, you can manually inspect and modify it. Of course, the downside is that if you have three years' worth of repository activity encapsulated in what is likely to be a very large dump file, it could take you a long, long time to manually inspect and modify it."
msgstr "Subversion版本库转储文件记录了所有版本数据的变更信息，而且以易于阅读的格式保存。可以使用<command moreinfo=\"none\">svnadmin dump</command>命令生成转储文件，然后用<command moreinfo=\"none\">svnadmin load</command>命令生成一个新的版本库。（参见 <xref linkend=\"svn.reposadmin.maint.migrate\"/>）。转储文件易于阅读意味着你可以小心翼翼的查看和修改它。当然，问题是如果你有一个运行了两年的版本库，那么生成的转储文件会很庞大，阅读和手工修改起来都会花费很多时间。"

#: build/en/book.xml:11744(para)
#, fuzzy
msgid "That's where <command moreinfo=\"none\">svndumpfilter</command> becomes useful. This program acts as path-based filter for repository dump streams. Simply give it either a list of paths you wish to keep, or a list of paths you wish to not keep, then pipe your repository dump data through this filter. The result will be a modified stream of dump data that contains only the versioned paths you (explicitly or implicitly) requested."
msgstr "虽然在管理员的日常工作中并不会经常使用，不过<command moreinfo=\"none\">svndumpfilter</command>可以对特定的路径进行过滤。这是一个独特而很有意义的用法，可以帮助你快速方便的修改转储的数据。使用时，只需提供一个你想要保留的（或者不想保留的）路径列表，然后把你的版本库转储文件送进这个过滤器。最后你就可以得到一个仅包含你想保留的路径的转储数据流。"

#: build/en/book.xml:11753(para)
msgid "Let's look a realistic example of how you might use this program. We discuss elsewhere (see <xref linkend=\"svn.reposadmin.projects.chooselayout\"/>) the process of deciding how to choose a layout for the data in your repositories—using one repository per project or combining them, arranging stuff within your repository, and so on. But sometimes after new revisions start flying in, you rethink your layout and would like to make some changes. A common change is the decision to move multiple projects which are sharing a single repository into separate repositories for each project."
msgstr "现在我来演示如何使用这个命令。我们会在其它章节（参见 <xref linkend=\"svn.reposadmin.projects.chooselayout\"/>）讨论关于如何选择设定版本库布局的问题，比如应该使用一个版本库管理多个项目还是使用一个版本库管理一个项目，或者如何在版本库中安排数据等等。不过，有些时候，即使在项目已经展开以后，你还是希望对版本库的布局做一些调整。最常见的情况是，把原来存放在同一个版本库中的几个项目分开，各自成家。"

#: build/en/book.xml:11764(para)
msgid "Our imaginary repository contains three projects: <literal moreinfo=\"none\">calc</literal>, <literal moreinfo=\"none\">calendar</literal>, and <literal moreinfo=\"none\">spreadsheet</literal>. They have been living side-by-side in a layout like this:"
msgstr "假设有一个包含三个项目的版本库： <literal moreinfo=\"none\">calc</literal>，<literal moreinfo=\"none\">calendar</literal>，和 <literal moreinfo=\"none\">spreadsheet</literal>。它们在版本库中的布局如下："

#: build/en/book.xml:11769(screen)
#, no-wrap
msgid ""
"\n"
"/\n"
"   calc/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   calendar/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   spreadsheet/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
msgstr ""
"\n"
"/\n"
"   calc/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   calendar/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   spreadsheet/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"

#: build/en/book.xml:11785(para)
msgid "To get these three projects into their own repositories, we first dump the whole repository:"
msgstr "现在要把这三个项目转移到三个独立的版本库中。首先，转储整个版本库："

#: build/en/book.xml:11788(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin dump /path/to/repos &gt; repos-dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"* Dumped revision 3.\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin dump /path/to/repos &gt; repos-dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"* Dumped revision 3.\n"
"…\n"
"$\n"

#: build/en/book.xml:11798(para)
msgid "Next, run that dump file through the filter, each time including only one of our top-level directories, and resulting in three new dump files:"
msgstr "然后，将转储文件三次送入过滤器，每次仅保留一个顶级目录，就可以得到三个转储文件："

#: build/en/book.xml:118(para)
msgid "What I love about this book is that it grew out of just such a process, and shows it on every page. It is the direct result of the authors' encounters with users. It began with Ben Collins-Sussman's observation that people were asking the same basic questions over and over on the Subversion mailing lists: What are the standard workflows to use with Subversion? Do branches and tags work the same way as in other version control systems? How can I find out who made a particular change?"
msgstr "我很喜欢这本书，因为它正是按照这种精神建立起来的，这种精神体现在本书的每一页中。这是作者与用户直接交流的结果。而这一切是源于Ben Collins-Sussman's对于Subversion常见问题邮件列表的研究。他发现人们总是在邮件列表中重复询问一些基本问题：使用subversion的一般程序是怎样的？分支与标签同其它版本控制系统的工作方式一样吗？我怎样知道某一处修改是谁做的？"

#: build/en/book.xml:11802(screen)
#, fuzzy, no-wrap
msgid ""
"\n"
"$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile\n"
"…\n"
"$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile\n"
"…\n"
"$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile\n"
"…\n"
"$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile\n"
"…\n"
"$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile\n"
"…\n"
"$\n"

#: build/en/book.xml:11812(para)
msgid "At this point, you have to make a decision. Each of your dump files will create a valid repository, but will preserve the paths exactly as they were in the original repository. This means that even though you would have a repository solely for your <literal moreinfo=\"none\">calc</literal> project, that repository would still have a top-level directory named <filename moreinfo=\"none\">calc</filename>. If you want your <filename moreinfo=\"none\">trunk</filename>, <filename moreinfo=\"none\">tags</filename>, and <filename moreinfo=\"none\">branches</filename> directories to live in the root of your repository, you might wish to edit your dump files, tweaking the <literal moreinfo=\"none\">Node-path</literal> and <literal moreinfo=\"none\">Node-copyfrom-path</literal> headers to no longer have that first <filename moreinfo=\"none\">calc/</filename> path component. Also, you'll want to remove the section of dump data that creates the <filename moreinfo=\"none\">calc</filename> directory. It will look something like:"
msgstr "现在你必须要作出一个决定了。这三个转储文件中，每个都可以用来创建一个可用的版本库，不过它们保留了原版本库的精确路径结构。也就是说，虽然项目<literal moreinfo=\"none\">calc</literal>现在独占了一个版本库，但版本库中还保留着名为<filename moreinfo=\"none\">calc</filename>的顶级目录。如果希望<filename moreinfo=\"none\">trunk</filename>、<filename moreinfo=\"none\">tags</filename>和<filename moreinfo=\"none\">branches</filename>这三个目录直接位于版本库的根路径下，你可能需要编辑转储文件，调整<literal moreinfo=\"none\">Node-path</literal>和<literal moreinfo=\"none\">Copyfrom-path</literal>头参数，将路径<filename moreinfo=\"none\">calc/</filename>删除。同时，你还要删除转储数据中创建<filename moreinfo=\"none\">calc</filename>目录的部分。一般来说，就是如下的一些内容："

#: build/en/book.xml:11829(screen)
#, fuzzy, no-wrap
msgid ""
"\n"
"Node-path: calc\n"
"Node-action: add\n"
"Node-kind: dir\n"
"Content-length: 0\n"
"  \n"
msgstr ""
"\n"
"Node-path: calc\n"
"Node-action: add\n"
"Node-kind: dir\n"
"Content-length: 0\n"
"\n"

#: build/en/book.xml:11838(para)
#, fuzzy
msgid "If you do plan on manually editing the dump file to remove a top-level directory, make sure that your editor is not set to automatically convert end-lines to the native format (e.g. \\r\\n to \\n) as the content will then not agree with the metadata. This will render the dump file useless."
msgstr "如果你打算通过手工编辑转储文件来移除一个顶级目录，注意不要让你的编辑器将换行符转换为本地格式（比如将\\r\\n转换为\\n）。否则文件的内容就与所需的格式不相符，这个转储文件也就失效了。"

#: build/en/book.xml:11846(para)
msgid "All that remains now is to create your three new repositories, and load each dump file into the right repository:"
msgstr "剩下的工作就是创建三个新的版本库，然后将三个转储文件分别导入："

#: build/en/book.xml:11850(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile\n"
"&lt;&lt;&lt; Started new transaction, based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : button.c ... done.\n"
"…\n"
"$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile\n"
"&lt;&lt;&lt; Started new transaction, based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : cal.c ... done.\n"
"…\n"
"$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile\n"
"&lt;&lt;&lt; Started new transaction, based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : ss.c ... done.\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile\n"
"&lt;&lt;&lt; Started new transaction， based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : button.c ... done.\n"
"…\n"
"$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile\n"
"&lt;&lt;&lt; Started new transaction， based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : cal.c ... done.\n"
"…\n"
"$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile\n"
"&lt;&lt;&lt; Started new transaction， based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : ss.c ... done.\n"
"…\n"
"$\n"

#: build/en/book.xml:11869(para)
msgid "Both of <command moreinfo=\"none\">svndumpfilter</command>'s subcommands accept options for deciding how to deal with <quote>empty</quote> revisions. If a given revision contained only changes to paths that were filtered out, that now-empty revision could be considered uninteresting or even unwanted. So to give the user control over what to do with those revisions, <command moreinfo=\"none\">svndumpfilter</command> provides the following command-line options:"
msgstr "<command moreinfo=\"none\">svndumpfilter</command>的两个子命令都可以通过选项设定如何处理<quote>空</quote>修订版本。如果某个指定的修订版本仅包含路径的更改，过滤器就会将它删除，因为当前为空的修订版本通常是无用的甚至是让人讨厌的。为了让用户有选择的处理这些修订版本，<command moreinfo=\"none\">svndumpfilter</command>提供了以下命令行选项："

#: build/en/book.xml:11880(option)
msgid "--drop-empty-revs"
msgstr "--drop-empty-revs"

#: build/en/book.xml:11882(para)
msgid "Do not generate empty revisions at all—just omit them."
msgstr "不生成任何空修订版本，忽略它们。"

#: build/en/book.xml:11887(option)
msgid "--renumber-revs"
msgstr "--renumber-revs"

#: build/en/book.xml:11889(para)
msgid "If empty revisions are dropped (using the <option>--drop-empty-revs</option> option), change the revision numbers of the remaining revisions so that there are no gaps in the numeric sequence."
msgstr "如果空修订版本被剔除（通过使用<option>--drop-empty-revs</option>选项），依次修改其它修订版本的编号，确保编号序列是连续的。"

#: build/en/book.xml:1189(title)
msgid "Versioning Models"
msgstr "版本模型"

#: build/en/book.xml:11896(option)
msgid "--preserve-revprops"
msgstr "--preserve-revprops"

#: build/en/book.xml:11898(para)
msgid "If empty revisions are not dropped, preserve the revision properties (log message, author, date, custom properties, etc.) for those empty revisions. Otherwise, empty revisions will only contain the original datestamp, and a generated log message that indicates that this revision was emptied by <command moreinfo=\"none\">svndumpfilter</command>."
msgstr "如果空修订版本被保留，保持这些空修订版本的属性（日志信息，作者，日期，自定义属性，等等）。如果不设定这个选项，空修订版本将仅保留初始时间戳，以及一个自动生成的日志信息，表明此修订版本由<command moreinfo=\"none\">svndumpfilter</command>处理过。"

#: build/en/book.xml:11909(para)
msgid "While <command moreinfo=\"none\">svndumpfilter</command> can be very useful, and a huge timesaver, there are unfortunately a couple of gotchas. First, this utility is overly sensitive to path semantics. Pay attention to whether paths in your dump file are specified with or without leading slashes. You'll want to look at the <literal moreinfo=\"none\">Node-path</literal> and <literal moreinfo=\"none\">Node-copyfrom-path</literal> headers."
msgstr "尽管<command moreinfo=\"none\">svndumpfilter</command>十分有用，能节省大量的时间，但它却是把不折不扣的双刃剑。首先，这个工具对路径语义极为敏感。仔细检查转储文件中的路径是不是以斜线开头。也许<literal moreinfo=\"none\">Node-path</literal>和<literal moreinfo=\"none\">Copyfrom-path</literal>这两个头参数对你有些帮助。"

#: build/en/book.xml:1191(para)
msgid "The core mission of a version control system is to enable collaborative editing and sharing of data. But different systems use different strategies to achieve this. It's important to understand these different strategies for a couple of reasons. First, it will help you compare and contrast existing version control systems, in case you encounter other systems similar to Subversion. Beyond that, it will also help you make more effective use of Subversion, since Subversion itself supports a couple of different ways of working."
msgstr ""

#: build/en/book.xml:11917(screen)
#, no-wrap
msgid ""
"\n"
"…\n"
"Node-path: spreadsheet/Makefile\n"
"…\n"
msgstr ""
"\n"
"…\n"
"Node-path: spreadsheet/Makefile\n"
"…\n"

#: build/en/book.xml:11923(para)
#, fuzzy
msgid "If the paths have leading slashes, you should include leading slashes in the paths you pass to <command moreinfo=\"none\">svndumpfilter include</command> and <command moreinfo=\"none\">svndumpfilter exclude</command> (and if they don't, you shouldn't). Further, if your dump file has an inconsistent usage of leading slashes for some reason, <placeholder-1/> you should probably normalize those paths so they all have, or lack, leading slashes."
msgstr "如果这些路径以斜线开头，那么你传递给<command moreinfo=\"none\">svndumpfilter include</command>和<command moreinfo=\"none\">svndumpfilter exclude</command>的路径也必须以斜线开头（反之亦然）。如果因为某些原因转储文件中的路径没有统一使用或不使用斜线开头，<footnote><placeholder-1/></footnote>也许需要修正这些路径，统一使用斜线开头或不使用斜线开头。"

#: build/en/book.xml:11930(para)
msgid "While <command moreinfo=\"none\">svnadmin dump</command> has a consistent leading slash policy—to not include them—other programs which generate dump data might not be so consistent."
msgstr "尽管<command moreinfo=\"none\">svnadmin dump</command>对是否以斜线作为路径的开头有统一的规定——这个规定就是不以斜线作为路径的开头——其它生成转储文件的程序不一定会遵守这个规定。"

#: build/en/book.xml:11938(para)
msgid "Also, copied paths can give you some trouble. Subversion supports copy operations in the repository, where a new path is created by copying some already existing path. It is possible that at some point in the lifetime of your repository, you might have copied a file or directory from some location that <command moreinfo=\"none\">svndumpfilter</command> is excluding, to a location that it is including. In order to make the dump data self-sufficient, <command moreinfo=\"none\">svndumpfilter</command> needs to still show the addition of the new path—including the contents of any files created by the copy—and not represent that addition as a copy from a source that won't exist in your filtered dump data stream. But because the Subversion repository dump format only shows what was changed in each revision, the contents of the copy source might not be readily available. If you suspect that you have any copies of this sort in your repository, you might want to rethink your set of included/excluded paths."
msgstr "此外，复制操作生成的路径也会带来麻烦。Subversion支持在版本库中进行复制操作，也就是复制一个存在的路径，生成一个新的路径。问题是，<command moreinfo=\"none\">svndumpfilter</command>保留的某个文件或目录可能是由某个<command moreinfo=\"none\">svndumpfilter</command>排除的文件或目录复制而来的。也就是说，为了确保转储数据的完整性，<command moreinfo=\"none\">svndumpfilter</command>需要切断这些复制自被排除路径的文件与源文件的关系，还要将这些文件的内容以新建的方式添加到转储数据中。但是由于Subversion版本库转储文件格式中仅包含了修订版本的更改信息，因此源文件的内容基本上无法获得。如果你不能确定版本库中是否存在类似的情况，最好重新考虑一下到底保留/排除哪些路径。"

#: build/en/book.xml:11957(para)
msgid "Finally, <command moreinfo=\"none\">svndumpfilter</command> takes path filtering quite literally. If you are trying to copy the history of a project rooted at <filename moreinfo=\"none\">trunk/my-project</filename> and move it into a repository of its own, you would, of course, use the <command moreinfo=\"none\">svndumpfilter include</command> command to keep all the changes in and under <filename moreinfo=\"none\">trunk/my-project</filename>. But the resulting dump file makes no assumptions about the repository into which you plan to load this data. Specifically, the dump data might begin with the revision which added the <filename moreinfo=\"none\">trunk/my-project</filename> directory, but it will <emphasis>not</emphasis> contain directives which would create the <filename moreinfo=\"none\">trunk</filename> directory itself (because <filename moreinfo=\"none\">trunk</filename> doesn't match the include filter). You'll need to make sure that any directories which the new dump stream expect to exist actually do exist in the target repository before trying to load the stream into that repository."
msgstr ""

#: build/en/book.xml:11981(title)
#, fuzzy
msgid "Repository Replication"
msgstr "版本库的恢复"

#: build/en/book.xml:11983(para)
msgid "There are several scenarios in which it is quite handy to have a Subversion repository whose version history is exactly the same as some other repository's. Perhaps the most obvious one is the maintenance of a simple backup repository, used when the primary repository has become inaccessible due to a hardware failure, network outage, or other such annoyance. Other scenarios include deploying mirror repositories to distribute heavy Subversion load across multiple servers, use as a soft-upgrade mechanism, and so on."
msgstr ""

#: build/en/book.xml:11993(para)
msgid "As of version 1.4, Subversion provides a program for managing scenarios like these—<command moreinfo=\"none\">svnsync</command>. <command moreinfo=\"none\">svnsync</command> works by essentially asking the Subversion server to <quote>replay</quote> revisions, one at a time. It then uses that revision information to mimic a commit of the same to another repository. Neither repository needs to be locally accessible to machine on which <command moreinfo=\"none\">svnsync</command> is running—its parameters are repository URLs, and it does all its work through Subversion's repository access (RA) interfaces. All it requires is read access to the source repository and read/write access to the destination repository."
msgstr ""

#. don't seem to render it.
#: build/en/book.xml:12(subtitle)
#, fuzzy
msgid "(Compiled from r2789)"
msgstr "(本书由 r2788 版本构建)"

#: build/en/book.xml:12008(para)
msgid "When using <command moreinfo=\"none\">svnsync</command> against a remote source repository, the Subversion server for that repository must be running Subversion version 1.4 or better."
msgstr ""

#: build/en/book.xml:12013(para)
msgid "Assuming you already have a source repository that you'd like to mirror, the next thing you need is an empty target repository which will actually serve as that mirror. This target repository can use either of the available filesystem data-store back-ends (see <xref linkend=\"svn.reposadmin.basics.backends\"/>), but it must not yet have any version history in it. The protocol via which <command moreinfo=\"none\">svnsync</command> communicates revision information is highly sensitive to mismatches between the versioned histories contained in the source and target repositories. For this reason, while <command moreinfo=\"none\">svnsync</command> cannot <emphasis>demand</emphasis> that the target repository be read-only, <placeholder-1/> allowing the revision history in the target repository to change by any mechanism other than the mirroring process is a recipe for disaster."
msgstr ""

#: build/en/book.xml:12026(para)
msgid "In fact, it can't truly be read-only, or <command moreinfo=\"none\">svnsync</command> itself would have a tough time copying revision history into it."
msgstr ""

#: build/en/book.xml:1203(title)
msgid "The Problem of File-Sharing"
msgstr "文件共享的问题"

#: build/en/book.xml:12035(para)
msgid "Do <emphasis>not</emphasis> modify a mirror repository in such a way as to cause its version history to deviate from that of the repository it mirrors. The only commits and revision property modifications that ever occur on that mirror repository should be those performed by the <command moreinfo=\"none\">svnsync</command> tool."
msgstr ""

#: build/en/book.xml:12043(para)
msgid "Another requirement of the target repository is that the <command moreinfo=\"none\">svnsync</command> process be allowed to modify certain revision properties. <command moreinfo=\"none\">svnsync</command> stores its bookkeeping information in special revision properties on revision 0 of the destination repository. Because <command moreinfo=\"none\">svnsync</command> works within the framework of that repository's hook system, the default state of the repository (which is to disallow revision property changes; see <xref linkend=\"svn.ref.reposhooks.pre-revprop-change\"/>) is insufficient. You'll need to explicitly implement the pre-revprop-change hook, and your script must allow <command moreinfo=\"none\">svnsync</command> to set and change its special properties. With those provisions in place, you are ready to start mirroring repository revisions."
msgstr ""

#: build/en/book.xml:1205(para)
msgid "All version control systems have to solve the same fundamental problem: how will the system allow users to share information, but prevent them from accidentally stepping on each other's feet? It's all too easy for users to accidentally overwrite each other's changes in the repository."
msgstr "所有的版本控制系统都需要解决这样一个基础问题：怎样让系统允许用户共享信息，而不会让他们因意外而互相干扰？版本库里意外覆盖别人的更改非常的容易。"

#: build/en/book.xml:12059(para)
msgid "It's a good idea to implement authorization measures which allow your repository replication process to perform its tasks while preventing other users from modifying the contents of your mirror repository at all."
msgstr ""

#: build/en/book.xml:12065(para)
msgid "Let's walk through the use of <command moreinfo=\"none\">svnsync</command> in a somewhat typical mirroring scenario. We'll pepper this discourse with practical recommendations which you are free to disregard if they aren't required by or suitable for your environment."
msgstr ""

#: build/en/book.xml:12071(para)
msgid "As a service to the fine developers of our favorite version control system, we will be mirroring the public Subversion source code repository and exposing that mirror publicly on the Internet, hosted on a different machine than the one on which the original Subversion source code repository lives. This remote host has a global configuration which permits anonymous users to read the contents of repositories on the host, but requires users to authenticate in order to modify those repositories. (Please forgive us for glossing over the details of Subversion server configuration for the moment—those are covered thoroughly in <xref linkend=\"svn.serverconfig\"/>.) And for no other reason than that it makes for a more interesting example, we'll be driving the replication process from a third machine, the one which we currently find ourselves using."
msgstr ""

#: build/en/book.xml:12086(para)
msgid "First, we'll create the repository which will be our mirror. This and the next couple of steps do require shell access to the machine on which the mirror repository will live. Once the repository is all configured, though, we shouldn't need to touch it directly again."
msgstr ""

#: build/en/book.xml:12092(screen)
#, no-wrap
msgid ""
"\n"
"$ ssh admin@svn.example.com \\\n"
"      \"svnadmin create /path/to/repositories/svn-mirror\"\n"
"admin@svn.example.com's password: ********\n"
"$\n"
msgstr ""

#: build/en/book.xml:12099(para)
msgid "At this point, we have our repository, and due to our server's configuration, that repository is now <quote>live</quote> on the Internet. Now, because we don't want anything modifying the repository except our replication process, we need a way to distinguish that process from other would-be committers. To do so, we use a dedicated username for our process. Only commits and revision property modifications performed by the special username <literal moreinfo=\"none\">syncuser</literal> will be allowed."
msgstr ""

#: build/en/book.xml:12109(para)
msgid "We'll use the repository's hook system both to allow the replication process to do what it needs to do, and to enforce that only it is doing those things. We accomplish this by implementing two of the repository event hooks—pre-revprop-change and start-commit. Our <filename moreinfo=\"none\">pre-revprop-change</filename> hook script is found in <xref linkend=\"svn.reposadmin.maint.replication.pre-revprop-change\"/>, and basically verifies that the user attempting the property changes is our <literal moreinfo=\"none\">syncuser</literal> user. If so, the change is allowed; otherwise, it is denied."
msgstr ""

#: build/en/book.xml:1212(para)
msgid "Consider the scenario shown in <xref linkend=\"svn.basic.vsn-models.problem-sharing.dia-1\"/>. Suppose we have two co-workers, Harry and Sally. They each decide to edit the same repository file at the same time. If Harry saves his changes to the repository first, then it's possible that (a few moments later) Sally could accidentally overwrite them with her own new version of the file. While Harry's version of the file won't be lost forever (because the system remembers every change), any changes Harry made <emphasis>won't</emphasis> be present in Sally's newer version of the file, because she never saw Harry's changes to begin with. Harry's work is still effectively lost—or at least missing from the latest version of the file—and probably by accident. This is definitely a situation we want to avoid!"
msgstr "考虑<xref linkend=\"svn.basic.vsn-models.problem-sharing.dia-1\"/>的情景，我们有两个共同工作者，Harry和Sally，他们想同时编辑版本库里的同一个文件，如果首先Harry保存它的修改，过了一会，Sally可能凑巧用自己的版本覆盖了这些文件，Harry的更改不会永远消失（因为系统记录了每次修改），Harry所有的修改<emphasis>不会</emphasis>出现在Sally的文件中，所以Harry的工作还是丢失了—至少是从最新的版本中丢失了—而且是意外的，这就是我们要明确避免的情况！"

#: build/en/book.xml:12120(title)
msgid "Mirror repository's pre-revprop-change hook script"
msgstr ""

#: build/en/book.xml:12122(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh \n"
"\n"
"USER=\"$3\"\n"
"\n"
"if [ \"$USER\" = \"syncuser\" ]; then exit 0; fi\n"
"\n"
"echo \"Only the syncuser user may change revision properties\" &gt;&amp;2\n"
"exit 1\n"
msgstr ""

#: build/en/book.xml:12134(para)
msgid "That covers revision property changes. Now we need to ensure that only the <literal moreinfo=\"none\">syncuser</literal> user is permitted to commit new revisions to the repository. We do this using a <filename moreinfo=\"none\">start-commit</filename> hook scripts like the one in <xref linkend=\"svn.reposadmin.maint.replication.start-commit\"/>."
msgstr ""

#: build/en/book.xml:12141(title)
msgid "Mirror repository's start-commit hook script"
msgstr ""

#: build/en/book.xml:12143(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh \n"
"\n"
"USER=\"$2\"\n"
"\n"
"if [ \"$USER\" = \"syncuser\" ]; then exit 0; fi\n"
"\n"
"echo \"Only the syncuser user may commit new revisions\" &gt;&amp;2\n"
"exit 1\n"
msgstr ""

#: build/en/book.xml:12155(para)
msgid "After installing our hook scripts and ensuring that they are executable by the Subversion server, we're finished with the setup of the mirror repository. Now, we get to actually do the mirroring."
msgstr ""

#: build/en/book.xml:12160(para)
msgid "The first thing we need to do with <command moreinfo=\"none\">svnsync</command> is to register in our target repository the fact that it will be a mirror of the source repository. We do this using the <command moreinfo=\"none\">svnsync initialize</command> subcommand. Note that the various <command moreinfo=\"none\">svnsync</command> subcommands provide several of the same authentication-related options that <command moreinfo=\"none\">svn</command> does: <option>--username</option>, <option>--password</option>, <option>--non-interactive</option>, <option>--config-dir</option>, and <option>--no-auth-cache</option>."
msgstr ""

#: build/en/book.xml:12173(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help init\n"
"initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL\n"
"\n"
"Initialize a destination repository for synchronization from\n"
"another repository.\n"
"\n"
"The destination URL must point to the root of a repository with\n"
"no committed revisions.  The destination repository must allow\n"
"revision property changes.\n"
"\n"
"You should not commit to, or make revision property changes in,\n"
"the destination repository by any method other than 'svnsync'.\n"
"In other words, the destination repository should be a read-only\n"
"mirror of the source repository.\n"
"\n"
"Valid options:\n"
"  --non-interactive        : do no interactive prompting\n"
"  --no-auth-cache          : do not cache authentication tokens\n"
"  --username arg           : specify a username ARG\n"
"  --password arg           : specify a password ARG\n"
"  --config-dir arg         : read user configuration files from directory ARG\n"
"\n"
"$ svnsync initialize http://svn.example.com/svn-mirror \\\n"
"                     http://svn.collab.net/repos/svn \\\n"
"                     --username syncuser --password syncpass\n"
"Copied properties for revision 0.\n"
"$\n"
msgstr ""

#: build/en/book.xml:12203(para)
msgid "Our target repository will now remember that it is a mirror of the public Subversion source code repository. Notice that we provided a username and password as arguments to <command moreinfo=\"none\">svnsync</command>—that was required by the pre-revprop-change hook on our mirror repository."
msgstr ""

#: build/en/book.xml:12210(para)
msgid "The URLs provided to <command moreinfo=\"none\">svnsync</command> must point to the root directories of the target and source repositories, respectively. The tool does not handle mirroring of repository subtrees."
msgstr ""

#: build/en/book.xml:12217(para)
msgid "The initial release of <command moreinfo=\"none\">svnsync</command> (in Subversion 1.4) has a small shortcoming—the values given to the <option>--username</option> and <option>--password</option> command-line options get used for authentication against both the source and destination repositories. Obviously, there's no guarantee that the synchronizing user's credentials are the same in both places. In the event that they are not the same, users trying to run <command moreinfo=\"none\">svnsync</command> in non-interactive mode (with the <option>--non-interactive</option> option) might experience problems."
msgstr ""

#: build/en/book.xml:12230(para)
msgid "And now comes the fun part. With a single subcommand, we can tell <command moreinfo=\"none\">svnsync</command> to copy all the as-yet-unmirrored revisions from the source repository to the target. <placeholder-1/> The <command moreinfo=\"none\">svnsync synchronize</command> subcommand will peek into the special revision properties previously stored on the target repository, and determine what repository it is mirroring and that the most recently mirrored revision was revision 0. Then it will query the source repository and determine what the latest revision in that repository is. Finally, it asks the source repository's server to start replaying all the revisions between 0 and that latest revision. As <command moreinfo=\"none\">svnsync</command> get the resulting response from the source repository's server, it begins forwarding those revisions to the target repository's server as new commits."
msgstr ""

#: build/en/book.xml:12235(para)
msgid "Be forewarned that while it will take only a few seconds for the average reader to parse this paragraph and the sample output which follows it, the actual time required to complete such a mirroring operation is, shall we say, quite a bit longer."
msgstr ""

#: build/en/book.xml:12254(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help synchronize\n"
"synchronize (sync): usage: svnsync synchronize DEST_URL\n"
"\n"
"Transfer all pending revisions from source to destination.\n"
"…\n"
"$ svnsync synchronize http://svn.example.com/svn-mirror \\\n"
"                      --username syncuser --password syncpass\n"
"Committed revision 1.\n"
"Copied properties for revision 1.\n"
"Committed revision 2.\n"
"Copied properties for revision 2.\n"
"Committed revision 3.\n"
"Copied properties for revision 3.\n"
"…\n"
"Committed revision 23406.\n"
"Copied properties for revision 23406.\n"
"Committed revision 23407.\n"
"Copied properties for revision 23407.\n"
"Committed revision 23408.\n"
"Copied properties for revision 23408.\n"
msgstr ""

#: build/en/book.xml:12277(para)
msgid "Of particular interest here is that for each mirrored revision, there is first a commit of that revision to the target repository, and then property changes follow. This is because the initial commit is performed by (and attributed to) the user <literal moreinfo=\"none\">syncuser</literal>, and datestamped with the time as of that revision's creation. Also, Subversion's underlying repository access interfaces don't provide a mechanism for setting arbitary revision properties as part of a commit. So <command moreinfo=\"none\">svnsync</command> follows up with an immediate series of property modifications which copy all the revision properties found for that revision in the source repository into the target repository. This also has the effect of fixing the author and datestamp of the revision to match that of the source repository."
msgstr ""

#: build/en/book.xml:1228(title)
msgid "The problem to avoid"
msgstr "需要避免的问题"

#: build/en/book.xml:12292(para)
msgid "Also noteworthy is that <command moreinfo=\"none\">svnsync</command> performs careful bookkeeping that allows it to be safely interrupted and restarted without ruining the integrity of the mirrored data. If a network glitch occurs while mirroring a repository, simply repeat the <command moreinfo=\"none\">svnsync synchronize</command> command and it will happily pick up right where it left off. In fact, as new revisions appear in the source repository, this is exactly what you to do in order to keep your mirror up-to-date."
msgstr ""

#: build/en/book.xml:12302(para)
msgid "There is, however, one bit of inelegance in the process. Because Subversion revision properties can be changed at any time throughout the lifetime of the repository, and don't leave an audit trail that indicates when they were changed, replication processes have to pay special attention to them. If you've already mirror the first 15 revisions of a repository and someone then changes a revision property on revision 12, <command moreinfo=\"none\">svnsync</command> won't know to go back and patch up its copy of revision 12. You'll need to tell it to do so manually by using (or with some additionally tooling around) the <command moreinfo=\"none\">svnsync copy-revprops</command> subcommand, which simply re-replicates all the revision properties for a particular revision."
msgstr ""

#: build/en/book.xml:12316(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help copy-revprops\n"
"copy-revprops: usage: svnsync copy-revprops DEST_URL REV\n"
"\n"
"Copy all revision properties for revision REV from source to\n"
"destination.\n"
"…\n"
"$ svnsync copy-revprops http://svn.example.com/svn-mirror 12 \\\n"
"                        --username syncuser --password syncpass\n"
"Copied properties for revision 12.\n"
"$\n"
msgstr ""

#: build/en/book.xml:12329(para)
msgid "That's repository replication in a nutshell. You'll likely want some automation around such a process. For example, while our example was a pull-and-push setup, you might wish to have your primary repository push changes to one or more blessed mirrors as part of its post-commit and post-revprop-change hook implementations. This would enable the mirror to be up-to-date in as near to realtime as is likely possible."
msgstr ""

#: build/en/book.xml:12338(para)
msgid "Also, while it isn't very commonplace to do so, <command moreinfo=\"none\">svnsync</command> does gracefully mirror repositories in which the user as whom it authenticates only has partial read access. It simply copies only the bits of the repository that it is permitted to see. Obviously such a mirror is not useful as a backup solution."
msgstr ""

#: build/en/book.xml:12345(para)
msgid "As far as user interaction with repositories and mirrors goes, it <emphasis>is</emphasis> possible to have a single working copy that interacts with both, but you'll have to jump through some hoops to make it happen. First, you need to ensure that both the primary and mirror repositories have the same repository UUID (which is not the case by default). You can set the mirror repository's UUID by loading a dump file stub into it which contains the UUID of the primary repository, like so:"
msgstr ""

#: build/en/book.xml:12355(screen)
#, no-wrap
msgid ""
"\n"
"$ cat - &lt;&lt;EOF | svnadmin load --force-uuid dest\n"
"SVN-fs-dump-format-version: 2\n"
"\n"
"UUID: 65390229-12b7-0310-b90b-f21a5aa7ec8e\n"
"EOF\n"
"$\n"
msgstr ""

#: build/en/book.xml:1236(title)
msgid "The Lock-Modify-Unlock Solution"
msgstr "锁定-修改-解锁 方案"

#: build/en/book.xml:12364(para)
msgid "Now that the two repositories have the same UUID, you can use <command moreinfo=\"none\">svn switch --relocate</command> to point your working copy to whichever of the repositories you wish to operate against, a process which is described in <xref linkend=\"svn.ref.svn.c.switch\"/>. There is a possible danger here, though, in that if the primary and mirror repositories aren't in close synchronization, a working copy up-to-date with and pointing to the primary repository will, if relocated to point to an out-of-date mirror, become confused about the apparent sudden loss of revisions it fully expects to be present."
msgstr ""

#: build/en/book.xml:12375(para)
msgid "Finally, be aware that the revision-based replication provided by <command moreinfo=\"none\">svnsync</command> is only that—replication of revisions. It does not include such things as the hook implementations, repository or server configuration data, uncommitted transactions, or information about user locks on repository paths. Only information carried by the Subversion repository dump file format is available for replication."
msgstr ""

#: build/en/book.xml:1238(para)
msgid "Many version control systems use a <firstterm>lock-modify-unlock</firstterm> model to address the problem of many authors clobbering each other's work. In this model, the repository allows only one person to change a file at a time. This exclusivity policy is managed using locks. Harry must <quote>lock</quote> a file before he can begin making changes to it. If Harry has locked a file, then Sally cannot also lock it, and therefore cannot make any changes to that file. All she can do is read the file, and wait for Harry to finish his changes and release his lock. After Harry unlocks the file, Sally can take her turn by locking and editing the file. <xref linkend=\"svn.basic.vsn-models.lock-unlock.dia-1\"/> demonstrates this simple solution."
msgstr "许多版本控制系统使用<firstterm>锁定-修改-解锁</firstterm>这种机制解决这种问题，在这样的模型里，在一个时间段里版本库的一个文件只允许被一个人修改。首先在修改之前，Harry要<quote>锁定</quote>住这个文件，锁定很像是从图书馆借一本书，如果Harry锁住这个文件，Sally不能做任何修改，如果Sally想请求得到一个锁，版本库会拒绝这个请求。在Harry结束编辑并且放开这个锁之前，她只可以阅读文件。Harry解锁后，就要换班了，Sally得到自己的轮换位置，锁定并且开始编辑这个文件。<xref linkend=\"svn.basic.vsn-models.lock-unlock.dia-1\"/>描述了这样的解决方案。"

#: build/en/book.xml:12388(title)
msgid "Repository Backup"
msgstr "版本库备份"

#: build/en/book.xml:12390(para)
msgid "Despite numerous advances in technology since the birth of the modern computer, one thing unfortunately rings true with crystalline clarity—sometimes, things go very, very awry. Power outages, network connectivity dropouts, corrupt RAM and crashed hard drives are but a taste of the evil that Fate is poised to unleash on even the most conscientious administrator. And so we arrive at a very important topic—how to make backup copies of your repository data."
msgstr "尽管现代计算机的诞生带来了许多便利，但有一件事听起来是完全正确的—有时候，事情变的糟糕，很糟糕，动力损耗、网络中断、坏掉的内存和损坏的硬盘都是对魔鬼的一种体验，即使对于最尽职的管理员，命运也早已注定。所以我们来到了这个最重要的主题—怎样备份你的版本库数据。"

#: build/en/book.xml:12400(para)
msgid "There are two types of backup methods available for Subversion repository administrators—full and incremental. A full backup of the repository involves squirreling away in one sweeping action all the information required to fully reconstruct that repository in the event of a catastrophe. Usually, it means quite literally the duplication of the entire repository directory (which includes either a Berkeley DB or FSFS environment). Incremental backups are lesser things, backups of only the portion of the repository data that has changed since the previous backup."
msgstr ""

#: build/en/book.xml:12412(para)
msgid "As far as full backups go, the naive approach might seem like a sane one, but unless you temporarily disable all other access to your repository, simply doing a recursive directory copy runs the risk of generating a faulty backup. In the case of Berkeley DB, the documentation describes a certain order in which database files can be copied that will guarantee a valid backup copy. A similar ordering exists for FSFS data. But you don't have to implement these algorithms yourself, because the Subversion development team has already done so. The <command moreinfo=\"none\">svnadmin hotcopy</command> command takes care of the minutia involved in making a hot backup of your repository. And its invocation is as trivial as Unix's <command moreinfo=\"none\">cp</command> or Windows' <command moreinfo=\"none\">copy</command> operations:"
msgstr ""

#: build/en/book.xml:12427(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin hotcopy /path/to/repos /path/to/repos-backup\n"
msgstr ""
"\n"
"$ svnadmin hotcopy /path/to/repos /path/to/repos-backup\n"

#: build/en/book.xml:12431(para)
msgid "The resulting backup is a fully functional Subversion repository, able to be dropped in as a replacement for your live repository should something go horribly wrong."
msgstr "作为结果的备份是一个完全功能的版本库，当发生严重错误时可以作为你的活动版本库的替换。"

#: build/en/book.xml:12435(para)
msgid "When making copies of a Berkeley DB repository, you can even instruct <command moreinfo=\"none\">svnadmin hotcopy</command> to purge any unused Berkeley DB logfiles (see <xref linkend=\"svn.reposadmin.maint.diskspace.bdblogs\"/>) from the original repository upon completion of the copy. Simply provide the <option>--clean-logs</option> option on the command-line."
msgstr ""

#: build/en/book.xml:12442(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin hotcopy --clean-logs /path/to/bdb-repos /path/to/bdb-repos-backup\n"
msgstr ""

#: build/en/book.xml:12446(para)
msgid "Additional tooling around this command is available, too. The <filename moreinfo=\"none\">tools/backup/</filename> directory of the Subversion source distribution holds the <command moreinfo=\"none\">hot-backup.py</command> script. This script adds a bit of backup management atop <command moreinfo=\"none\">svnadmin hotcopy</command>, allowing you to keep only the most recent configured number of backups of each repository. It will automatically manage the names of the backed-up repository directories to avoid collisions with previous backups, and will <quote>rotate off</quote> older backups, deleting them so only the most recent ones remain. Even if you also have an incremental backup, you might want to run this program on a regular basis. For example, you might consider using <command moreinfo=\"none\">hot-backup.py</command> from a program scheduler (such as <command moreinfo=\"none\">cron</command> on Unix systems) which will cause it to run nightly (or at whatever granularity of Time you deem safe enough for you)."
msgstr ""

#: build/en/book.xml:12464(para)
msgid "Some administrators use a different backup mechanism built around generating and storing repository dump data. We described in <xref linkend=\"svn.reposadmin.maint.migrate\"/> how to use <command moreinfo=\"none\">svnadmin dump --incremental</command> to perform an incremental backup of a given revision or range of revisions. And of course, there is a full backup variation of this achieved by omitting the <option>--incremental</option> option to that command. There is some value in these methods in that the format of your backed-up information is flexible—it's not tied to a particular platform, versioned filesystem type, or release of Subversion or Berkeley DB. But that flexibility comes at a cost, namely that restoring that data can take a long time—longer with each new revision committed to your repository. Also, as is the case with so many of the various backup methods, revision property changes made to already-backed-up revisions won't get picked up by a non-overlapping, incremental dump generation. For these reasons, we recommend against relying solely on dump-based backup approaches."
msgstr ""

#: build/en/book.xml:12484(para)
#, fuzzy
msgid "As you can see, each of the various backup types and methods has its advantages and disadvantages. The easiest is by far the full hot backup, which will always result in a perfect working replica of your repository. Should something bad happen to your live repository, you can restore from the backup with a simple recursive directory copy. Unfortunately, if you are maintaining multiple backups of your repository, these full copies will each eat up just as much disk space as your live repository. Incremental backups, by contrast, tend to be quicker to generate and smaller to store. But the restoration process can be a pain, often involving applying multiple incremental backups. And other methods have their own peculiarities. Administators need to find the balance between the cost of making the backup and the cost of restoring it."
msgstr "两种备份方式都有各自的优点，最简单的方式是完全备份，将会每次建立版本库的完美复制品，这意味着如果当你的活动版本库发生了什么事情，你可以用备份恢复。但不幸的是，如果你维护多个备份，每个完全的备份会吞噬掉和你的活动版本库同样的空间。"

#: build/en/book.xml:12500(para)
msgid "The <command moreinfo=\"none\">svnsync</command> program (see <xref linkend=\"svn.reposadmin.maint.replication\"/>) actually provides a rather handy middle-ground approach. If you are regularly synchronizing a read-only mirror with your main repository, then in a pinch, your read-only mirror is probably a good candidate for replacing that main repository if it falls over. The primary disadvantage of this method is that only the versioned repository data gets synchronized—repository configuration files, user-specified repository path locks, and other items which might live in the physical repository directory but not <emphasis>inside</emphasis> the repository's virtual versioned filesystem are not handled by svnsync."
msgstr ""

#: build/en/book.xml:12513(para)
#, fuzzy
msgid "In any backup scenario, repository administrators need to be aware of how modifications to unversioned revision properties affect their backups. Since these changes do not themselves generate new revisions, they will not trigger post-commit hooks, and may not even trigger the pre-revprop-change and post-revprop-change hooks. <placeholder-1/> And since you can change revision properties without respect to chronological order—you can change any revision's properties at any time—an incremental backup of the latest few revisions might not catch a property modification to a revision that was included as part of a previous backup."
msgstr "在每一种备份情境下，版本库管理员需要意识到对未版本化的修订版本属性的修改对备份的影响，因为这些修改本身不会产生新的修订版本，所以不会触发post-commit的钩子程序，也不会触发pre-revprop-change和post-revprop-change的钩子。 <footnote><placeholder-1/></footnote> 而且因为你可以改变修订版本的属性，而不需要遵照时间顺序—你可在任何时刻修改任何修订版本的属性—因此最新版本的增量备份不会捕捉到以前特定修订版本的属性修改。"

#: build/en/book.xml:12520(para)
msgid "<command moreinfo=\"none\">svnadmin setlog</command> can be called in a way that bypasses the hook interface altogether."
msgstr "<command moreinfo=\"none\">svnadmin setlog</command>可以被绕过钩子程序被调用。"

#: build/en/book.xml:1253(title)
msgid "The lock-modify-unlock solution"
msgstr "锁定-修改-解锁 方案2"

#: build/en/book.xml:12530(para)
#, fuzzy
msgid "Generally speaking, only the truly paranoid would need to backup their entire repository, say, every time a commit occurred. However, assuming that a given repository has some other redundancy mechanism in place with relatively fine granularity (like per-commit emails or incremental dumps), a hot backup of the database might be something that a repository administrator would want to include as part of a system-wide nightly backup. It's your data—protect it as much as you'd like."
msgstr "通常说来，在每次提交时，只有妄想狂才会备份整个版本库，然而，假设一个给定的版本库拥有一些恰当粒度的冗余机制（如每次提交的邮件）。版本库管理员也许会希望将版本库的热备份引入到系统级的每夜备份，对大多数版本库，归档的提交邮件为保存资源提供了足够的冗余措施，至少对于最近的提交。但是它是你的数据—你喜欢怎样保护都可以。"

#: build/en/book.xml:12540(para)
#, fuzzy
msgid "Often, the best approach to repository backups is a diversified one which leverages combinations of the methods described here. The Subversion developers, for example, back up the Subversion source code repository nightly using <command moreinfo=\"none\">hot-backup.py</command> and an offsite <command moreinfo=\"none\">rsync</command> of those full backups; keep multiple archives of all the commit and property change notification emails; and have repository mirrors maintained by various volunteers using <command moreinfo=\"none\">svnsync</command>. Your solution might be similar, but should be catered to your needs and that delicate balance of convenience with paranoia. And whatever you do, validate your backups from time to time—what good is a spare tire that has a hole in it? While all of this might not save your hardware from the iron fist of Fate, <placeholder-1/> it should certainly help you recover from those trying times."
msgstr "通常情况下，最好的版本库备份方式是混合的，你可以平衡完全和增量备份，另外配合提交邮件的归档，Subversion开发者，举个例子，在每个新的修订版本建立时备份Subversion的源代码版本库，并且保留所有的提交和属性修改通知文件。你的解决方案类似，必须迎合你的需要，平衡便利和你的偏执。然而这些不会改变你的硬件来自钢铁的命运。<footnote><placeholder-1/></footnote> 这一定会帮助你减少尝试的时间。"

#: build/en/book.xml:12555(para)
msgid "You know—the collective term for all of her <quote>fickle fingers</quote>."
msgstr "你知道的—只是对各种变化莫测的问题的统称。"

#: build/en/book.xml:12569(title) build/en/book.xml:2047(title)
#: build/en/book.xml:3978(title) build/en/book.xml:9639(title)
msgid "Summary"
msgstr "概要"

#: build/en/book.xml:1257(para)
msgid "The problem with the lock-modify-unlock model is that it's a bit restrictive, and often becomes a roadblock for users:"
msgstr "锁定-修改-解锁模型有一点问题就是限制太多，经常会成为用户的障碍："

#: build/en/book.xml:12571(para)
msgid "By now you should have a basic understanding of how to create, configure, and maintain Subversion repositories. We've introduced you to the various tools that will assist you with this task. Throughout the chapter, we've noted common administration pitfalls, and suggestions for avoiding them."
msgstr "现在，你应该已经对如何创建、配置以及维护Subversion版本库有了个基本的认识。我们向您介绍了几个可以帮助您工作的工具。通过这一章，我们说明了一些常见的管理误区，并提出了避免陷入误区的建议。"

#: build/en/book.xml:12578(para)
msgid "All that remains is for you to decide what exciting data to store in your repository, and finally, how to make it available over a network. The next chapter is all about networking."
msgstr "剩下的，就是由你决定在你的版本库中存放一些什么有趣的资料，并最终通过网络获得这些资料。下一章是关于网络的内容。"

#: build/en/book.xml:12592(title)
msgid "Server Configuration"
msgstr "配置服务器"

#: build/en/book.xml:12594(para)
#, fuzzy
msgid "A Subversion repository can be accessed simultaneously by clients running on the same machine on which the repository resides using the <literal moreinfo=\"none\">file://</literal> method. But the typical Subversion setup involves a single server machine being accessed from clients on computers all over the office—or, perhaps, all over the world."
msgstr "一个Subversion的版本库可以和客户端同时运行在同一个机器上，使用<literal moreinfo=\"none\">file:///</literal>访问，但是一个典型的Subversion设置应该包括一个单独的服务器，可以被办公室的所有客户端访问—或者有可能是整个世界。"

#: build/en/book.xml:12601(para)
#, fuzzy
msgid "This chapter describes how to get your Subversion repository exposed outside its host machine for use by remote clients. We will cover Subversion's currently available server mechanisms, discussing the configuration and use of each. After reading this section, you should be able to decide which networking setup is right for your needs, and understand how to enable such a setup on your host computer."
msgstr "本小节描述了怎样将一个Subversion的版本库暴露给远程客户端，我们会覆盖Subversion已存在的服务器机制，讨论各种方式的配置和使用。经过阅读本小节，你可以决定你需要哪种网络设置，并且明白怎样在你的主机上进行配置。"

#: build/en/book.xml:12615(title)
msgid "Overview"
msgstr "概述"

#: build/en/book.xml:12617(para)
#, fuzzy
msgid "Subversion was designed with an abstract network layer. This means that a repository can be programmatically accessed by any sort of server process, and the client <quote>repository access</quote> API allows programmers to write plugins that speak relevant network protocols. In theory, Subversion can use an infinite number of network implementations. In practice, there are only two servers at the time of this writing."
msgstr "Subversion的设计包括一个抽象的网络层，这意味着版本库可以通过各种服务器进程访问，而且客户端<quote>版本库访问</quote>的API允许程序员写出相关协议的插件，理论上讲，Subversion可以使用无限数量的网络协议实现，目前实践中存在着两种服务器。"

#: build/en/book.xml:12625(para)
#, fuzzy
msgid "Apache is an extremely popular webserver; using the <command moreinfo=\"none\">mod_dav_svn</command> module, Apache can access a repository and make it available to clients via the WebDAV/DeltaV protocol, which is an extension of HTTP. Because Apache is an extremely extensible web server, it provides a number of features <quote>for free</quote>, such as encrypted SSL communication, logging, integration with a number of third-party authentication systems, and limited built-in web browsing of repositories."
msgstr "Apache是最流行的web服务器，通过使用<command moreinfo=\"none\">mod_dav_svn</command