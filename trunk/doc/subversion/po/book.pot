msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2007-04-28 03:26 +0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: en.xml:4(title) 
msgid "Version Control with Subversion"
msgstr ""

#. don't seem to render it.
#: en.xml:8(subtitle) 
msgid "For Subversion 1.3"
msgstr ""

#: en.xml:9(subtitle) 
msgid "(book compiled from 2517)"
msgstr ""

#: en.xml:13(edition) 
msgid "First"
msgstr ""

#: en.xml:14(isbn) 
msgid "0-59600-448-6"
msgstr ""

#: en.xml:18(firstname) 
msgid "Ben"
msgstr ""

#: en.xml:19(surname) 
msgid "Collins-Sussman"
msgstr ""

#: en.xml:23(firstname) 
msgid "Brian W."
msgstr ""

#: en.xml:24(surname) 
msgid "Fitzpatrick"
msgstr ""

#: en.xml:28(firstname) 
msgid "C. Michael"
msgstr ""

#: en.xml:29(surname) 
msgid "Pilato"
msgstr ""

#: en.xml:35(firstname) 
msgid "Linda"
msgstr ""

#: en.xml:36(surname) 
msgid "Mui"
msgstr ""

#: en.xml:39(pagenums) 
msgid "350 pages (est.)"
msgstr ""

#: en.xml:40(pubdate) 
msgid "(TBA)"
msgstr ""

#: en.xml:43(year) 
msgid "2002"
msgstr ""

#: en.xml:44(year) 
msgid "2003"
msgstr ""

#: en.xml:45(year) 
msgid "2004"
msgstr ""

#: en.xml:46(year) 
msgid "2005"
msgstr ""

#: en.xml:47(year) 
msgid "2006"
msgstr ""

#: en.xml:48(holder) 
msgid "Ben Collins-Sussman"
msgstr ""

#: en.xml:49(holder) en.xml:203(attribution) 
msgid "Brian W. Fitzpatrick"
msgstr ""

#: en.xml:50(holder) 
msgid "C. Michael Pilato"
msgstr ""

#: en.xml:53(para) 
msgid "This work is licensed under the Creative Commons Attribution License. To view a copy of this license, visit <ulink url=\"http://creativecommons.org/licenses/by/2.0/\"/> or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA."
msgstr ""

#: en.xml:69(title) 
msgid "Foreword"
msgstr ""

#: en.xml:73(para) 
msgid "A bad Frequently Asked Questions (FAQ) sheet is one that is composed not of the questions people actually asked, but of the questions the FAQ's author <emphasis>wished</emphasis> people had asked. Perhaps you've seen the type before:"
msgstr ""

#: en.xml:79(para) 
msgid "Q: How can I use Glorbosoft XYZ to maximize team productivity?"
msgstr ""

#: en.xml:84(para) 
msgid "A: Many of our customers want to know how they can maximize productivity through our patented office groupware innovations. The answer is simple: first, click on the <quote><literal moreinfo=\"none\">File</literal></quote> menu, scroll down to <quote><literal moreinfo=\"none\">Increase Productivity</literal></quote>, then…"
msgstr ""

#: en.xml:92(para) 
msgid "The problem with such FAQs is that they are not, in a literal sense, FAQs at all. No one ever called the tech support line and asked, <quote>How can we maximize productivity?</quote>. Rather, people asked highly specific questions, like, <quote>How can we change the calendaring system to send reminders two days in advance instead of one?</quote> and so on. But it's a lot easier to make up imaginary Frequently Asked Questions than it is to discover the real ones. Compiling a true FAQ sheet requires a sustained, organized effort: over the lifetime of the software, incoming questions must be tracked, responses monitored, and all gathered into a coherent, searchable whole that reflects the collective experience of users in the wild. It calls for the patient, observant attitude of a field naturalist. No grand hypothesizing, no visionary pronouncements here—open eyes and accurate note-taking are what's needed most."
msgstr ""

#: en.xml:109(para) 
msgid "What I love about this book is that it grew out of just such a process, and shows it on every page. It is the direct result of the authors' encounters with users. It began with Ben Collins-Sussman's observation that people were asking the same basic questions over and over on the Subversion mailing lists: What are the standard workflows to use with Subversion? Do branches and tags work the same way as in other version control systems? How can I find out who made a particular change?"
msgstr ""

#: en.xml:118(para) 
msgid "Frustrated at seeing the same questions day after day, Ben worked intensely over a month in the summer of 2002 to write <citetitle>The Subversion Handbook</citetitle>, a sixty page manual that covered all the basics of using Subversion. The manual made no pretense of being complete, but it was distributed with Subversion and got users over that initial hump in the learning curve. When O'Reilly and Associates decided to publish a full-length Subversion book, the path of least resistance was obvious: just expand the Subversion handbook."
msgstr ""

#: en.xml:129(para) 
msgid "The three co-authors of the new book were thus presented with an unusual opportunity. Officially, their task was to write a book top-down, starting from a table of contents and an initial draft. But they also had access to a steady stream—indeed, an uncontrollable geyser—of bottom-up source material. Subversion was already in the hands of thousands of early adopters, and those users were giving tons of feedback, not only about Subversion, but about its existing documentation."
msgstr ""

#: en.xml:139(para) 
msgid "During the entire time they wrote this book, Ben, Mike, and Brian haunted the Subversion mailing lists and chat rooms incessantly, carefully noting the problems users were having in real-life situations. Monitoring such feedback is part of their job descriptions at CollabNet anyway, and it gave them a huge advantage when they set out to document Subversion. The book they produced is grounded firmly in the bedrock of experience, not in the shifting sands of wishful thinking; it combines the best aspects of user manual and FAQ sheet. This duality might not be noticeable on a first reading. Taken in order, front to back, the book is simply a straightforward description of a piece of software. There's the overview, the obligatory guided tour, the chapter on administrative configuration, some advanced topics, and of course a command reference and troubleshooting guide. Only when you come back to it later, seeking the solution to some specific problem, does its authenticity shine out: the telling details that can only result from encounters with the unexpected, the examples honed from genuine use cases, and most of all the sensitivity to the user's needs and the user's point of view."
msgstr ""

#: en.xml:160(para) 
msgid "Of course, no one can promise that this book will answer every question you have about Subversion. Sometimes, the precision with which it anticipates your questions will seem eerily telepathic; yet occasionally, you will stumble into a hole in the community's knowledge, and come away empty-handed. When this happens, the best thing you can do is email <email>users@subversion.tigris.org</email> and present your problem. The authors are still there, still watching, and they include not just the three listed on the cover, but many others who contributed corrections and original material. From the community's point of view, solving your problem is merely a pleasant side effect of a much larger project—namely, slowly adjusting this book, and ultimately Subversion itself, to more closely match the way people actually use it. They are eager to hear from you not merely because they can help you, but because you can help them. With Subversion as with all active free software projects, <emphasis>you are not alone</emphasis>."
msgstr ""

#: en.xml:179(para) 
msgid "Let this book be your first companion."
msgstr ""

#: en.xml:181(para) 
msgid "— <author><firstname>Karl</firstname><surname>Fogel</surname></author>, Chicago, 14 March, 2004"
msgstr ""

#: en.xml:198(title) 
msgid "Preface"
msgstr ""

#: en.xml:204(quote) 
msgid "If C gives you enough rope to hang yourself, think of Subversion as a sort of rope storage facility."
msgstr ""

#: en.xml:208(para) 
msgid "In the world of open-source software, the Concurrent Versions System (CVS) has long been the tool of choice for version control. And rightly so. CVS itself is free software, and its non-restrictive <foreignphrase>modus operandi</foreignphrase> and support for networked operation—which allow dozens of geographically dispersed programmers to share their work—fits the collaborative nature of the open-source world very well. CVS and its semi-chaotic development model have become cornerstones of open-source culture."
msgstr ""

#: en.xml:220(para) 
msgid "But like many tools, CVS is starting to show its age. Subversion is a relatively new version control system designed to be the successor to CVS. The designers set out to win the hearts of CVS users in two ways: by creating an open-source system with a design (and <quote>look and feel</quote>) similar to CVS, and by attempting to fix most of CVS's noticeable flaws. While the result isn't necessarily the next great evolution in version control design, Subversion <emphasis>is</emphasis> very powerful, very usable, and very flexible."
msgstr ""

#: en.xml:231(para) 
msgid "This book is written to document the 1.3 series of the Subversion version control system. We have made every attempt to be thorough in our coverage. However, Subversion has a thriving and energetic development community, so there are already a number of features and improvements planned for future versions of Subversion that may change some of the commands and specific notes in this book."
msgstr ""

#: en.xml:248(title) 
msgid "Audience"
msgstr ""

#: en.xml:250(para) 
msgid "This book is written for computer-literate folk who want to use Subversion to manage their data. While Subversion runs on a number of different operating systems, its primary user interface is command-line based. It is that command-line tool (<command moreinfo=\"none\">svn</command>) which is discussed and used in this book. For consistency, the examples in this book assume the reader is using a Unix-like operating system, and is relatively comfortable with Unix and command-line interfaces."
msgstr ""

#: en.xml:259(para) 
msgid "That said, the <command moreinfo=\"none\">svn</command> program also runs on non-Unix platforms like Microsoft Windows. With a few minor exceptions, such as the use of backward slashes (<literal moreinfo=\"none\">\\</literal>) instead of forward slashes (<literal moreinfo=\"none\">/</literal>) for path separators, the input to and output from this tool when run on Windows are identical to its Unix counterpart. However, Windows users may find more success by running the examples inside the Cygwin Unix emulation environment."
msgstr ""

#: en.xml:269(para) 
msgid "Most readers are probably programmers or system administrators who need to track changes to source code. This is the most common use for Subversion, and therefore it is the scenario underlying all of the book's examples. But Subversion can be used to manage changes to any sort of information: images, music, databases, documentation, and so on. To Subversion, all data is just data."
msgstr ""

#: en.xml:277(para) 
msgid "While this book is written with the assumption that the reader has never used version control, we've also tried to make it easy for users of CVS to make a painless leap into Subversion. Special sidebars may discuss CVS from time to time, and a special appendix summarizes most of the differences between CVS and Subversion."
msgstr ""

#: en.xml:290(title) 
msgid "How to Read this Book"
msgstr ""

#: en.xml:292(para) 
msgid "This book aims to be useful to people of widely different backgrounds—from people with no previous experience in version control to experienced system administrators. Depending on your own background, certain chapters may be more or less important to you. The following can be considered a <quote>recommended reading list</quote> for various types of readers:"
msgstr ""

#: en.xml:302(term) 
msgid "Experienced System Administrators"
msgstr ""

#: en.xml:304(para) 
msgid "The assumption here is that you've probably used CVS before, and are dying to get a Subversion server up and running ASAP. <xref linkend=\"svn.reposadmin\"/> and <xref linkend=\"svn.serverconfig\"/> will show you how to create your first repository and make it available over the network. After that's done, <xref linkend=\"svn.tour\"/> and <xref linkend=\"svn.forcvs\"/> are the fastest routes to learning the Subversion client while drawing on your CVS experience."
msgstr ""

#: en.xml:316(term) 
msgid "New users"
msgstr ""

#: en.xml:318(para) 
msgid "Your administrator has probably set up Subversion already, and you need to learn how to use the client. If you've never used a version control system (like CVS), then <xref linkend=\"svn.basic\"/> and <xref linkend=\"svn.tour\"/> are a vital introduction. If you're already an old hand at CVS, chapter 3 and appendix A are the best place to start."
msgstr ""

#: en.xml:328(term) 
msgid "Advanced users"
msgstr ""

#: en.xml:330(para) 
msgid "Whether you're a user or administrator, eventually your project will grow larger. You're going to want to learn how to do more advanced things with Subversion, such as how to use branches and perform merges (<xref linkend=\"svn.branchmerge\"/>), how to use Subversion's property support, how to configure runtime options (<xref linkend=\"svn.advanced\"/>), and other things. These two chapters aren't vital at first, but be sure to read them once you're comfortable with the basics."
msgstr ""

#: en.xml:341(term) 
msgid "Developers"
msgstr ""

#: en.xml:343(para) 
msgid "Presumably, you're already familiar with Subversion, and now want to either extend it or build new software on top of its many APIs. <xref linkend=\"svn.developer\"/> is just for you."
msgstr ""

#: en.xml:351(para) 
msgid "The book ends with reference material—<xref linkend=\"svn.ref\"/> is a reference guide for all Subversion commands, and the appendices cover a number of useful topics. These are the chapters you're mostly likely to come back to after you've finished the book."
msgstr ""

#: en.xml:362(title) 
msgid "Conventions Used in This Book"
msgstr ""

#: en.xml:364(para) 
msgid "This section covers the various conventions used in this book."
msgstr ""

#: en.xml:369(title) 
msgid "Typographic Conventions"
msgstr ""

#: en.xml:374(command) 
msgid "Constant width"
msgstr ""

#: en.xml:376(para) 
msgid "Used for commands, command output, and switches"
msgstr ""

#: en.xml:381(replaceable) 
msgid "Constant width italic"
msgstr ""

#: en.xml:383(para) 
msgid "Used for replaceable items in code and text"
msgstr ""

#: en.xml:388(filename) 
msgid "Italic"
msgstr ""

#: en.xml:390(para) 
msgid "Used for file and directory names"
msgstr ""

#: en.xml:400(title) 
msgid "Icons"
msgstr ""

#: en.xml:403(para) 
msgid "This icon designates a note relating to the surrounding text."
msgstr ""

#: en.xml:408(para) 
msgid "This icon designates a helpful tip relating to the surrounding text."
msgstr ""

#: en.xml:413(para) 
msgid "This icon designates a warning relating to the surrounding text."
msgstr ""

#: en.xml:418(para) 
msgid "Note that the source code examples are just that—examples. While they will compile with the proper compiler incantations, they are intended to illustrate the problem at hand, not necessarily serve as examples of good programming style."
msgstr ""

#: en.xml:430(title) 
msgid "Organization of This Book"
msgstr ""

#: en.xml:432(para) 
msgid "The chapters that follow and their contents are listed here:"
msgstr ""

#: en.xml:440(para) 
msgid "Covers the history of Subversion as well as its features, architecture, components, and install methods. Also includes a quick-start guide."
msgstr ""

#: en.xml:449(para) 
msgid "Explains the basics of version control and different versioning models, along with Subversion's repository, working copies, and revisions."
msgstr ""

#: en.xml:458(para) 
msgid "Walks you through a day in the life of a Subversion user. It demonstrates how to use Subversion to obtain, modify, and commit data."
msgstr ""

#: en.xml:467(para) 
msgid "Discusses branches, merges, and tagging, including best practices for branching and merging, common use cases, how to undo changes, and how to easily swing from one branch to the next."
msgstr ""

#: en.xml:477(para) 
msgid "Describes the basics of the Subversion repository, how to create, configure, and maintain a repository, and the tools you can use to do all of this."
msgstr ""

#: en.xml:486(para) 
msgid "Explains how to configure your Subversion server and the three ways to access your repository: <literal moreinfo=\"none\">HTTP</literal>, the <literal moreinfo=\"none\">svn</literal> protocol, and local access. It also covers the details of authentication, authorization and anonymous access."
msgstr ""

#: en.xml:498(para) 
msgid "Explores the Subversion client configuration files, file and directory properties, how to <literal moreinfo=\"none\">ignore</literal> files in your working copy, how to include external trees in your working copy, and lastly, how to handle vendor branches."
msgstr ""

#: en.xml:509(para) 
msgid "Describes the internals of Subversion, the Subversion filesystem, and the working copy administrative areas from a programmer's point of view. Demonstrates how to use the public APIs to write a program that uses Subversion, and most importantly, how to contribute to the development of Subversion."
msgstr ""

#: en.xml:521(para) 
msgid "Explains in great detail every subcommand of <command moreinfo=\"none\">svn</command>, <command moreinfo=\"none\">svnadmin</command>, and <command moreinfo=\"none\">svnlook</command> with plenty of examples for the whole family!"
msgstr ""

#: en.xml:531(para) 
msgid "Covers the similarities and differences between Subversion and CVS, with numerous suggestions on how to break all the bad habits you picked up from years of using CVS. Included are descriptions of Subversion revision numbers, versioned directories, offline operations, <command moreinfo=\"none\">update</command> vs. <command moreinfo=\"none\">status</command>, branches, tags, metadata, conflict resolution, and authentication."
msgstr ""

#: en.xml:545(para) 
msgid "Describes the details of WebDAV and DeltaV, and how you can configure your Subversion repository to be mounted read/write as a DAV share."
msgstr ""

#: en.xml:554(para) 
msgid "Discusses tools that support or use Subversion, including alternative client programs, repository browser tools, and so on."
msgstr ""

#: en.xml:569(title) 
msgid "This Book is Free"
msgstr ""

#: en.xml:571(para) 
msgid "This book started out as bits of documentation written by Subversion project developers, which were then coalesced into a single work and rewritten. As such, it has always been under a free license. (See <xref linkend=\"svn.copyright\"/>.) In fact, the book was written in the public eye, as a part of Subversion. This means two things:"
msgstr ""

#: en.xml:580(para) 
msgid "You will always find the latest version of this book in the book's own Subversion repository."
msgstr ""

#: en.xml:585(para) 
msgid "You can distribute and make changes to this book however you wish—it's under a free license. Of course, rather than distribute your own private version of this book, we'd much rather you send feedback and patches to the Subversion developer community. See <xref linkend=\"svn.developer.contrib\"/> to learn about joining this community."
msgstr ""

#. O'Reilly Hardcopy Only
#.     <para>You can send publishing comments and questions to O'Reilly
#.       here: <remark>###insert boilerplate.</remark></para>
#: en.xml:599(para) 
msgid "A relatively recent online version of this book can be found at <ulink url=\"http://svnbook.red-bean.com\"/>."
msgstr ""

#: en.xml:608(title) 
msgid "Acknowledgments"
msgstr ""

#: en.xml:616(para) 
msgid "Oh, and thanks, Karl, for being too overworked to write this book yourself."
msgstr ""

#: en.xml:610(para) 
msgid "This book would not be possible (nor very useful) if Subversion did not exist. For that, the authors would like to thank Brian Behlendorf and CollabNet for the vision to fund such a risky and ambitious new Open Source project; Jim Blandy for the original Subversion name and design—we love you, Jim; Karl Fogel for being such a good friend and a great community leader, in that order.<footnote><placeholder-1/></footnote>"
msgstr ""

#: en.xml:620(para) 
msgid "Thanks to O'Reilly and our editors, Linda Mui and Tatiana Diaz for their patience and support."
msgstr ""

#: en.xml:623(para) 
msgid "Finally, we thank the countless people who contributed to this book with informal reviews, suggestions, and fixes: While this is undoubtedly not a complete list, this book would be incomplete and incorrect without the help of: Jani Averbach, Ryan Barrett, Francois Beausoleil, Jennifer Bevan, Matt Blais, Zack Brown, Martin Buchholz, Brane Cibej, John R. Daily, Peter Davis, Olivier Davy, Robert P. J. Day, Mo DeJong, Brian Denny, Joe Drew, Nick Duffek, Ben Elliston, Justin Erenkrantz, Shlomi Fish, Julian Foad, Chris Foote, Martin Furter, Dave Gilbert, Eric Gillespie, Matthew Gregan, Art Haas, Greg Hudson, Alexis Huxley, Jens B. Jorgensen, Tez Kamihira, David Kimdon, Mark Benedetto King, Andreas J. Koenig, Nuutti Kotivuori, Matt Kraai, Scott Lamb, Vincent Lefevre, Morten Ludvigsen, Paul Lussier, Bruce A. Mah, Philip Martin, Feliciano Matias, Patrick Mayweg, Gareth McCaughan, Jon Middleton, Tim Moloney, Mats Nilsson, Joe Orton, Amy Lyn Pilato, Kevin Pilch-Bisson, Dmitriy Popkov, Michael Price, Mark Proctor, Steffen Prohaska, Daniel Rall, Tobias Ringstrom, Garrett Rooney, Joel Rosdahl, Christian Sauer, Larry Shatzer, Russell Steicke, Sander Striker, Erik Sjoelund, Johan Sundstroem, John Szakmeister, Mason Thomas, Eric Wadsworth, Colin Watson, Alex Waugh, Chad Whitacre, Josef Wolf, Blair Zajac, and the entire Subversion community."
msgstr ""

#: en.xml:648(title) 
msgid "From Ben Collins-Sussman"
msgstr ""

#: en.xml:650(para) 
msgid "Thanks to my wife Frances, who, for many months, got to hear, <quote>But honey, I'm still working on the book</quote>, rather than the usual, <quote>But honey, I'm still doing email.</quote> I don't know where she gets all that patience! She's my perfect counterbalance."
msgstr ""

#: en.xml:656(para) 
msgid "Thanks to my extended family for their sincere encouragement, despite having no actual interest in the subject. (You know, the ones who say, <quote>Ooh, you're writing a book?</quote>, and then when you tell them it's a computer book, sort of glaze over.)"
msgstr ""

#: en.xml:662(para) 
msgid "Thanks to all my close friends, who make me a rich, rich man. Don't look at me that way—you know who you are."
msgstr ""

#: en.xml:669(title) 
msgid "From Brian W. Fitzpatrick"
msgstr ""

#: en.xml:671(para) 
msgid "Huge thanks to my wife Marie for being incredibly understanding, supportive, and most of all, patient. Thank you to my brother Eric who first introduced me to UNIX programming way back when. Thanks to my Mom and Grandmother for all their support, not to mention enduring a Christmas holiday where I came home and promptly buried my head in my laptop to work on the book."
msgstr ""

#: en.xml:679(para) 
msgid "To Mike and Ben: It was a pleasure working with you on the book. Heck, it's a pleasure working with you at work!"
msgstr ""

#: en.xml:682(para) 
msgid "To everyone in the Subversion community and the Apache Software Foundation, thanks for having me. Not a day goes by where I don't learn something from at least one of you."
msgstr ""

#: en.xml:687(para) 
msgid "Lastly, thanks to my Grandfather who always told me that <quote>freedom equals responsibility.</quote> I couldn't agree more."
msgstr ""

#: en.xml:695(title) 
msgid "From C. Michael Pilato"
msgstr ""

#: en.xml:697(para) 
msgid "Special thanks to my wife, Amy, for her love and patient support, for putting up with late nights, and for even reviewing entire sections of this book—you always go the extra mile, and do so with incredible grace. Gavin, when you're old enough to read, I hope you're as proud of your Daddy as he is of you. Mom and Dad (and the rest of the family), thanks for your constant support and enthusiasm."
msgstr ""

#: en.xml:705(para) 
msgid "Hats off to Shep Kendall, through whom the world of computers was first opened to me; Ben Collins-Sussman, my tour-guide through the open-source world; Karl Fogel—you <emphasis>are</emphasis> my <filename moreinfo=\"none\">.emacs</filename>; Greg Stein, for oozing practical programming know-how; Brian Fitzpatrick—for sharing this writing experience with me. To the many folks from whom I am constantly picking up new knowledge—keep dropping it!"
msgstr ""

#: en.xml:714(para) 
msgid "Finally, to the One who perfectly demonstrates creative excellence—thank you."
msgstr ""

#: en.xml:731(title) 
msgid "Introduction"
msgstr ""

#: en.xml:734(para) 
msgid "Version control is the art of managing changes to information. It has long been a critical tool for programmers, who typically spend their time making small changes to software and then undoing those changes the next day. But the usefulness of version control software extends far beyond the bounds of the software development world. Anywhere you can find people using computers to manage information that changes often, there is room for version control. And that's where Subversion comes into play."
msgstr ""

#: en.xml:744(para) 
msgid "This chapter contains a high-level introduction to Subversion—what it is; what it does; how to get it."
msgstr ""

#: en.xml:755(title) 
msgid "What is Subversion?"
msgstr ""

#: en.xml:757(para) 
msgid "Subversion is a free/open-source version control system. That is, Subversion manages files and directories over time. A tree of files is placed into a central <firstterm>repository</firstterm>. The repository is much like an ordinary file server, except that it remembers every change ever made to your files and directories. This allows you to recover older versions of your data, or examine the history of how your data changed. In this regard, many people think of a version control system as a sort of <quote>time machine</quote>."
msgstr ""

#: en.xml:768(para) 
msgid "Subversion can access its repository across networks, which allows it to be used by people on different computers. At some level, the ability for various people to modify and manage the same set of data from their respective locations fosters collaboration. Progress can occur more quickly without a single conduit through which all modifications must occur. And because the work is versioned, you need not fear that quality is the trade-off for losing that conduit—if some incorrect change is made to the data, just undo that change."
msgstr ""

#: en.xml:778(para) 
msgid "Some version control systems are also software configuration management (SCM) systems. These systems are specifically tailored to manage trees of source code, and have many features that are specific to software development—such as natively understanding programming languages, or supplying tools for building software. Subversion, however, is not one of these systems. It is a general system that can be used to manage <emphasis>any</emphasis> collection of files. For you, those files might be source code—for others, anything from grocery shopping lists to digital video mixdowns and beyond."
msgstr ""

#: en.xml:797(title) 
msgid "Subversion's History"
msgstr ""

#: en.xml:805(para) 
msgid "There's also a CollabNet Team Edition (CTE) offering aimed at smaller groups."
msgstr ""

#: en.xml:799(para) 
msgid "In early 2000, CollabNet, Inc. (<ulink url=\"http://www.collab.net\"/>) began seeking developers to write a replacement for CVS. CollabNet offers a collaboration software suite called CollabNet Enterprise Edition (CEE) <footnote><placeholder-1/></footnote> of which one component is version control. Although CEE used CVS as its initial version control system, CVS's limitations were obvious from the beginning, and CollabNet knew it would eventually have to find something better. Unfortunately, CVS had become the <foreignphrase>de facto</foreignphrase> standard in the open source world largely because there <emphasis>wasn't</emphasis> anything better, at least not under a free license. So CollabNet determined to write a new version control system from scratch, retaining the basic ideas of CVS, but without the bugs and misfeatures."
msgstr ""

#: en.xml:819(para) 
msgid "In February 2000, they contacted Karl Fogel, the author of <citetitle>Open Source Development with CVS</citetitle> (Coriolis, 1999), and asked if he'd like to work on this new project. Coincidentally, at the time Karl was already discussing a design for a new version control system with his friend Jim Blandy. In 1995, the two had started Cyclic Software, a company providing CVS support contracts, and although they later sold the business, they still used CVS every day at their jobs. Their frustration with CVS had led Jim to think carefully about better ways to manage versioned data, and he'd already come up with not only the name <quote>Subversion</quote>, but also with the basic design of the Subversion repository. When CollabNet called, Karl immediately agreed to work on the project, and Jim got his employer, Red Hat Software, to essentially donate him to the project for an indefinite period of time. CollabNet hired Karl and Ben Collins-Sussman, and detailed design work began in May. With the help of some well-placed prods from Brian Behlendorf and Jason Robbins of CollabNet, and Greg Stein (at the time an independent developer active in the WebDAV/DeltaV specification process), Subversion quickly attracted a community of active developers. It turned out that many people had had the same frustrating experiences with CVS, and welcomed the chance to finally do something about it."
msgstr ""

#: en.xml:844(para) 
msgid "The original design team settled on some simple goals. They didn't want to break new ground in version control methodology, they just wanted to fix CVS. They decided that Subversion would match CVS's features, and preserve the same development model, but not duplicate CVS's most obvious flaws. And although it did not need to be a drop-in replacement for CVS, it should be similar enough that any CVS user could make the switch with little effort."
msgstr ""

#: en.xml:853(para) 
msgid "After fourteen months of coding, Subversion became <quote>self-hosting</quote> on August 31, 2001. That is, Subversion developers stopped using CVS to manage Subversion's own source code, and started using Subversion instead."
msgstr ""

#: en.xml:858(para) 
msgid "While CollabNet started the project, and still funds a large chunk of the work (it pays the salaries of a few full-time Subversion developers), Subversion is run like most open-source projects, governed by a loose, transparent set of rules that encourage meritocracy. CollabNet's copyright license is fully compliant with the Debian Free Software Guidelines. In other words, anyone is free to download, modify, and redistribute Subversion as he pleases; no permission from CollabNet or anyone else is required."
msgstr ""

#: en.xml:875(title) 
msgid "Subversion's Features"
msgstr ""

#: en.xml:877(para) 
msgid "When discussing the features that Subversion brings to the version control table, it is often helpful to speak of them in terms of how they improve upon CVS's design. If you're not familiar with CVS, you may not understand all of these features. And if you're not familiar with version control at all, your eyes may glaze over unless you first read <xref linkend=\"svn.basic\"/>, in which we provide a gentle introduction to version control in general."
msgstr ""

#: en.xml:885(para) 
msgid "Subversion provides:"
msgstr ""

#: en.xml:889(term) 
msgid "Directory versioning"
msgstr ""

#: en.xml:891(para) 
msgid "CVS only tracks the history of individual files, but Subversion implements a <quote>virtual</quote> versioned filesystem that tracks changes to whole directory trees over time. Files <emphasis>and</emphasis> directories are versioned."
msgstr ""

#: en.xml:900(term) 
msgid "True version history"
msgstr ""

#: en.xml:902(para) 
msgid "Since CVS is limited to file versioning, operations such as copies and renames—which might happen to files, but which are really changes to the contents of some containing directory—aren't supported in CVS. Additionally, in CVS you cannot replace a versioned file with some new thing of the same name without the new item inheriting the history of the old—perhaps completely unrelated—file. With Subversion, you can add, delete, copy, and rename both files and directories. And every newly added file begins with a fresh, clean history all its own."
msgstr ""

#: en.xml:917(term) 
msgid "Atomic commits"
msgstr ""

#: en.xml:919(para) 
msgid "A collection of modifications either goes into the repository completely, or not at all. This allows developers to construct and commit changes as logical chunks, and prevents problems that can occur when only a portion of a set of changes is successfully sent to the repository."
msgstr ""

#: en.xml:929(term) 
msgid "Versioned metadata"
msgstr ""

#: en.xml:931(para) 
msgid "Each file and directory has a set of properties—keys and their values—associated with it. You can create and store any arbitrary key/value pairs you wish. Properties are versioned over time, just like file contents."
msgstr ""

#: en.xml:940(term) 
msgid "Choice of network layers"
msgstr ""

#: en.xml:942(para) 
msgid "Subversion has an abstracted notion of repository access, making it easy for people to implement new network mechanisms. Subversion can plug into the Apache HTTP Server as an extension module. This gives Subversion a big advantage in stability and interoperability, and instant access to existing features provided by that server—authentication, authorization, wire compression, and so on. A more lightweight, standalone Subversion server process is also available. This server speaks a custom protocol which can be easily tunneled over SSH."
msgstr ""

#: en.xml:957(term) 
msgid "Consistent data handling"
msgstr ""

#: en.xml:959(para) 
msgid "Subversion expresses file differences using a binary differencing algorithm, which works identically on both text (human-readable) and binary (human-unreadable) files. Both types of files are stored equally compressed in the repository, and differences are transmitted in both directions across the network."
msgstr ""

#: en.xml:969(term) 
msgid "Efficient branching and tagging"
msgstr ""

#: en.xml:971(para) 
msgid "The cost of branching and tagging need not be proportional to the project size. Subversion creates branches and tags by simply copying the project, using a mechanism similar to a hard-link. Thus these operations take only a very small, constant amount of time."
msgstr ""

#: en.xml:981(term) 
msgid "Hackability"
msgstr ""

#: en.xml:983(para) 
msgid "Subversion has no historical baggage; it is implemented as a collection of shared C libraries with well-defined APIs. This makes Subversion extremely maintainable and usable by other applications and languages."
msgstr ""

#: en.xml:1000(title) en.xml:1007(title) 
msgid "Subversion's Architecture"
msgstr ""

#: en.xml:1002(para) 
msgid "<xref linkend=\"svn.intro.architecture.dia-1\"/> illustrates what one might call a <quote>mile-high</quote> view of Subversion's design."
msgstr ""

#: en.xml:1011(para) 
msgid "On one end is a Subversion repository that holds all of your versioned data. On the other end is your Subversion client program, which manages local reflections of portions of that versioned data (called <quote>working copies</quote>). Between these extremes are multiple routes through various Repository Access (RA) layers. Some of these routes go across computer networks and through network servers which then access the repository. Others bypass the network altogether and access the repository directly."
msgstr ""

#: en.xml:1028(title) 
msgid "Installing Subversion"
msgstr ""

#: en.xml:1030(para) 
msgid "Subversion is built on a portability layer called APR—the Apache Portable Runtime library. The APR library provides all the interfaces that Subversion needs to function on different operating systems: disk access, network access, memory management, and so on. While Subversion is able to use Apache as one of its network server programs, its dependence on APR <emphasis>does not</emphasis> mean that Apache is a required component. APR is a standalone library useable by any application. It does mean, however, that like Apache, Subversion clients and servers run on any operating system that the Apache httpd server runs on: Windows, Linux, all flavors of BSD, Mac OS X, Netware, and others."
msgstr ""

#: en.xml:1043(para) 
msgid "The easiest way to get Subversion is to download a binary package built for your operating system. Subversion's website (<ulink url=\"http://subversion.tigris.org\"/>) often has these packages available for download, posted by volunteers. The site usually contains graphical installer packages for users of Microsoft operating systems. If you run a Unix-like operating system, you can use your system's native package distribution system (RPMs, DEBs, the ports tree, etc.) to get Subversion."
msgstr ""

#: en.xml:1053(para) 
msgid "Alternately, you can build Subversion directly from source code. From the Subversion website, download the latest source-code release. After unpacking it, follow the instructions in the <filename moreinfo=\"none\">INSTALL</filename> file to build it. Note that a released source package contains everything you need to build a command-line client capable of talking to a remote repository (in particular, the apr, apr-util, and neon libraries). But optional portions of Subversion have many other dependencies, such as Berkeley DB and possibly Apache httpd. If you want to do a complete build, make sure you have all of the packages documented in the <filename moreinfo=\"none\">INSTALL</filename> file. If you plan to work on Subversion itself, you can use your client program to grab the latest, bleeding-edge source code. This is documented in <xref linkend=\"svn.developer.contrib.get-code\"/>."
msgstr ""

#: en.xml:1075(title) 
msgid "Subversion's Components"
msgstr ""

#: en.xml:1077(para) 
msgid "Subversion, once installed, has a number of different pieces. The following is a quick overview of what you get. Don't be alarmed if the brief descriptions leave you scratching your head—there are <emphasis>plenty</emphasis> more pages in this book devoted to alleviating that confusion."
msgstr ""

#: en.xml:1085(term) 
msgid "svn"
msgstr ""

#: en.xml:1087(para) 
msgid "The command-line client program."
msgstr ""

#: en.xml:1092(term) en.xml:23254(command) en.xml:23258(refname) 
msgid "svnversion"
msgstr ""

#: en.xml:1094(para) 
msgid "A program for reporting the state (in terms of revisions of the items present) of a working copy."
msgstr ""

#: en.xml:1100(term) en.xml:7514(title) en.xml:22249(command) en.xml:22335(command) 
msgid "svnlook"
msgstr ""

#: en.xml:1102(para) 
msgid "A tool for inspecting a Subversion repository."
msgstr ""

#: en.xml:1107(term) en.xml:7797(title) en.xml:21413(command) 
msgid "svnadmin"
msgstr ""

#: en.xml:1109(para) 
msgid "A tool for creating, tweaking or repairing a Subversion repository."
msgstr ""

#: en.xml:1115(term) en.xml:7962(title) 
msgid "svndumpfilter"
msgstr ""

#: en.xml:1117(para) 
msgid "A program for filtering Subversion repository dump streams."
msgstr ""

#: en.xml:1123(term) en.xml:15571(entry) en.xml:23384(command) en.xml:23389(literal) 
msgid "mod_dav_svn"
msgstr ""

#: en.xml:1125(para) 
msgid "A plug-in module for the Apache HTTP Server, used to make your repository available to others over a network."
msgstr ""

#: en.xml:1132(term) en.xml:1730(literal) en.xml:9446(entry) en.xml:23094(command) 
msgid "svnserve"
msgstr ""

#: en.xml:1134(para) 
msgid "A custom standalone server program, runnable as a daemon process or invokable by SSH; another way to make your repository available to others over a network."
msgstr ""

#: en.xml:1141(para) 
msgid "Assuming you have Subversion installed correctly, you should be ready to start. The next two chapters will walk you through the use of <command moreinfo=\"none\">svn</command>, Subversion's command-line client program."
msgstr ""

#: en.xml:1154(title) 
msgid "A Quick Start"
msgstr ""

#: en.xml:1156(para) 
msgid "Some people have trouble absorbing a new technology by reading the sort of <quote>top down</quote> approach provided by this book. This section is a very short introduction to Subversion, and is designed to give <quote>bottom up</quote> learners a fighting chance. If you prefer to learn by experimentation, the following demonstration will get you up and running. Along the way, we give links to the relevant chapters of this book."
msgstr ""

#: en.xml:1165(para) 
msgid "If you're new to the entire concept of version control or to the <quote>copy-modify-merge</quote> model used by both CVS and Subversion, then you should read <xref linkend=\"svn.basic\"/> before going any further."
msgstr ""

#: en.xml:1171(para) 
msgid "The following example assumes that you have <command moreinfo=\"none\">svn</command>, the Subversion command-line client, and <command moreinfo=\"none\">svnadmin</command>, the administrative tool, ready to go. It also assumes you are using Subversion 1.2 or later (run <command moreinfo=\"none\">svn --version</command> to check.)"
msgstr ""

#: en.xml:1178(para) 
msgid "Subversion stores all versioned data in a central repository. To begin, create a new repository:"
msgstr ""

#: en.xml:1181(screen) 
#, no-wrap
msgid "\n$ svnadmin create /path/to/repos\n$ ls /path/to/repos\nconf/  dav/  db/  format  hooks/  locks/  README.txt\n"
msgstr ""

#: en.xml:1187(para) 
msgid "This command creates a new directory <filename moreinfo=\"none\">/path/to/repos</filename> which contains a Subversion repository. This new directory contains (among other things) a collection of database files. You won't see your versioned files if you peek inside. For more information about repository creation and maintenance, see <xref linkend=\"svn.reposadmin\"/>."
msgstr ""

#: en.xml:1195(para) 
msgid "Subversion has no concept of a <quote>project</quote>. The repository is just a virtual versioned filesystem, a large tree that can hold anything you wish. Some administrators prefer to store only one project in a repository, and others prefer to store multiple projects in a repository by placing them into separate directories. The merits of each approach are discussed in <xref linkend=\"svn.reposadmin.projects.chooselayout\"/>. Either way, the repository only manages files and directories, so it's up to humans to interpret particular directories as <quote>projects</quote>. So while you might see references to projects throughout this book, keep in mind that we're only ever talking about some directory (or collection of directories) in the repository."
msgstr ""

#: en.xml:1209(para) 
msgid "In this example, we assume that you already have some sort of project (a collection of files and directories) that you wish to import into your newly created Subversion repository. Begin by organizing them into a single directory called <filename moreinfo=\"none\">myproject</filename> (or whatever you wish). For reasons that will be clear later (see <xref linkend=\"svn.branchmerge\"/>), your project's tree structure should contain three top-level directories named <filename moreinfo=\"none\">branches</filename>, <filename moreinfo=\"none\">tags</filename>, and <filename moreinfo=\"none\">trunk</filename>. The <filename moreinfo=\"none\">trunk</filename> directory should contain all of your data, while <filename moreinfo=\"none\">branches</filename> and <filename moreinfo=\"none\">tags</filename> directories are empty:"
msgstr ""

#: en.xml:1224(screen) 
#, no-wrap
msgid "\n/tmp/myproject/branches/\n/tmp/myproject/tags/\n/tmp/myproject/trunk/\n                     foo.c\n                     bar.c\n                     Makefile\n                     …\n"
msgstr ""

#: en.xml:1234(para) 
msgid "The <filename moreinfo=\"none\">branches</filename>, <filename moreinfo=\"none\">tags</filename>, and <filename moreinfo=\"none\">trunk</filename> subdirectories aren't actually required by Subversion. They're merely a popular convention that you'll most likely want to use later on."
msgstr ""

#: en.xml:1239(para) 
msgid "Once you have your tree of data ready to go, import it into the repository with the <command moreinfo=\"none\">svn import</command> command (see <xref linkend=\"svn.tour.other.import\"/>):"
msgstr ""

#: en.xml:1243(screen) 
#, no-wrap
msgid "\n$ svn import /tmp/myproject file:///path/to/repos/myproject -m \"initial import\"\nAdding         /tmp/myproject/branches\nAdding         /tmp/myproject/tags\nAdding         /tmp/myproject/trunk\nAdding         /tmp/myproject/trunk/foo.c\nAdding         /tmp/myproject/trunk/bar.c\nAdding         /tmp/myproject/trunk/Makefile\n…\nCommitted revision 1.\n$ \n"
msgstr ""

#: en.xml:1256(para) 
msgid "Now the repository contains this tree of data. As mentioned earlier, you won't see your files by directly peeking into the repository; they're all stored within a database. But the repository's imaginary filesystem now contains a top-level directory named <filename moreinfo=\"none\">myproject</filename>, which in turn contains your data."
msgstr ""

#: en.xml:1263(para) 
msgid "Note that the original <filename moreinfo=\"none\">/tmp/myproject</filename> directory is unchanged; Subversion is unaware of it. (In fact, you can even delete that directory if you wish.) In order to start manipulating repository data, you need to create a new <quote>working copy</quote> of the data, a sort of private workspace. Ask Subversion to <quote>check out</quote> a working copy of the <filename moreinfo=\"none\">myproject/trunk</filename> directory in the repository:"
msgstr ""

#: en.xml:1272(screen) 
#, no-wrap
msgid "\n$ svn checkout file:///path/to/repos/myproject/trunk myproject\nA  myproject/foo.c\nA  myproject/bar.c\nA  myproject/Makefile\n…\nChecked out revision 1.\n"
msgstr ""

#: en.xml:1281(para) 
msgid "Now you have a personal copy of part of the repository in a new directory named <filename moreinfo=\"none\">myproject</filename>. You can edit the files in your working copy and then commit those changes back into the repository."
msgstr ""

#: en.xml:1288(para) 
msgid "Enter your working copy and edit a file's contents."
msgstr ""

#: en.xml:1292(para) 
msgid "Run <command moreinfo=\"none\">svn diff</command> to see unified diff output of your changes."
msgstr ""

#: en.xml:1296(para) 
msgid "Run <command moreinfo=\"none\">svn commit</command> to commit the new version of your file to the repository."
msgstr ""

#: en.xml:1300(para) 
msgid "Run <command moreinfo=\"none\">svn update</command> to bring your working copy <quote>up-to-date</quote> with the repository."
msgstr ""

#: en.xml:1305(para) 
msgid "For a full tour of all the things you can do with your working copy, read <xref linkend=\"svn.tour\"/>."
msgstr ""

#: en.xml:1308(para) 
msgid "At this point, you have the option of making your repository available to others over a network. See <xref linkend=\"svn.serverconfig\"/> to learn about the different sorts of server processes available and how to configure them."
msgstr ""

#: en.xml:1324(title) 
msgid "Basic Concepts"
msgstr ""

#: en.xml:1327(para) 
msgid "This chapter is a short, casual introduction to Subversion. If you're new to version control, this chapter is definitely for you. We begin with a discussion of general version control concepts, work our way into the specific ideas behind Subversion, and show some simple examples of Subversion in use."
msgstr ""

#: en.xml:1334(para) 
msgid "Even though the examples in this chapter show people sharing collections of program source code, keep in mind that Subversion can manage any sort of file collection—it's not limited to helping computer programmers."
msgstr ""

#: en.xml:1345(title) 
msgid "The Repository"
msgstr ""

#: en.xml:1347(para) 
msgid "Subversion is a centralized system for sharing information. At its core is a repository, which is a central store of data. The repository stores information in the form of a <firstterm>filesystem tree</firstterm>—a typical hierarchy of files and directories. Any number of <firstterm>clients</firstterm> connect to the repository, and then read or write to these files. By writing data, a client makes the information available to others; by reading data, the client receives information from others. <xref linkend=\"svn.basic.repository.dia-1\"/> illustrates this."
msgstr ""

#: en.xml:1358(title) 
msgid "A typical client/server system"
msgstr ""

#: en.xml:1362(para) 
msgid "So why is this interesting? So far, this sounds like the definition of a typical file server. And indeed, the repository <emphasis>is</emphasis> a kind of file server, but it's not your usual breed. What makes the Subversion repository special is that <emphasis>it remembers every change</emphasis> ever written to it: every change to every file, and even changes to the directory tree itself, such as the addition, deletion, and rearrangement of files and directories."
msgstr ""

#: en.xml:1371(para) 
msgid "When a client reads data from the repository, it normally sees only the latest version of the filesystem tree. But the client also has the ability to view <emphasis>previous</emphasis> states of the filesystem. For example, a client can ask historical questions like, <quote>What did this directory contain last Wednesday?</quote> or <quote>Who was the last person to change this file, and what changes did he make?</quote> These are the sorts of questions that are at the heart of any <firstterm>version control system</firstterm>: systems that are designed to record and track changes to data over time."
msgstr ""

#: en.xml:1389(title) 
msgid "Versioning Models"
msgstr ""

#: en.xml:1391(para) 
msgid "The core mission of a version control system is to enable collaborative editing and sharing of data. But different systems use different strategies to achieve this."
msgstr ""

#: en.xml:1397(title) 
msgid "The Problem of File-Sharing"
msgstr ""

#: en.xml:1399(para) 
msgid "All version control systems have to solve the same fundamental problem: how will the system allow users to share information, but prevent them from accidentally stepping on each other's feet? It's all too easy for users to accidentally overwrite each other's changes in the repository."
msgstr ""

#: en.xml:1406(para) 
msgid "Consider the scenario shown in <xref linkend=\"svn.basic.vsn-models.problem-sharing.dia-1\"/>. Suppose we have two co-workers, Harry and Sally. They each decide to edit the same repository file at the same time. If Harry saves his changes to the repository first, then it's possible that (a few moments later) Sally could accidentally overwrite them with her own new version of the file. While Harry's version of the file won't be lost forever (because the system remembers every change), any changes Harry made <emphasis>won't</emphasis> be present in Sally's newer version of the file, because she never saw Harry's changes to begin with. Harry's work is still effectively lost—or at least missing from the latest version of the file—and probably by accident. This is definitely a situation we want to avoid!"
msgstr ""

#: en.xml:1422(title) 
msgid "The problem to avoid"
msgstr ""

#: en.xml:1430(title) 
msgid "The Lock-Modify-Unlock Solution"
msgstr ""

#: en.xml:1432(para) 
msgid "Many version control systems use a <firstterm>lock-modify-unlock</firstterm> model to address the problem of many authors clobbering each other's work. In this model, the repository allows only one person to change a file at a time. This exclusivity policy is managed using locks. Harry must <quote>lock</quote> a file before he can begin making changes to it. If Harry has locked a file, then Sally cannot also lock it, and therefore cannot make any changes to that file. All she can do is read the file, and wait for Harry to finish his changes and release his lock. After Harry unlocks the file, Sally can take her turn by locking and editing the file. <xref linkend=\"svn.basic.vsn-models.lock-unlock.dia-1\"/> demonstrates this simple solution."
msgstr ""

#: en.xml:1447(title) 
msgid "The lock-modify-unlock solution"
msgstr ""

#: en.xml:1451(para) 
msgid "The problem with the lock-modify-unlock model is that it's a bit restrictive, and often becomes a roadblock for users:"
msgstr ""

#: en.xml:1457(para) 
msgid "<emphasis>Locking may cause administrative problems.</emphasis> Sometimes Harry will lock a file and then forget about it. Meanwhile, because Sally is still waiting to edit the file, her hands are tied. And then Harry goes on vacation. Now Sally has to get an administrator to release Harry's lock. The situation ends up causing a lot of unnecessary delay and wasted time."
msgstr ""

#: en.xml:1469(para) 
msgid "<emphasis>Locking may cause unnecessary serialization.</emphasis> What if Harry is editing the beginning of a text file, and Sally simply wants to edit the end of the same file? These changes don't overlap at all. They could easily edit the file simultaneously, and no great harm would come, assuming the changes were properly merged together. There's no need for them to take turns in this situation."
msgstr ""

#: en.xml:1482(para) 
msgid "<emphasis>Locking may create a false sense of security.</emphasis> Pretend that Harry locks and edits file A, while Sally simultaneously locks and edits file B. But suppose that A and B depend on one another, and the changes made to each are semantically incompatible. Suddenly A and B don't work together anymore. The locking system was powerless to prevent the problem—yet it somehow provided a false sense of security. It's easy for Harry and Sally to imagine that by locking files, each is beginning a safe, insulated task, and thus not bother discussing their incompatible changes early on."
msgstr ""

#: en.xml:1503(title) 
msgid "The Copy-Modify-Merge Solution"
msgstr ""

#: en.xml:1505(para) 
msgid "Subversion, CVS, and other version control systems use a <firstterm>copy-modify-merge</firstterm> model as an alternative to locking. In this model, each user's client contacts the project repository and creates a personal <firstterm>working copy</firstterm>—a local reflection of the repository's files and directories. Users then work in parallel, modifying their private copies. Finally, the private copies are merged together into a new, final version. The version control system often assists with the merging, but ultimately a human being is responsible for making it happen correctly."
msgstr ""

#: en.xml:1517(para) 
msgid "Here's an example. Say that Harry and Sally each create working copies of the same project, copied from the repository. They work concurrently, and make changes to the same file A within their copies. Sally saves her changes to the repository first. When Harry attempts to save his changes later, the repository informs him that his file A is <firstterm>out-of-date</firstterm>. In other words, that file A in the repository has somehow changed since he last copied it. So Harry asks his client to <firstterm>merge</firstterm> any new changes from the repository into his working copy of file A. Chances are that Sally's changes don't overlap with his own; so once he has both sets of changes integrated, he saves his working copy back to the repository. <xref linkend=\"svn.basic.vsn-models.copy-merge.dia-1\"/> and <xref linkend=\"svn.basic.vsn-models.copy-merge.dia-2\"/> show this process."
msgstr ""

#: en.xml:1533(title) 
msgid "The copy-modify-merge solution"
msgstr ""

#: en.xml:1538(title) 
msgid "The copy-modify-merge solution (continued)"
msgstr ""

#: en.xml:1542(para) 
msgid "But what if Sally's changes <emphasis>do</emphasis> overlap with Harry's changes? What then? This situation is called a <firstterm>conflict</firstterm>, and it's usually not much of a problem. When Harry asks his client to merge the latest repository changes into his working copy, his copy of file A is somehow flagged as being in a state of conflict: he'll be able to see both sets of conflicting changes, and manually choose between them. Note that software can't automatically resolve conflicts; only humans are capable of understanding and making the necessary intelligent choices. Once Harry has manually resolved the overlapping changes—perhaps after a discussion with Sally—he can safely save the merged file back to the repository."
msgstr ""

#: en.xml:1556(para) 
msgid "The copy-modify-merge model may sound a bit chaotic, but in practice, it runs extremely smoothly. Users can work in parallel, never waiting for one another. When they work on the same files, it turns out that most of their concurrent changes don't overlap at all; conflicts are infrequent. And the amount of time it takes to resolve conflicts is far less than the time lost by a locking system."
msgstr ""

#: en.xml:1564(para) 
msgid "In the end, it all comes down to one critical factor: user communication. When users communicate poorly, both syntactic and semantic conflicts increase. No system can force users to communicate perfectly, and no system can detect semantic conflicts. So there's no point in being lulled into a false promise that a locking system will somehow prevent conflicts; in practice, locking seems to inhibit productivity more than anything else."
msgstr ""

#: en.xml:1574(title) 
msgid "When Locking is Necessary"
msgstr ""

#: en.xml:1576(para) 
msgid "While the lock-modify-unlock model is considered generally harmful to collaboration, there are still times when locking is appropriate."
msgstr ""

#: en.xml:1580(para) 
msgid "The copy-modify-merge model is based on the assumption that files are contextually mergeable: that is, that the majority of the files in the repository are line-based text files (such as program source code). But for files with binary formats, such as artwork or sound, it's often impossible to merge conflicting changes. In these situations, it really is necessary to users to take strict turns when changing the file. Without serialized access, somebody ends up wasting time on changes that are ultimately discarded."
msgstr ""

#: en.xml:1591(para) 
msgid "While CVS and Subversion are still primarily copy-modify-merge systems, they both recognize the need to lock an occasional file and provide mechanisms for this. See <xref linkend=\"svn.advanced.locking\"/>."
msgstr ""

#: en.xml:1608(title) 
msgid "Subversion in Action"
msgstr ""

#: en.xml:1610(para) 
msgid "It's time to move from the abstract to the concrete. In this section, we'll show real examples of Subversion being used."
msgstr ""

#: en.xml:1616(title) 
msgid "Working Copies"
msgstr ""

#: en.xml:1618(para) 
msgid "You've already read about working copies; now we'll demonstrate how the Subversion client creates and uses them."
msgstr ""

#: en.xml:1622(para) 
msgid "A Subversion working copy is an ordinary directory tree on your local system, containing a collection of files. You can edit these files however you wish, and if they're source code files, you can compile your program from them in the usual way. Your working copy is your own private work area: Subversion will never incorporate other people's changes, nor make your own changes available to others, until you explicitly tell it to do so. You can even have multiple working copies of the same project."
msgstr ""

#: en.xml:1632(para) 
msgid "After you've made some changes to the files in your working copy and verified that they work properly, Subversion provides you with commands to <quote>publish</quote> your changes to the other people working with you on your project (by writing to the repository). If other people publish their own changes, Subversion provides you with commands to merge those changes into your working directory (by reading from the repository)."
msgstr ""

#: en.xml:1641(para) 
msgid "A working copy also contains some extra files, created and maintained by Subversion, to help it carry out these commands. In particular, each directory in your working copy contains a subdirectory named <filename moreinfo=\"none\">.svn</filename>, also known as the working copy <firstterm>administrative directory</firstterm>. The files in each administrative directory help Subversion recognize which files contain unpublished changes, and which files are out-of-date with respect to others' work."
msgstr ""

#: en.xml:1651(para) 
msgid "A typical Subversion repository often holds the files (or source code) for several projects; usually, each project is a subdirectory in the repository's filesystem tree. In this arrangement, a user's working copy will usually correspond to a particular subtree of the repository."
msgstr ""

#: en.xml:1657(para) 
msgid "For example, suppose you have a repository that contains two software projects, <literal moreinfo=\"none\">paint</literal> and <literal moreinfo=\"none\">calc</literal>. Each project lives in its own top-level subdirectory, as shown in <xref linkend=\"svn.basic.in-action.wc.dia-1\"/>."
msgstr ""

#: en.xml:1663(title) 
msgid "The repository's filesystem"
msgstr ""

#: en.xml:1667(para) 
msgid "To get a working copy, you must <firstterm>check out</firstterm> some subtree of the repository. (The term <quote>check out</quote> may sound like it has something to do with locking or reserving resources, but it doesn't; it simply creates a private copy of the project for you.) For example, if you check out <filename moreinfo=\"none\">/calc</filename>, you will get a working copy like this:"
msgstr ""

#: en.xml:1675(screen) 
#, no-wrap
msgid "\n$ svn checkout http://svn.example.com/repos/calc\nA    calc/Makefile\nA    calc/integer.c\nA    calc/button.c\nChecked out revision 56.\n\n$ ls -A calc\nMakefile  integer.c  button.c  .svn/\n"
msgstr ""

#: en.xml:1686(para) 
msgid "The list of letter A's indicates that Subversion is adding a number of items to your working copy. You now have a personal copy of the repository's <filename moreinfo=\"none\">/calc</filename> directory, with one additional entry—<filename moreinfo=\"none\">.svn</filename>—which holds the extra information needed by Subversion, as mentioned earlier."
msgstr ""

#: en.xml:1695(title) 
msgid "Repository URLs"
msgstr ""

#: en.xml:1697(para) 
msgid "Subversion repositories can be accessed through many different methods—on local disk, or through various network protocols. A repository location, however, is always a URL. <xref linkend=\"svn.basic.in-action.wc.tbl-1\"/> describes how different URL schemas map to the available access methods."
msgstr ""

#: en.xml:1704(title) 
msgid "Repository Access URLs"
msgstr ""

#: en.xml:1708(entry) 
msgid "Schema"
msgstr ""

#: en.xml:1709(entry) 
msgid "Access Method"
msgstr ""

#: en.xml:1714(literal) 
msgid "file:///"
msgstr ""

#: en.xml:1715(entry) 
msgid "direct repository access (on local disk)"
msgstr ""

#: en.xml:1718(literal) en.xml:1724(literal) 
msgid "http://"
msgstr ""

#: en.xml:1719(entry) 
msgid "access via WebDAV protocol to Subversion-aware Apache server"
msgstr ""

#: en.xml:1723(literal) 
msgid "https://"
msgstr ""

#: en.xml:1724(entry) 
msgid "same as <placeholder-1/>, but with SSL encryption."
msgstr ""

#: en.xml:1728(literal) en.xml:1734(literal) 
msgid "svn://"
msgstr ""

#: en.xml:1729(entry) 
msgid "access via custom protocol to an <placeholder-1/> server"
msgstr ""

#: en.xml:1733(literal) 
msgid "svn+ssh://"
msgstr ""

#: en.xml:1734(entry) 
msgid "same as <placeholder-1/>, but through an SSH tunnel."
msgstr ""

#: en.xml:1741(para) 
msgid "For more information on how Subversion parses URLs, see <xref linkend=\"svn.advanced.reposurls\"/>."
msgstr ""

#: en.xml:1746(para) 
msgid "Suppose you make changes to <filename moreinfo=\"none\">button.c</filename>. Since the <filename moreinfo=\"none\">.svn</filename> directory remembers the file's modification date and original contents, Subversion can tell that you've changed the file. However, Subversion does not make your changes public until you explicitly tell it to. The act of publishing your changes is more commonly known as <firstterm>committing</firstterm> (or <firstterm>checking in</firstterm>) changes to the repository."
msgstr ""

#: en.xml:1755(para) 
msgid "To publish your changes to others, you can use Subversion's <command moreinfo=\"none\">commit</command> command:"
msgstr ""

#: en.xml:1758(screen) 
#, no-wrap
msgid "\n$ svn commit button.c\nSending        button.c\nTransmitting file data .\nCommitted revision 57.\n"
msgstr ""

#: en.xml:1765(para) 
msgid "Now your changes to <filename moreinfo=\"none\">button.c</filename> have been committed to the repository; if another user checks out a working copy of <filename moreinfo=\"none\">/calc</filename>, they will see your changes in the latest version of the file."
msgstr ""

#: en.xml:1770(para) 
msgid "Suppose you have a collaborator, Sally, who checked out a working copy of <filename moreinfo=\"none\">/calc</filename> at the same time you did. When you commit your change to <filename moreinfo=\"none\">button.c</filename>, Sally's working copy is left unchanged; Subversion only modifies working copies at the user's request."
msgstr ""

#: en.xml:1777(para) 
msgid "To bring her project up to date, Sally can ask Subversion to <firstterm>update</firstterm> her working copy, by using the Subversion <command moreinfo=\"none\">update</command> command. This will incorporate your changes into her working copy, as well as any others that have been committed since she checked it out."
msgstr ""

#: en.xml:1784(screen) 
#, no-wrap
msgid "\n$ pwd\n/home/sally/calc\n\n$ ls -A \n.svn/ Makefile integer.c button.c\n\n$ svn update\nU    button.c\nUpdated to revision 57.\n"
msgstr ""

#: en.xml:1796(para) 
msgid "The output from the <command moreinfo=\"none\">svn update</command> command indicates that Subversion updated the contents of <filename moreinfo=\"none\">button.c</filename>. Note that Sally didn't need to specify which files to update; Subversion uses the information in the <filename moreinfo=\"none\">.svn</filename> directory, and further information in the repository, to decide which files need to be brought up to date."
msgstr ""

#: en.xml:1809(title) 
msgid "Revisions"
msgstr ""

#: en.xml:1811(para) 
msgid "An <command moreinfo=\"none\">svn commit</command> operation can publish changes to any number of files and directories as a single atomic transaction. In your working copy, you can change files' contents, create, delete, rename and copy files and directories, and then commit the complete set of changes as a unit."
msgstr ""

#: en.xml:1818(para) 
msgid "In the repository, each commit is treated as an atomic transaction: either all the commit's changes take place, or none of them take place. Subversion tries to retain this atomicity in the face of program crashes, system crashes, network problems, and other users' actions."
msgstr ""

#: en.xml:1824(para) 
msgid "Each time the repository accepts a commit, this creates a new state of the filesystem tree, called a <firstterm>revision</firstterm>. Each revision is assigned a unique natural number, one greater than the number of the previous revision. The initial revision of a freshly created repository is numbered zero, and consists of nothing but an empty root directory."
msgstr ""

#: en.xml:1832(para) 
msgid "<xref linkend=\"svn.basic.in-action.revs.dia-1\"/> illustrates a nice way to visualize the repository. Imagine an array of revision numbers, starting at 0, stretching from left to right. Each revision number has a filesystem tree hanging below it, and each tree is a <quote>snapshot</quote> of the way the repository looked after a commit."
msgstr ""

#: en.xml:1840(title) 
msgid "The repository"
msgstr ""

#: en.xml:1845(title) 
msgid "Global Revision Numbers"
msgstr ""

#: en.xml:1847(para) 
msgid "Unlike those of many other version control systems, Subversion's revision numbers apply to <emphasis>entire trees</emphasis>, not individual files. Each revision number selects an entire tree, a particular state of the repository after some committed change. Another way to think about it is that revision N represents the state of the repository filesystem after the Nth commit. When Subversion users talk about <quote>revision 5 of <filename moreinfo=\"none\">foo.c</filename></quote>, they really mean <quote><filename moreinfo=\"none\">foo.c</filename> as it appears in revision 5.</quote> Notice that in general, revisions N and M of a file do <emphasis>not</emphasis> necessarily differ! Because CVS uses per-file revision numbers, CVS users might want to see <xref linkend=\"svn.forcvs\"/> for more details."
msgstr ""

#: en.xml:1863(para) 
msgid "It's important to note that working copies do not always correspond to any single revision in the repository; they may contain files from several different revisions. For example, suppose you check out a working copy from a repository whose most recent revision is 4:"
msgstr ""

#: en.xml:1869(screen) 
#, no-wrap
msgid "\ncalc/Makefile:4\n     integer.c:4\n     button.c:4\n"
msgstr ""

#: en.xml:1875(para) 
msgid "At the moment, this working directory corresponds exactly to revision 4 in the repository. However, suppose you make a change to <filename moreinfo=\"none\">button.c</filename>, and commit that change. Assuming no other commits have taken place, your commit will create revision 5 of the repository, and your working copy will now look like this:"
msgstr ""

#: en.xml:1882(screen) 
#, no-wrap
msgid "\ncalc/Makefile:4\n     integer.c:4\n     button.c:5\n"
msgstr ""

#: en.xml:1888(para) 
msgid "Suppose that, at this point, Sally commits a change to <filename moreinfo=\"none\">integer.c</filename>, creating revision 6. If you use <command moreinfo=\"none\">svn update</command> to bring your working copy up to date, then it will look like this:"
msgstr ""

#: en.xml:1893(screen) 
#, no-wrap
msgid "\ncalc/Makefile:6\n     integer.c:6\n     button.c:6\n"
msgstr ""

#: en.xml:1899(para) 
msgid "Sally's change to <filename moreinfo=\"none\">integer.c</filename> will appear in your working copy, and your change will still be present in <filename moreinfo=\"none\">button.c</filename>. In this example, the text of <filename moreinfo=\"none\">Makefile</filename> is identical in revisions 4, 5, and 6, but Subversion will mark your working copy of <filename moreinfo=\"none\">Makefile</filename> with revision 6 to indicate that it is still current. So, after you do a clean update at the top of your working copy, it will generally correspond to exactly one revision in the repository."
msgstr ""

#: en.xml:1914(title) 
msgid "How Working Copies Track the Repository"
msgstr ""

#: en.xml:1916(para) 
msgid "For each file in a working directory, Subversion records two essential pieces of information in the <filename moreinfo=\"none\">.svn/</filename> administrative area:"
msgstr ""

#: en.xml:1923(para) 
msgid "what revision your working file is based on (this is called the file's <firstterm>working revision</firstterm>), and"
msgstr ""

#: en.xml:1929(para) 
msgid "a timestamp recording when the local copy was last updated by the repository."
msgstr ""

#: en.xml:1934(para) 
msgid "Given this information, by talking to the repository, Subversion can tell which of the following four states a working file is in:"
msgstr ""

#: en.xml:1940(term) 
msgid "Unchanged, and current"
msgstr ""

#: en.xml:1943(para) 
msgid "The file is unchanged in the working directory, and no changes to that file have been committed to the repository since its working revision. An <command moreinfo=\"none\">svn commit</command> of the file will do nothing, and an <command moreinfo=\"none\">svn update</command> of the file will do nothing."
msgstr ""

#: en.xml:1953(term) 
msgid "Locally changed, and current"
msgstr ""

#: en.xml:1956(para) 
msgid "The file has been changed in the working directory, and no changes to that file have been committed to the repository since its base revision. There are local changes that have not been committed to the repository, thus an <command moreinfo=\"none\">svn commit</command> of the file will succeed in publishing your changes, and an <command moreinfo=\"none\">svn update</command> of the file will do nothing."
msgstr ""

#: en.xml:1967(term) 
msgid "Unchanged, and out-of-date"
msgstr ""

#: en.xml:1970(para) 
msgid "The file has not been changed in the working directory, but it has been changed in the repository. The file should eventually be updated, to make it current with the public revision. An <command moreinfo=\"none\">svn commit</command> of the file will do nothing, and an <command moreinfo=\"none\">svn update</command> of the file will fold the latest changes into your working copy."
msgstr ""

#: en.xml:1981(term) 
msgid "Locally changed, and out-of-date"
msgstr ""

#: en.xml:1984(para) 
msgid "The file has been changed both in the working directory, and in the repository. An <command moreinfo=\"none\">svn commit</command> of the file will fail with an <quote>out-of-date</quote> error. The file should be updated first; an <command moreinfo=\"none\">svn update</command> command will attempt to merge the public changes with the local changes. If Subversion can't complete the merge in a plausible way automatically, it leaves it to the user to resolve the conflict."
msgstr ""

#: en.xml:1998(para) 
msgid "This may sound like a lot to keep track of, but the <command moreinfo=\"none\">svn status</command> command will show you the state of any item in your working copy. For more information on that command, see <xref linkend=\"svn.tour.cycle.examine.status\"/>."
msgstr ""

#: en.xml:2007(title) 
msgid "Mixed Revision Working Copies"
msgstr ""

#: en.xml:2009(para) 
msgid "As a general principle, Subversion tries to be as flexible as possible. One special kind of flexibility is the ability to have a working copy containing files and directories with a mix of different working revision numbers. Unfortunately, this flexibility tends to confuse a number of new users. If the earlier example showing mixed revisions perplexed you, here's a primer on both why the feature exists and how to make use of it."
msgstr ""

#: en.xml:2019(title) 
msgid "Updates and Commits are Separate"
msgstr ""

#: en.xml:2021(para) 
msgid "One of the fundamental rules of Subversion is that a <quote>push</quote> action does not cause a <quote>pull</quote>, nor the other way around. Just because you're ready to submit new changes to the repository doesn't mean you're ready to receive changes from other people. And if you have new changes still in progress, then <command moreinfo=\"none\">svn update</command> should gracefully merge repository changes into your own, rather than forcing you to publish them."
msgstr ""

#: en.xml:2031(para) 
msgid "The main side-effect of this rule is that it means a working copy has to do extra bookkeeping to track mixed revisions, and be tolerant of the mixture as well. It's made more complicated by the fact that directories themselves are versioned."
msgstr ""

#: en.xml:2037(para) 
msgid "For example, suppose you have a working copy entirely at revision 10. You edit the file <filename moreinfo=\"none\">foo.html</filename> and then perform an <command moreinfo=\"none\">svn commit</command>, which creates revision 15 in the repository. After the commit succeeds, many new users would expect the working copy to be entirely at revision 15, but that's not the case! Any number of changes might have happened in the repository between revisions 10 and 15. The client knows nothing of those changes in the repository, since you haven't yet run <command moreinfo=\"none\">svn update</command>, and <command moreinfo=\"none\">svn commit</command> doesn't pull down new changes. If, on the other hand, <command moreinfo=\"none\">svn commit</command><emphasis>were</emphasis> to automatically download the newest changes, then it would be possible to set the entire working copy to revision 15—but then we'd be breaking the fundamental rule of <quote>push</quote> and <quote>pull</quote> remaining separate actions. Therefore the only safe thing the Subversion client can do is mark the one file—<filename moreinfo=\"none\">foo.html</filename>—as being at revision 15. The rest of the working copy remains at revision 10. Only by running <command moreinfo=\"none\">svn update</command> can the latest changes be downloaded, and the whole working copy be marked as revision 15."
msgstr ""

#: en.xml:2065(title) 
msgid "Mixed revisions are normal"
msgstr ""

#: en.xml:2067(para) 
msgid "The fact is, <emphasis>every time</emphasis> you run <command moreinfo=\"none\">svn commit</command>, your working copy ends up with some mixture of revisions. The things you just committed are marked as having larger working revisions than everything else. After several commits (with no updates in-between) your working copy will contain a whole mixture of revisions. Even if you're the only person using the repository, you will still see this phenomenon. To examine your mixture of working revisions, use the <command moreinfo=\"none\">svn status --verbose</command> command (see <xref linkend=\"svn.tour.cycle.examine.status\"/> for more information.)"
msgstr ""

#: en.xml:2080(para) 
msgid "Often, new users are completely unaware that their working copy contains mixed revisions. This can be confusing, because many client commands are sensitive to the working revision of the item they're examining. For example, the <command moreinfo=\"none\">svn log</command> command is used to display the history of changes to a file or directory (see <xref linkend=\"svn.tour.history.log\"/>). When the user invokes this command on a working copy object, they expect to see the entire history of the object. But if the object's working revision is quite old (often because <command moreinfo=\"none\">svn update</command> hasn't been run in a long time), then the history of the <emphasis>older</emphasis> version of the object is shown."
msgstr ""

#: en.xml:2097(title) 
msgid "Mixed revisions are useful"
msgstr ""

#: en.xml:2099(para) 
msgid "If your project is sufficiently complex, you'll discover that it's sometimes nice to forcibly <quote>backdate</quote> portions of your working copy to an earlier revision; you'll learn how to do that in <xref linkend=\"svn.tour\"/>. Perhaps you'd like to test an earlier version of a sub-module contained in a subdirectory, or perhaps you'd like to figure out when a bug first came into existence in a specific file. This is the <quote>time machine</quote> aspect of a version control system — the feature which allows you to move any portion of your working copy forward and backward in history."
msgstr ""

#: en.xml:2114(title) 
msgid "Mixed revisions have limitations"
msgstr ""

#: en.xml:2116(para) 
msgid "However you make use of mixed revisions in your working copy, there are limitations to this flexibility."
msgstr ""

#: en.xml:2120(para) 
msgid "First, you cannot commit the deletion of a file or directory which isn't fully up-to-date. If a newer version of the item exists in the repository, your attempt to delete will be rejected, to prevent you from accidentally destroying changes you've not yet seen."
msgstr ""

#: en.xml:2127(para) 
msgid "Second, you cannot commit a metadata change to a directory unless it's fully up-to-date. You'll learn about attaching <quote>properties</quote> to items in <xref linkend=\"svn.serverconfig\"/>. A directory's working revision defines a specific set of entries and properties, and thus committing a property change to an out-of-date directory may destroy properties you've not yet seen."
msgstr ""

#: en.xml:2147(title) en.xml:4424(title) en.xml:6520(title) en.xml:9359(title) 
msgid "Summary"
msgstr ""

#: en.xml:2149(para) 
msgid "We've covered a number of fundamental Subversion concepts in this chapter:"
msgstr ""

#: en.xml:2154(para) 
msgid "We've introduced the notions of the central repository, the client working copy, and the array of repository revision trees."
msgstr ""

#: en.xml:2160(para) 
msgid "We've seen some simple examples of how two collaborators can use Subversion to publish and receive changes from one another, using the <quote>copy-modify-merge</quote> model."
msgstr ""

#: en.xml:2167(para) 
msgid "We've talked a bit about the way Subversion tracks and manages information in a working copy."
msgstr ""

#: en.xml:2173(para) 
msgid "At this point, you should have a good idea of how Subversion works in the most general sense. Armed with this knowledge, you should now be ready to jump into the next chapter, which is a detailed tour of Subversion's commands and features."
msgstr ""

#: en.xml:2189(title) 
msgid "Guided Tour"
msgstr ""

#: en.xml:2193(para) 
msgid "Now we will go into the details of using Subversion. By the time you reach the end of this chapter, you will be able to perform almost all the tasks you need to use Subversion in a normal day's work. You'll start with an initial checkout of your code, and walk through making changes and examining those changes. You'll also see how to bring changes made by others into your working copy, examine them, and work through any conflicts that might arise."
msgstr ""

#: en.xml:2202(para) 
msgid "Note that this chapter is not meant to be an exhaustive list of all Subversion's commands—rather, it's a conversational introduction to the most common Subversion tasks you'll encounter. This chapter assumes that you've read and understood <xref linkend=\"svn.basic\"/> and are familiar with the general model of Subversion. For a complete reference of all commands, see <xref linkend=\"svn.ref\"/>."
msgstr ""

#: en.xml:2216(title) en.xml:19001(refpurpose) 
msgid "Help!"
msgstr ""

#: en.xml:2219(para) 
msgid "Before reading on, here is the most important command you'll ever need when using Subversion: <command moreinfo=\"none\">svn help</command>. The Subversion command-line client is self-documenting—at any time, a quick <command moreinfo=\"none\">svn help &lt;subcommand&gt;</command> will describe the syntax, switches, and behavior of the <command moreinfo=\"none\">subcommand</command>."
msgstr ""

#: en.xml:2232(title) 
msgid "Import"
msgstr ""

#: en.xml:2234(para) 
msgid "You use <command moreinfo=\"none\">svn import</command> to import a new project into a Subversion repository. While this is most likely the very first thing you will do when you set up your Subversion server, it's not something that happens very often. For a detailed description of import, see <xref linkend=\"svn.tour.other.import\"/> later in this chapter."
msgstr ""

#: en.xml:2246(title) 
msgid "Revisions: Numbers, Keywords, and Dates, Oh My!"
msgstr ""

#: en.xml:2248(para) 
msgid "Before we go on, you should know a bit about how to identify a particular revision in your repository. As you learned in <xref linkend=\"svn.basic.in-action.revs\"/>, a revision is a <quote>snapshot</quote> of the repository at a particular moment in time. As you continue to commit and grow your repository, you need a mechanism for identifying these snapshots."
msgstr ""

#: en.xml:2255(para) 
msgid "You specify these revisions by using the <option>--revision</option> (<option>-r</option>) switch plus the revision you want (<command moreinfo=\"none\">svn --revision REV</command>) or you can specify a range by separating two revisions with a colon (<command moreinfo=\"none\">svn --revision REV1:REV2</command>). And Subversion lets you refer to these revisions by number, keyword, or date."
msgstr ""

#: en.xml:2265(title) 
msgid "Revision Numbers"
msgstr ""

#: en.xml:2267(para) 
msgid "When you create a new Subversion repository, it begins its life at revision zero and each successive commit increases the revision number by one. After your commit completes, the Subversion client informs you of the new revision number:"
msgstr ""

#: en.xml:2273(screen) en.xml:3846(screen) 
#, no-wrap
msgid "\n$ svn commit --message \"Corrected number of cheese slices.\"\nSending        sandwich.txt\nTransmitting file data .\nCommitted revision 3.\n"
msgstr ""

#: en.xml:2280(para) 
msgid "If at any point in the future you want to refer to that revision (we'll see how and why we might want to do that later in this chapter), you can refer to it as <quote>3</quote>."
msgstr ""

#: en.xml:2289(title) 
msgid "Revision Keywords"
msgstr ""

#: en.xml:2291(para) 
msgid "The Subversion client understands a number of <firstterm>revision keywords</firstterm>. These keywords can be used instead of integer arguments to the <option>--revision</option> switch, and are resolved into specific revision numbers by Subversion:"
msgstr ""

#: en.xml:2298(para) 
msgid "Each directory in your working copy contains an administrative subdirectory called <filename moreinfo=\"none\">.svn</filename>. For every file in a directory, Subversion keeps a copy of each file in the administrative area. This copy is an unmodified (no keyword expansion, no end-of-line translation, no nothing) copy of the file as it existed in the last revision (called the <quote>BASE</quote> revision) that you updated it to in your working copy. We refer to this file as the <firstterm>pristine copy</firstterm> or <firstterm>text-base</firstterm> version of your file, and it's always an exact byte-for-byte copy of the file as it exists in the repository."
msgstr ""

#: en.xml:2315(term) 
msgid "HEAD"
msgstr ""

#: en.xml:2317(para) 
msgid "The latest (or <quote>youngest</quote>) revision in the repository."
msgstr ""

#: en.xml:2323(term) 
msgid "BASE"
msgstr ""

#: en.xml:2325(para) 
msgid "The revision number of an item in a working copy. If the item has been locally modified, the <quote>BASE version</quote> refers to the way the item appears without those local modifications."
msgstr ""

#: en.xml:2333(term) 
msgid "COMMITTED"
msgstr ""

#: en.xml:2335(para) 
msgid "The most recent revision prior to, or equal to, <literal moreinfo=\"none\">BASE</literal>, in which an item changed."
msgstr ""

#: en.xml:2341(term) 
msgid "PREV"
msgstr ""

#: en.xml:2343(para) 
msgid "The revision immediately <emphasis>before</emphasis> the last revision in which an item changed. (Technically, <literal moreinfo=\"none\">COMMITTED</literal> - 1.)"
msgstr ""

#: en.xml:2352(para) 
msgid "<literal moreinfo=\"none\">PREV</literal>, <literal moreinfo=\"none\">BASE</literal>, and <literal moreinfo=\"none\">COMMITTED</literal> can be used to refer to local paths, but not to URLs."
msgstr ""

#: en.xml:2357(para) 
msgid "Here are some examples of revision keywords in action. Don't worry if the commands don't make sense yet; we'll be explaining these commands as we go through the chapter:"
msgstr ""

#: en.xml:2373(quote) 
msgid "pristine"
msgstr ""

#: en.xml:2361(screen) 
#, no-wrap
msgid "\n$ svn diff --revision PREV:COMMITTED foo.c\n# shows the last change committed to foo.c\n\n$ svn log --revision HEAD\n# shows log message for the latest repository commit\n\n$ svn diff --revision HEAD\n# compares your working file (with local changes) to the latest version\n# in the repository\n\n$ svn diff --revision BASE:HEAD foo.c\n# compares your <placeholder-1/> foo.c (no local changes) with the \n# latest version in the repository\n\n$ svn log --revision BASE:HEAD\n# shows all commit logs since you last updated\n\n$ svn update --revision PREV foo.c\n# rewinds the last change on foo.c\n# (foo.c's working revision is decreased)\n"
msgstr ""

#: en.xml:2384(para) 
msgid "These keywords allow you to perform many common (and helpful) operations without having to look up specific revision numbers or remember the exact revision of your working copy."
msgstr ""

#: en.xml:2393(title) 
msgid "Revision Dates"
msgstr ""

#: en.xml:2395(para) 
msgid "Anywhere that you specify a revision number or revision keyword, you can also specify a date inside curly braces <quote>{}</quote>. You can even access a range of changes in the repository using both dates and revisions together!"
msgstr ""

#: en.xml:2401(para) 
msgid "Here are examples of the date formats that Subversion accepts. Remember to use quotes around any date that contains spaces."
msgstr ""

#: en.xml:2405(screen) 
#, no-wrap
msgid "\n$ svn checkout --revision {2002-02-17}\n$ svn checkout --revision {15:30}\n$ svn checkout --revision {15:30:00.200000}\n$ svn checkout --revision {\"2002-02-17 15:30\"}\n$ svn checkout --revision {\"2002-02-17 15:30 +0230\"}\n$ svn checkout --revision {2002-02-17T15:30}\n$ svn checkout --revision {2002-02-17T15:30Z}\n$ svn checkout --revision {2002-02-17T15:30-04:00}\n$ svn checkout --revision {20020217T1530}\n$ svn checkout --revision {20020217T1530Z}\n$ svn checkout --revision {20020217T1530-0500}\n…\n"
msgstr ""

#: en.xml:2420(para) 
msgid "When you specify a date as a revision, Subversion finds the most recent revision of the repository as of that date:"
msgstr ""

#: en.xml:2424(screen) 
#, no-wrap
msgid "\n$ svn log --revision {2002-11-28}\n------------------------------------------------------------------------\nr12 | ira | 2002-11-27 12:31:51 -0600 (Wed, 27 Nov 2002) | 6 lines\n…\n"
msgstr ""

#: en.xml:2432(title) 
msgid "Is Subversion a Day Early?"
msgstr ""

#: en.xml:2434(para) 
msgid "If you specify a single date as a revision without specifying a time of day (for example <literal moreinfo=\"none\">2002-11-27</literal>), you may think that Subversion should give you the last revision that took place on the 27th of November. Instead, you'll get back a revision from the 26th, or even earlier. Remember that Subversion will find the <emphasis>most recent revision of the repository</emphasis> as of the date you give. If you give a date without a timestamp, like <literal moreinfo=\"none\">2002-11-27</literal>, Subversion assumes a time of 00:00:00, so looking for the most recent revision won't return anything on the day of the 27th."
msgstr ""

#: en.xml:2447(para) 
msgid "If you want to include the 27th in your search, you can either specify the 27th with the time (<literal moreinfo=\"none\">{\"2002-11-27 23:59\"}</literal>), or just specify the next day (<literal moreinfo=\"none\">{2002-11-28}</literal>)."
msgstr ""

#: en.xml:2454(para) 
msgid "You can also use a range of dates. Subversion will find all revisions between both dates, inclusive:"
msgstr ""

#: en.xml:2457(screen) 
#, no-wrap
msgid "\n$ svn log --revision {2002-11-20}:{2002-11-29}\n…\n"
msgstr ""

#: en.xml:2462(para) 
msgid "As we pointed out, you can also mix dates and revisions:"
msgstr ""

#: en.xml:2464(screen) 
#, no-wrap
msgid "\n$ svn log --revision {2002-11-20}:4040\n"
msgstr ""

#: en.xml:2468(para) 
msgid "Users should be aware of a subtlety that can become quite a stumbling-block when dealing with dates in Subversion. Since the timestamp of a revision is stored as a property of the revision—an unversioned, modifiable property—revision timestamps can be changed to represent complete falsifications of true chronology, or even removed altogether. This will wreak havoc on the internal date-to-revision conversion that Subversion performs."
msgstr ""

#: en.xml:2485(title) 
msgid "Initial Checkout"
msgstr ""

#: en.xml:2487(para) 
msgid "Most of the time, you will start using a Subversion repository by doing a <firstterm>checkout</firstterm> of your project. Checking out a repository creates a copy of it on your local machine. This copy contains the <literal moreinfo=\"none\">HEAD</literal> (latest revision) of the Subversion repository that you specify on the command line:"
msgstr ""

#: en.xml:2495(screen) 
#, no-wrap
msgid "\n$ svn checkout http://svn.collab.net/repos/svn/trunk\nA  trunk/subversion.dsw\nA  trunk/svn_check.dsp\nA  trunk/COMMITTERS\nA  trunk/configure.in\nA  trunk/IDEAS\n…\nChecked out revision 2499.\n"
msgstr ""

#: en.xml:2507(title) 
msgid "What's in a Name?"
msgstr ""

#: en.xml:2509(para) 
msgid "Subversion tries hard not to limit the type of data you can place under version control. The contents of files and property values are stored and transmitted as binary data, and <xref linkend=\"svn.advanced.props.special.mime-type\"/> tells you how to give Subversion a hint that <quote>textual</quote> operations don't make sense for a particular file. There are a few places, however, where Subversion places restrictions on information it stores."
msgstr ""

#: en.xml:2519(para) 
msgid "Subversion internally handles certain bits of data—for example, property names, path names, and log messages—as UTF-8 encoded Unicode. This is not to say that all your interactions with Subversion must involve UTF-8, though. As a general rule, Subversion clients will gracefully and transparently handle conversions between UTF-8 and the encoding system in use on your computer, if such a conversion can meaningfully be done (which is the case for most common encodings in use today)."
msgstr ""

#: en.xml:2529(para) 
msgid "In addition, path names are used as XML attribute values in WebDAV exchanges, as well in as some of Subversion's housekeeping files. This means that path names can only contain legal XML (1.0) characters. Subversion also prohibits TAB, CR, and LF characters in path names, so they aren't broken up in diffs, or in the output of commands like <xref linkend=\"svn.ref.svn.c.log\"/> or <xref linkend=\"svn.ref.svn.c.status\"/>."
msgstr ""

#: en.xml:2536(para) 
msgid "While it may seem like a lot to remember, in practice these limitations are rarely a problem. As long as your locale settings are compatible with UTF-8, and you don't use control characters in path names, you should have no trouble communicating with Subversion. The command-line client adds an extra bit of help—it will automatically escape legal path characters as needed in URLs you type to create <quote>legally correct</quote> versions for internal use."
msgstr ""

#: en.xml:2546(para) 
msgid "Experienced users of Subversion have also developed a set of best-practice conventions for laying out paths in the repository. While these aren't strict requirements like the syntax described above, they help to organize frequently performed tasks. The <literal moreinfo=\"none\">/trunk</literal> part of URLs you'll find throughout this book is one of these conventions; we'll talk a lot more about it and related recommendations in <xref linkend=\"svn.branchmerge\"/>."
msgstr ""

#: en.xml:2557(para) 
msgid "Although the above example checks out the trunk directory, you can just as easily check out any deep subdirectory of a repository by specifying the subdirectory in the checkout URL:"
msgstr ""

#: en.xml:2562(screen) 
#, no-wrap
msgid "\n$ svn checkout http://svn.collab.net/repos/svn/trunk/doc/book/tools\nA  tools/readme-dblite.html\nA  tools/fo-stylesheet.xsl\nA  tools/svnbook.el\nA  tools/dtd\nA  tools/dtd/dblite.dtd\n…\nChecked out revision 2499.\n"
msgstr ""

#: en.xml:2573(para) 
msgid "Since Subversion uses a <quote>copy-modify-merge</quote> model instead of <quote>lock-modify-unlock</quote> (see <xref linkend=\"svn.basic\"/>), you're already able to start making changes to the files and directories in your working copy. Your working copy is just like any other collection of files and directories on your system. You can edit and change them, move them around, you can even delete the entire working copy and forget about it."
msgstr ""

#: en.xml:2582(para) 
msgid "While your working copy is <quote>just like any other collection of files and directories on your system</quote>, you need to let Subversion know if you're going to be rearranging anything inside of your working copy. If you want to copy or move an item in a working copy, you should use <command moreinfo=\"none\">svn copy</command> or <command moreinfo=\"none\">svn move</command> instead of the copy and move commands provided by your operating system. We'll talk more about them later in this chapter."
msgstr ""

#: en.xml:2593(para) 
msgid "Unless you're ready to commit a new file or directory, or changes to existing ones, there's no need to further notify the Subversion server that you've done anything."
msgstr ""

#: en.xml:2598(title) 
msgid "What's with the <filename moreinfo=\"none\">.svn</filename> directory?"
msgstr ""

#: en.xml:2600(para) 
msgid "Every directory in a working copy contains an administrative area, a subdirectory named <filename moreinfo=\"none\">.svn</filename>. Usually, directory listing commands won't show this subdirectory, but it is nevertheless an important directory. Whatever you do, don't delete or change anything in the administrative area! Subversion depends on it to manage your working copy."
msgstr ""

#: en.xml:2610(para) 
msgid "While you can certainly check out a working copy with the URL of the repository as the only argument, you can also specify a directory after your repository URL. This places your working copy in the new directory that you name. For example:"
msgstr ""

#: en.xml:2615(screen) 
#, no-wrap
msgid "\n$ svn checkout http://svn.collab.net/repos/svn/trunk subv\nA  subv/subversion.dsw\nA  subv/svn_check.dsp\nA  subv/COMMITTERS\nA  subv/configure.in\nA  subv/IDEAS\n…\nChecked out revision 2499.\n"
msgstr ""

#: en.xml:2626(para) 
msgid "That will place your working copy in a directory named <literal moreinfo=\"none\">subv</literal> instead of a directory named <literal moreinfo=\"none\">trunk</literal> as we did previously."
msgstr ""

#: en.xml:2636(title) 
msgid "Basic Work Cycle"
msgstr ""

#: en.xml:2638(para) 
msgid "Subversion has numerous features, options, bells and whistles, but on a day-to-day basis, odds are that you will only use a few of them. In this section we'll run through the most common things that you might find yourself doing with Subversion in the course of a day's work."
msgstr ""

#: en.xml:2644(para) 
msgid "The typical work cycle looks like this:"
msgstr ""

#: en.xml:2648(para) 
msgid "Update your working copy"
msgstr ""

#: en.xml:2651(command) en.xml:2694(command) en.xml:21268(refname) 
msgid "svn update"
msgstr ""

#: en.xml:2658(para) 
msgid "Make changes"
msgstr ""

#: en.xml:2661(command) en.xml:17802(refname) 
msgid "svn add"
msgstr ""

#: en.xml:2664(command) en.xml:18542(refname) 
msgid "svn delete"
msgstr ""

#: en.xml:2667(command) en.xml:18374(refname) 
msgid "svn copy"
msgstr ""

#: en.xml:2670(command) en.xml:19922(refname) 
msgid "svn move"
msgstr ""

#: en.xml:2676(para) 
msgid "Examine your changes"
msgstr ""

#: en.xml:2679(command) en.xml:3013(command) en.xml:20631(refname) en.xml:23872(command) 
msgid "svn status"
msgstr ""

#: en.xml:2682(command) en.xml:3319(command) en.xml:3952(command) en.xml:4098(command) en.xml:18648(refname) en.xml:23879(command) 
msgid "svn diff"
msgstr ""

#: en.xml:2685(command) en.xml:3406(command) en.xml:20534(refname) en.xml:23886(command) 
msgid "svn revert"
msgstr ""

#: en.xml:2691(para) 
msgid "Merge others' changes into your working copy"
msgstr ""

#: en.xml:2697(command) en.xml:20452(refname) 
msgid "svn resolved"
msgstr ""

#: en.xml:2703(para) 
msgid "Commit your changes"
msgstr ""

#: en.xml:2706(command) en.xml:18243(refname) 
msgid "svn commit"
msgstr ""

#: en.xml:2714(title) 
msgid "Update Your Working Copy"
msgstr ""

#: en.xml:2716(para) 
msgid "When working on a project with a team, you'll want to update your working copy to receive any changes made since your last update by other developers on the project. Use <command moreinfo=\"none\">svn update</command> to bring your working copy into sync with the latest revision in the repository."
msgstr ""

#: en.xml:2722(screen) 
#, no-wrap
msgid "\n$ svn update\nU  foo.c\nU  bar.c\nUpdated to revision 2.\n"
msgstr ""

#: en.xml:2729(para) 
msgid "In this case, someone else checked in modifications to both <filename moreinfo=\"none\">foo.c</filename> and <filename moreinfo=\"none\">bar.c</filename> since the last time you updated, and Subversion has updated your working copy to include those changes."
msgstr ""

#: en.xml:2734(para) 
msgid "Let's examine the output of <command moreinfo=\"none\">svn update</command> a bit more. When the server sends changes to your working copy, a letter code is displayed next to each item to let you know what actions Subversion performed to bring your working copy up-to-date:"
msgstr ""

#: en.xml:2743(computeroutput) 
#, no-wrap
msgid "U      foo"
msgstr ""

#: en.xml:2745(para) 
msgid "File <filename moreinfo=\"none\">foo</filename> was <computeroutput moreinfo=\"none\">U</computeroutput>pdated (received changes from the server)."
msgstr ""

#: en.xml:2752(computeroutput) 
#, no-wrap
msgid "A      foo"
msgstr ""

#: en.xml:2754(para) 
msgid "File or directory <filename moreinfo=\"none\">foo</filename> was <computeroutput moreinfo=\"none\">A</computeroutput>dded to your working copy."
msgstr ""

#: en.xml:2761(computeroutput) 
#, no-wrap
msgid "D      foo"
msgstr ""

#: en.xml:2763(para) 
msgid "File or directory <filename moreinfo=\"none\">foo</filename> was <computeroutput moreinfo=\"none\">D</computeroutput>eleted from your working copy."
msgstr ""

#: en.xml:2770(computeroutput) 
#, no-wrap
msgid "R      foo"
msgstr ""

#: en.xml:2772(para) 
msgid "File or directory <filename moreinfo=\"none\">foo</filename> was <computeroutput moreinfo=\"none\">R</computeroutput>eplaced in your working copy; that is, <filename moreinfo=\"none\">foo</filename> was deleted, and a new item with the same name was added. While they may have the same name, the repository considers them to be distinct objects with distinct histories."
msgstr ""

#: en.xml:2782(computeroutput) 
#, no-wrap
msgid "G      foo"
msgstr ""

#: en.xml:2784(para) 
msgid "File <filename moreinfo=\"none\">foo</filename> received new changes from the repository, but your local copy of the file had your modifications. Either the changes did not intersect, or the changes were exactly the same as your local modifications, so Subversion has successfully mer<computeroutput moreinfo=\"none\">G</computeroutput>ed the repository's changes into the file without a problem."
msgstr ""

#: en.xml:2795(computeroutput) 
#, no-wrap
msgid "C      foo"
msgstr ""

#: en.xml:2797(para) 
msgid "File <filename moreinfo=\"none\">foo</filename> received <computeroutput moreinfo=\"none\">C</computeroutput>onflicting changes from the server. The changes from the server directly overlap your own changes to the file. No need to panic, though. This overlap needs to be resolved by a human (you); we discuss this situation later in this chapter."
msgstr ""

#: en.xml:2812(title) 
msgid "Make Changes to Your Working Copy"
msgstr ""

#: en.xml:2814(para) 
msgid "Now you can get to work and make changes in your working copy. It's usually most convenient to decide on a particular change (or set of changes) to make, such as writing a new feature, fixing a bug, etc. The Subversion commands that you will use here are <command moreinfo=\"none\">svn add</command>, <command moreinfo=\"none\">svn delete</command>, <command moreinfo=\"none\">svn copy</command>, and <command moreinfo=\"none\">svn move</command>. However, if you are merely editing files that are already in Subversion, you may not need to use any of these commands until you commit. Changes you can make to your working copy:"
msgstr ""

#: en.xml:2828(term) 
msgid "File changes"
msgstr ""

#: en.xml:2830(para) 
msgid "This is the simplest sort of change. You don't need to tell Subversion that you intend to change a file; just make your changes. Subversion will be able to automatically detect which files have been changed."
msgstr ""

#: en.xml:2839(term) 
msgid "Tree changes"
msgstr ""

#: en.xml:2841(para) 
msgid "You can ask Subversion to <quote>mark</quote> files and directories for scheduled removal, addition, copying, or moving. While these changes may take place immediately in your working copy, no additions or removals will happen in the repository until you commit them."
msgstr ""

#: en.xml:2852(para) 
msgid "To make file changes, use your text editor, word processor, graphics program, or whatever tool you would normally use. Subversion handles binary files just as easily as it handles text files—and just as efficiently too."
msgstr ""

#: en.xml:2858(para) 
msgid "Here is an overview of the four Subversion subcommands that you'll use most often to make tree changes (we'll cover <command moreinfo=\"none\">svn import</command> and <command moreinfo=\"none\">svn mkdir</command> later)."
msgstr ""

#: en.xml:2864(para) 
msgid "While you can edit your files with whatever tool you like, you shouldn't change the structure of your working copy without letting Subversion know what you're doing. Use the <command moreinfo=\"none\">svn copy</command>, <command moreinfo=\"none\">svn delete</command>, and <command moreinfo=\"none\">svn move</command> commands to change the structure of your working copy, and use the <command moreinfo=\"none\">svn add</command> command to place new files and directories under version control."
msgstr ""

#: en.xml:2876(command) 
msgid "svn add foo"
msgstr ""

#: en.xml:2878(para) 
msgid "Schedule file, directory, or symbolic link <filename moreinfo=\"none\">foo</filename> to be added to the repository. When you next commit, <filename moreinfo=\"none\">foo</filename> will become a child of its parent directory. Note that if <filename moreinfo=\"none\">foo</filename> is a directory, everything underneath <filename moreinfo=\"none\">foo</filename> will be scheduled for addition. If you only want to add <filename moreinfo=\"none\">foo</filename> itself, pass the <option>--non-recursive</option> (<option>-N</option>) switch."
msgstr ""

#: en.xml:2893(command) 
msgid "svn delete foo"
msgstr ""

#: en.xml:2903(para) 
msgid "Of course, nothing is ever totally deleted from the repository—just from the <literal moreinfo=\"none\">HEAD</literal> of the repository. You can get back anything you delete by checking out (or updating your working copy) a revision earlier than the one in which you deleted it."
msgstr ""

#: en.xml:2895(para) 
msgid "Schedule file, directory, or symbolic link <filename moreinfo=\"none\">foo</filename> to be deleted from the repository. If <filename moreinfo=\"none\">foo</filename> is a file or link, it is immediately deleted from your working copy. If <filename moreinfo=\"none\">foo</filename> is a directory, it is not deleted, but Subversion schedules it for deletion. When you commit your changes, <filename moreinfo=\"none\">foo</filename> will be removed from your working copy and the repository. <placeholder-1/>"
msgstr ""

#: en.xml:2913(command) 
msgid "svn copy foo bar"
msgstr ""

#: en.xml:2915(para) 
msgid "Create a new item <filename moreinfo=\"none\">bar</filename> as a duplicate of <filename moreinfo=\"none\">foo</filename>. <filename moreinfo=\"none\">bar</filename> is automatically scheduled for addition. When <filename moreinfo=\"none\">bar</filename> is added to the repository on the next commit, its copy history is recorded (as having originally come from <filename moreinfo=\"none\">foo</filename>). <command moreinfo=\"none\">svn copy</command> does not create intermediate directories."
msgstr ""

#: en.xml:2927(command) 
msgid "svn move foo bar"
msgstr ""

#: en.xml:2929(para) 
msgid "This command is exactly the same as running <command moreinfo=\"none\">svn copy foo bar; svn delete foo</command>. That is, <filename moreinfo=\"none\">bar</filename> is scheduled for addition as a copy of <filename moreinfo=\"none\">foo</filename>, and <filename moreinfo=\"none\">foo</filename> is scheduled for removal. <command moreinfo=\"none\">svn move</command> does not create intermediate directories."
msgstr ""

#: en.xml:2942(title) 
msgid "Changing the Repository Without a Working Copy"
msgstr ""

#. though, so that this sidebar makes more sense.
#: en.xml:2953(para) 
msgid "Earlier in this chapter, we said that you have to commit any changes that you make in order for the repository to reflect these changes. That's not entirely true—there <emphasis>are</emphasis> some use cases that immediately commit tree changes to the repository. This only happens when a subcommand is operating directly on a URL, rather than on a working-copy path. In particular, specific uses of <command moreinfo=\"none\">svn mkdir</command>, <command moreinfo=\"none\">svn copy</command>, <command moreinfo=\"none\">svn move</command>, and <command moreinfo=\"none\">svn delete</command> can work with URLs."
msgstr ""

#: en.xml:2964(para) 
msgid "URL operations behave in this manner because commands that operate on a working copy can use the working copy as a sort of <quote>staging area</quote> to set up your changes before committing them to the repository. Commands that operate on URLs don't have this luxury, so when you operate directly on a URL, any of the above actions represent an immediate commit."
msgstr ""

#: en.xml:2978(title) 
msgid "Examine Your Changes"
msgstr ""

#: en.xml:2980(para) 
msgid "Once you've finished making changes, you need to commit them to the repository, but before you do so, it's usually a good idea to take a look at exactly what you've changed. By examining your changes before you commit, you can make a more accurate log message. You may also discover that you've inadvertently changed a file, and this gives you a chance to revert those changes before committing. Additionally, this is a good opportunity to review and scrutinize changes before publishing them. You can see exactly what changes you've made by using <command moreinfo=\"none\">svn status</command>, <command moreinfo=\"none\">svn diff</command>, and <command moreinfo=\"none\">svn revert</command>. You will usually use the first two commands to find out what files have changed in your working copy, and then perhaps the third to revert some (or all) of those changes."
msgstr ""

#. repository may not be local.
#: en.xml:3003(para) 
msgid "Subversion has been optimized to help you with this task, and is able to do many things without communicating with the repository. In particular, your working copy contains a secret cached <quote>pristine</quote> copy of each version controlled file within the <filename moreinfo=\"none\">.svn</filename> area. Because of this, Subversion can quickly show you how your working files have changed, or even allow you to undo your changes without contacting the repository."
msgstr ""

#: en.xml:3015(para) 
msgid "You'll probably use the <command moreinfo=\"none\">svn status</command> command more than any other Subversion command."
msgstr ""

#: en.xml:3019(title) 
msgid "CVS Users: Hold That Update!"
msgstr ""

#: en.xml:3021(para) 
msgid "You're probably used to using <command moreinfo=\"none\">cvs update</command> to see what changes you've made to your working copy. <command moreinfo=\"none\">svn status</command> will give you all the information you need regarding what has changed in your working copy—without accessing the repository or potentially incorporating new changes published by other users."
msgstr ""

#: en.xml:3029(para) 
msgid "In Subversion, <command moreinfo=\"none\">update</command> does just that—it updates your working copy with any changes committed to the repository since the last time you've updated your working copy. You'll have to break the habit of using the <command moreinfo=\"none\">update</command> command to see what local modifications you've made."
msgstr ""

#: en.xml:3038(para) 
msgid "If you run <command moreinfo=\"none\">svn status</command> at the top of your working copy with no arguments, it will detect all file and tree changes you've made. Below are examples of the different status codes that <command moreinfo=\"none\">svn status</command> can return. (Note that the text following <literal moreinfo=\"none\">#</literal> is not actually printed by <command moreinfo=\"none\">svn status</command>.)"
msgstr ""

#: en.xml:3046(screen) 
#, no-wrap
msgid "\n  L     some_dir            # svn left a lock in the .svn area of some_dir\nM       bar.c               # the content in bar.c has local modifications\n M      baz.c               # baz.c has property but no content modifications\nX       3rd_party           # dir is part of an externals definition\n?       foo.o               # svn doesn't manage foo.o\n!       some_dir            # svn manages this, but it's missing or incomplete\n~       qux                 # versioned as file/dir/link, but type has changed\nI       .screenrc           # svn doesn't manage this, and is set to ignore it\nA  +    moved_dir           # added with history of where it came from\nM  +    moved_dir/README    # added with history and has local modifications\nD       stuff/fish.c        # file is scheduled for deletion\nA       stuff/loot/bloo.h   # file is scheduled for addition\nC       stuff/loot/lump.c   # file has textual conflicts from an update\n C      stuff/loot/glub.c   # file has property conflicts from an update\nR       xyz.c               # file is scheduled for replacement\n    S   stuff/squawk        # file or dir has been switched to a branch\n     K  dog.jpg             # file is locked locally; lock-token present \n     O  cat.jpg             # file is locked in the repository by other user\n     B  bird.jpg            # file is locked locally, but lock has been broken\n     T  fish.jpg            # file is locked locally, but lock has been stolen\n\n"
msgstr ""

#: en.xml:3070(para) 
msgid "In this output format <command moreinfo=\"none\">svn status</command> prints five columns of characters, followed by several whitespace characters, followed by a file or directory name. The first column tells the status of a file or directory and/or its contents. The codes printed here are:"
msgstr ""

#: en.xml:3080(computeroutput) 
#, no-wrap
msgid "A      item"
msgstr ""

#: en.xml:3082(para) 
msgid "The file, directory, or symbolic link <filename moreinfo=\"none\">item</filename> has been scheduled for addition into the repository."
msgstr ""

#: en.xml:3089(computeroutput) 
#, no-wrap
msgid "C      item"
msgstr ""

#: en.xml:3091(para) 
msgid "The file <filename moreinfo=\"none\">item</filename> is in a state of conflict. That is, changes received from the server during an update overlap with local changes that you have in your working copy. You must resolve this conflict before committing your changes to the repository."
msgstr ""

#: en.xml:3101(computeroutput) 
#, no-wrap
msgid "D      item"
msgstr ""

#: en.xml:3103(para) 
msgid "The file, directory, or symbolic link <filename moreinfo=\"none\">item</filename> has been scheduled for deletion from the repository."
msgstr ""

#: en.xml:3110(computeroutput) 
#, no-wrap
msgid "M      item"
msgstr ""

#: en.xml:3112(para) 
msgid "The contents of the file <filename moreinfo=\"none\">item</filename> have been modified."
msgstr ""

#: en.xml:3118(computeroutput) 
#, no-wrap
msgid "R      item"
msgstr ""

#: en.xml:3120(para) 
msgid "The file, directory, or symbolic link <filename moreinfo=\"none\">item</filename> has been scheduled to replace <filename moreinfo=\"none\">item</filename> in the repository. This means that the object is first deleted, then another object of the same name is added, all within a single revision."
msgstr ""

#: en.xml:3130(computeroutput) 
#, no-wrap
msgid "X      item"
msgstr ""

#: en.xml:3132(para) 
msgid "The directory <filename moreinfo=\"none\">item</filename> is unversioned, but is related to a Subversion externals definition. To find out more about externals definitions, see <xref linkend=\"svn.advanced.externals\"/>."
msgstr ""

#: en.xml:3140(computeroutput) 
#, no-wrap
msgid "?      item"
msgstr ""

#: en.xml:3142(para) 
msgid "The file, directory, or symbolic link <filename moreinfo=\"none\">item</filename> is not under version control. You can silence the question marks by either passing the <option>--quiet</option> (<option>-q</option>) switch to <command moreinfo=\"none\">svn status</command>, or by setting the <literal moreinfo=\"none\">svn:ignore</literal> property on the parent directory. For more information on ignored files, see <xref linkend=\"svn.advanced.props.special.ignore\"/>."
msgstr ""

#: en.xml:3156(computeroutput) 
#, no-wrap
msgid "!      item"
msgstr ""

#: en.xml:3158(para) 
msgid "The file, directory, or symbolic link <filename moreinfo=\"none\">item</filename> is under version control but is missing or somehow incomplete. The item can be missing if it's removed using a non-Subversion command. In the case of a directory, it can be incomplete if you happened to interrupt a checkout or update. A quick <command moreinfo=\"none\">svn update</command> will refetch the file or directory from the repository, or <command moreinfo=\"none\">svn revert file</command> will restore a missing file."
msgstr ""

#: en.xml:3172(computeroutput) 
#, no-wrap
msgid "~      item"
msgstr ""

#: en.xml:3174(para) 
msgid "The file, directory, or symbolic link <filename moreinfo=\"none\">item</filename> is in the repository as one kind of object, but what's actually in your working copy is some other kind. For example, Subversion might have a file in the repository, but you removed the file and created a directory in its place, without using the <command moreinfo=\"none\">svn delete</command> or <command moreinfo=\"none\">svn add</command> command."
msgstr ""

#: en.xml:3186(computeroutput) 
#, no-wrap
msgid "I      item"
msgstr ""

#: en.xml:3188(para) 
msgid "The file, directory, or symbolic link <filename moreinfo=\"none\">item</filename> is not under version control, and Subversion is configured to ignore it during <command moreinfo=\"none\">svn add</command>, <command moreinfo=\"none\">svn import</command> and <command moreinfo=\"none\">svn status</command> operations. For more information on ignored files, see <xref linkend=\"svn.advanced.props.special.ignore\"/>. Note that this symbol only shows up if you pass the <option>--no-ignore</option> option to <command moreinfo=\"none\">svn status</command>—otherwise the file would be ignored and not listed at all!"
msgstr ""

#: en.xml:3203(para) 
msgid "The second column tells the status of a file or directory's properties (see <xref linkend=\"svn.advanced.props\"/> for more information on properties). If an <computeroutput moreinfo=\"none\">M</computeroutput> appears in the second column, then the properties have been modified, otherwise a whitespace will be printed."
msgstr ""

#: en.xml:3209(para) 
msgid "The third column will only show whitespace or an <computeroutput moreinfo=\"none\">L</computeroutput> which means that Subversion has locked the directory's <filename moreinfo=\"none\">.svn</filename> working area. You will see an <computeroutput moreinfo=\"none\">L</computeroutput> if you run <command moreinfo=\"none\">svn status</command> in a directory where an <command moreinfo=\"none\">svn commit</command> is in progress—perhaps when you are editing the log message. If Subversion is not running, then presumably Subversion was interrupted and the lock needs to be cleaned up by running <command moreinfo=\"none\">svn cleanup</command> (more about that later in this chapter)."
msgstr ""

#: en.xml:3221(para) 
msgid "The fourth column will only show whitespace or a <computeroutput moreinfo=\"none\">+</computeroutput> which means that the file or directory is scheduled to be added or modified with additional attached history. This typically happens when you <command moreinfo=\"none\">svn move</command> or <command moreinfo=\"none\">svn copy</command> a file or directory. If you see <computeroutput moreinfo=\"none\">A  +</computeroutput>, this means the item is scheduled for addition-with-history. It could be a file, or the root of a copied directory. <computeroutput moreinfo=\"none\">+</computeroutput> means the item is part of a subtree scheduled for addition-with-history, i.e. some parent got copied, and it's just coming along for the ride. <computeroutput moreinfo=\"none\">M  +</computeroutput> means the item is part of a subtree scheduled for addition-with-history, <emphasis>and</emphasis> it has local modifications. When you commit, first the parent will be added-with-history (copied), which means this file will automatically exist in the copy. Then the local modifications will be uploaded into the copy."
msgstr ""

#: en.xml:3242(para) 
msgid "The fifth column will only show whitespace or an <computeroutput moreinfo=\"none\">S</computeroutput>. This signifies that the file or directory has been switched from the path of the rest of the working copy (using <command moreinfo=\"none\">svn switch</command>) to a branch."
msgstr ""

#: en.xml:3248(para) 
msgid "The sixth column shows information about locks, which is further explained in <xref linkend=\"svn.advanced.locking\"/>. (These are not the same locks as the ones indicated by an <computeroutput moreinfo=\"none\">L</computeroutput> in the third column; see <xref linkend=\"svn.advanced.locking.meanings\"/>.)"
msgstr ""

#: en.xml:3254(para) 
msgid "If you pass a specific path to <command moreinfo=\"none\">svn status</command>, it gives you information about that item alone:"
msgstr ""

#: en.xml:3258(screen) 
#, no-wrap
msgid "\n$ svn status stuff/fish.c\nD      stuff/fish.c\n"
msgstr ""

#: en.xml:3263(para) 
msgid "<command moreinfo=\"none\">svn status</command> also has a <option>--verbose</option> (<option>-v</option>) switch, which will show you the status of <emphasis>every</emphasis> item in your working copy, even if it has not been changed:"
msgstr ""

#: en.xml:3269(screen) 
#, no-wrap
msgid "\n$ svn status --verbose\nM               44        23    sally     README\n                44        30    sally     INSTALL\nM               44        20    harry     bar.c\n                44        18    ira       stuff\n                44        35    harry     stuff/trout.c\nD               44        19    ira       stuff/fish.c\n                44        21    sally     stuff/things\nA                0         ?     ?        stuff/things/bloo.h\n                44        36    harry     stuff/things/gloo.c\n"
msgstr ""

#: en.xml:3282(para) 
msgid "This is the <quote>long form</quote> output of <command moreinfo=\"none\">svn status</command>. The first column remains the same, but the second column shows the working-revision of the item. The third and fourth columns show the revision in which the item last changed, and who changed it."
msgstr ""

#: en.xml:3288(para) 
msgid "None of the above invocations to <command moreinfo=\"none\">svn status</command> contact the repository, they work only locally by comparing the metadata in the <filename moreinfo=\"none\">.svn</filename> directory with the working copy. Finally, there is the <option>--show-updates</option> (<option>-u</option>) switch, which contacts the repository and adds information about things that are out-of-date:"
msgstr ""

#: en.xml:3297(screen) 
#, no-wrap
msgid "\n$ svn status --show-updates --verbose\nM      *        44        23    sally     README\nM               44        20    harry     bar.c\n       *        44        35    harry     stuff/trout.c\nD               44        19    ira       stuff/fish.c\nA                0         ?     ?        stuff/things/bloo.h\nStatus against revision:   46\n"
msgstr ""

#: en.xml:3307(para) 
msgid "Notice the two asterisks: if you were to run <command moreinfo=\"none\">svn update</command> at this point, you would receive changes to <filename moreinfo=\"none\">README</filename> and <filename moreinfo=\"none\">trout.c</filename>. This tells you some very useful information—you'll need to update and get the server changes on <filename moreinfo=\"none\">README</filename> before you commit, or the repository will reject your commit for being out-of-date. (More on this subject later.)"
msgstr ""

#: en.xml:3326(para) 
msgid "Subversion uses its internal diff engine, which produces unified diff format, by default. If you want diff output in a different format, specify an external diff program using <option>--diff-cmd</option> and pass any flags you'd like to it using the <option>--extensions</option> switch. For example, to see local differences in file <filename moreinfo=\"none\">foo.c</filename> in context output format while ignoring whitespace changes, you might run <command moreinfo=\"none\">svn diff --diff-cmd /usr/bin/diff --extensions '-bc' foo.c</command>."
msgstr ""

#: en.xml:3321(para) 
msgid "Another way to examine your changes is with the <command moreinfo=\"none\">svn diff</command> command. You can find out <emphasis>exactly</emphasis> how you've modified things by running <command moreinfo=\"none\">svn diff</command> with no arguments, which prints out file changes in unified diff format:<footnote><placeholder-1/></footnote>"
msgstr ""

#: en.xml:3338(screen) 
#, no-wrap
msgid "\n$ svn diff\nIndex: bar.c\n===================================================================\n--- bar.c\t(revision 3)\n+++ bar.c\t(working copy)\n@@ -1,7 +1,12 @@\n+#include &lt;sys/types.h&gt;\n+#include &lt;sys/stat.h&gt;\n+#include &lt;unistd.h&gt;\n+\n+#include &lt;stdio.h&gt;\n\n int main(void) {\n-  printf(\"Sixty-four slices of American Cheese...\\n\");\n+  printf(\"Sixty-five slices of American Cheese...\\n\");\n return 0;\n }\n\nIndex: README\n===================================================================\n--- README\t(revision 3)\n+++ README\t(working copy)\n@@ -193,3 +193,4 @@ \n+Note to self:  pick up laundry.\n\nIndex: stuff/fish.c\n===================================================================\n--- stuff/fish.c\t(revision 1)\n+++ stuff/fish.c\t(working copy)\n-Welcome to the file known as 'fish'.\n-Information on fish will be here soon.\n\nIndex: stuff/things/bloo.h\n===================================================================\n--- stuff/things/bloo.h\t(revision 8)\n+++ stuff/things/bloo.h\t(working copy)\n+Here is a new file to describe\n+things about bloo.\n"
msgstr ""

#: en.xml:3379(para) 
msgid "The <command moreinfo=\"none\">svn diff</command> command produces this output by comparing your working files against the cached <quote>pristine</quote> copies within the <filename moreinfo=\"none\">.svn</filename> area. Files scheduled for addition are displayed as all added-text, and files scheduled for deletion are displayed as all deleted text."
msgstr ""

#: en.xml:3387(para) 
msgid "Output is displayed in <firstterm>unified diff format</firstterm>. That is, removed lines are prefaced with a <literal moreinfo=\"none\">-</literal> and added lines are prefaced with a <literal moreinfo=\"none\">+</literal>. <command moreinfo=\"none\">svn diff</command> also prints filename and offset information useful to the <command moreinfo=\"none\">patch</command> program, so you can generate <quote>patches</quote> by redirecting the diff output to a file:"
msgstr ""

#: en.xml:3396(screen) 
#, no-wrap
msgid "\n$ svn diff &gt; patchfile\n"
msgstr ""

#: en.xml:3400(para) 
msgid "You could, for example, email the patch file to another developer for review or testing prior to commit."
msgstr ""

#: en.xml:3408(para) 
msgid "Now suppose you see the above diff output, and realize that your changes to <filename moreinfo=\"none\">README</filename> are a mistake; perhaps you accidentally typed that text into the wrong file in your editor."
msgstr ""

#: en.xml:3413(para) 
msgid "This is a perfect opportunity to use <command moreinfo=\"none\">svn revert</command>."
msgstr ""

#: en.xml:3416(screen) 
#, no-wrap
msgid "\n$ svn revert README\nReverted 'README'\n"
msgstr ""

#: en.xml:3421(para) 
msgid "Subversion reverts the file to its pre-modified state by overwriting it with the cached <quote>pristine</quote> copy from the <filename moreinfo=\"none\">.svn</filename> area. But also note that <command moreinfo=\"none\">svn revert</command> can undo <emphasis>any</emphasis> scheduled operations—for example, you might decide that you don't want to add a new file after all:"
msgstr ""

#: en.xml:3429(screen) 
#, no-wrap
msgid "\n$ svn status foo\n?      foo\n\n$ svn add foo\nA         foo\n\n$ svn revert foo\nReverted 'foo'\n\n$ svn status foo\n?      foo\n"
msgstr ""

#: en.xml:3444(para) 
msgid "<command moreinfo=\"none\">svn revert</command><replaceable>ITEM</replaceable> has exactly the same effect as deleting <replaceable>ITEM</replaceable> from your working copy and then running <command moreinfo=\"none\">svn update -r BASE</command><replaceable>ITEM</replaceable>. However, if you're reverting a file, <command moreinfo=\"none\">svn revert</command> has one very noticeable difference—it doesn't have to communicate with the repository to restore your file."
msgstr ""

#: en.xml:3455(para) 
msgid "Or perhaps you mistakenly removed a file from version control:"
msgstr ""

#: en.xml:3458(screen) 
#, no-wrap
msgid "\n$ svn status README \n       README\n\n$ svn delete README \nD         README\n\n$ svn revert README\nReverted 'README'\n\n$ svn status README\n       README\n"
msgstr ""

#: en.xml:3475(title) 
msgid "Look Ma! No Network!"
msgstr ""

#: en.xml:3477(para) 
msgid "All three of these commands (<command moreinfo=\"none\">svn status</command>, <command moreinfo=\"none\">svn diff</command>, and <command moreinfo=\"none\">svn revert</command>) can be used without any network access. This makes it easy to manage your changes-in-progress when you are somewhere without a network connection, such as travelling on an airplane, riding a commuter train or hacking on the beach."
msgstr ""

#: en.xml:3485(para) 
msgid "Subversion does this by keeping private caches of pristine versions of each versioned file inside of the <filename moreinfo=\"none\">.svn</filename> administrative areas. This allows Subversion to report—and revert—local modifications to those files <emphasis>without network access</emphasis>. This cache (called the <quote>text-base</quote>) also allows Subversion to send the user's local modifications during a commit to the server as a compressed <firstterm>delta</firstterm> (or <quote>difference</quote>) against the pristine version. Having this cache is a tremendous benefit—even if you have a fast net connection, it's much faster to send only a file's changes rather than the whole file to the server. At first glance, this might not seem that important, but imagine the repercussions if you try to commit a one line change to a 400MB file and have to send the whole file to the server!"
msgstr ""

#: en.xml:3508(title) 
msgid "Resolve Conflicts (Merging Others' Changes)"
msgstr ""

#: en.xml:3510(para) 
msgid "We've already seen how <command moreinfo=\"none\">svn status -u</command> can predict conflicts. Suppose you run <command moreinfo=\"none\">svn update</command> and some interesting things occur:"
msgstr ""

#: en.xml:3514(screen) 
#, no-wrap
msgid "\n$ svn update\nU  INSTALL\nG  README\nC  bar.c\nUpdated to revision 46.\n"
msgstr ""

#: en.xml:3522(para) 
msgid "The <computeroutput moreinfo=\"none\">U</computeroutput> and <computeroutput moreinfo=\"none\">G</computeroutput> codes are no cause for concern; those files cleanly absorbed changes from the repository. The files marked with <computeroutput moreinfo=\"none\">U</computeroutput> contained no local changes but were <computeroutput moreinfo=\"none\">U</computeroutput>pdated with changes from the repository. The <computeroutput moreinfo=\"none\">G</computeroutput> stands for mer<computeroutput moreinfo=\"none\">G</computeroutput>ed, which means that the file had local changes to begin with, but the changes coming from the repository didn't overlap with the local changes."
msgstr ""

#: en.xml:3534(para) 
msgid "But the <computeroutput moreinfo=\"none\">C</computeroutput> stands for conflict. This means that the changes from the server overlapped with your own, and now you have to manually choose between them."
msgstr ""

#: en.xml:3539(para) 
msgid "Whenever a conflict occurs, three things typically occur to assist you in noticing and resolving that conflict:"
msgstr ""

#: en.xml:3545(para) 
msgid "Subversion prints a <computeroutput moreinfo=\"none\">C</computeroutput> during the update, and remembers that the file is in a state of conflict."
msgstr ""

#: en.xml:3551(para) 
msgid "If Subversion considers the file to be of a mergeable type, it places <firstterm>conflict markers</firstterm>—special strings of text which delimit the <quote>sides</quote> of the conflict—into the file to visibly demonstrate the overlapping areas. (Subversion uses the <literal moreinfo=\"none\">svn:mime-type</literal> property to decide if a file is capable of contextual, line-based merging. See <xref linkend=\"svn.advanced.props.special.mime-type\"/> to learn more.)"
msgstr ""

#: en.xml:3563(para) 
msgid "For every conflicted file, Subversion places up to three extra unversioned files in your working copy:"
msgstr ""

#: en.xml:3569(filename) 
msgid "filename.mine"
msgstr ""

#: en.xml:3571(para) 
msgid "This is your file as it existed in your working copy before you updated your working copy—that is, without conflict markers. This file has your latest changes in it and nothing else. (If Subversion considers the file to be unmergeable, then the <filename moreinfo=\"none\">.mine</filename> file isn't created, since it would be identical to the working file.)"
msgstr ""

#: en.xml:3583(filename) 
msgid "filename.rOLDREV"
msgstr ""

#: en.xml:3585(para) 
msgid "This is the file that was the <literal moreinfo=\"none\">BASE</literal> revision before you updated your working copy. That is, the file that you checked out before you made your latest edits."
msgstr ""

#: en.xml:3594(filename) 
msgid "filename.rNEWREV"
msgstr ""

#: en.xml:3596(para) 
msgid "This is the file that your Subversion client just received from the server when you updated your working copy. This file corresponds to the <literal moreinfo=\"none\">HEAD</literal> revision of the repository."
msgstr ""

#: en.xml:3606(para) 
msgid "Here <literal moreinfo=\"none\">OLDREV</literal> is the revision number of the file in your <filename moreinfo=\"none\">.svn</filename> directory and <literal moreinfo=\"none\">NEWREV</literal> is the revision number of the repository <literal moreinfo=\"none\">HEAD</literal>."
msgstr ""

#: en.xml:3614(para) 
msgid "For example, Sally makes changes to the file <filename moreinfo=\"none\">sandwich.txt</filename> in the repository. Harry has just changed the file in his working copy and checked it in. Sally updates her working copy before checking in and she gets a conflict:"
msgstr ""

#: en.xml:3620(screen) 
#, no-wrap
msgid "\n$ svn update\nC  sandwich.txt\nUpdated to revision 2.\n$ ls -1\nsandwich.txt\nsandwich.txt.mine\nsandwich.txt.r1\nsandwich.txt.r2\n"
msgstr ""

#: en.xml:3631(para) 
msgid "At this point, Subversion will <emphasis>not</emphasis> allow you to commit the file <filename moreinfo=\"none\">sandwich.txt</filename> until the three temporary files are removed."
msgstr ""

#: en.xml:3635(screen) 
#, no-wrap
msgid "\n$ svn commit --message \"Add a few more things\"\nsvn: Commit failed (details follow):\nsvn: Aborting commit: '/home/sally/svn-work/sandwich.txt' remains in conflict\n"
msgstr ""

#: en.xml:3641(para) 
msgid "If you get a conflict, you need to do one of three things:"
msgstr ""

#: en.xml:3647(para) 
msgid "Merge the conflicted text <quote>by hand</quote> (by examining and editing the conflict markers within the file)."
msgstr ""

#: en.xml:3653(para) 
msgid "Copy one of the temporary files on top of your working file."
msgstr ""

#: en.xml:3658(para) 
msgid "Run <command moreinfo=\"none\">svn revert &lt;filename&gt;</command> to throw away all of your local changes."
msgstr ""

#: en.xml:3668(para) 
msgid "You can always remove the temporary files yourself, but would you really want to do that when Subversion can do it for you? We didn't think so."
msgstr ""

#: en.xml:3664(para) 
msgid "Once you've resolved the conflict, you need to let Subversion know by running <command moreinfo=\"none\">svn resolved</command>. This removes the three temporary files and Subversion no longer considers the file to be in a state of conflict.<footnote><placeholder-1/></footnote>"
msgstr ""

#: en.xml:3673(screen) 
#, no-wrap
msgid "\n$ svn resolved sandwich.txt\nResolved conflicted state of 'sandwich.txt'\n"
msgstr ""

#: en.xml:3679(title) 
msgid "Merging Conflicts by Hand"
msgstr ""

#: en.xml:3681(para) 
msgid "Merging conflicts by hand can be quite intimidating the first time you attempt it, but with a little practice, it can become as easy as falling off a bike."
msgstr ""

#: en.xml:3685(para) 
msgid "Here's an example. Due to a miscommunication, you and Sally, your collaborator, both edit the file <filename moreinfo=\"none\">sandwich.txt</filename> at the same time. Sally commits her changes, and when you go to update your working copy, you get a conflict and we're going to have to edit <filename moreinfo=\"none\">sandwich.txt</filename> to resolve the conflicts. First, let's take a look at the file:"
msgstr ""

#: en.xml:3693(screen) 
#, no-wrap
msgid "\n$ cat sandwich.txt\nTop piece of bread\nMayonnaise\nLettuce\nTomato\nProvolone\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine\nSalami\nMortadella\nProsciutto\n=======\nSauerkraut\nGrilled Chicken\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2\nCreole Mustard\nBottom piece of bread\n"
msgstr ""

#: en.xml:3712(para) 
msgid "The strings of less-than signs, equal signs, and greater-than signs are conflict markers, and are not part of the actual data in conflict. You generally want to ensure that those are removed from the file before your next commit. The text between the first two sets of markers is composed of the changes you made in the conflicting area:"
msgstr ""

#: en.xml:3720(screen) 
#, no-wrap
msgid "\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine\nSalami\nMortadella\nProsciutto\n=======\n"
msgstr ""

#: en.xml:3728(para) 
msgid "The text between the second and third sets of conflict markers is the text from Sally's commit:"
msgstr ""

#: en.xml:3731(screen) 
#, no-wrap
msgid "\n=======\nSauerkraut\nGrilled Chicken\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2\n"
msgstr ""

#: en.xml:3743(para) 
msgid "And if you ask them for it, they may very well ride you out of town on a rail."
msgstr ""

#: en.xml:3738(para) 
msgid "Usually you won't want to just delete the conflict markers and Sally's changes—she's going to be awfully surprised when the sandwich arrives and it's not what she wanted. So this is where you pick up the phone or walk across the office and explain to Sally that you can't get sauerkraut from an Italian deli.<placeholder-1/> Once you've agreed on the changes you will check in, edit your file and remove the conflict markers."
msgstr ""

#: en.xml:3749(screen) 
#, no-wrap
msgid "\nTop piece of bread\nMayonnaise\nLettuce\nTomato\nProvolone\nSalami\nMortadella\nProsciutto\nCreole Mustard\nBottom piece of bread\n"
msgstr ""

#: en.xml:3762(para) 
msgid "Now run <command moreinfo=\"none\">svn resolved</command>, and you're ready to commit your changes:"
msgstr ""

#: en.xml:3765(screen) 
#, no-wrap
msgid "\n$ svn resolved sandwich.txt\n$ svn commit -m \"Go ahead and use my sandwich, discarding Sally's edits.\"\n"
msgstr ""

#: en.xml:3770(para) 
msgid "Remember, if you ever get confused while editing the conflicted file, you can always consult the three files that Subversion creates for you in your working copy—including your file as it was before you updated. You can even use a third-party interactive merging tool to examine those three files."
msgstr ""

#: en.xml:3780(title) 
msgid "Copying a File Onto Your Working File"
msgstr ""

#: en.xml:3782(para) 
msgid "If you get a conflict and decide that you want to throw out your changes, you can merely copy one of the temporary files created by Subversion over the file in your working copy:"
msgstr ""

#: en.xml:3787(screen) 
#, no-wrap
msgid "\n$ svn update\nC  sandwich.txt\nUpdated to revision 2.\n$ ls sandwich.*\nsandwich.txt  sandwich.txt.mine  sandwich.txt.r2  sandwich.txt.r1\n$ cp sandwich.txt.r2 sandwich.txt\n$ svn resolved sandwich.txt\n"
msgstr ""

#: en.xml:3800(title) 
msgid "Punting: Using <command moreinfo=\"none\">svn revert</command>"
msgstr ""

#: en.xml:3802(para) 
msgid "If you get a conflict, and upon examination decide that you want to throw out your changes and start your edits again, just revert your changes:"
msgstr ""

#: en.xml:3806(screen) 
#, no-wrap
msgid "\n$ svn revert sandwich.txt\nReverted 'sandwich.txt'\n$ ls sandwich.*\nsandwich.txt\n"
msgstr ""

#: en.xml:3813(para) 
msgid "Note that when you revert a conflicted file, you don't have to run <command moreinfo=\"none\">svn resolved</command>."
msgstr ""

#: en.xml:3818(para) 
msgid "Now you're ready to check in your changes. Note that <command moreinfo=\"none\">svn resolved</command>, unlike most of the other commands we've dealt with in this chapter, requires an argument. In any case, you want to be careful and only run <command moreinfo=\"none\">svn resolved</command> when you're certain that you've fixed the conflict in your file—once the temporary files are removed, Subversion will let you commit the file even if it still contains conflict markers."
msgstr ""

#: en.xml:3831(title) 
msgid "Commit Your Changes"
msgstr ""

#: en.xml:3833(para) 
msgid "Finally! Your edits are finished, you've merged all changes from the server, and you're ready to commit your changes to the repository."
msgstr ""

#: en.xml:3837(para) 
msgid "The <command moreinfo=\"none\">svn commit</command> command sends all of your changes to the repository. When you commit a change, you need to supply a <firstterm>log message</firstterm>, describing your change. Your log message will be attached to the new revision you create. If your log message is brief, you may wish to supply it on the command line using the <option>--message</option> (or <option>-m</option>) option:"
msgstr ""

#: en.xml:3853(para) 
msgid "However, if you've been composing your log message as you work, you may want to tell Subversion to get the message from a file by passing the filename with the <option>--file</option> switch:"
msgstr ""

#: en.xml:3858(screen) 
#, no-wrap
msgid "\n$ svn commit --file logmsg \nSending        sandwich.txt\nTransmitting file data .\nCommitted revision 4.\n"
msgstr ""

#: en.xml:3865(para) 
msgid "If you fail to specify either the <option>--message</option> or <option>--file</option> switch, then Subversion will automatically launch your favorite editor (see the <literal moreinfo=\"none\">editor-cmd</literal> section in <xref linkend=\"svn.advanced.confarea.opts.config\"/>) for composing a log message."
msgstr ""

#: en.xml:3874(para) 
msgid "If you're in your editor writing a commit message and decide that you want to cancel your commit, you can just quit your editor without saving changes. If you've already saved your commit message, simply delete the text and save again."
msgstr ""

#: en.xml:3880(screen) 
#, no-wrap
msgid "\n$ svn commit\nWaiting for Emacs...Done\n\nLog message unchanged or not specified\na)bort, c)ontinue, e)dit\na\n$\n"
msgstr ""

#: en.xml:3891(para) 
msgid "The repository doesn't know or care if your changes make any sense as a whole; it only checks to make sure that nobody else has changed any of the same files that you did when you weren't looking. If somebody <emphasis>has</emphasis> done that, the entire commit will fail with a message informing you that one or more of your files is out-of-date:"
msgstr ""

#: en.xml:3898(screen) 
#, no-wrap
msgid "\n$ svn commit --message \"Add another rule\"\nSending        rules.txt\nsvn: Commit failed (details follow):\nsvn: Out of date: 'rules.txt' in transaction 'g'\n"
msgstr ""

#: en.xml:3905(para) 
msgid "At this point, you need to run <command moreinfo=\"none\">svn update</command>, deal with any merges or conflicts that result, and attempt your commit again."
msgstr ""

#: en.xml:3910(para) 
msgid "That covers the basic work cycle for using Subversion. There are many other features in Subversion that you can use to manage your repository and working copy, but you can get by quite easily using only the commands that we've discussed so far in this chapter."
msgstr ""

#: en.xml:3924(title) 
msgid "Examining History"
msgstr ""

#: en.xml:3926(para) 
msgid "As we mentioned earlier, the repository is like a time machine. It keeps a record of every change ever committed, and allows you to explore this history by examining previous versions of files and directories as well as the metadata that accompanies them. With a single Subversion command, you can check out the repository (or restore an existing working copy) exactly as it was at any date or revision number in the past. However, sometimes you just want to <emphasis>peer into</emphasis> the past instead of <emphasis>going into</emphasis> the past."
msgstr ""

#: en.xml:3937(para) 
msgid "There are several commands that can provide you with historical data from the repository:"
msgstr ""

#: en.xml:3943(command) en.xml:3981(command) en.xml:19492(refname) 
msgid "svn log"
msgstr ""

#: en.xml:3945(para) 
msgid "Shows you broad information: log messages with date and author information attached to revisions, and which paths changed in each revision."
msgstr ""

#: en.xml:3954(para) 
msgid "Shows you the specific details of how a file changed over time."
msgstr ""

#: en.xml:3960(command) en.xml:4220(command) en.xml:17964(refname) 
msgid "svn cat"
msgstr ""

#: en.xml:3962(para) 
msgid "This is used to retrieve any file as it existed in a particular revision number and display it on your screen."
msgstr ""

#: en.xml:3969(command) en.xml:4264(command) en.xml:19294(refname) 
msgid "svn list"
msgstr ""

#: en.xml:3971(para) 
msgid "Displays the files in a directory for any given revision."
msgstr ""

#: en.xml:3983(para) 
msgid "To find information about the history of a file or directory, use the <command moreinfo=\"none\">svn log</command> command. <command moreinfo=\"none\">svn log</command> will provide you with a record of who made changes to a file or directory, at what revision it changed, the time and date of that revision, and, if it was provided, the log message that accompanied the commit."
msgstr ""

#: en.xml:3991(screen) 
#, no-wrap
msgid "\n$ svn log\n------------------------------------------------------------------------\nr3 | sally | Mon, 15 Jul 2002 18:03:46 -0500 | 1 line\n\nAdded include lines and corrected # of cheese slices.\n------------------------------------------------------------------------\nr2 | harry | Mon, 15 Jul 2002 17:47:57 -0500 | 1 line\n\nAdded main() methods.\n------------------------------------------------------------------------\nr1 | sally | Mon, 15 Jul 2002 17:40:08 -0500 | 1 line\n\nInitial import\n------------------------------------------------------------------------\n"
msgstr ""

#: en.xml:4008(para) 
msgid "Note that the log messages are printed in <emphasis>reverse chronological order</emphasis> by default. If you wish to see a different range of revisions in a particular order, or just a single revision, pass the <option>--revision</option> (<option>-r</option>) switch:"
msgstr ""

#: en.xml:4015(screen) 
#, no-wrap
msgid "\n$ svn log --revision 5:19    # shows logs 5 through 19 in chronological order\n\n$ svn log -r 19:5            # shows logs 5 through 19 in reverse order\n\n$ svn log -r 8               # shows log for revision 8\n"
msgstr ""

#: en.xml:4023(para) 
msgid "You can also examine the log history of a single file or directory. For example:"
msgstr ""

#: en.xml:4026(screen) 
#, no-wrap
msgid "\n$ svn log foo.c\n…\n$ svn log http://foo.com/svn/trunk/code/foo.c\n…\n"
msgstr ""

#: en.xml:4033(para) 
msgid "These will display log messages <emphasis>only</emphasis> for those revisions in which the working file (or URL) changed."
msgstr ""

#: en.xml:4037(para) 
msgid "If you want even more information about a file or directory, <command moreinfo=\"none\">svn log</command> also takes a <option>--verbose</option> (<option>-v</option>) switch. Because Subversion allows you to move and copy files and directories, it is important to be able to track path changes in the filesystem, so in verbose mode, <command moreinfo=\"none\">svn log</command> will include a list of changed paths in a revision in its output:"
msgstr ""

#: en.xml:4046(screen) 
#, no-wrap
msgid "\n$ svn log -r 8 -v\n------------------------------------------------------------------------\nr8 | sally | 2002-07-14 08:15:29 -0500 | 1 line\nChanged paths:\nM /trunk/code/foo.c\nM /trunk/code/bar.h\nA /trunk/code/doc/README\n\nFrozzled the sub-space winch.\n\n------------------------------------------------------------------------\n"
msgstr ""

#: en.xml:4060(para) 
msgid "<command moreinfo=\"none\">svn log</command> also takes a <option>--quiet</option> (<option>-q</option>) switch, which suppresses the body of the log message. When combined with <option>--verbose</option>, it gives just the names of the changed files."
msgstr ""

#: en.xml:4067(title) 
msgid "Why Does <command moreinfo=\"none\">svn log</command> Give Me an Empty Response?"
msgstr ""

#: en.xml:4070(para) 
msgid "After working with Subversion for a bit, most users will come across something like this:"
msgstr ""

#: en.xml:4073(screen) 
#, no-wrap
msgid "\n$ svn log -r 2\n------------------------------------------------------------------------\n$\n"
msgstr ""

#: en.xml:4079(para) 
msgid "At first glance, this seems like an error. But recall that while revisions are repository-wide, <command moreinfo=\"none\">svn log</command> operates on a path in the repository. If you supply no path, Subversion uses the current working directory as the default target. As a result, if you're operating in a subdirectory of your working copy and attempt to see the log of a revision in which neither that directory nor any of its children was changed, Subversion will show you an empty log. If you want to see what changed in that revision, try pointing <command moreinfo=\"none\">svn log</command> directly at the top-most URL of your repository, as in <command moreinfo=\"none\">svn log -r 2 http://svn.collab.net/repos/svn</command>."
msgstr ""

#: en.xml:4100(para) 
msgid "We've already seen <command moreinfo=\"none\">svn diff</command> before—it displays file differences in unified diff format; it was used to show the local modifications made to our working copy before committing to the repository."
msgstr ""

#: en.xml:4105(para) 
msgid "In fact, it turns out that there are <emphasis>three</emphasis> distinct uses of <command moreinfo=\"none\">svn diff</command>:"
msgstr ""

#: en.xml:4112(para) 
msgid "Examine local changes"
msgstr ""

#: en.xml:4116(para) 
msgid "Compare your working copy to the repository"
msgstr ""

#: en.xml:4120(para) 
msgid "Compare repository to repository"
msgstr ""

#: en.xml:4126(title) 
msgid "Examining Local Changes"
msgstr ""

#: en.xml:4128(para) 
msgid "As we've seen, invoking <command moreinfo=\"none\">svn diff</command> with no switches will compare your working files to the cached <quote>pristine</quote> copies in the <filename moreinfo=\"none\">.svn</filename> area:"
msgstr ""

#: en.xml:4133(screen) 
#, no-wrap
msgid "\n$ svn diff\nIndex: rules.txt\n===================================================================\n--- rules.txt\t(revision 3)\n+++ rules.txt\t(working copy)\n@@ -1,4 +1,5 @@\n Be kind to others\n Freedom = Responsibility\n Everything in moderation\n-Chew with your mouth open\n+Chew with your mouth closed\n+Listen when others are speaking\n$\n"
msgstr ""

#: en.xml:4152(title) 
msgid "Comparing Working Copy to Repository"
msgstr ""

#: en.xml:4154(para) 
msgid "If a single <option>--revision</option> (<option>-r</option>) number is passed, then your working copy is compared to the specified revision in the repository."
msgstr ""

#: en.xml:4159(screen) 
#, no-wrap
msgid "\n$ svn diff --revision 3 rules.txt \nIndex: rules.txt\n===================================================================\n--- rules.txt\t(revision 3)\n+++ rules.txt\t(working copy)\n@@ -1,4 +1,5 @@\n Be kind to others\n Freedom = Responsibility\n Everything in moderation\n-Chew with your mouth open\n+Chew with your mouth closed\n+Listen when others are speaking\n$\n"
msgstr ""

#: en.xml:4178(title) 
msgid "Comparing Repository to Repository"
msgstr ""

#: en.xml:4180(para) 
msgid "If two revision numbers, separated by a colon, are passed via <option>--revision</option> (<option>-r</option>), then the two revisions are directly compared."
msgstr ""

#: en.xml:4185(screen) 
#, no-wrap
msgid "\n$ svn diff --revision 2:3 rules.txt \nIndex: rules.txt\n===================================================================\n--- rules.txt\t(revision 2)\n+++ rules.txt\t(revision 3)\n@@ -1,4 +1,4 @@\n Be kind to others\n-Freedom = Chocolate Ice Cream\n+Freedom = Responsibility\n Everything in moderation\n Chew with your mouth open\n$\n"
msgstr ""

#: en.xml:4200(para) 
msgid "Not only can you use <command moreinfo=\"none\">svn diff</command> to compare files in your working copy to the repository, but if you supply a URL argument, you can examine the differences between items in the repository without even having a working copy. This is especially useful if you wish to inspect changes in a file when you don't have a working copy on your local machine:"
msgstr ""

#: en.xml:4208(screen) 
#, no-wrap
msgid "\n$ svn diff --revision 4:5 http://svn.red-bean.com/repos/example/trunk/text/rules.txt\n…\n$\n"
msgstr ""

#: en.xml:4222(para) 
msgid "If you want to examine an earlier version of a file and not necessarily the differences between two files, you can use <command moreinfo=\"none\">svn cat</command>:"
msgstr ""

#: en.xml:4226(screen) 
#, no-wrap
msgid "\n$ svn cat --revision 2 rules.txt \nBe kind to others\nFreedom = Chocolate Ice Cream\nEverything in moderation\nChew with your mouth open\n$\n"
msgstr ""

#: en.xml:4235(para) 
msgid "You can also redirect the output directly into a file:"
msgstr ""

#: en.xml:4238(screen) 
#, no-wrap
msgid "\n$ svn cat --revision 2 rules.txt &gt; rules.txt.v2\n$\n"
msgstr ""

#: en.xml:4243(para) 
msgid "You're probably wondering why we don't just use <command moreinfo=\"none\">svn update --revision</command> to update the file to the older revision. There are a few reasons why we might prefer to use <command moreinfo=\"none\">svn cat</command>."
msgstr ""

#: en.xml:4248(para) 
msgid "First, you may want to see the differences between two revisions of a file using an external diff program (perhaps a graphical one, or perhaps your file is in such a format that the output of unified diff is nonsensical). In this case, you'll need to grab a copy of the old revision, redirect it to a file, and pass both that and the file in your working copy to your external diff program."
msgstr ""

#: en.xml:4256(para) 
msgid "Sometimes it's easier to look at an older version of a file in its entirety as opposed to just the differences between it and another revision."
msgstr ""

#: en.xml:4266(para) 
msgid "The <command moreinfo=\"none\">svn list</command> command shows you what files are in a repository directory without actually downloading the files to your local machine:"
msgstr ""

#: en.xml:4270(screen) 
#, no-wrap
msgid "\n$ svn list http://svn.collab.net/repos/svn\nREADME\nbranches/\nclients/\ntags/\ntrunk/\n"
msgstr ""

#: en.xml:4279(para) 
msgid "If you want a more detailed listing, pass the <option>--verbose</option> (<option>-v</option>) flag to get output like this:"
msgstr ""

#: en.xml:4283(screen) 
#, no-wrap
msgid "\n$ svn list --verbose http://svn.collab.net/repos/svn\n   2755 harry          1331 Jul 28 02:07 README\n   2773 sally               Jul 29 15:07 branches/\n   2769 sally               Jul 29 12:07 clients/\n   2698 harry               Jul 24 18:07 tags/\n   2785 sally               Jul 29 19:07 trunk/\n"
msgstr ""

#: en.xml:4292(para) 
msgid "The columns tell you the revision at which the file or directory was last modified, the user who modified it, the size if it is a file, the date it was last modified, and the item's name."
msgstr ""

#: en.xml:4301(title) 
msgid "A Final Word on History"
msgstr ""

#: en.xml:4307(para) 
msgid "See? We told you that Subversion was a time machine."
msgstr ""

#: en.xml:4303(para) 
msgid "In addition to all of the above commands, you can use <command moreinfo=\"none\">svn update</command> and <command moreinfo=\"none\">svn checkout</command> with the <option>--revision</option> switch to take an entire working copy <quote>back in time</quote><placeholder-1/>:"
msgstr ""

#: en.xml:4310(screen) 
#, no-wrap
msgid "\n$ svn checkout --revision 1729 # Checks out a new working copy at r1729\n…\n$ svn update --revision 1729 # Updates an existing working copy to r1729\n…\n"
msgstr ""

#: en.xml:4326(title) 
msgid "Other Useful Commands"
msgstr ""

#: en.xml:4328(para) 
msgid "While not as frequently used as the commands previously discussed in this chapter, you will occasionally need these commands."
msgstr ""

#: en.xml:4334(command) en.xml:18172(refname) 
msgid "svn cleanup"
msgstr ""

#: en.xml:4336(para) 
msgid "When Subversion modifies your working copy (or any information within <filename moreinfo=\"none\">.svn</filename>), it tries to do so as safely as possible. Before changing the working copy, Subversion writes its intentions to a log file. Next it executes the commands in the log file to apply the requested change, holding a lock on the relevant part of the working copy while it works — to prevent other Subversion clients from accessing the working copy in mid-change. Finally, Subversion removes the log file. Architecturally, this is similar to a journaled filesystem. If a Subversion operation is interrupted (if the process is killed, or if the machine crashes, for example), the log files remain on disk. By re-executing the log files, Subversion can complete the previously started operation, and your working copy can get itself back into a consistent state."
msgstr ""

#: en.xml:4352(para) 
msgid "And this is exactly what <command moreinfo=\"none\">svn cleanup</command> does: it searches your working copy and runs any leftover logs, removing working copy locks in the process. If Subversion ever tells you that some part of your working copy is <quote>locked</quote>, then this is the command that you should run. Also, <command moreinfo=\"none\">svn status</command> will display an <literal moreinfo=\"none\">L</literal> next to locked items:"
msgstr ""

#: en.xml:4360(screen) 
#, no-wrap
msgid "\n$ svn status\n  L    somedir\nM      somedir/foo.c \n\n$ svn cleanup\n$ svn status\nM      somedir/foo.c\n"
msgstr ""

#: en.xml:4370(para) 
msgid "Don't confuse these working copy locks with the ordinary locks that Subversion users create when using the <quote>lock-modify-unlock</quote> model of concurrent version control; see <xref linkend=\"svn.advanced.locking.meanings\"/> for clarification."
msgstr ""

#: en.xml:4382(command) en.xml:19045(refname) 
msgid "svn import"
msgstr ""

#: en.xml:4384(para) 
msgid "The <command moreinfo=\"none\">svn import</command> command is a quick way to copy an unversioned tree of files into a repository, creating intermediate directories as necessary."
msgstr ""

#: en.xml:4388(screen) 
#, no-wrap
msgid "\n$ svnadmin create /usr/local/svn/newrepos\n$ svn import mytree file:///usr/local/svn/newrepos/some/project \\\n             -m \"Initial import\"\nAdding         mytree/foo.c\nAdding         mytree/bar.c\nAdding         mytree/subdir\nAdding         mytree/subdir/quux.h\n\nCommitted revision 1.\n"
msgstr ""

#: en.xml:4400(para) 
msgid "The previous example copied the contents of directory <filename moreinfo=\"none\">mytree</filename> under the directory <filename moreinfo=\"none\">some/project</filename> in the repository:"
msgstr ""

#: en.xml:4404(screen) 
#, no-wrap
msgid "\n$ svn list file:///usr/local/svn/newrepos/some/project\nbar.c\nfoo.c\nsubdir/\n"
msgstr ""

#: en.xml:4411(para) 
msgid "Note that after the import is finished, the original tree is <emphasis>not</emphasis> converted into a working copy. To start working, you still need to <command moreinfo=\"none\">svn checkout</command> a fresh working copy of the tree."
msgstr ""

#: en.xml:4426(para) 
msgid "Now we've covered most of the Subversion client commands. Notable exceptions are those dealing with branching and merging (see <xref linkend=\"svn.branchmerge\"/>) and properties (see <xref linkend=\"svn.advanced.props\"/>). However, you may want to take a moment to skim through <xref linkend=\"svn.ref\"/> to get an idea of all the many different commands that Subversion has—and how you can use them to make your work easier."
msgstr ""

#: en.xml:4446(title) 
msgid "Branching and Merging"
msgstr ""

#: en.xml:4450(para) 
msgid "Branching, tagging, and merging are concepts common to almost all version control systems. If you're not familiar with these ideas, we provide a good introduction in this chapter. If you are familiar, then hopefully you'll find it interesting to see how Subversion implements these ideas."
msgstr ""

#: en.xml:4456(para) 
msgid "Branching is a fundamental part of version control. If you're going to allow Subversion to manage your data, then this is a feature you'll eventually come to depend on. This chapter assumes that you're already familiar with Subversion's basic concepts (<xref linkend=\"svn.basic\"/>)."
msgstr ""

#: en.xml:4468(title) 
msgid "What's a Branch?"
msgstr ""

#: en.xml:4470(para) 
msgid "Suppose it's your job to maintain a document for a division in your company, a handbook of some sort. One day a different division asks you for the same handbook, but with a few parts <quote>tweaked</quote> for them, since they do things slightly differently."
msgstr ""

#: en.xml:4476(para) 
msgid "What do you do in this situation? You do the obvious thing: you make a second copy of your document, and begin maintaining the two copies separately. As each department asks you to make small changes, you incorporate them into one copy or the other."
msgstr ""

#: en.xml:4482(para) 
msgid "You often want to make the same change to both copies. For example, if you discover a typo in the first copy, it's very likely that the same typo exists in the second copy. The two documents are almost the same, after all; they only differ in small, specific ways."
msgstr ""

#: en.xml:4488(para) 
msgid "This is the basic concept of a <firstterm>branch</firstterm>—namely, a line of development that exists independently of another line, yet still shares a common history if you look far enough back in time. A branch always begins life as a copy of something, and moves on from there, generating its own history (see <xref linkend=\"svn.branchmerge.whatis.dia-1\"/>)."
msgstr ""

#: en.xml:4496(title) 
msgid "Branches of development"
msgstr ""

#: en.xml:4500(para) 
msgid "Subversion has commands to help you maintain parallel branches of your files and directories. It allows you to create branches by copying your data, and remembers that the copies are related to one another. It also helps you duplicate changes from one branch to another. Finally, it can make portions of your working copy reflect different branches, so that you can <quote>mix and match</quote> different lines of development in your daily work."
msgstr ""

#: en.xml:4515(title) 
msgid "Using Branches"
msgstr ""

#: en.xml:4517(para) 
msgid "At this point, you should understand how each commit creates an entire new filesystem tree (called a <quote>revision</quote>) in the repository. If not, go back and read about revisions in <xref linkend=\"svn.basic.in-action.revs\"/>."
msgstr ""

#: en.xml:4522(para) 
msgid "For this chapter, we'll go back to the same example from <xref linkend=\"svn.basic\"/>. Remember that you and your collaborator, Sally, are sharing a repository that contains two projects, <filename moreinfo=\"none\">paint</filename> and <filename moreinfo=\"none\">calc</filename>. Notice that in <xref linkend=\"svn.branchmerge.using.dia-1\"/>, however, each project directory now contains subdirectories named <filename moreinfo=\"none\">trunk</filename> and <filename moreinfo=\"none\">branches</filename>. The reason for this will soon become clear."
msgstr ""

#: en.xml:4532(title) 
msgid "Starting repository layout"
msgstr ""

#: en.xml:4536(para) 
msgid "As before, assume that Sally and you both have working copies of the <quote>calc</quote> project. Specifically, you each have a working copy of <filename moreinfo=\"none\">/calc/trunk</filename>. All the files for the project are in this subdirectory rather than in <filename moreinfo=\"none\">/calc</filename> itself, because your team has decided that <filename moreinfo=\"none\">/calc/trunk</filename> is where the <quote>main line</quote> of development is going to take place."
msgstr ""

#: en.xml:4545(para) 
msgid "Let's say that you've been given the task of performing a radical reorganization of the project. It will take a long time to write, and will affect all the files in the project. The problem here is that you don't want to interfere with Sally, who is in the process of fixing small bugs here and there. She's depending on the fact that the latest version of the project (in <filename moreinfo=\"none\">/calc/trunk</filename>) is always usable. If you start committing your changes bit-by-bit, you'll surely break things for Sally."
msgstr ""

#: en.xml:4555(para) 
msgid "One strategy is to crawl into a hole: you and Sally can stop sharing information for a week or two. That is, start gutting and reorganizing all the files in your working copy, but don't commit or update until you're completely finished with the task. There are a number of problems with this, though. First, it's not very safe. Most people like to save their work to the repository frequently, should something bad accidentally happen to their working copy. Second, it's not very flexible. If you do your work on different computers (perhaps you have a working copy of <filename moreinfo=\"none\">/calc/trunk</filename> on two different machines), you'll need to manually copy your changes back and forth, or just do all the work on a single computer. By that same token, it's difficult to share your changes-in-progress with anyone else. A common software development <quote>best practice</quote> is to allow your peers to review your work as you go. If nobody sees your intermediate commits, you lose potential feedback. Finally, when you're finished with all your changes, you might find it very difficult to re-merge your final work with the rest of the company's main body of code. Sally (or others) may have made many other changes in the repository that are difficult to incorporate into your working copy—especially if you run <command moreinfo=\"none\">svn update</command> after weeks of isolation."
msgstr ""

#: en.xml:4579(para) 
msgid "The better solution is to create your own branch, or line of development, in the repository. This allows you to save your half-broken work frequently without interfering with others, yet you can still selectively share information with your collaborators. You'll see exactly how this works later on."
msgstr ""

#: en.xml:4588(title) 
msgid "Creating a Branch"
msgstr ""

#: en.xml:4590(para) 
msgid "Creating a branch is very simple—you make a copy of the project in the repository using the <command moreinfo=\"none\">svn copy</command> command. Subversion is not only able to copy single files, but whole directories as well. In this case, you want to make a copy of the <filename moreinfo=\"none\">/calc/trunk</filename> directory. Where should the new copy live? Wherever you wish—it's a matter of project policy. Let's say that your team has a policy of creating branches in the <filename moreinfo=\"none\">/calc/branches</filename> area of the repository, and you want to name your branch <literal moreinfo=\"none\">my-calc-branch</literal>. You'll want to create a new directory, <filename moreinfo=\"none\">/calc/branches/my-calc-branch</filename>, which begins its life as a copy of <filename moreinfo=\"none\">/calc/trunk</filename>."
msgstr ""

#: en.xml:4606(para) 
msgid "There are two different ways to make a copy. We'll demonstrate the messy way first, just to make the concept clear. To begin, check out a working copy of the project's root directory, <filename moreinfo=\"none\">/calc</filename>:"
msgstr ""

#: en.xml:4611(screen) 
#, no-wrap
msgid "\n$ svn checkout http://svn.example.com/repos/calc bigwc\nA  bigwc/trunk/\nA  bigwc/trunk/Makefile\nA  bigwc/trunk/integer.c\nA  bigwc/trunk/button.c\nA  bigwc/branches/\nChecked out revision 340.\n"
msgstr ""

#: en.xml:4621(para) 
msgid "Making a copy is now simply a matter of passing two working-copy paths to the <command moreinfo=\"none\">svn copy</command> command:"
msgstr ""

#: en.xml:4625(screen) 
#, no-wrap
msgid "\n$ cd bigwc\n$ svn copy trunk branches/my-calc-branch\n$ svn status\nA  +   branches/my-calc-branch\n"
msgstr ""

#: en.xml:4632(para) 
msgid "In this case, the <command moreinfo=\"none\">svn copy</command> command recursively copies the <filename moreinfo=\"none\">trunk</filename> working directory to a new working directory, <filename moreinfo=\"none\">branches/my-calc-branch</filename>. As you can see from the <command moreinfo=\"none\">svn status</command> command, the new directory is now scheduled for addition to the repository. But also notice the <quote>+</quote> sign next to the letter A. This indicates that the scheduled addition is a <emphasis>copy</emphasis> of something, not something new. When you commit your changes, Subversion will create <filename moreinfo=\"none\">/calc/branches/my-calc-branch</filename> in the repository by copying <filename moreinfo=\"none\">/calc/trunk</filename>, rather than resending all of the working copy data over the network:"
msgstr ""

#: en.xml:4647(screen) 
#, no-wrap
msgid "\n$ svn commit -m \"Creating a private branch of /calc/trunk.\"\nAdding         branches/my-calc-branch\nCommitted revision 341.\n"
msgstr ""

#: en.xml:4653(para) 
msgid "And now the easier method of creating a branch, which we should have told you about in the first place: <command moreinfo=\"none\">svn copy</command> is able to operate directly on two URLs."
msgstr ""

#: en.xml:4657(screen) 
#, no-wrap
msgid "\n$ svn copy http://svn.example.com/repos/calc/trunk \\\n           http://svn.example.com/repos/calc/branches/my-calc-branch \\\n      -m \"Creating a private branch of /calc/trunk.\"\n\nCommitted revision 341.\n"
msgstr ""

#: en.xml:4671(para) 
msgid "Subversion does not support cross-repository copying. When using URLs with <command moreinfo=\"none\">svn copy</command> or <command moreinfo=\"none\">svn move</command>, you can only copy items within the same repository."
msgstr ""

#: en.xml:4665(para) 
msgid "There's really no difference between these two methods. Both procedures create a new directory in revision 341, and the new directory is a copy of <filename moreinfo=\"none\">/calc/trunk</filename>. This is shown in <xref linkend=\"svn.branchmerge.using.create.dia-1\"/>. Notice that the second method, however, performs an <emphasis>immediate</emphasis> commit. <footnote><placeholder-1/></footnote> It's an easier procedure, because it doesn't require you to check out a large mirror of the repository. In fact, this technique doesn't even require you to have a working copy at all."
msgstr ""

#: en.xml:4682(title) 
msgid "Repository with new copy"
msgstr ""

#: en.xml:4687(title) 
msgid "Cheap Copies"
msgstr ""

#: en.xml:4689(para) 
msgid "Subversion's repository has a special design. When you copy a directory, you don't need to worry about the repository growing huge—Subversion doesn't actually duplicate any data. Instead, it creates a new directory entry that points to an <emphasis>existing</emphasis> tree. If you're a Unix user, this is the same concept as a hard-link. From there, the copy is said to be <quote>lazy</quote>. That is, if you commit a change to one file within the copied directory, then only that file changes—the rest of the files continue to exist as links to the original files in the original directory."
msgstr ""

#: en.xml:4702(para) 
msgid "This is why you'll often hear Subversion users talk about <quote>cheap copies</quote>. It doesn't matter how large the directory is—it takes a very tiny, constant amount of time to make a copy of it. In fact, this feature is the basis of how commits work in Subversion: each revision is a <quote>cheap copy</quote> of the previous revision, with a few items lazily changed within. (To read more about this, visit Subversion's website and read about the <quote>bubble up</quote> method in Subversion's design documents.)"
msgstr ""

#: en.xml:4713(para) 
msgid "Of course, these internal mechanics of copying and sharing data are hidden from the user, who simply sees copies of trees. The main point here is that copies are cheap, both in time and space. Make branches as often as you want."
msgstr ""

#: en.xml:4724(title) 
msgid "Working with Your Branch"
msgstr ""

#: en.xml:4726(para) 
msgid "Now that you've created a branch of the project, you can check out a new working copy to start using it:"
msgstr ""

#: en.xml:4729(screen) 
#, no-wrap
msgid "\n$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch\nA  my-calc-branch/Makefile\nA  my-calc-branch/integer.c\nA  my-calc-branch/button.c\nChecked out revision 341.\n"
msgstr ""

#: en.xml:4737(para) 
msgid "There's nothing special about this working copy; it simply mirrors a different directory in the repository. When you commit changes, however, Sally won't ever see them when she updates. Her working copy is of <filename moreinfo=\"none\">/calc/trunk</filename>. (Be sure to read <xref linkend=\"svn.branchmerge.switchwc\"/> later in this chapter: the <command moreinfo=\"none\">svn switch</command> command is an alternate way of creating a working copy of a branch.)"
msgstr ""

#: en.xml:4745(para) 
msgid "Let's pretend that a week goes by, and the following commits happen:"
msgstr ""

#: en.xml:4749(para) 
msgid "You make a change to <filename moreinfo=\"none\">/calc/branches/my-calc-branch/button.c</filename>, which creates revision 342."
msgstr ""

#: en.xml:4755(para) 
msgid "You make a change to <filename moreinfo=\"none\">/calc/branches/my-calc-branch/integer.c</filename>, which creates revision 343."
msgstr ""

#: en.xml:4761(para) 
msgid "Sally makes a change to <filename moreinfo=\"none\">/calc/trunk/integer.c</filename>, which creates revision 344."
msgstr ""

#: en.xml:4768(para) 
msgid "There are now two independent lines of development, shown in <xref linkend=\"svn.branchmerge.using.work.dia-1\"/>, happening on <filename moreinfo=\"none\">integer.c</filename>."
msgstr ""

#: en.xml:4773(title) 
msgid "The branching of one file's history"
msgstr ""

#: en.xml:4777(para) 
msgid "Things get interesting when you look at the history of changes made to your copy of <filename moreinfo=\"none\">integer.c</filename>:"
msgstr ""

#: en.xml:4781(screen) 
#, no-wrap
msgid "\n$ pwd\n/home/user/my-calc-branch\n\n$ svn log --verbose integer.c\n------------------------------------------------------------------------\nr343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines\nChanged paths:\n   M /calc/branches/my-calc-branch/integer.c\n\n* integer.c:  frozzled the wazjub.\n\n------------------------------------------------------------------------\nr341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines\nChanged paths:\n   A /calc/branches/my-calc-branch (from /calc/trunk:340)\n\nCreating a private branch of /calc/trunk.\n\n------------------------------------------------------------------------\nr303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines\nChanged paths:\n   M /calc/trunk/integer.c\n\n* integer.c:  changed a docstring.\n\n------------------------------------------------------------------------\nr98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines\nChanged paths:\n   M /calc/trunk/integer.c\n\n* integer.c:  adding this file to the project.\n\n------------------------------------------------------------------------\n"
msgstr ""

#: en.xml:4817(para) 
msgid "Notice that Subversion is tracing the history of your branch's <filename moreinfo=\"none\">integer.c</filename> all the way back through time, even traversing the point where it was copied. It shows the creation of the branch as an event in the history, because <filename moreinfo=\"none\">integer.c</filename> was implicitly copied when all of <filename moreinfo=\"none\">/calc/trunk/</filename> was copied. Now look what happens when Sally runs the same command on her copy of the file:"
msgstr ""

#: en.xml:4826(screen) 
#, no-wrap
msgid "\n$ pwd\n/home/sally/calc\n\n$ svn log --verbose integer.c\n------------------------------------------------------------------------\nr344 | sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines\nChanged paths:\n   M /calc/trunk/integer.c\n\n* integer.c:  fix a bunch of spelling errors.\n\n------------------------------------------------------------------------\nr303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines\nChanged paths:\n   M /calc/trunk/integer.c\n\n* integer.c:  changed a docstring.\n\n------------------------------------------------------------------------\nr98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines\nChanged paths:\n   M /calc/trunk/integer.c\n\n* integer.c:  adding this file to the project.\n\n------------------------------------------------------------------------\n"
msgstr ""

#: en.xml:4855(para) 
msgid "Sally sees her own revision 344 change, but not the change you made in revision 343. As far as Subversion is concerned, these two commits affected different files in different repository locations. However, Subversion <emphasis>does</emphasis> show that the two files share a common history. Before the branch-copy was made in revision 341, they used to be the same file. That's why you and Sally both see the changes made in revisions 303 and 98."
msgstr ""

#: en.xml:4868(title) 
msgid "The Key Concepts Behind Branches"
msgstr ""

#: en.xml:4870(para) 
msgid "There are two important lessons that you should remember from this section."
msgstr ""

#: en.xml:4875(para) 
msgid "Unlike many other version control systems, Subversion's branches exist as <emphasis>normal filesystem directories</emphasis> in the repository, not in an extra dimension. These directories just happen to carry some extra historical information."
msgstr ""

#: en.xml:4882(para) 
msgid "Subversion has no internal concept of a branch—only copies. When you copy a directory, the resulting directory is only a <quote>branch</quote> because <emphasis>you</emphasis> attach that meaning to it. You may think of the directory differently, or treat it differently, but to Subversion it's just an ordinary directory that happens to have been created by copying."
msgstr ""

#: en.xml:4901(title) 
msgid "Copying Changes Between Branches"
msgstr ""

#: en.xml:4903(para) 
msgid "Now you and Sally are working on parallel branches of the project: you're working on a private branch, and Sally is working on the <firstterm>trunk</firstterm>, or main line of development."
msgstr ""

#: en.xml:4908(para) 
msgid "For projects that have a large number of contributors, it's common for most people to have working copies of the trunk. Whenever someone needs to make a long-running change that is likely to disrupt the trunk, a standard procedure is to create a private branch and commit changes there until all the work is complete."
msgstr ""

#: en.xml:4915(para) 
msgid "So, the good news is that you and Sally aren't interfering with each other. The bad news is that it's very easy to drift <emphasis>too</emphasis> far apart. Remember that one of the problems with the <quote>crawl in a hole</quote> strategy is that by the time you're finished with your branch, it may be near-impossible to merge your changes back into the trunk without a huge number of conflicts."
msgstr ""

#: en.xml:4923(para) 
msgid "Instead, you and Sally might continue to share changes as you work. It's up to you to decide which changes are worth sharing; Subversion gives you the ability to selectively <quote>copy</quote> changes between branches. And when you're completely finished with your branch, your entire set of branch changes can be copied back into the trunk."
msgstr ""

#: en.xml:4933(title) 
msgid "Copying Specific Changes"
msgstr ""

#: en.xml:4936(para) 
msgid "In the previous section, we mentioned that both you and Sally made changes to <filename moreinfo=\"none\">integer.c</filename> on different branches. If you look at Sally's log message for revision 344, you can see that she fixed some spelling errors. No doubt, your copy of the same file still has the same spelling errors. It's likely that your future changes to this file will be affecting the same areas that have the spelling errors, so you're in for some potential conflicts when you merge your branch someday. It's better, then, to receive Sally's change now, <emphasis>before</emphasis> you start working too heavily in the same places."
msgstr ""

#: en.xml:4948(para) 
msgid "It's time to use the <command moreinfo=\"none\">svn merge</command> command. This command, it turns out, is a very close cousin to the <command moreinfo=\"none\">svn diff</command> command (which you read about in <xref linkend=\"svn.tour\"/>). Both commands are able to compare any two objects in the repository and describe the differences. For example, you can ask <command moreinfo=\"none\">svn diff</command> to show you the exact change made by Sally in revision 344:"
msgstr ""

#: en.xml:4957(screen) 
#, no-wrap
msgid "\n$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk\n\nIndex: integer.c\n===================================================================\n--- integer.c\t(revision 343)\n+++ integer.c\t(revision 344)\n@@ -147,7 +147,7 @@\n     case 6:  sprintf(info-&gt;operating_system, \"HPFS (OS/2 or NT)\"); break;\n     case 7:  sprintf(info-&gt;operating_system, \"Macintosh\"); break;\n     case 8:  sprintf(info-&gt;operating_system, \"Z-System\"); break;\n-    case 9:  sprintf(info-&gt;operating_system, \"CPM\"); break;\n+    case 9:  sprintf(info-&gt;operating_system, \"CP/M\"); break;\n     case 10:  sprintf(info-&gt;operating_system, \"TOPS-20\"); break;\n     case 11:  sprintf(info-&gt;operating_system, \"NTFS (Windows NT)\"); break;\n     case 12:  sprintf(info-&gt;operating_system, \"QDOS\"); break;\n@@ -164,7 +164,7 @@\n     low = (unsigned short) read_byte(gzfile);  /* read LSB */\n     high = (unsigned short) read_byte(gzfile); /* read MSB */\n     high = high &lt;&lt; 8;  /* interpret MSB correctly */\n-    total = low + high; /* add them togethe for correct total */\n+    total = low + high; /* add them together for correct total */\n \n     info-&gt;extra_header = (unsigned char *) my_malloc(total);\n     fread(info-&gt;extra_header, total, 1, gzfile);\n@@ -241,7 +241,7 @@\n      Store the offset with ftell() ! */\n \n   if ((info-&gt;data_offset = ftell(gzfile))== -1) {\n-    printf(\"error: ftell() retturned -1.\\n\");\n+    printf(\"error: ftell() returned -1.\\n\");\n     exit(1);\n   }\n \n@@ -249,7 +249,7 @@\n   printf(\"I believe start of compressed data is %u\\n\", info-&gt;data_offset);\n   #endif\n   \n-  /* Set postion eight bytes from the end of the file. */\n+  /* Set position eight bytes from the end of the file. */\n \n   if (fseek(gzfile, -8, SEEK_END)) {\n     printf(\"error: fseek() returned non-zero\\n\");\n"
msgstr ""

#: en.xml:5002(para) 
msgid "The <command moreinfo=\"none\">svn merge</command> command is almost exactly the same. Instead of printing the differences to your terminal, however, it applies them directly to your working copy as <emphasis>local modifications</emphasis>:"
msgstr ""

#: en.xml:5007(screen) 
#, no-wrap
msgid "\n$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk\nU  integer.c\n\n$ svn status\nM  integer.c\n"
msgstr ""

#: en.xml:5015(para) 
msgid "The output of <command moreinfo=\"none\">svn merge</command> shows that your copy of <filename moreinfo=\"none\">integer.c</filename> was patched. It now contains Sally's change—the change has been <quote>copied</quote> from the trunk to your working copy of your private branch, and now exists as a local modification. At this point, it's up to you to review the local modification and make sure it works correctly."
msgstr ""

#: en.xml:5023(para) 
msgid "In another scenario, it's possible that things may not have gone so well, and that <filename moreinfo=\"none\">integer.c</filename> may have entered a conflicted state. You might need to resolve the conflict using standard procedures (see <xref linkend=\"svn.tour\"/>), or if you decide that the merge was a bad idea altogether, simply give up and <command moreinfo=\"none\">svn revert</command> the local change."
msgstr ""

#: en.xml:5030(para) 
msgid "But assuming that you've reviewed the merged change, you can <command moreinfo=\"none\">svn commit</command> the change as usual. At that point, the change has been merged into your repository branch. In version control terminology, this act of copying changes between branches is commonly called <firstterm>porting</firstterm> changes."
msgstr ""

#: en.xml:5037(para) 
msgid "When you commit the local modification, make sure your log message mentions that you're porting a specific change from one branch to another. For example:"
msgstr ""

#: en.xml:5041(screen) 
#, no-wrap
msgid "\n$ svn commit -m \"integer.c: ported r344 (spelling fixes) from trunk.\"\nSending        integer.c\nTransmitting file data .\nCommitted revision 360.\n"
msgstr ""

#: en.xml:5048(para) 
msgid "As you'll see in the next sections, this is a very important <quote>best practice</quote> to follow."
msgstr ""

#: en.xml:5052(title) 
msgid "Why Not Use Patches Instead?"
msgstr ""

#: en.xml:5054(para) 
msgid "A question may be on your mind, especially if you're a Unix user: why bother to use <command moreinfo=\"none\">svn merge</command> at all? Why not simply use the operating system's <command moreinfo=\"none\">patch</command> command to accomplish the same job? For example:"
msgstr ""

#: en.xml:5060(screen) 
#, no-wrap
msgid "\n$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk &gt; patchfile\n$ patch -p0  &lt; patchfile\nPatching file integer.c using Plan A...\nHunk #1 succeeded at 147.\nHunk #2 succeeded at 164.\nHunk #3 succeeded at 241.\nHunk #4 succeeded at 249.\ndone\n"
msgstr ""

#: en.xml:5084(para) 
msgid "In the future, the Subversion project plans to use (or invent) an expanded patch format that describes changes in tree structure and properties."
msgstr ""

#: en.xml:5071(para) 
msgid "In this particular case, yes, there really is no difference. But <command moreinfo=\"none\">svn merge</command> has special abilities that surpass the <command moreinfo=\"none\">patch</command> program. The file format used by <command moreinfo=\"none\">patch</command> is quite limited; it's only able to tweak file contents. There's no way to represent changes to <emphasis>trees</emphasis>, such as the addition, removal, or renaming of files and directories. If Sally's change had, say, added a new directory, the output of <command moreinfo=\"none\">svn diff</command> wouldn't have mentioned it at all. <command moreinfo=\"none\">svn diff</command> only outputs the limited patch-format, so there are some ideas it simply can't express. <footnote><placeholder-1/></footnote> The <command moreinfo=\"none\">svn merge</command> command, however, can express changes in tree structure and properties by directly applying them to your working copy."
msgstr ""

#: en.xml:5094(para) 
msgid "A word of warning: while <command moreinfo=\"none\">svn diff</command> and <command moreinfo=\"none\">svn merge</command> are very similar in concept, they do have different syntax in many cases. Be sure to read about them in <xref linkend=\"svn.ref\"/> for details, or ask <command moreinfo=\"none\">svn help</command>. For example, <command moreinfo=\"none\">svn merge</command> requires a working-copy path as a target, i.e. a place where it should apply the tree-changes. If the target isn't specified, it assumes you are trying to perform one of the following common operations:"
msgstr ""

#: en.xml:5106(para) 
msgid "You want to merge directory changes into your current working directory."
msgstr ""

#: en.xml:5110(para) 
msgid "You want to merge the changes in a specific file into a file by the same name which exists in your current working directory."
msgstr ""

#: en.xml:5116(para) 
msgid "If you are merging a directory and haven't specified a target path, <command moreinfo=\"none\">svn merge</command> assumes the first case above and tries to apply the changes into your current directory. If you are merging a file, and that file (or a file by the same name) exists in your current working directory, <command moreinfo=\"none\">svn merge</command> assumes the second case and tries to apply the changes to a local file with the same name."
msgstr ""

#: en.xml:5124(para) 
msgid "If you want changes applied somewhere else, you'll need to say so. For example, if you're sitting in the parent directory of your working copy, you'll have to specify the target directory to receive the changes:"
msgstr ""

#: en.xml:5129(screen) 
#, no-wrap
msgid "\n$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk my-calc-branch\nU   my-calc-branch/integer.c\n"
msgstr ""

#: en.xml:5138(title) 
msgid "The Key Concept Behind Merging"
msgstr ""

#: en.xml:5140(para) 
msgid "You've now seen an example of the <command moreinfo=\"none\">svn merge</command> command, and you're about to see several more. If you're feeling confused about exactly how merging works, you're not alone. Many users (especially those new to version control) are initially perplexed about the proper syntax of the command, and about how and when the feature should be used. But fear not, this command is actually much simpler than you think! There's a very easy technique for understanding exactly how <command moreinfo=\"none\">svn merge</command> behaves."
msgstr ""

#: en.xml:5151(para) 
msgid "The main source of confusion is the <emphasis>name</emphasis> of the command. The term <quote>merge</quote> somehow denotes that branches are combined together, or that there's some sort of mysterious blending of data going on. That's not the case. A better name for the command might have been <command moreinfo=\"none\">svn diff-and-apply</command>, because that's all that happens: two repository trees are compared, and the differences are applied to a working copy."
msgstr ""

#: en.xml:5161(para) 
msgid "The command takes three arguments:"
msgstr ""

#: en.xml:5165(para) 
msgid "An initial repository tree (often called the <firstterm>left side</firstterm> of the comparison),"
msgstr ""

#: en.xml:5169(para) 
msgid "A final repository tree (often called the <firstterm>right side</firstterm> of the comparison),"
msgstr ""

#: en.xml:5173(para) 
msgid "A working copy to accept the differences as local changes (often called the <firstterm>target</firstterm> of the merge)."
msgstr ""

#: en.xml:5179(para) 
msgid "Once these three arguments are specified, the two trees are compared, and the resulting differences are applied to the target working copy as local modifications. When the command is done, the results are no different than if you had hand-edited the files, or run various <command moreinfo=\"none\">svn add</command> or <command moreinfo=\"none\">svn delete</command> commands yourself. If you like the results, you can commit them. If you don't like the results, you can simply <command moreinfo=\"none\">svn revert</command> all of the changes."
msgstr ""

#: en.xml:5189(para) 
msgid "The syntax of <command moreinfo=\"none\">svn merge</command> allows you to specify the three necessary arguments rather flexibly. Here are some examples:"
msgstr ""

#: en.xml:5193(screen) 
#, no-wrap
msgid "      \n$ svn merge http://svn.example.com/repos/branch1@150 \\\n            http://svn.example.com/repos/branch2@212 \\\n            my-working-copy\n            \n$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy\n\n$ svn merge -r 100:200 http://svn.example.com/repos/trunk\n"
msgstr ""

#: en.xml:5203(para) 
msgid "The first syntax lays out all three arguments explicitly, naming each tree in the form <emphasis>URL@REV</emphasis> and naming the working copy target. The second syntax can be used as a shorthand for situations when you're comparing two different revisions of the same URL. The last syntax shows how the working-copy argument is optional; if omitted, it defaults to the current directory."
msgstr ""

#: en.xml:5216(title) 
msgid "Best Practices for Merging"
msgstr ""

#: en.xml:5219(title) 
msgid "Tracking Merges Manually"
msgstr ""

#: en.xml:5221(para) 
msgid "Merging changes sounds simple enough, but in practice it can become a headache. The problem is that if you repeatedly merge changes from one branch to another, you might accidentally merge the same change <emphasis>twice</emphasis>. When this happens, sometimes things will work fine. When patching a file, Subversion typically notices if the file already has the change, and does nothing. But if the already-existing change has been modified in any way, you'll get a conflict."
msgstr ""

#: en.xml:5231(para) 
msgid "Ideally, your version control system should prevent the double-application of changes to a branch. It should automatically remember which changes a branch has already received, and be able to list them for you. It should use this information to help automate merges as much as possible."
msgstr ""

#: en.xml:5238(para) 
msgid "Unfortunately, Subversion is not such a system. Like CVS, Subversion does not yet record any information about merge operations. When you commit local modifications, the repository has no idea whether those changes came from running <command moreinfo=\"none\">svn merge</command>, or from just hand-editing the files."
msgstr ""

#: en.xml:5245(para) 
msgid "What does this mean to you, the user? It means that until the day Subversion grows this feature, you'll have to track merge information yourself. The best place to do this is in the commit log-message. As demonstrated in the earlier example, it's recommended that your log-message mention a specific revision number (or range of revisions) that are being merged into your branch. Later on, you can run <command moreinfo=\"none\">svn log</command> to review which changes your branch already contains. This will allow you to carefully construct a subsequent <command moreinfo=\"none\">svn merge</command> command that won't be redundant with previously ported changes."
msgstr ""

#: en.xml:5258(para) 
msgid "In the next section, we'll show some examples of this technique in action."
msgstr ""

#: en.xml:5264(title) 
msgid "Previewing Merges"
msgstr ""

#: en.xml:5266(para) 
msgid "Because merging only results in local modifications, it's not usually a high-risk operation. If you get the merge wrong the first time, simply <command moreinfo=\"none\">svn revert</command> the changes and try again."
msgstr ""

#: en.xml:5271(para) 
msgid "It's possible, however, that your working copy might already have local modifications. The changes applied by a merge will be mixed with your pre-existing ones, and running <command moreinfo=\"none\">svn revert</command> is no longer an option. The two sets of changes may be impossible to separate."
msgstr ""

#: en.xml:5277(para) 
msgid "In cases like this, people take comfort in being able to predict or examine merges before they happen. One simple way to do that is to run <command moreinfo=\"none\">svn diff</command> with the same arguments you plan to pass to <command moreinfo=\"none\">svn merge</command>, as we already showed in our first example of merging. Another method of previewing is to pass the <option>--dry-run</option> option to the merge command:"
msgstr ""

#: en.xml:5286(screen) 
#, no-wrap
msgid "\n$ svn merge --dry-run -r 343:344 http://svn.example.com/repos/calc/trunk\nU  integer.c\n\n$ svn status\n#  nothing printed, working copy is still unchanged.\n"
msgstr ""

#: en.xml:5294(para) 
msgid "The <option>--dry-run</option> option doesn't actually apply any local changes to the working copy. It only shows status codes that <emphasis>would</emphasis> be printed in a real merge. It's useful for getting a <quote>high level</quote> preview of the potential merge, for those times when running <command moreinfo=\"none\">svn diff</command> gives too much detail."
msgstr ""

#: en.xml:5305(title) 
msgid "Subversion and Changesets"
msgstr ""

#: en.xml:5307(para) 
msgid "Everyone seems to have a slightly different definition of <quote>changeset</quote>, or at least a different expectation of what it means for a version control system to have <quote>changeset features</quote>. For our purpose, let's say that a changeset is just a collection of changes with a unique name. The changes might include textual edits to file contents, modifications to tree structure, or tweaks to metadata. In more common speak, a changeset is just a patch with a name you can refer to."
msgstr ""

#: en.xml:5317(para) 
msgid "In Subversion, a global revision number N names a tree in the repository: it's the way the repository looked after the Nth commit. It's also the name of an implicit changeset: if you compare tree N with tree N-1, you can derive the exact patch that was committed. For this reason, it's easy to think of <quote>revision N</quote> as not just a tree, but a changeset as well. If you use an issue tracker to manage bugs, you can use the revision numbers to refer to particular patches that fix bugs—for example, <quote>this issue was fixed by revision 9238.</quote>. Somebody can then run <command moreinfo=\"none\">svn log -r9238</command> to read about the exact changeset which fixed the bug, and run <command moreinfo=\"none\">svn diff -r9237:9238</command> to see the patch itself. And Subversion's <literal moreinfo=\"none\">merge</literal> command also uses revision numbers. You can merge specific changesets from one branch to another by naming them in the merge arguments: <command moreinfo=\"none\">svn merge -r9237:9238</command> would merge changeset #9238 into your working copy."
msgstr ""

#: en.xml:5338(title) 
msgid "Merge Conflicts"
msgstr ""

#: en.xml:5340(para) 
msgid "Just like the <command moreinfo=\"none\">svn update</command> command, <command moreinfo=\"none\">svn merge</command> applies changes to your working copy. And therefore it's also capable of creating conflicts. The conflicts produced by <command moreinfo=\"none\">svn merge</command>, however, are sometimes different, and this section explains those differences."
msgstr ""

#: en.xml:5347(para) 
msgid "To begin with, assume that your working copy has no local edits. When you <command moreinfo=\"none\">svn update</command> to a particular revision, the changes sent by the server will always apply <quote>cleanly</quote> to your working copy. The server produces the delta by comparing two trees: a virtual snapshot of your working copy, and the revision tree you're interested in. Because the left-hand side of the comparison is exactly equal to what you already have, the delta is guaranteed to correctly convert your working copy into the right-hand tree."
msgstr ""

#: en.xml:5358(para) 
msgid "But <command moreinfo=\"none\">svn merge</command> has no such guarantees and can be much more chaotic: the user can ask the server to compare <emphasis>any</emphasis> two trees at all, even ones that are unrelated to the working copy! This means there's large potential for human error. Users will sometimes compare the wrong two trees, creating a delta that doesn't apply cleanly. <command moreinfo=\"none\">svn merge</command> will do its best to apply as much of the delta as possible, but some parts may be impossible. Just like the Unix <command moreinfo=\"none\">patch</command> command sometimes complains about <quote>failed hunks</quote>, <command moreinfo=\"none\">svn merge</command> will complain about <quote>skipped targets</quote>:"
msgstr ""

#: en.xml:5371(screen) 
#, no-wrap
msgid "\n$ svn merge -r 1288:1351 http://svn.example.com/repos/branch\nU  foo.c\nU  bar.c\nSkipped missing target: 'baz.c'\nU  glub.c\nC  glorb.h\n\n$\n"
msgstr ""

#: en.xml:5382(para) 
msgid "In the previous example it might be the case that <filename moreinfo=\"none\">baz.c</filename> exists in both snapshots of the branch being compared, and the resulting delta wants to change the file's contents, but the file doesn't exist in the working copy. Whatever the case, the <quote>skipped</quote> message means that the user is most likely comparing the wrong two trees; they're the classic sign of driver error. When this happens, it's easy to recursively revert all the changes created by the merge (<command moreinfo=\"none\">svn revert --recursive</command>), delete any unversioned files or directories left behind after the revert, and re-run <command moreinfo=\"none\">svn merge</command> with different arguments."
msgstr ""

#: en.xml:5396(para) 
msgid "Also notice that the previous example shows a conflict happening on <filename moreinfo=\"none\">glorb.h</filename>. We already stated that the working copy has no local edits: how can a conflict possibly happen? Again, because the user can use <command moreinfo=\"none\">svn merge</command> to define and apply any old delta to the working copy, that delta may contain textual changes that don't cleanly apply to a working file, even if the file has no local modifications."
msgstr ""

#: en.xml:5405(para) 
msgid "Another small difference between <command moreinfo=\"none\">svn update</command> and <command moreinfo=\"none\">svn merge</command> are the names of the full-text files created when a conflict happens. In <xref linkend=\"svn.tour.cycle.resolve\"/>, we saw that an update produces files named <filename moreinfo=\"none\">filename.mine</filename>, <filename moreinfo=\"none\">filename.rOLDREV</filename>, and <filename moreinfo=\"none\">filename.rNEWREV</filename>. When <command moreinfo=\"none\">svn merge</command> produces a conflict, though, it creates three files named <filename moreinfo=\"none\">filename.working</filename>, <filename moreinfo=\"none\">filename.left</filename>, and <filename moreinfo=\"none\">filename.right</filename>. In this case, the terms <quote>left</quote> and <quote>right</quote> are describing which side of the double-tree comparison the file came from. In any case, these differing names will help you distinguish between conflicts that happened as a result of an update versus ones that happened as a result of a merge."
msgstr ""

#: en.xml:5427(title) 
msgid "Noticing or Ignoring Ancestry"
msgstr ""

#: en.xml:5429(para) 
msgid "When conversing with a Subversion developer, you might very likely hear reference to the term <firstterm>ancestry</firstterm>. This word is used to describe the relationship between two objects in a repository: if they're related to each other, then one object is said to be an ancestor of the other."
msgstr ""

#: en.xml:5436(para) 
msgid "For example, suppose you commit revision 100, which includes a change to a file <filename moreinfo=\"none\">foo.c</filename>. Then <filename moreinfo=\"none\">foo.c@99</filename> is an <quote>ancestor</quote> of <filename moreinfo=\"none\">foo.c@100</filename>. On the other hand, suppose you commit the deletion of <filename moreinfo=\"none\">foo.c</filename> in revision 101, and then add a new file by the same name in revision 102. In this case, <filename moreinfo=\"none\">foo.c@99</filename> and <filename moreinfo=\"none\">foo.c@102</filename> may appear to be related (they have the same path), but in fact are completely different objects in the repository. They share no history or <quote>ancestry</quote>."
msgstr ""

#: en.xml:5449(para) 
msgid "The reason for bringing this up is to point out an important difference between <command moreinfo=\"none\">svn diff</command> and <command moreinfo=\"none\">svn merge</command>. The former command ignores ancestry, while the latter command is quite sensitive to it. For example, if you asked <command moreinfo=\"none\">svn diff</command> to compare revisions 99 and 102 of <filename moreinfo=\"none\">foo.c</filename>, you would see line-based diffs; the <literal moreinfo=\"none\">diff</literal> command is blindly comparing two paths. But if you asked <command moreinfo=\"none\">svn merge</command> to compare the same two objects, it would notice that they're unrelated and first attempt to delete the old file, then add the new file; the output would indicate a deletion followed by an add:"
msgstr ""

#: en.xml:5462(screen) 
#, no-wrap
msgid "\nD  foo.c\nA  foo.c\n"
msgstr ""

#: en.xml:5467(para) 
msgid "Most merges involve comparing trees that are ancestrally related to one another, and therefore <command moreinfo=\"none\">svn merge</command> defaults to this behavior. Occasionally, however, you may want the <literal moreinfo=\"none\">merge</literal> command to compare two unrelated trees. For example, you may have imported two source-code trees representing different vendor releases of a software project (see <xref linkend=\"svn.advanced.vendorbr\"/>). If you asked <command moreinfo=\"none\">svn merge</command> to compare the two trees, you'd see the entire first tree being deleted, followed by an add of the entire second tree!"
msgstr ""

#: en.xml:5478(para) 
msgid "In these situations, you'll want <command moreinfo=\"none\">svn merge</command> to do a path-based comparison only, ignoring any relations between files and directories. Add the <option>--ignore-ancestry</option> option to your merge command, and it will behave just like <command moreinfo=\"none\">svn diff</command>. (And conversely, the <option>--notice-ancestry</option> option will cause <command moreinfo=\"none\">svn diff</command> to behave like the <literal moreinfo=\"none\">merge</literal> command.)"
msgstr ""

#: en.xml:5499(title) 
msgid "Common Use-Cases"
msgstr ""

#: en.xml:5501(para) 
msgid "There are many different uses for branching and <command moreinfo=\"none\">svn merge</command>, and this section describes the most common ones you're likely to run into."
msgstr ""

#: en.xml:5507(title) 
msgid "Merging a Whole Branch to Another"
msgstr ""

#: en.xml:5509(para) 
msgid "To complete our running example, we'll move forward in time. Suppose several days have passed, and many changes have happened on both the trunk and your private branch. Suppose that you've finished working on your private branch; the feature or bug fix is finally complete, and now you want to merge all of your branch changes back into the trunk for others to enjoy."
msgstr ""

#: en.xml:5517(para) 
msgid "So how do we use <command moreinfo=\"none\">svn merge</command> in this scenario? Remember that this command compares two trees, and applies the differences to a working copy. So to receive the changes, you need to have a working copy of the trunk. We'll assume that either you still have your original one lying around (fully updated), or that you recently checked out a fresh working copy of <filename moreinfo=\"none\">/calc/trunk</filename>."
msgstr ""

#: en.xml:5525(para) 
msgid "But which two trees should be compared? At first glance, the answer may seem obvious: just compare the latest trunk tree with your latest branch tree. But beware—this assumption is <emphasis>wrong</emphasis>, and has burned many a new user! Since <command moreinfo=\"none\">svn merge</command> operates like <command moreinfo=\"none\">svn diff</command>, comparing the latest trunk and branch trees will <emphasis>not</emphasis> merely describe the set of changes you made to your branch. Such a comparison shows too many changes: it would not only show the addition of your branch changes, but also the <emphasis>removal</emphasis> of trunk changes that never happened on your branch."
msgstr ""

#: en.xml:5537(para) 
msgid "To express only the changes that happened on your branch, you need to compare the initial state of your branch to its final state. Using <command moreinfo=\"none\">svn log</command> on your branch, you can see that your branch was created in revision 341. And the final state of your branch is simply a matter of using the <literal moreinfo=\"none\">HEAD</literal> revision. That means you want to compare revisions 341 and <literal moreinfo=\"none\">HEAD</literal> of your branch directory, and apply those differences to a working copy of the trunk."
msgstr ""

#: en.xml:5548(para) 
msgid "A nice way of finding the revision in which a branch was created (the <quote>base</quote> of the branch) is to use the <option>--stop-on-copy</option> option to <command moreinfo=\"none\">svn log</command>. The log subcommand will normally show every change ever made to the branch, including tracing back through the copy which created the branch. So normally, you'll see history from the trunk as well. The <option>--stop-on-copy</option> will halt log output as soon as <command moreinfo=\"none\">svn log</command> detects that its target was copied or renamed."
msgstr ""

#: en.xml:5559(para) 
msgid "So in our continuing example,"
msgstr ""

#: en.xml:5561(screen) 
#, no-wrap
msgid "\n$ svn log --verbose --stop-on-copy \\\n          http://svn.example.com/repos/calc/branches/my-calc-branch\n…\n------------------------------------------------------------------------\nr341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines\nChanged paths:\n   A /calc/branches/my-calc-branch (from /calc/trunk:340)\n\n$\n"
msgstr ""

#: en.xml:5573(para) 
msgid "As expected, the final revision printed by this command is the revision in which <filename moreinfo=\"none\">my-calc-branch</filename> was created by copying."
msgstr ""

#: en.xml:5579(para) 
msgid "Here's the final merging procedure, then:"
msgstr ""

#: en.xml:5581(screen) 
#, no-wrap
msgid "\n$ cd calc/trunk\n$ svn update\nAt revision 405.\n\n$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch\nU   integer.c\nU   button.c\nU   Makefile\n\n$ svn status\nM   integer.c\nM   button.c\nM   Makefile\n\n# ...examine the diffs, compile, test, etc...\n\n$ svn commit -m \"Merged my-calc-branch changes r341:405 into the trunk.\"\nSending        integer.c\nSending        button.c\nSending        Makefile\nTransmitting file data ...\nCommitted revision 406.\n"
msgstr ""

#: en.xml:5606(para) 
msgid "Again, notice that the commit log message very specifically mentions the range of changes that was merged into the trunk. Always remember to do this, because it's critical information you'll need later on."
msgstr ""

#: en.xml:5611(para) 
msgid "For example, suppose you decide to keep working on your branch for another week, in order to complete an enhancement to your original feature or bug fix. The repository's <literal moreinfo=\"none\">HEAD</literal> revision is now 480, and you're ready to do another merge from your private branch to the trunk. But as discussed in <xref linkend=\"svn.branchmerge.copychanges.bestprac\"/>, you don't want to merge the changes you've already merged before; you only want to merge everything <quote>new</quote> on your branch since the last time you merged. The trick is to figure out what's new."
msgstr ""

#: en.xml:5622(para) 
msgid "The first step is to run <command moreinfo=\"none\">svn log</command> on the trunk, and look for a log message about the last time you merged from the branch:"
msgstr ""

#: en.xml:5626(screen) 
#, no-wrap
msgid "\n$ cd calc/trunk\n$ svn log\n…\n------------------------------------------------------------------------\nr406 | user | 2004-02-08 11:17:26 -0600 (Sun, 08 Feb 2004) | 1 line\n\nMerged my-calc-branch changes r341:405 into the trunk.\n------------------------------------------------------------------------\n…\n"
msgstr ""

#: en.xml:5638(para) 
msgid "Aha! Since all branch-changes that happened between revisions 341 and 405 were previously merged to the trunk as revision 406, you now know that you want to merge only the branch changes after that—by comparing revisions 406 and <literal moreinfo=\"none\">HEAD</literal>."
msgstr ""

#: en.xml:5644(screen) 
#, no-wrap
msgid "\n$ cd calc/trunk\n$ svn update\nAt revision 480.\n\n# We notice that HEAD is currently 480, so we use it to do the merge:\n\n$ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch\nU   integer.c\nU   button.c\nU   Makefile\n\n$ svn commit -m \"Merged my-calc-branch changes r406:480 into the trunk.\"\nSending        integer.c\nSending        button.c\nSending        Makefile\nTransmitting file data ...\nCommitted revision 481.\n"
msgstr ""

#: en.xml:5664(para) 
msgid "Now the trunk contains the complete second wave of changes made to the branch. At this point, you can either delete your branch (we'll discuss this later on), or continue working on your branch and repeat this procedure for subsequent merges."
msgstr ""

#: en.xml:5674(title) 
msgid "Undoing Changes"
msgstr ""

#: en.xml:5676(para) 
msgid "Another common use for <command moreinfo=\"none\">svn merge</command> is to roll back a change that has already been committed. Suppose you're working away happily on a working copy of <filename moreinfo=\"none\">/calc/trunk</filename>, and you discover that the change made way back in revision 303, which changed <filename moreinfo=\"none\">integer.c</filename>, is completely wrong. It never should have been committed. You can use <command moreinfo=\"none\">svn merge</command> to <quote>undo</quote> the change in your working copy, and then commit the local modification to the repository. All you need to do is to specify a <emphasis>reverse</emphasis> difference:"
msgstr ""

#: en.xml:5689(screen) 
#, no-wrap
msgid "\n$ svn merge -r 303:302 http://svn.example.com/repos/calc/trunk\nU  integer.c\n\n$ svn status\nM  integer.c\n\n$ svn diff\n…\n# verify that the change is removed\n…\n\n$ svn commit -m \"Undoing change committed in r303.\"\nSending        integer.c\nTransmitting file data .\nCommitted revision 350.\n"
msgstr ""

#: en.xml:5707(para) 
msgid "One way to think about a repository revision is as a specific group of changes (some version control systems call these <firstterm>changesets</firstterm>). By using the <option>-r</option> switch, you can ask <command moreinfo=\"none\">svn merge</command> to apply a changeset, or whole range of changesets, to your working copy. In our case of undoing a change, we're asking <command moreinfo=\"none\">svn merge</command> to apply changeset #303 to our working copy <emphasis>backwards</emphasis>."
msgstr ""

#: en.xml:5717(para) 
msgid "Keep in mind that rolling back a change like this is just like any other <command moreinfo=\"none\">svn merge</command> operation, so you should use <command moreinfo=\"none\">svn status</command> and <command moreinfo=\"none\">svn diff</command> to confirm that your work is in the state you want it to be in, and then use <command moreinfo=\"none\">svn commit</command> to send the final version to the repository. After committing, this particular changeset is no longer reflected in the <literal moreinfo=\"none\">HEAD</literal> revision."
msgstr ""

#: en.xml:5726(para) 
msgid "Again, you may be thinking: well, that really didn't undo the commit, did it? The change still exists in revision 303. If somebody checks out a version of the <filename moreinfo=\"none\">calc</filename> project between revisions 303 and 349, they'll still see the bad change, right?"
msgstr ""

#: en.xml:5748(para) 
msgid "The Subversion project has plans, however, to someday implement an <command moreinfo=\"none\">svnadmin obliterate</command> command that would accomplish the task of permanently deleting information. In the meantime, see <xref linkend=\"svn.reposadmin.maint.tk.svndumpfilter\"/> for a possible workaround."
msgstr ""

#: en.xml:5732(para) 
msgid "Yes, that's true. When we talk about <quote>removing</quote> a change, we're really talking about removing it from <literal moreinfo=\"none\">HEAD</literal>. The original change still exists in the repository's history. For most situations, this is good enough. Most people are only interested in tracking the <literal moreinfo=\"none\">HEAD</literal> of a project anyway. There are special cases, however, where you really might want to destroy all evidence of the commit. (Perhaps somebody accidentally committed a confidential document.) This isn't so easy, it turns out, because Subversion was deliberately designed to never lose information. Revisions are immutable trees which build upon one another. Removing a revision from history would cause a domino effect, creating chaos in all subsequent revisions and possibly invalidating all working copies. <footnote><placeholder-1/></footnote>"
msgstr ""

#: en.xml:5760(title) 
msgid "Resurrecting Deleted Items"
msgstr ""

#: en.xml:5762(para) 
msgid "The great thing about version control systems is that information is never lost. Even when you delete a file or directory, it may be gone from the <literal moreinfo=\"none\">HEAD</literal> revision, but the object still exists in earlier revisions. One of the most common questions new users ask is, <quote>How do I get my old file or directory back?</quote>."
msgstr ""

#: en.xml:5769(para) 
msgid "The first step is to define exactly <emphasis role=\"bold\">which</emphasis> item you're trying to resurrect. Here's a useful metaphor: you can think of every object in the repository as existing in a sort of two-dimensional coordinate system. The first coordinate is a particular revision tree, and the second coordinate is a path within that tree. So every version of your file or directory can be defined by a specific coordinate pair."
msgstr ""

#: en.xml:5780(para) 
msgid "Because CVS doesn't version trees, it creates an <filename moreinfo=\"none\">Attic</filename> area within each repository directory as a way of remembering deleted files."
msgstr ""

#: en.xml:5777(para) 
msgid "Subversion has no <filename moreinfo=\"none\">Attic</filename> directory like CVS does, <footnote><placeholder-1/></footnote> so you need to use <command moreinfo=\"none\">svn log</command> to discover the exact coordinate pair you wish to resurrect. A good strategy is to run <command moreinfo=\"none\">svn log --verbose</command> in a directory which used to contain your deleted item. The <option>--verbose</option> option shows a list of all changed items in each revision; all you need to do is find the revision in which you deleted the file or directory. You can do this visually, or by using another tool to examine the log output (via <command moreinfo=\"none\">grep</command>, or perhaps via an incremental search in an editor)."
msgstr ""

#: en.xml:5795(screen) 
#, no-wrap
msgid "\n$ cd parent-dir\n$ svn log --verbose\n…\n------------------------------------------------------------------------\nr808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines\nChanged paths:\n   D /calc/trunk/real.c\n   M /calc/trunk/integer.c\n\nAdded fast fourier transform functions to integer.c.\nRemoved real.c because code now in double.c.\n…\n"
msgstr ""

#: en.xml:5810(para) 
msgid "In the example, we're assuming that you're looking for a deleted file <filename moreinfo=\"none\">real.c</filename>. By looking through the logs of a parent directory, you've spotted that this file was deleted in revision 808. Therefore, the last version of the file to exist was in the revision right before that. Conclusion: you want to resurrect the path <filename moreinfo=\"none\">/calc/trunk/real.c</filename> from revision 807."
msgstr ""

#: en.xml:5819(para) 
msgid "That was the hard part—the research. Now that you know what you want to restore, you have two different choices."
msgstr ""

#: en.xml:5823(para) 
msgid "One option is to use <command moreinfo=\"none\">svn merge</command> to apply revision 808 <quote>in reverse</quote>. (We've already discussed how to undo changes, see <xref linkend=\"svn.branchmerge.commonuses.undo\"/>.) This would have the effect of re-adding <filename moreinfo=\"none\">real.c</filename> as a local modification. The file would be scheduled for addition, and after a commit, the file would again exist in <literal moreinfo=\"none\">HEAD</literal>."
msgstr ""

#: en.xml:5830(para) 
msgid "In this particular example, however, this is probably not the best strategy. Reverse-applying revision 808 would not only schedule <filename moreinfo=\"none\">real.c</filename> for addition, but the log message indicates that it would also undo certain changes to <filename moreinfo=\"none\">integer.c</filename>, which you don't want. Certainly, you could reverse-merge revision 808 and then <command moreinfo=\"none\">svn revert</command> the local modifications to <filename moreinfo=\"none\">integer.c</filename>, but this technique doesn't scale well. What if there were 90 files changed in revision 808?"
msgstr ""

#: en.xml:5841(para) 
msgid "A second, more targeted strategy is not to use <command moreinfo=\"none\">svn merge</command> at all, but rather the <command moreinfo=\"none\">svn copy</command> command. Simply copy the exact revision and path <quote>coordinate pair</quote> from the repository to your working copy:"
msgstr ""

#: en.xml:5847(screen) 
#, no-wrap
msgid "\n$ svn copy --revision 807 \\\n           http://svn.example.com/repos/calc/trunk/real.c ./real.c\n\n$ svn status\nA  +   real.c\n\n$ svn commit -m \"Resurrected real.c from revision 807, /calc/trunk/real.c.\"\nAdding         real.c\nTransmitting file data .\nCommitted revision 1390.\n"
msgstr ""

#: en.xml:5860(para) 
msgid "The plus sign in the status output indicates that the item isn't merely scheduled for addition, but scheduled for addition <quote>with history</quote>. Subversion remembers where it was copied from. In the future, running <command moreinfo=\"none\">svn log</command> on this file will traverse back through the file's resurrection and through all the history it had prior to revision 807. In other words, this new <filename moreinfo=\"none\">real.c</filename> isn't really new; it's a direct descendant of the original, deleted file."
msgstr ""

#: en.xml:5870(para) 
msgid "Although our example shows us resurrecting a file, note that these same techniques work just as well for resurrecting deleted directories."
msgstr ""

#: en.xml:5878(title) 
msgid "Common Branching Patterns"
msgstr ""

#: en.xml:5880(para) 
msgid "Version control is most often used for software development, so here's a quick peek at two of the most common branching/merging patterns used by teams of programmers. If you're not using Subversion for software development, feel free to skip this section. If you're a software developer using version control for the first time, pay close attention, as these patterns are often considered best practices by experienced folk. These processes aren't specific to Subversion; they're applicable to any version control system. Still, it may help to see them described in Subversion terms."
msgstr ""

#: en.xml:5893(title) 
msgid "Release Branches"
msgstr ""

#: en.xml:5895(para) 
msgid "Most software has a typical lifecycle: code, test, release, repeat. There are two problems with this process. First, developers need to keep writing new features while quality-assurance teams take time to test supposedly-stable versions of the software. New work cannot halt while the software is tested. Second, the team almost always needs to support older, released versions of software; if a bug is discovered in the latest code, it most likely exists in released versions as well, and customers will want to get that bugfix without having to wait for a major new release."
msgstr ""

#: en.xml:5907(para) 
msgid "Here's where version control can help. The typical procedure looks like this:"
msgstr ""

#: en.xml:5913(para) 
msgid "<emphasis>Developers commit all new work to the trunk.</emphasis> Day-to-day changes are committed to <filename moreinfo=\"none\">/trunk</filename>: new features, bugfixes, and so on."
msgstr ""

#: en.xml:5922(para) 
msgid "<emphasis>The trunk is copied to a <quote>release</quote> branch.</emphasis> When the team thinks the software is ready for release (say, a 1.0 release), then <filename moreinfo=\"none\">/trunk</filename> might be copied to <filename moreinfo=\"none\">/branches/1.0</filename>."
msgstr ""

#: en.xml:5932(para) 
msgid "<emphasis>Teams continue to work in parallel.</emphasis> One team begins rigorous testing of the release branch, while another team continues new work (say, for version 2.0) on <filename moreinfo=\"none\">/trunk</filename>. If bugs are discovered in either location, fixes are ported back and forth as necessary. At some point, however, even that process stops. The branch is <quote>frozen</quote> for final testing right before a release."
msgstr ""

#: en.xml:5944(para) 
msgid "<emphasis>The branch is tagged and released.</emphasis> When testing is complete, <filename moreinfo=\"none\">/branches/1.0</filename> is copied to <filename moreinfo=\"none\">/tags/1.0.0</filename> as a reference snapshot. The tag is packaged and released to customers."
msgstr ""

#: en.xml:5954(para) 
msgid "<emphasis>The branch is maintained over time.</emphasis> While work continues on <filename moreinfo=\"none\">/trunk</filename> for version 2.0, bugfixes continue to be ported from <filename moreinfo=\"none\">/trunk</filename> to <filename moreinfo=\"none\">/branches/1.0</filename>. When enough bugfixes have accumulated, management may decide to do a 1.0.1 release: <filename moreinfo=\"none\">/branches/1.0</filename> is copied to <filename moreinfo=\"none\">/tags/1.0.1</filename>, and the tag is packaged and released."
msgstr ""

#: en.xml:5968(para) 
msgid "This entire process repeats as the software matures: when the 2.0 work is complete, a new 2.0 release branch is created, tested, tagged, and eventually released. After some years, the repository ends up with a number of release branches in <quote>maintenance</quote> mode, and a number of tags representing final shipped versions."
msgstr ""

#: en.xml:5978(title) 
msgid "Feature Branches"
msgstr ""

#: en.xml:5980(para) 
msgid "A <firstterm>feature branch</firstterm> is the sort of branch that's been the dominant example in this chapter, the one you've been working on while Sally continues to work on <filename moreinfo=\"none\">/trunk</filename>. It's a temporary branch created to work on a complex change without interfering with the stability of <filename moreinfo=\"none\">/trunk</filename>. Unlike release branches (which may need to be supported forever), feature branches are born, used for a while, merged back to the trunk, then ultimately deleted. They have a finite span of usefulness."
msgstr ""

#: en.xml:5991(para) 
msgid "Again, project policies vary widely concerning exactly when it's appropriate to create a feature branch. Some projects never use feature branches at all: commits to <filename moreinfo=\"none\">/trunk</filename> are a free-for-all. The advantage to this system is that it's simple—nobody needs to learn about branching or merging. The disadvantage is that the trunk code is often unstable or unusable. Other projects use branches to an extreme: no change is <emphasis>ever</emphasis> committed to the trunk directly. Even the most trivial changes are created on a short-lived branch, carefully reviewed and merged to the trunk. Then the branch is deleted. This system guarantees an exceptionally stable and usable trunk at all times, but at the cost of tremendous process overhead."
msgstr ""

#: en.xml:6006(para) 
msgid "Most projects take a middle-of-the-road approach. They commonly insist that <filename moreinfo=\"none\">/trunk</filename> compile and pass regression tests at all times. A feature branch is only required when a change requires a large number of destabilizing commits. A good rule of thumb is to ask this question: if the developer worked for days in isolation and then committed the large change all at once (so that <filename moreinfo=\"none\">/trunk</filename> were never destabilized), would it be too large a change to review? If the answer to that question is <quote>yes</quote>, then the change should be developed on a feature branch. As the developer commits incremental changes to the branch, they can be easily reviewed by peers."
msgstr ""

#: en.xml:6020(para) 
msgid "Finally, there's the issue of how to best keep a feature branch in <quote>sync</quote> with the trunk as work progresses. As we mentioned earlier, there's a great risk to working on a branch for weeks or months; trunk changes may continue to pour in, to the point where the two lines of development differ so greatly that it may become a nightmare trying to merge the branch back to the trunk."
msgstr ""

#: en.xml:6028(para) 
msgid "This situation is best avoided by regularly merging trunk changes to the branch. Make up a policy: once a week, merge the last week's worth of trunk changes to the branch. Take care when doing this; the merging needs to be hand-tracked to avoid the problem of repeated merges (as described in <xref linkend=\"svn.branchmerge.copychanges.bestprac.track\"/>). You'll need to write careful log messages detailing exactly which revision ranges have been merged already (as demonstrated in <xref linkend=\"svn.branchmerge.commonuses.wholebr\"/>). It may sound intimidating, but it's actually pretty easy to do."
msgstr ""

#: en.xml:6040(para) 
msgid "At some point, you'll be ready to merge the <quote>synchronized</quote> feature branch back to the trunk. To do this, begin by doing a final merge of the latest trunk changes to the branch. When that's done, the latest versions of branch and trunk will be absolutely identical except for your branch changes. So in this special case, you would merge by comparing the branch with the trunk:"
msgstr ""

#: en.xml:6049(screen) 
#, no-wrap
msgid "\n$ cd trunk-working-copy\n\n$ svn update\nAt revision 1910.\n\n$ svn merge http://svn.example.com/repos/calc/trunk@1910 \\\n            http://svn.example.com/repos/calc/branches/mybranch@1910\nU  real.c\nU  integer.c\nA  newdirectory\nA  newdirectory/newfile\n…\n"
msgstr ""

#: en.xml:6064(para) 
msgid "By comparing the <literal moreinfo=\"none\">HEAD</literal> revision of the trunk with the <literal moreinfo=\"none\">HEAD</literal> revision of the branch, you're defining a delta that describes only the changes you made to the branch; both lines of development already have all of the trunk changes."
msgstr ""

#: en.xml:6070(para) 
msgid "Another way of thinking about this pattern is that your weekly sync of trunk to branch is analogous to running <command moreinfo=\"none\">svn update</command> in a working copy, while the final merge step is analogous to running <command moreinfo=\"none\">svn commit</command> from a working copy. After all, what else <emphasis>is</emphasis> a working copy but a very shallow private branch? It's a branch that's only capable of storing one change at a time."
msgstr ""

#: en.xml:6089(title) 
msgid "Switching a Working Copy"
msgstr ""

#: en.xml:6091(para) 
msgid "The <command moreinfo=\"none\">svn switch</command> command transforms an existing working copy into a different branch. While this command isn't strictly necessary for working with branches, it provides a nice shortcut to users. In our earlier example, after creating your private branch, you checked out a fresh working copy of the new repository directory. Instead, you can simply ask Subversion to change your working copy of <filename moreinfo=\"none\">/calc/trunk</filename> to mirror the new branch location:"
msgstr ""

#: en.xml:6101(screen) 
#, no-wrap
msgid "\n$ cd calc\n\n$ svn info | grep URL\nURL: http://svn.example.com/repos/calc/trunk\n\n$ svn switch http://svn.example.com/repos/calc/branches/my-calc-branch\nU   integer.c\nU   button.c\nU   Makefile\nUpdated to revision 341.\n\n$ svn info | grep URL\nURL: http://svn.example.com/repos/calc/branches/my-calc-branch\n"
msgstr ""

#: en.xml:6117(para) 
msgid "After <quote>switching</quote> to the branch, your working copy is no different than what you would get from doing a fresh checkout of the directory. And it's usually more efficient to use this command, because often branches only differ by a small degree. The server sends only the minimal set of changes necessary to make your working copy reflect the branch directory."
msgstr ""

#: en.xml:6125(para) 
msgid "The <command moreinfo=\"none\">svn switch</command> command also takes a <option>--revision</option> (<option>-r</option>) option, so you need not always move your working copy to the <quote>tip</quote> of the branch."
msgstr ""

#: en.xml:6130(para) 
msgid "Of course, most projects are more complicated than our <filename moreinfo=\"none\">calc</filename> example, containing multiple subdirectories. Subversion users often follow a specific algorithm when using branches:"
msgstr ""

#: en.xml:6137(para) 
msgid "Copy the project's entire <quote>trunk</quote> to a new branch directory."
msgstr ""

#: en.xml:6141(para) 
msgid "Switch only <emphasis>part</emphasis> of the trunk working copy to mirror the branch."
msgstr ""

#: en.xml:6146(para) 
msgid "In other words, if a user knows that the branch-work only needs to happen on a specific subdirectory, they use <command moreinfo=\"none\">svn switch</command> to move only that subdirectory to the branch. (Or sometimes users will switch just a single working file to the branch!) That way, they can continue to receive normal <quote>trunk</quote> updates to most of their working copy, but the switched portions will remain immune (unless someone commits a change to their branch). This feature adds a whole new dimension to the concept of a <quote>mixed working copy</quote>—not only can working copies contain a mixture of working revisions, but a mixture of repository locations as well."
msgstr ""

#: en.xml:6159(para) 
msgid "If your working copy contains a number of switched subtrees from different repository locations, it continues to function as normal. When you update, you'll receive patches to each subtree as appropriate. When you commit, your local changes will still be applied as a single, atomic change to the repository."
msgstr ""

#: en.xml:6170(para) 
msgid "You <emphasis>can</emphasis>, however, use <command moreinfo=\"none\">svn switch</command> with the <option>--relocate</option> switch if the URL of your server changes and you don't want to abandon an existing working copy. See the <command moreinfo=\"none\">svn switch</command> section in <xref linkend=\"svn.ref\"/> for more information and an example."
msgstr ""

#: en.xml:6165(para) 
msgid "Note that while it's okay for your working copy to reflect a mixture of repository locations, these locations must all be within the <emphasis>same</emphasis> repository. Subversion repositories aren't yet able to communicate with one another; that's a feature planned beyond Subversion 1.0.<footnote><placeholder-1/></footnote>"
msgstr ""

#: en.xml:6178(title) 
msgid "Switches and Updates"
msgstr ""

#: en.xml:6180(para) 
msgid "Have you noticed that the output of <command moreinfo=\"none\">svn switch</command> and <command moreinfo=\"none\">svn update</command> look the same? The <literal moreinfo=\"none\">switch</literal> command is actually a superset of the update command."
msgstr ""

#: en.xml:6185(para) 
msgid "When you run <command moreinfo=\"none\">svn update</command>, you're asking the repository to compare two trees. The repository does so, and then sends a description of the differences back to the client. The only difference between <command moreinfo=\"none\">svn switch</command> and <command moreinfo=\"none\">svn update</command> is that the <literal moreinfo=\"none\">update</literal> command always compares two identical paths."
msgstr ""

#: en.xml:6193(para) 
msgid "That is, if your working copy is a mirror of <filename moreinfo=\"none\">/calc/trunk</filename>, then <command moreinfo=\"none\">svn update</command> will automatically compare your working copy of <filename moreinfo=\"none\">/calc/trunk</filename> to <filename moreinfo=\"none\">/calc/trunk</filename> in the <literal moreinfo=\"none\">HEAD</literal> revision. If you're switching your working copy to a branch, then <command moreinfo=\"none\">svn switch</command> will compare your working copy of <filename moreinfo=\"none\">/calc/trunk</filename> to some <emphasis>other</emphasis> branch-directory in the <literal moreinfo=\"none\">HEAD</literal> revision."
msgstr ""

#: en.xml:6205(para) 
msgid "In other words, an update moves your working copy through time. A switch moves your working copy through time <emphasis>and</emphasis> space."
msgstr ""

#: en.xml:6210(para) 
msgid "Because <command moreinfo=\"none\">svn switch</command> is essentially a variant of <command moreinfo=\"none\">svn update</command>, it shares the same behaviors; any local modifications in your working copy are preserved when new data arrives from the repository. This allows you to perform all sorts of clever tricks."
msgstr ""

#: en.xml:6216(para) 
msgid "For example, suppose you have a working copy of <filename moreinfo=\"none\">/calc/trunk</filename> and make a number of changes to it. Then you suddenly realize that you meant to make the changes to a branch instead. No problem! When you <command moreinfo=\"none\">svn switch</command> your working copy to the branch, the local changes will remain. You can then test and commit them to the branch."
msgstr ""

#: en.xml:6231(title) 
msgid "Tags"
msgstr ""

#: en.xml:6233(para) 
msgid "Another common version control concept is a <firstterm>tag</firstterm>. A tag is just a <quote>snapshot</quote> of a project in time. In Subversion, this idea already seems to be everywhere. Each repository revision is exactly that—a snapshot of the filesystem after each commit."
msgstr ""

#: en.xml:6240(para) 
msgid "However, people often want to give more human-friendly names to tags, like <literal moreinfo=\"none\">release-1.0</literal>. And they want to make snapshots of smaller subdirectories of the filesystem. After all, it's not so easy to remember that release-1.0 of a piece of software is a particular subdirectory of revision 4822."
msgstr ""

#: en.xml:6249(title) 
msgid "Creating a Simple Tag"
msgstr ""

#: en.xml:6251(para) 
msgid "Once again, <command moreinfo=\"none\">svn copy</command> comes to the rescue. If you want to create a snapshot of <filename moreinfo=\"none\">/calc/trunk</filename> exactly as it looks in the <literal moreinfo=\"none\">HEAD</literal> revision, then make a copy of it:"
msgstr ""

#: en.xml:6256(screen) 
#, no-wrap
msgid "\n$ svn copy http://svn.example.com/repos/calc/trunk \\\n           http://svn.example.com/repos/calc/tags/release-1.0 \\\n      -m \"Tagging the 1.0 release of the 'calc' project.\"\n\nCommitted revision 351.\n"
msgstr ""

#: en.xml:6264(para) 
msgid "This example assumes that a <filename moreinfo=\"none\">/calc/tags</filename> directory already exists. (If it doesn't, see <xref linkend=\"svn.ref.svn.c.mkdir\"/>). After the copy completes, the new <filename moreinfo=\"none\">release-1.0</filename> directory is forever a snapshot of how the project looked in the <literal moreinfo=\"none\">HEAD</literal> revision at the time you made the copy. Of course you might want to be more precise about exactly which revision you copy, in case somebody else may have committed changes to the project when you weren't looking. So if you know that revision 350 of <filename moreinfo=\"none\">/calc/trunk</filename> is exactly the snapshot you want, you can specify it by passing <option>-r 350</option> to the <command moreinfo=\"none\">svn copy</command> command."
msgstr ""

#: en.xml:6279(para) 
msgid "But wait a moment: isn't this tag-creation procedure the same procedure we used to create a branch? Yes, in fact, it is. In Subversion, there's no difference between a tag and a branch. Both are just ordinary directories that are created by copying. Just as with branches, the only reason a copied directory is a <quote>tag</quote> is because <emphasis>humans</emphasis> have decided to treat it that way: as long as nobody ever commits to the directory, it forever remains a snapshot. If people start committing to it, it becomes a branch."
msgstr ""

#: en.xml:6290(para) 
msgid "If you are administering a repository, there are two approaches you can take to managing tags. The first approach is <quote>hands off</quote>: as a matter of project policy, decide where your tags will live, and make sure all users know how to treat the directories they copy in there. (That is, make sure they know not to commit to them.) The second approach is more paranoid: you can use one of the access-control scripts provided with Subversion to prevent anyone from doing anything but creating new copies in the tags-area (See <xref linkend=\"svn.serverconfig\"/>.) The paranoid approach, however, isn't usually necessary. If a user accidentally commits a change to a tag-directory, you can simply undo the change as discussed in the previous section. This is version control, after all."
msgstr ""

#: en.xml:6309(title) 
msgid "Creating a Complex Tag"
msgstr ""

#: en.xml:6311(para) 
msgid "Sometimes you may want your <quote>snapshot</quote> to be more complicated than a single directory at a single revision."
msgstr ""

#: en.xml:6315(para) 
msgid "For example, pretend your project is much larger than our <filename moreinfo=\"none\">calc</filename> example: suppose it contains a number of subdirectories and many more files. In the course of your work, you may decide that you need to create a working copy that is designed to have specific features and bug fixes. You can accomplish this by selectively backdating files or directories to particular revisions (using <command moreinfo=\"none\">svn update -r</command> liberally), or by switching files and directories to particular branches (making use of <command moreinfo=\"none\">svn switch</command>). When you're done, your working copy is a hodgepodge of repository locations from different revisions. But after testing, you know it's the precise combination of data you need."
msgstr ""

#: en.xml:6329(para) 
msgid "Time to make a snapshot. Copying one URL to another won't work here. In this case, you want to make a snapshot of your exact working copy arrangement and store it in the repository. Luckily, <command moreinfo=\"none\">svn copy</command> actually has four different uses (which you can read about in <xref linkend=\"svn.ref\"/>), including the ability to copy a working-copy tree to the repository:"
msgstr ""

#: en.xml:6336(screen) 
#, no-wrap
msgid "\n$ ls\nmy-working-copy/\n\n$ svn copy my-working-copy http://svn.example.com/repos/calc/tags/mytag\n\nCommitted revision 352.\n"
msgstr ""

#: en.xml:6345(para) 
msgid "Now there is a new directory in the repository, <filename moreinfo=\"none\">/calc/tags/mytag</filename>, which is an exact snapshot of your working copy—mixed revisions, URLs, and all."
msgstr ""

#: en.xml:6350(para) 
msgid "Other users have found interesting uses for this feature. Sometimes there are situations where you have a bunch of local changes made to your working copy, and you'd like a collaborator to see them. Instead of running <command moreinfo=\"none\">svn diff</command> and sending a patch file (which won't capture tree changes, symlink changes or changes in properties), you can instead use <command moreinfo=\"none\">svn copy</command> to <quote>upload</quote> your working copy to a private area of the repository. Your collaborator can then either checkout a verbatim copy of your working copy, or use <command moreinfo=\"none\">svn merge</command> to receive your exact changes."
msgstr ""

#: en.xml:6370(title) 
msgid "Branch Maintenance"
msgstr ""

#: en.xml:6372(para) 
msgid "You may have noticed by now that Subversion is extremely flexible. Because it implements branches and tags with the same underlying mechanism (directory copies), and because branches and tags appear in normal filesystem space, many people find Subversion intimidating. It's almost <emphasis>too</emphasis> flexible. In this section, we'll offer some suggestions for arranging and managing your data over time."
msgstr ""

#: en.xml:6382(title) 
msgid "Repository Layout"
msgstr ""

#: en.xml:6384(para) 
msgid "There are some standard, recommended ways to organize a repository. Most people create a <filename moreinfo=\"none\">trunk</filename> directory to hold the <quote>main line</quote> of development, a <filename moreinfo=\"none\">branches</filename> directory to contain branch copies, and a <filename moreinfo=\"none\">tags</filename> directory to contain tag copies. If a repository holds only one project, then often people create these top-level directories:"
msgstr ""

#: en.xml:6392(screen) 
#, no-wrap
msgid "\n/trunk\n/branches\n/tags\n"
msgstr ""

#: en.xml:6398(para) 
msgid "If a repository contains multiple projects, admins typically index their layout by project (see <xref linkend=\"svn.reposadmin.projects.chooselayout\"/> to read more about <quote>project roots</quote>):"
msgstr ""

#: en.xml:6402(screen) 
#, no-wrap
msgid "\n/paint/trunk\n/paint/branches\n/paint/tags\n/calc/trunk\n/calc/branches\n/calc/tags\n"
msgstr ""

#: en.xml:6411(para) 
msgid "Of course, you're free to ignore these common layouts. You can create any sort of variation, whatever works best for you or your team. Remember that whatever you choose, it's not a permanent commitment. You can reorganize your repository at any time. Because branches and tags are ordinary directories, the <command moreinfo=\"none\">svn move</command> command can move or rename them however you wish. Switching from one layout to another is just a matter of issuing a series of server-side moves; if you don't like the way things are organized in the repository, just juggle the directories around."
msgstr ""

#: en.xml:6422(para) 
msgid "Remember, though, that while moving directories may be easy to do, you need to be considerate of your users as well. Your juggling can be disorienting to users with existing working copies. If a user has a working copy of a particular repository directory, your <command moreinfo=\"none\">svn move</command> operation might remove the path from the latest revision. When the user next runs <command moreinfo=\"none\">svn update</command>, she will be told that her working copy represents a path that no longer exists, and the user will be forced to <command moreinfo=\"none\">svn switch</command> to the new location."
msgstr ""

#: en.xml:6438(title) 
msgid "Data Lifetimes"
msgstr ""

#: en.xml:6440(para) 
msgid "Another nice feature of Subversion's model is that branches and tags can have finite lifetimes, just like any other versioned item. For example, suppose you eventually finish all your work on your personal branch of the <filename moreinfo=\"none\">calc</filename> project. After merging all of your changes back into <filename moreinfo=\"none\">/calc/trunk</filename>, there's no need for your private branch directory to stick around anymore:"
msgstr ""

#: en.xml:6449(screen) 
#, no-wrap
msgid "\n$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \\\n             -m \"Removing obsolete branch of calc project.\"\n\nCommitted revision 375.\n"
msgstr ""

#: en.xml:6456(para) 
msgid "And now your branch is gone. Of course it's not really gone: the directory is simply missing from the <literal moreinfo=\"none\">HEAD</literal> revision, no longer distracting anyone. If you use <command moreinfo=\"none\">svn checkout</command>, <command moreinfo=\"none\">svn switch</command>, or <command moreinfo=\"none\">svn list</command> to examine an earlier revision, you'll still be able to see your old branch."
msgstr ""

#: en.xml:6464(para) 
msgid "If browsing your deleted directory isn't enough, you can always bring it back. Resurrecting data is very easy in Subversion. If there's a deleted directory (or file) that you'd like to bring back into <literal moreinfo=\"none\">HEAD</literal>, simply use <command moreinfo=\"none\">svn copy -r</command> to copy it from the old revision:"
msgstr ""

#: en.xml:6471(screen) 
#, no-wrap
msgid "\n$ svn copy -r 374 http://svn.example.com/repos/calc/branches/my-calc-branch \\\n                  http://svn.example.com/repos/calc/branches/my-calc-branch\n\nCommitted revision 376.\n"
msgstr ""

#: en.xml:6478(para) 
msgid "In our example, your personal branch had a relatively short lifetime: you may have created it to fix a bug or implement a new feature. When your task is done, so is the branch. In software development, though, it's also common to have two <quote>main</quote> branches running side-by-side for very long periods. For example, suppose it's time to release a stable version of the <filename moreinfo=\"none\">calc</filename> project to the public, and you know it's going to take a couple of months to shake bugs out of the software. You don't want people to add new features to the project, but you don't want to tell all developers to stop programming either. So instead, you create a <quote>stable</quote> branch of the software that won't change much:"
msgstr ""

#: en.xml:6492(screen) 
#, no-wrap
msgid "\n$ svn copy http://svn.example.com/repos/calc/trunk \\\n         http://svn.example.com/repos/calc/branches/stable-1.0 \\\n         -m \"Creating stable branch of calc project.\"\n\nCommitted revision 377.\n"
msgstr ""

#: en.xml:6500(para) 
msgid "And now developers are free to continue adding cutting-edge (or experimental) features to <filename moreinfo=\"none\">/calc/trunk</filename>, and you can declare a project policy that only bug fixes are to be committed to <filename moreinfo=\"none\">/calc/branches/stable-1.0</filename>. That is, as people continue to work on the trunk, a human selectively ports bug fixes over to the stable branch. Even after the stable branch has shipped, you'll probably continue to maintain the branch for a long time—that is, as long as you continue to support that release for customers."
msgstr ""

#: en.xml:6522(para) 
msgid "We've covered a lot of ground in this chapter. We've discussed the concepts of tags and branches, and demonstrated how Subversion implements these concepts by copying directories with the <command moreinfo=\"none\">svn copy</command> command. We've shown how to use <command moreinfo=\"none\">svn merge</command> to copy changes from one branch to another, or roll back bad changes. We've gone over the use of <command moreinfo=\"none\">svn switch</command> to create mixed-location working copies. And we've talked about how one might manage the organization and lifetimes of branches in a repository."
msgstr ""

#: en.xml:6533(para) 
msgid "Remember the Subversion mantra: branches and tags are cheap. So use them liberally!"
msgstr ""

#: en.xml:6549(title) 
msgid "Repository Administration"
msgstr ""

#: en.xml:6553(para) 
msgid "The Subversion repository is the central storehouse of versioned data for any number of projects. As such, it becomes an obvious candidate for all the love and attention an administrator can offer. While the repository is generally a low-maintenance item, it is important to understand how to properly configure and care for it so that potential problems are avoided, and actual problems are safely resolved."
msgstr ""

#: en.xml:6561(para) 
msgid "In this chapter, we'll discuss how to create and configure a Subversion repository. We'll also talk about repository maintenance, including the use of the <command moreinfo=\"none\">svnlook</command> and <command moreinfo=\"none\">svnadmin</command> tools (which are provided with Subversion). We'll address some common questions and mistakes, and give some suggestions on how to arrange the data in the repository."
msgstr ""

#: en.xml:6575(para) 
msgid "This may sound really prestigious and lofty, but we're just talking about anyone who is interested in that mysterious realm beyond the working copy where everyone's data hangs out."
msgstr ""

#: en.xml:6569(para) 
msgid "If you plan to access a Subversion repository only in the role of a user whose data is under version control (that is, via a Subversion client), you can skip this chapter altogether. However, if you are, or wish to become, a Subversion repository administrator, <footnote><placeholder-1/></footnote> you should definitely pay attention to this chapter."
msgstr ""

#: en.xml:6588(title) 
msgid "Repository Basics"
msgstr ""

#: en.xml:6590(para) 
msgid "Before jumping into the broader topic of repository administration, let's further define what a repository is. How does it look? How does it feel? Does it take its tea hot or iced, sweetened, and with lemon? As an administrator, you'll be expected to understand the composition of a repository both from a logical perspective—dealing with how data is represented inside the repository—and from a physical nuts-and-bolts perspective—how a repository looks and acts with respect to non-Subversion tools. The following section covers some of these basic concepts at a very high level."
msgstr ""

#: en.xml:6603(title) 
msgid "Understanding Transactions and Revisions"
msgstr ""

#: en.xml:6605(para) 
msgid "Conceptually speaking, a Subversion repository is a sequence of directory trees. Each tree is a snapshot of how the files and directories versioned in your repository looked at some point in time. These snapshots are created as a result of client operations, and are called revisions."
msgstr ""

#: en.xml:6611(para) 
msgid "Every revision begins life as a transaction tree. When doing a commit, a client builds a Subversion transaction that mirrors their local changes (plus any additional changes that might have been made to the repository since the beginning of the client's commit process), and then instructs the repository to store that tree as the next snapshot in the sequence. If the commit succeeds, the transaction is effectively promoted into a new revision tree, and is assigned a new revision number. If the commit fails for some reason, the transaction is destroyed and the client is informed of the failure."
msgstr ""

#: en.xml:6623(para) 
msgid "Updates work in a similar way. The client builds a temporary transaction tree that mirrors the state of the working copy. The repository then compares that transaction tree with the revision tree at the requested revision (usually the most recent, or <quote>youngest</quote> tree), and sends back information that informs the client about what changes are needed to transform their working copy into a replica of that revision tree. After the update completes, the temporary transaction is deleted."
msgstr ""

#: en.xml:6633(para) 
msgid "The use of transaction trees is the only way to make permanent changes to a repository's versioned filesystem. However, it's important to understand that the lifetime of a transaction is completely flexible. In the case of updates, transactions are temporary trees that are immediately destroyed. In the case of commits, transactions are transformed into permanent revisions (or removed if the commit fails). In the case of an error or bug, it's possible that a transaction can be accidentally left lying around in the repository (not really affecting anything, but still taking up space)."
msgstr ""

#: en.xml:6645(para) 
msgid "In theory, someday whole workflow applications might revolve around more fine-grained control of transaction lifetime. It is feasible to imagine a system whereby each transaction slated to become a revision is left in stasis well after the client finishes describing its changes to repository. This would enable each new commit to be reviewed by someone else, perhaps a manager or engineering QA team, who can choose to promote the transaction into a revision, or abort it."
msgstr ""

#: en.xml:6659(title) en.xml:23662(title) 
msgid "Unversioned Properties"
msgstr ""

#: en.xml:6661(para) 
msgid "Transactions and revisions in the Subversion repository can have properties attached to them. These properties are generic key-to-value mappings, and are generally used to store information about the tree to which they are attached. The names and values of these properties are stored in the repository's filesystem, along with the rest of your tree data."
msgstr ""

#: en.xml:6669(para) 
msgid "Revision and transaction properties are useful for associating information with a tree that is not strictly related to the files and directories in that tree—the kind of information that isn't managed by client working copies. For example, when a new commit transaction is created in the repository, Subversion adds a property to that transaction named <literal moreinfo=\"none\">svn:date</literal>—a datestamp representing the time that the transaction was created. By the time the commit process is finished, and the transaction is promoted to a permanent revision, the tree has also been given a property to store the username of the revision's author (<literal moreinfo=\"none\">svn:author</literal>) and a property to store the log message attached to that revision (<literal moreinfo=\"none\">svn:log</literal>)."
msgstr ""

#: en.xml:6684(para) 
msgid "Revision and transaction properties are <firstterm>unversioned properties</firstterm>—as they are modified, their previous values are permanently discarded. Also, while revision trees themselves are immutable, the properties attached to those trees are not. You can add, remove, and modify revision properties at any time in the future. If you commit a new revision and later realize that you had some misinformation or spelling error in your log message, you can simply replace the value of the <literal moreinfo=\"none\">svn:log</literal> property with a new, corrected log message."
msgstr ""

#: en.xml:6700(title) 
msgid "Repository Data Stores"
msgstr ""

#: en.xml:6711(para) 
msgid "Pronounced <quote>fuzz-fuzz</quote>, if Jack Repenning has anything to say about it."
msgstr ""

#: en.xml:6702(para) 
msgid "As of Subversion 1.1, there are two options for storing data in a Subversion repository. One type of repository stores everything in a Berkeley DB database; the other kind stores data in ordinary flat files, using a custom format. Because Subversion developers often refer to a repository as <quote>the (versioned) filesystem</quote>, they have adopted the habit of referring to the latter type of repository as <firstterm>FSFS</firstterm><footnote><placeholder-1/></footnote> —a versioned filesystem implementation that uses the native OS filesystem to store data."
msgstr ""

#: en.xml:6718(para) 
msgid "When a repository is created, an administrator must decide whether it will use Berkeley DB or FSFS. There are advantages and disadvantages to each, which we'll describe in a bit. Neither back-end is more <quote>official</quote> than another, and programs which access the repository are insulated from this implementation detail. Programs have no idea how a repository is storing data; they only see revision and transaction trees through the repository API."
msgstr ""

#: en.xml:6727(para) 
msgid "<xref linkend=\"svn.reposadmin.basics.backends.tbl-1\"/> gives a comparative overview of Berkeley DB and FSFS repositories. The next sections go into detail."
msgstr ""

#: en.xml:6732(title) 
msgid "Repository Data Store Comparison"
msgstr ""

#: en.xml:6736(entry) en.xml:9444(entry) 
msgid "Feature"
msgstr ""

#: en.xml:6737(entry) en.xml:6840(title) 
msgid "Berkeley DB"
msgstr ""

#: en.xml:6738(entry) en.xml:6929(title) 
msgid "FSFS"
msgstr ""

#: en.xml:6743(entry) 
msgid "Sensitivity to interruptions"
msgstr ""

#: en.xml:6746(quote) 
msgid "wedged"
msgstr ""

#: en.xml:6745(entry) 
msgid "very; crashes and permission problems can leave the database <placeholder-1/>, requiring journaled recovery procedures."
msgstr ""

#: en.xml:6749(entry) 
msgid "quite insensitive."
msgstr ""

#: en.xml:6753(entry) 
msgid "Usable from a read-only mount"
msgstr ""

#: en.xml:6755(entry) en.xml:6763(entry) en.xml:6771(entry) 
msgid "no"
msgstr ""

#: en.xml:6757(entry) en.xml:6765(entry) en.xml:6773(entry) 
msgid "yes"
msgstr ""

#: en.xml:6761(entry) 
msgid "Platform-independent storage"
msgstr ""

#: en.xml:6769(entry) 
msgid "Usable over network filesystems"
msgstr ""

#: en.xml:6777(entry) 
msgid "Repository size"
msgstr ""

#: en.xml:6779(entry) 
msgid "slightly larger"
msgstr ""

#: en.xml:6781(entry) 
msgid "slightly smaller"
msgstr ""

#: en.xml:6785(entry) 
msgid "Scalability: number of revision trees"
msgstr ""

#: en.xml:6787(entry) 
msgid "database; no problems"
msgstr ""

#: en.xml:6789(entry) 
msgid "some older native filesystems don't scale well with thousands of entries in a single directory."
msgstr ""

#: en.xml:6794(entry) 
msgid "Scalability: directories with many files"
msgstr ""

#: en.xml:6796(entry) en.xml:6806(entry) 
msgid "slower"
msgstr ""

#: en.xml:6798(entry) en.xml:6804(entry) 
msgid "faster"
msgstr ""

#: en.xml:6802(entry) 
msgid "Speed: checking out latest code"
msgstr ""

#: en.xml:6810(entry) 
msgid "Speed: large commits"
msgstr ""

#: en.xml:6812(entry) 
msgid "slower, but work is spread throughout commit"
msgstr ""

#: en.xml:6814(entry) 
msgid "faster, but finalization delay may cause client timeouts"
msgstr ""

#: en.xml:6819(entry) 
msgid "Group permissions handling"
msgstr ""

#: en.xml:6821(entry) 
msgid "sensitive to user umask problems; best if accessed by only one user."
msgstr ""

#: en.xml:6824(entry) 
msgid "works around umask problems"
msgstr ""

#: en.xml:6828(entry) 
msgid "Code maturity"
msgstr ""

#: en.xml:6830(entry) 
msgid "in use since 2001"
msgstr ""

#: en.xml:6832(entry) 
msgid "in use since 2004"
msgstr ""

#: en.xml:6842(para) 
msgid "When the initial design phase of Subversion was in progress, the developers decided to use Berkeley DB for a variety of reasons, including its open-source license, transaction support, reliability, performance, API simplicity, thread-safety, support for cursors, and so on."
msgstr ""

#: en.xml:6849(para) 
msgid "Berkeley DB provides real transaction support—perhaps its most powerful feature. Multiple processes accessing your Subversion repositories don't have to worry about accidentally clobbering each other's data. The isolation provided by the transaction system is such that for any given operation, the Subversion repository code sees a static view of the database—not a database that is constantly changing at the hand of some other process—and can make decisions based on that view. If the decision made happens to conflict with what another process is doing, the entire operation is rolled back as if it never happened, and Subversion gracefully retries the operation against a new, updated (and yet still static) view of the database."
msgstr ""

#: en.xml:6864(para) 
msgid "Another great feature of Berkeley DB is <firstterm>hot backups</firstterm>—the ability to backup the database environment without taking it <quote>offline</quote>. We'll discuss how to backup your repository in <xref linkend=\"svn.reposadmin.maint.backup\"/>, but the benefits of being able to make fully functional copies of your repositories without any downtime should be obvious."
msgstr ""

#: en.xml:6871(para) 
msgid "Berkeley DB is also a very reliable database system. Subversion uses Berkeley DB's logging facilities, which means that the database first writes to on-disk log files a description of any modifications it is about to make, and then makes the modification itself. This is to ensure that if anything goes wrong, the database system can back up to a previous <firstterm>checkpoint</firstterm>—a location in the log files known not to be corrupt—and replay transactions until the data is restored to a usable state. See <xref linkend=\"svn.reposadmin.maint.diskspace\"/> for more about Berkeley DB log files."
msgstr ""

#: en.xml:6883(para) 
msgid "But every rose has its thorn, and so we must note some known limitations of Berkeley DB. First, Berkeley DB environments are not portable. You cannot simply copy a Subversion repository that was created on a Unix system onto a Windows system and expect it to work. While much of the Berkeley DB database format is architecture independent, there are other aspects of the environment that are not. Secondly, Subversion uses Berkeley DB in a way that will not operate on Windows 95/98 systems—if you need to house a repository on a Windows machine, stick with Windows 2000 or Windows XP. Also, you should never keep a Berkeley DB repository on a network share. While Berkeley DB promises to behave correctly on network shares that meet a particular set of specifications, almost no known shares actually meet all those specifications."
msgstr ""

#: en.xml:6899(para) 
msgid "Finally, because Berkeley DB is a library linked directly into Subversion, it's more sensitive to interruptions than a typical relational database system. Most SQL systems, for example, have a dedicated server process that mediates all access to tables. If a program accessing the database crashes for some reason, the database daemon notices the lost connection and cleans up any mess left behind. And because the database daemon is the only process accessing the tables, applications don't need to worry about permission conflicts. These things are not the case with Berkeley DB, however. Subversion (and programs using Subversion libraries) access the database tables directly, which means that a program crash can leave the database in a temporarily inconsistent, inaccessible state. When this happens, an administrator needs to ask Berkeley DB to restore to a checkpoint, which is a bit of an annoyance. Other things can cause a repository to <quote>wedge</quote> besides crashed processes, such as programs conflicting over ownership and permissions on the database files. So while a Berkeley DB repository is quite fast and scalable, it's best used by a single server process running as one user—such as Apache's <command moreinfo=\"none\">httpd</command> or <command moreinfo=\"none\">svnserve</command> (see <xref linkend=\"svn.serverconfig\"/>)—rather than accessing it as many different users via <literal moreinfo=\"none\">file:///</literal> or <literal moreinfo=\"none\">svn+ssh://</literal> URLs. If using a Berkeley DB repository directly as multiple users, be sure to read <xref linkend=\"svn.serverconfig.multimethod\"/>."
msgstr ""

#: en.xml:6931(para) 
msgid "In mid-2004, a second type of repository storage system came into being: one which doesn't use a database at all. An FSFS repository stores a revision tree in a single file, and so all of a repository's revisions can be found in a single subdirectory full of numbered files. Transactions are created in separate subdirectories. When complete, a single transaction file is created and moved to the revisions directory, thus guaranteeing that commits are atomic. And because a revision file is permanent and unchanging, the repository also can be backed up while <quote>hot</quote>, just like a Berkeley DB repository."
msgstr ""

#: en.xml:6943(para) 
msgid "The revision-file format represents a revision's directory structure, file contents, and deltas against files in other revision trees. Unlike a Berkeley DB database, this storage format is portable across different operating systems and isn't sensitive to CPU architecture. Because there's no journaling or shared-memory files being used, the repository can be safely accessed over a network filesystem and examined in a read-only environment. The lack of database overhead also means that the overall repository size is a bit smaller."
msgstr ""

#: en.xml:6954(para) 
msgid "FSFS has different performance characteristics too. When committing a directory with a huge number of files, FSFS uses an O(N) algorithm to append entries, while Berkeley DB uses an O(N^2) algorithm to rewrite the whole directory. On the other hand, FSFS writes the latest version of a file as a delta against an earlier version, which means that checking out the latest tree is a bit slower than fetching the fulltexts stored in a Berkeley DB HEAD revision. FSFS also has a longer delay when finalizing a commit, which could in extreme cases cause clients to time out when waiting for a response."
msgstr ""

#: en.xml:6966(para) 
msgid "The most important distinction, however, is FSFS's inability to be <quote>wedged</quote> when something goes wrong. If a process using a Berkeley DB database runs into a permissions problem or suddenly crashes, the database is left unusable until an administrator recovers it. If the same scenarios happen to a process using an FSFS repository, the repository isn't affected at all. At worst, some transaction data is left behind."
msgstr ""

#: en.xml:6975(para) 
msgid "The only real argument against FSFS is its relative immaturity compared to Berkeley DB. It hasn't been used or stress-tested nearly as much, and so a lot of these assertions about speed and scalability are just that: assertions, based on good guesses. In theory, it promises a lower barrier to entry for new administrators and is less susceptible to problems. In practice, only time will tell."
msgstr ""

#: en.xml:6992(title) 
msgid "Repository Creation and Configuration"
msgstr ""

#: en.xml:6994(para) 
msgid "Creating a Subversion repository is an incredibly simple task. The <command moreinfo=\"none\">svnadmin</command> utility, provided with Subversion, has a subcommand for doing just that. To create a new repository, just run:"
msgstr ""

#: en.xml:6999(screen) 
#, no-wrap
msgid "\n$ svnadmin create /path/to/repos\n"
msgstr ""

#: en.xml:7003(para) 
msgid "This creates a new repository in the directory <filename moreinfo=\"none\">/path/to/repos</filename>. This new repository begins life at revision 0, which is defined to consist of nothing but the top-level root (<filename moreinfo=\"none\">/</filename>) filesystem directory. Initially, revision 0 also has a single revision property, <literal moreinfo=\"none\">svn:date</literal>, set to the time at which the repository was created."
msgstr ""

#: en.xml:7011(para) 
msgid "In Subversion 1.2, a repository is created with an FSFS back-end by default (see <xref linkend=\"svn.reposadmin.basics.backends\"/>). The back-end can be explicitly chosen with the <option>--fs-type</option> argument:"
msgstr ""

#: en.xml:7016(screen) 
#, no-wrap
msgid "\n$ svnadmin create --fs-type fsfs /path/to/repos\n$ svnadmin create --fs-type bdb /path/to/other/repos\n"
msgstr ""

#: en.xml:7023(para) 
msgid "Do not create a Berkeley DB repository on a network share—it <emphasis>cannot</emphasis> exist on a remote filesystem such as NFS, AFS, or Windows SMB. Berkeley DB requires that the underlying filesystem implement strict POSIX locking semantics, and more importantly, the ability to map files directly into process memory. Almost no network filesystems provide these features. If you attempt to use Berkeley DB on a network share, the results are unpredictable—you may see mysterious errors right away, or it may be months before you discover that your repository database is subtly corrupted."
msgstr ""

#: en.xml:7035(para) 
msgid "If you need multiple computers to access the repository, you create an FSFS repository on the network share, not a Berkeley DB repository. Or better yet, set up a real server process (such as Apache or <command moreinfo=\"none\">svnserve</command>), store the repository on a local filesystem which the server can access, and make the repository available over a network. <xref linkend=\"svn.serverconfig\"/> covers this process in detail."
msgstr ""

#: en.xml:7045(para) 
msgid "You may have noticed that the path argument to <command moreinfo=\"none\">svnadmin</command> was just a regular filesystem path and not a URL like the <command moreinfo=\"none\">svn</command> client program uses when referring to repositories. Both <command moreinfo=\"none\">svnadmin</command> and <command moreinfo=\"none\">svnlook</command> are considered server-side utilities—they are used on the machine where the repository resides to examine or modify aspects of the repository, and are in fact unable to perform tasks across a network. A common mistake made by Subversion newcomers is trying to pass URLs (even <quote>local</quote><literal moreinfo=\"none\">file:</literal> ones) to these two programs."
msgstr ""

#: en.xml:7057(para) 
msgid "So, after you've run the <command moreinfo=\"none\">svnadmin create</command> command, you have a shiny new Subversion repository in its own directory. Let's take a peek at what is actually created inside that subdirectory."
msgstr ""

#: en.xml:7062(screen) 
#, no-wrap
msgid "\n$ ls repos\nconf/  dav/  db/  format  hooks/  locks/  README.txt\n"
msgstr ""

#: en.xml:7067(para) 
msgid "With the exception of the <filename moreinfo=\"none\">README.txt</filename> and <filename moreinfo=\"none\">format</filename> files, the repository directory is a collection of subdirectories. As in other areas of the Subversion design, modularity is given high regard, and hierarchical organization is preferred to cluttered chaos. Here is a brief description of all of the items you see in your new repository directory:"
msgstr ""

#: en.xml:7077(term) 
msgid "conf"
msgstr ""

#: en.xml:7079(para) 
msgid "A directory containing repository configuration files."
msgstr ""

#: en.xml:7083(term) 
msgid "dav"
msgstr ""

#: en.xml:7085(para) 
msgid "A directory provided to Apache and mod_dav_svn for their private housekeeping data."
msgstr ""

#: en.xml:7090(term) 
msgid "db"
msgstr ""

#: en.xml:7092(para) 
msgid "Where all of your versioned data resides. This directory is either a Berkeley DB environment (full of DB tables and other things), or is an FSFS environment containing revision files."
msgstr ""

#: en.xml:7099(term) 
msgid "format"
msgstr ""

#: en.xml:7101(para) 
msgid "A file whose contents are a single integer value that dictates the version number of the repository layout."
msgstr ""

#: en.xml:7106(term) 
msgid "hooks"
msgstr ""

#: en.xml:7108(para) 
msgid "A directory full of hook script templates (and hook scripts themselves, once you've installed some)."
msgstr ""

#: en.xml:7113(term) 
msgid "locks"
msgstr ""

#: en.xml:7115(para) 
msgid "A directory for Subversion's repository locking data, used for tracking accessors to the repository."
msgstr ""

#: en.xml:7120(term) 
msgid "README.txt"
msgstr ""

#: en.xml:7122(para) 
msgid "A file which merely informs its readers that they are looking at a Subversion repository."
msgstr ""

#: en.xml:7128(para) 
msgid "In general, you shouldn't tamper with your repository <quote>by hand</quote>. The <command moreinfo=\"none\">svnadmin</command> tool should be sufficient for any changes necessary to your repository, or you can look to third-party tools (such as Berkeley DB's tool suite) for tweaking relevant subsections of the repository. Some exceptions exist, though, and we'll cover those here."
msgstr ""

#: en.xml:7138(title) 
msgid "Hook Scripts"
msgstr ""

#: en.xml:7140(para) 
msgid "A <firstterm>hook</firstterm> is a program triggered by some repository event, such as the creation of a new revision or the modification of an unversioned property. Each hook is handed enough information to tell what that event is, what target(s) it's operating on, and the username of the person who triggered the event. Depending on the hook's output or return status, the hook program may continue the action, stop it, or suspend it in some way."
msgstr ""

#: en.xml:7149(para) 
msgid "The <filename moreinfo=\"none\">hooks</filename> subdirectory is, by default, filled with templates for various repository hooks."
msgstr ""

#: en.xml:7153(screen) 
#, no-wrap
msgid "\n$ ls repos/hooks/\npost-commit.tmpl          post-unlock.tmpl          pre-revprop-change.tmpl\npost-lock.tmpl            pre-commit.tmpl           pre-unlock.tmpl\npost-revprop-change.tmpl  pre-lock.tmpl             start-commit.tmpl\n"
msgstr ""

#: en.xml:7160(para) 
msgid "There is one template for each hook that the Subversion repository implements, and by examining the contents of those template scripts, you can see what triggers each such script to run and what data is passed to that script. Also present in many of these templates are examples of how one might use that script, in conjunction with other Subversion-supplied programs, to perform common useful tasks. To actually install a working hook, you need only place some executable program or script into the <filename moreinfo=\"none\">repos/hooks</filename> directory which can be executed as the name (like <command moreinfo=\"none\">start-commit</command> or <command moreinfo=\"none\">post-commit</command>) of the hook."
msgstr ""

#: en.xml:7173(para) 
msgid "On Unix platforms, this means supplying a script or program (which could be a shell script, a Python program, a compiled C binary, or any number of other things) named exactly like the name of the hook. Of course, the template files are present for more than just informational purposes—the easiest way to install a hook on Unix platforms is to simply copy the appropriate template file to a new file that lacks the <literal moreinfo=\"none\">.tmpl</literal> extension, customize the hook's contents, and ensure that the script is executable. Windows, however, uses file extensions to determine whether or not a program is executable, so you would need to supply a program whose basename is the name of the hook, and whose extension is one of the special extensions recognized by Windows for executable programs, such as <filename moreinfo=\"none\">.exe</filename> or <filename moreinfo=\"none\">.com</filename> for programs, and <filename moreinfo=\"none\">.bat</filename> for batch files."
msgstr ""

#: en.xml:7192(para) 
msgid "For security reasons, the Subversion repository executes hook scripts with an empty environment—that is, no environment variables are set at all, not even <literal moreinfo=\"none\">$PATH</literal> or <literal moreinfo=\"none\">%PATH%</literal>. Because of this, a lot of administrators are baffled when their hook script runs fine by hand, but doesn't work when run by Subversion. Be sure to explicitly set environment variables in your hook and/or use absolute paths to programs."
msgstr ""

#: en.xml:7203(para) 
msgid "There are nine hooks implemented by the Subversion repository:"
msgstr ""

#: en.xml:7208(filename) 
msgid "start-commit"
msgstr ""

#: en.xml:7210(para) 
msgid "This is run before the commit transaction is even created. It is typically used to decide if the user has commit privileges at all. The repository passes two arguments to this program: the path to the repository, and username which is attempting the commit. If the program returns a non-zero exit value, the commit is stopped before the transaction is even created. If the hook program writes data to stderr, it will be marshalled back to the client."
msgstr ""

#: en.xml:7223(filename) 
msgid "pre-commit"
msgstr ""

#: en.xml:7225(para) 
msgid "This is run when the transaction is complete, but before it is committed. Typically, this hook is used to protect against commits that are disallowed due to content or location (for example, your site might require that all commits to a certain branch include a ticket number from the bug tracker, or that the incoming log message is non-empty). The repository passes two arguments to this program: the path to the repository, and the name of the transaction being committed. If the program returns a non-zero exit value, the commit is aborted and the transaction is removed. If the hook program writes data to stderr, it will be marshalled back to the client."
msgstr ""

#: en.xml:7239(para) 
msgid "The Subversion distribution includes some access control scripts (located in the <filename moreinfo=\"none\">tools/hook-scripts</filename> directory of the Subversion source tree) that can be called from <command moreinfo=\"none\">pre-commit</command> to implement fine-grained write-access control. Another option is to use the <command moreinfo=\"none\">mod_authz_svn</command> Apache httpd module, which provides both read and write access control on individual directories (see <xref linkend=\"svn.serverconfig.httpd.authz.perdir\"/>). In a future version of Subversion, we plan to implement access control lists (ACLs) directly in the filesystem."
msgstr ""

#: en.xml:7254(filename) 
msgid "post-commit"
msgstr ""

#: en.xml:7256(para) 
msgid "This is run after the transaction is committed, and a new revision is created. Most people use this hook to send out descriptive emails about the commit or to make a backup of the repository. The repository passes two arguments to this program: the path to the repository, and the new revision number that was created. The exit code of the program is ignored."
msgstr ""

#: en.xml:7264(para) 
msgid "The Subversion distribution includes <command moreinfo=\"none\">mailer.py</command> and <command moreinfo=\"none\">commit-email.pl</command> scripts (located in the <filename moreinfo=\"none\">tools/hook-scripts/</filename> directory of the Subversion source tree) that can be used to send email with (and/or append to a log file) a description of a given commit. This mail contains a list of the paths that were changed, the log message attached to the commit, the author and date of the commit, as well as a GNU diff-style display of the changes made to the various versioned files as part of the commit."
msgstr ""

#: en.xml:7276(para) 
msgid "Another useful tool provided by Subversion is the <command moreinfo=\"none\">hot-backup.py</command> script (located in the <filename moreinfo=\"none\">tools/backup/</filename> directory of the Subversion source tree). This script performs hot backups of your Subversion repository (a feature supported by the Berkeley DB database back-end), and can be used to make a per-commit snapshot of your repository for archival or emergency recovery purposes."
msgstr ""

#: en.xml:7288(filename) 
msgid "pre-revprop-change"
msgstr ""

#: en.xml:7290(para) 
msgid "Because Subversion's revision properties are not versioned, making modifications to such a property (for example, the <literal moreinfo=\"none\">svn:log</literal> commit message property) will overwrite the previous value of that property forever. Since data can be potentially lost here, Subversion supplies this hook (and its counterpart, <filename moreinfo=\"none\">post-revprop-change</filename>) so that repository administrators can keep records of changes to these items using some external means if they so desire. As a precaution against losing unversioned property data, Subversion clients will not be allowed to remotely modify revision properties at all unless this hook is implemented for your repository."
msgstr ""

#: en.xml:7304(para) 
msgid "This hook runs just before such a modification is made to the repository. The repository passes four arguments to this hook: the path to the repository, the revision on which the to-be-modified property exists, the authenticated username of the person making the change, and the name of the property itself."
msgstr ""

#: en.xml:7314(filename) 
msgid "post-revprop-change"
msgstr ""

#: en.xml:7316(para) 
msgid "As mentioned earlier, this hook is the counterpart of the <filename moreinfo=\"none\">pre-revprop-change</filename> hook. In fact, for the sake of paranoia this script will not run unless the <filename moreinfo=\"none\">pre-revprop-change</filename> hook exists. When both of these hooks are present, the <filename moreinfo=\"none\">post-revprop-change</filename> hook runs just after a revision property has been changed, and is typically used to send an email containing the new value of the changed property. The repository passes four arguments to this hook: the path to the repository, the revision on which the property exists, the authenticated username of the person making the change, and the name of the property itself."
msgstr ""

#: en.xml:7330(para) 
msgid "The Subversion distribution includes a <command moreinfo=\"none\">propchange-email.pl</command> script (located in the <filename moreinfo=\"none\">tools/hook-scripts/</filename> directory of the Subversion source tree) that can be used to send email with (and/or append to a log file) the details of a revision property change. This mail contains the revision and name of the changed property, the user who made the change, and the new property value."
msgstr ""

#: en.xml:7343(filename) 
msgid "pre-lock"
msgstr ""

#: en.xml:7345(para) 
msgid "This hook runs whenever someone attempts to lock a file. It can be used to prevent locks altogether, or to create a more complex policy specifying exactly which users are allowed to lock particular paths. If the hook notices a pre-existing lock, then it can also decide whether a user is allowed to <quote>steal</quote> the existing lock. The repository passes three arguments to the hook: the path to the repository, the path being locked, and the user attempting to perform the lock. If the program returns a non-zero exit value, the lock action is aborted and anything printed to stderr is marshalled back to the client."
msgstr ""

#: en.xml:7361(filename) 
msgid "post-lock"
msgstr ""

#: en.xml:7363(para) 
msgid "This hook runs after a path is locked. The locked path is passed to the hook's stdin, and the hook also receives two arguments: the path to the repository, and the user who performed the lock. The hook is then free to send email notification or record the event in any way it chooses. Because the lock already happened, the output of the hook is ignored."
msgstr ""

#: en.xml:7374(filename) 
msgid "pre-unlock"
msgstr ""

#: en.xml:7376(para) 
msgid "This hook runs whenever someone attempts to remove a lock on a file. It can be used to create policies that specify which users are allowed to unlock particular paths. It's particularly important for determining policies about lock breakage. If user A locks a file, is user B allowed to break the lock? What if the lock is more than a week old? These sorts of things can be decided and enforced by the hook. The repository passes three arguments to the hook: the path to the repository, the path being unlocked, and the user attempting to remove the lock. If the program returns a non-zero exit value, the unlock action is aborted and anything printed to stderr is marshalled back to the client."
msgstr ""

#: en.xml:7393(filename) 
msgid "post-unlock"
msgstr ""

#: en.xml:7395(para) 
msgid "This hook runs after a path is unlocked. The unlocked path is passed to the hook's stdin, and the hook also receives two arguments: the path to the repository, and the user who removed the lock. The hook is then free to send email notification or record the event in any way it chooses. Because the lock removal already happened, the output of the hook is ignored."
msgstr ""

#: en.xml:7408(para) 
msgid "Do not attempt to modify the transaction using hook scripts. A common example of this would be to automatically set properties such as <literal moreinfo=\"none\">svn:eol-style</literal> or <literal moreinfo=\"none\">svn:mime-type</literal> during the commit. While this might seem like a good idea, it causes problems. The main problem is that the client does not know about the change made by the hook script, and there is no way to inform the client that it is out-of-date. This inconsistency can lead to surprising and unexpected behavior."
msgstr ""

#: en.xml:7419(para) 
msgid "Instead of attempting to modify the transaction, it is much better to <emphasis>check</emphasis> the transaction in the <filename moreinfo=\"none\">pre-commit</filename> hook and reject the commit if it does not meet the desired requirements."
msgstr ""

#: en.xml:7425(para) 
msgid "Subversion will attempt to execute hooks as the same user who owns the process which is accessing the Subversion repository. In most cases, the repository is being accessed via Apache HTTP server and mod_dav_svn, so this user is the same user that Apache runs as. The hooks themselves will need to be configured with OS-level permissions that allow that user to execute them. Also, this means that any file or programs (including the Subversion repository itself) accessed directly or indirectly by the hook will be accessed as the same user. In other words, be alert to potential permission-related problems that could prevent the hook from performing the tasks you've written it to perform."
msgstr ""

#: en.xml:7442(title) 
msgid "Berkeley DB Configuration"
msgstr ""

#: en.xml:7444(para) 
msgid "A Berkeley DB environment is an encapsulation of one or more databases, log files, region files and configuration files. The Berkeley DB environment has its own set of default configuration values for things like the number of database locks allowed to be taken out at any given time, or the maximum size of the journaling log files, etc. Subversion's filesystem code additionally chooses default values for some of the Berkeley DB configuration options. However, sometimes your particular repository, with its unique collection of data and access patterns, might require a different set of configuration option values."
msgstr ""

#: en.xml:7456(para) 
msgid "The folks at Sleepycat (the producers of Berkeley DB) understand that different databases have different requirements, and so they have provided a mechanism for overriding at runtime many of the configuration values for the Berkeley DB environment. Berkeley checks for the presence of a file named <filename moreinfo=\"none\">DB_CONFIG</filename> in each environment directory, and parses the options found in that file for use with that particular Berkeley environment."
msgstr ""

#: en.xml:7465(para) 
msgid "The Berkeley configuration file for your repository is located in the <filename moreinfo=\"none\">db</filename> environment directory, at <filename moreinfo=\"none\">repos/db/DB_CONFIG</filename>. Subversion itself creates this file when it creates the rest of the repository. The file initially contains some default options, as well as pointers to the Berkeley DB online documentation so you can read about what those options do. Of course, you are free to add any of the supported Berkeley DB options to your <filename moreinfo=\"none\">DB_CONFIG</filename> file. Just be aware that while Subversion never attempts to read or interpret the contents of the file, and makes no use of the option settings in it, you'll want to avoid any configuration changes that may cause Berkeley DB to behave in a fashion that is unexpected by the rest of the Subversion code. Also, changes made to <filename moreinfo=\"none\">DB_CONFIG</filename> won't take effect until you recover the database environment (using <command moreinfo=\"none\">svnadmin recover</command>)."
msgstr ""

#: en.xml:7490(title) 
msgid "Repository Maintenance"
msgstr ""

#: en.xml:7492(para) 
msgid "Maintaining a Subversion repository can be a daunting task, mostly due to the complexities inherent in systems which have a database backend. Doing the task well is all about knowing the tools—what they are, when to use them, and how to use them. This section will introduce you to the repository administration tools provided by Subversion, and how to wield them to accomplish tasks such as repository migrations, upgrades, backups and cleanups."
msgstr ""

#: en.xml:7503(title) 
msgid "An Administrator's Toolkit"
msgstr ""

#: en.xml:7505(para) 
msgid "Subversion provides a handful of utilities useful for creating, inspecting, modifying and repairing your repository. Let's look more closely at each of those tools. Afterward, we'll briefly examine some of the utilities included in the Berkeley DB distribution that provide functionality specific to your repository's database backend not otherwise provided by Subversion's own tools."
msgstr ""

#: en.xml:7516(para) 
msgid "<command moreinfo=\"none\">svnlook</command> is a tool provided by Subversion for examining the various revisions and transactions in a repository. No part of this program attempts to change the repository—it's a <quote>read-only</quote> tool. <command moreinfo=\"none\">svnlook</command> is typically used by the repository hooks for reporting the changes that are about to be committed (in the case of the <command moreinfo=\"none\">pre-commit</command> hook) or that were just committed (in the case of the <command moreinfo=\"none\">post-commit</command> hook) to the repository. A repository administrator may use this tool for diagnostic purposes."
msgstr ""

#: en.xml:7528(para) 
msgid "<command moreinfo=\"none\">svnlook</command> has a straightforward syntax:"
msgstr ""

#: en.xml:7531(screen) 
#, no-wrap
msgid "\n$ svnlook help\ngeneral usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]\nNote: any subcommand which takes the '--revision' and '--transaction'\n      options will, if invoked without one of those options, act on\n      the repository's youngest revision.\nType \"svnlook help &lt;subcommand&gt;\" for help on a specific subcommand.\n…\n"
msgstr ""

#: en.xml:7541(para) 
msgid "Nearly every one of <command moreinfo=\"none\">svnlook</command>'s subcommands can operate on either a revision or a transaction tree, printing information about the tree itself, or how it differs from the previous revision of the repository. You use the <option>--revision</option> and <option>--transaction</option> options to specify which revision or transaction, respectively, to examine. Note that while revision numbers appear as natural numbers, transaction names are alphanumeric strings. Keep in mind that the filesystem only allows browsing of uncommitted transactions (transactions that have not resulted in a new revision). Most repositories will have no such transactions, because transactions are usually either committed (which disqualifies them from viewing) or aborted and removed."
msgstr ""

#: en.xml:7557(para) 
msgid "In the absence of both the <option>--revision</option> and <option>--transaction</option> options, <command moreinfo=\"none\">svnlook</command> will examine the youngest (or <quote>HEAD</quote>) revision in the repository. So the following two commands do exactly the same thing when 19 is the youngest revision in the repository located at <filename moreinfo=\"none\">/path/to/repos</filename>:"
msgstr ""

#: en.xml:7565(screen) 
#, no-wrap
msgid "\n$ svnlook info /path/to/repos\n$ svnlook info /path/to/repos --revision 19\n"
msgstr ""

#: en.xml:7570(para) 
msgid "The only exception to these rules about subcommands is the <command moreinfo=\"none\">svnlook youngest</command> subcommand, which takes no options, and simply prints out the <literal moreinfo=\"none\">HEAD</literal> revision number."
msgstr ""

#: en.xml:7575(screen) 
#, no-wrap
msgid "\n$ svnlook youngest /path/to/repos\n19\n"
msgstr ""

#: en.xml:7580(para) 
msgid "Output from <command moreinfo=\"none\">svnlook</command> is designed to be both human- and machine-parsable. Take as an example the output of the <literal moreinfo=\"none\">info</literal> subcommand:"
msgstr ""

#: en.xml:7584(screen) 
#, no-wrap
msgid "\n$ svnlook info /path/to/repos\nsally\n2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)\n27\nAdded the usual\nGreek tree.\n"
msgstr ""

#: en.xml:7593(para) 
msgid "The output of the <literal moreinfo=\"none\">info</literal> subcommand is defined as:"
msgstr ""

#: en.xml:7598(para) 
msgid "The author, followed by a newline."
msgstr ""

#: en.xml:7601(para) 
msgid "The date, followed by a newline."
msgstr ""

#: en.xml:7604(para) 
msgid "The number of characters in the log message, followed by a newline."
msgstr ""

#: en.xml:7608(para) 
msgid "The log message itself, followed by a newline."
msgstr ""

#: en.xml:7612(para) 
msgid "This output is human-readable, meaning items like the datestamp are displayed using a textual representation instead of something more obscure (such as the number of nanoseconds since the Tasty Freeze guy drove by). But this output is also machine-parsable—because the log message can contain multiple lines and be unbounded in length, <command moreinfo=\"none\">svnlook</command> provides the length of that message before the message itself. This allows scripts and other wrappers around this command to make intelligent decisions about the log message, such as how much memory to allocate for the message, or at least how many bytes to skip in the event that this output is not the last bit of data in the stream."
msgstr ""

#: en.xml:7626(para) 
msgid "Another common use of <command moreinfo=\"none\">svnlook</command> is to actually view the contents of a revision or transaction tree. The <command moreinfo=\"none\">svnlook tree</command> command displays the directories and files in the requested tree. If you supply the <option>--show-ids</option> option, it will also show the filesystem node revision IDs for each of those paths (which is generally of more use to developers than to users)."
msgstr ""

#: en.xml:7635(screen) 
#, no-wrap
msgid "\n$ svnlook tree /path/to/repos --show-ids\n/ &lt;0.0.1&gt;\n A/ &lt;2.0.1&gt;\n  B/ &lt;4.0.1&gt;\n   lambda &lt;5.0.1&gt;\n   E/ &lt;6.0.1&gt;\n    alpha &lt;7.0.1&gt;\n    beta &lt;8.0.1&gt;\n   F/ &lt;9.0.1&gt;\n  mu &lt;3.0.1&gt;\n  C/ &lt;a.0.1&gt;\n  D/ &lt;b.0.1&gt;\n   gamma &lt;c.0.1&gt;\n   G/ &lt;d.0.1&gt;\n    pi &lt;e.0.1&gt;\n    rho &lt;f.0.1&gt;\n    tau &lt;g.0.1&gt;\n   H/ &lt;h.0.1&gt;\n    chi &lt;i.0.1&gt;\n    omega &lt;k.0.1&gt;\n    psi &lt;j.0.1&gt;\n iota &lt;1.0.1&gt;\n"
msgstr ""

#: en.xml:7660(para) 
msgid "Once you've seen the layout of directories and files in your tree, you can use commands like <command moreinfo=\"none\">svnlook cat</command>, <command moreinfo=\"none\">svnlook propget</command>, and <command moreinfo=\"none\">svnlook proplist</command> to dig into the details of those files and directories."
msgstr ""

#: en.xml:7666(para) 
msgid "<command moreinfo=\"none\">svnlook</command> can perform a variety of other queries, displaying subsets of bits of information we've mentioned previously, reporting which paths were modified in a given revision or transaction, showing textual and property differences made to files and directories, and so on. The following is a brief description of the current list of subcommands accepted by <command moreinfo=\"none\">svnlook</command>, and the output of those subcommands:"
msgstr ""

#: en.xml:7677(literal) 
msgid "author"
msgstr ""

#: en.xml:7679(para) 
msgid "Print the tree's author."
msgstr ""

#: en.xml:7684(literal) 
msgid "cat"
msgstr ""

#: en.xml:7686(para) 
msgid "Print the contents of a file in the tree."
msgstr ""

#: en.xml:7691(literal) 
msgid "changed"
msgstr ""

#: en.xml:7693(para) 
msgid "List all files and directories that changed in the tree."
msgstr ""

#: en.xml:7699(literal) 
msgid "date"
msgstr ""

#: en.xml:7701(para) 
msgid "Print the tree's datestamp."
msgstr ""

#: en.xml:7706(literal) 
msgid "diff"
msgstr ""

#: en.xml:7708(para) 
msgid "Print unified diffs of changed files."
msgstr ""

#: en.xml:7713(literal) 
msgid "dirs-changed"
msgstr ""

#: en.xml:7715(para) 
msgid "List the directories in the tree that were themselves changed, or whose file children were changed."
msgstr ""

#: en.xml:7722(literal) 
msgid "history"
msgstr ""

#: en.xml:7724(para) 
msgid "Display interesting points in the history of a versioned path (places where modifications or copies occurred)."
msgstr ""

#: en.xml:7731(literal) 
msgid "info"
msgstr ""

#: en.xml:7733(para) 
msgid "Print the tree's author, datestamp, log message character count, and log message."
msgstr ""

#: en.xml:7739(literal) 
msgid "lock"
msgstr ""

#: en.xml:7741(para) 
msgid "If a path is locked, describe the lock attributes."
msgstr ""

#: en.xml:7746(literal) 
msgid "log"
msgstr ""

#: en.xml:7748(para) 
msgid "Print the tree's log message."
msgstr ""

#: en.xml:7753(literal) 
msgid "propget"
msgstr ""

#: en.xml:7755(para) 
msgid "Print the value of a property on a path in the tree."
msgstr ""

#: en.xml:7761(literal) 
msgid "proplist"
msgstr ""

#: en.xml:7763(para) 
msgid "Print the names and values of properties set on paths in the tree."
msgstr ""

#: en.xml:7769(literal) 
msgid "tree"
msgstr ""

#: en.xml:7771(para) 
msgid "Print the tree listing, optionally revealing the filesystem node revision IDs associated with each path."
msgstr ""

#: en.xml:7778(literal) 
msgid "uuid"
msgstr ""

#: en.xml:7780(para) 
msgid "Print the repository's UUID— <emphasis>U</emphasis>niversal <emphasis>U</emphasis>nique <emphasis>ID</emphasis>entifier."
msgstr ""

#: en.xml:7787(literal) 
msgid "youngest"
msgstr ""

#: en.xml:7789(para) en.xml:23060(refpurpose) 
msgid "Print the youngest revision number."
msgstr ""

#: en.xml:7799(para) 
msgid "The <command moreinfo=\"none\">svnadmin</command> program is the repository administrator's best friend. Besides providing the ability to create Subversion repositories, this program allows you to perform several maintenance operations on those repositories. The syntax of <command moreinfo=\"none\">svnadmin</command> is similar to that of <command moreinfo=\"none\">svnlook</command>:"
msgstr ""

#: en.xml:7807(screen) 
#, no-wrap
msgid "\n$ svnadmin help\ngeneral usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]\nType \"svnadmin help &lt;subcommand&gt;\" for help on a specific subcommand.\n\nAvailable subcommands:\n   create\n   deltify\n   dump\n   help (?, h)\n…\n"
msgstr ""

#: en.xml:7820(para) 
msgid "We've already mentioned <command moreinfo=\"none\">svnadmin</command>'s <literal moreinfo=\"none\">create</literal> subcommand (see <xref linkend=\"svn.reposadmin.create\"/>). Most of the others we will cover in more detail later in this chapter. For now, let's just take a quick glance at what each of the available subcommands offers."
msgstr ""

#: en.xml:7828(literal) 
msgid "create"
msgstr ""

#: en.xml:7830(para) 
msgid "Create a new Subversion repository."
msgstr ""

#: en.xml:7835(literal) 
msgid "deltify"
msgstr ""

#: en.xml:7837(para) 
msgid "Run over a specified revision range, performing predecessor deltification on the paths changed in those revisions. If no revisions are specified, this command will simply deltify the <literal moreinfo=\"none\">HEAD</literal> revision."
msgstr ""

#: en.xml:7846(literal) 
msgid "dump"
msgstr ""

#: en.xml:7848(para) 
msgid "Dump the contents of the repository, bounded by a given set of revisions, using a portable dump format."
msgstr ""

#: en.xml:7854(literal) 
msgid "hotcopy"
msgstr ""

#: en.xml:7856(para) 
msgid "Make a hot copy of a repository. You can run this command at any time and make a safe copy of the repository, regardless if other processes are using the repository."
msgstr ""

#: en.xml:7864(literal) 
msgid "list-dblogs"
msgstr ""

#: en.xml:7866(para) 
msgid "(Berkeley DB repositories only.) List the paths of Berkeley DB log files associated with the repository. This list includes all log files—those still in use by Subversion, as well as those no longer in use."
msgstr ""

#: en.xml:7875(literal) 
msgid "list-unused-dblogs"
msgstr ""

#: en.xml:7877(para) 
msgid "(Berkeley DB repositories only.) List the paths of Berkeley DB log files associated with, but no longer used by, the repository. You may safely remove these log files from the repository layout, possibly archiving them for use in the event that you ever need to perform a catastrophic recovery of the repository."
msgstr ""

#: en.xml:7888(literal) 
msgid "load"
msgstr ""

#: en.xml:7890(para) 
msgid "Load a set of revisions into a repository from a stream of data that uses the same portable dump format generated by the <literal moreinfo=\"none\">dump</literal> subcommand."
msgstr ""

#: en.xml:7897(literal) 
msgid "lslocks"
msgstr ""

#: en.xml:7899(para) 
msgid "List and describe any locks that exist in the repository."
msgstr ""

#: en.xml:7905(literal) 
msgid "lstxns"
msgstr ""

#: en.xml:7907(para) 
msgid "List the names of uncommitted Subversion transactions that currently exist in the repository."
msgstr ""

#: en.xml:7913(literal) 
msgid "recover"
msgstr ""

#: en.xml:7915(para) 
msgid "Perform recovery steps on a repository that is in need of such, generally after a fatal error has occurred that prevented a process from cleanly shutting down its communication with the repository."
msgstr ""

#: en.xml:7923(literal) 
msgid "rmlocks"
msgstr ""

#: en.xml:7925(para) 
msgid "Unconditionally remove locks from listed paths."
msgstr ""

#: en.xml:7931(literal) 
msgid "rmtxns"
msgstr ""

#: en.xml:7933(para) 
msgid "Cleanly remove Subversion transactions from the repository (conveniently fed by output from the <literal moreinfo=\"none\">lstxns</literal> subcommand)."
msgstr ""

#: en.xml:7940(literal) 
msgid "setlog"
msgstr ""

#: en.xml:7942(para) 
msgid "Replace the current value of the <literal moreinfo=\"none\">svn:log</literal> (commit log message) property on a given revision in the repository with a new value."
msgstr ""

#: en.xml:7950(literal) 
msgid "verify"
msgstr ""

#: en.xml:7952(para) 
msgid "Verify the contents of the repository. This includes, among other things, checksum comparisons of the versioned data stored in the repository."
msgstr ""

#: en.xml:7970(para) 
msgid "That, by the way, is a <emphasis>feature</emphasis>, not a bug."
msgstr ""

#: en.xml:7964(para) 
msgid "Since Subversion stores everything in an opaque database system, attempting manual tweaks is unwise, if not quite difficult. And once data has been stored in your repository, Subversion generally doesn't provide an easy way to remove that data. <footnote><placeholder-1/></footnote> But inevitably, there will be times when you would like to manipulate the history of your repository. You might need to strip out all instances of a file that was accidentally added to the repository (and shouldn't be there for whatever reason). Or, perhaps you have multiple projects sharing a single repository, and you decide to split them up into their own repositories. To accomplish tasks like this, administrators need a more manageable and malleable representation of the data in their repositories—the Subversion repository dump format."
msgstr ""

#: en.xml:7984(para) 
msgid "The Subversion repository dump format is a human-readable representation of the changes that you've made to your versioned data over time. You use the <command moreinfo=\"none\">svnadmin dump</command> command to generate the dump data, and <command moreinfo=\"none\">svnadmin load</command> to populate a new repository with it (see <xref linkend=\"svn.reposadmin.maint.migrate\"/>). The great thing about the human-readability aspect of the dump format is that, if you aren't careless about it, you can manually inspect and modify it. Of course, the downside is that if you have two years' worth of repository activity encapsulated in what is likely to be a very large dump file, it could take you a long, long time to manually inspect and modify it."
msgstr ""

#: en.xml:7997(para) 
msgid "While it won't be the most commonly used tool at the administrator's disposal, <command moreinfo=\"none\">svndumpfilter</command> provides a very particular brand of useful functionality—the ability to quickly and easily modify that dump data by acting as a path-based filter. Simply give it either a list of paths you wish to keep, or a list of paths you wish to not keep, then pipe your repository dump data through this filter. The result will be a modified stream of dump data that contains only the versioned paths you (explicitly or implicitly) requested."
msgstr ""

#: en.xml:8008(para) 
msgid "The syntax of <command moreinfo=\"none\">svndumpfilter</command> is as follows:"
msgstr ""

#: en.xml:8011(screen) 
#, no-wrap
msgid "\n$ svndumpfilter help\ngeneral usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]\nType \"svndumpfilter help &lt;subcommand&gt;\" for help on a specific subcommand.\n\nAvailable subcommands:\n   exclude\n   include\n   help (?, h)\n"
msgstr ""

#: en.xml:8022(para) 
msgid "There are only two interesting subcommands. They allow you to make the choice between explicit or implicit inclusion of paths in the stream:"
msgstr ""

#: en.xml:8028(literal) 
msgid "exclude"
msgstr ""

#: en.xml:8030(para) 
msgid "Filter out a set of paths from the dump data stream."
msgstr ""

#: en.xml:8036(literal) 
msgid "include"
msgstr ""

#: en.xml:8038(para) 
msgid "Allow only the requested set of paths to pass through the dump data stream."
msgstr ""

#: en.xml:8044(para) 
msgid "Let's look a realistic example of how you might use this program. We discuss elsewhere (see <xref linkend=\"svn.reposadmin.projects.chooselayout\"/>) the process of deciding how to choose a layout for the data in your repositories—using one repository per project or combining them, arranging stuff within your repository, and so on. But sometimes after new revisions start flying in, you rethink your layout and would like to make some changes. A common change is the decision to move multiple projects which are sharing a single repository into separate repositories for each project."
msgstr ""

#: en.xml:8055(para) 
msgid "Our imaginary repository contains three projects: <literal moreinfo=\"none\">calc</literal>, <literal moreinfo=\"none\">calendar</literal>, and <literal moreinfo=\"none\">spreadsheet</literal>. They have been living side-by-side in a layout like this:"
msgstr ""

#: en.xml:8060(screen) 
#, no-wrap
msgid "\n/\n   calc/\n      trunk/\n      branches/\n      tags/\n   calendar/\n      trunk/\n      branches/\n      tags/\n   spreadsheet/\n      trunk/\n      branches/\n      tags/\n"
msgstr ""

#: en.xml:8076(para) 
msgid "To get these three projects into their own repositories, we first dump the whole repository:"
msgstr ""

#: en.xml:8079(screen) 
#, no-wrap
msgid "\n$ svnadmin dump /path/to/repos &gt; repos-dumpfile\n* Dumped revision 0.\n* Dumped revision 1.\n* Dumped revision 2.\n* Dumped revision 3.\n…\n$\n"
msgstr ""

#: en.xml:8089(para) 
msgid "Next, run that dump file through the filter, each time including only one of our top-level directories, and resulting in three new dump files:"
msgstr ""

#: en.xml:8093(screen) 
#, no-wrap
msgid "\n$ cat repos-dumpfile | svndumpfilter include calc &gt; calc-dumpfile\n…\n$ cat repos-dumpfile | svndumpfilter include calendar &gt; cal-dumpfile\n…\n$ cat repos-dumpfile | svndumpfilter include spreadsheet &gt; ss-dumpfile\n…\n$\n"
msgstr ""

#: en.xml:8103(para) 
msgid "At this point, you have to make a decision. Each of your dump files will create a valid repository, but will preserve the paths exactly as they were in the original repository. This means that even though you would have a repository solely for your <literal moreinfo=\"none\">calc</literal> project, that repository would still have a top-level directory named <filename moreinfo=\"none\">calc</filename>. If you want your <filename moreinfo=\"none\">trunk</filename>, <filename moreinfo=\"none\">tags</filename>, and <filename moreinfo=\"none\">branches</filename> directories to live in the root of your repository, you might wish to edit your dump files, tweaking the <literal moreinfo=\"none\">Node-path</literal> and <literal moreinfo=\"none\">Node-copyfrom-path</literal> headers to no longer have that first <filename moreinfo=\"none\">calc/</filename> path component. Also, you'll want to remove the section of dump data that creates the <filename moreinfo=\"none\">calc</filename> directory. It will look something like:"
msgstr ""

#: en.xml:8120(screen) 
#, no-wrap
msgid "\nNode-path: calc\nNode-action: add\nNode-kind: dir\nContent-length: 0\n\n"
msgstr ""

#: en.xml:8129(para) 
msgid "If you do plan on manually editing the dump file to remove a top-level directory, make sure that your editor is not set to automatically convert end-lines to the native format (e.g. \\r\\n to \\n) as the content will then not agree with the metadata and this will render the dump file useless."
msgstr ""

#: en.xml:8137(para) 
msgid "All that remains now is to create your three new repositories, and load each dump file into the right repository:"
msgstr ""

#: en.xml:8141(screen) 
#, no-wrap
msgid "\n$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile\n&lt;&lt;&lt; Started new transaction, based on original revision 1\n     * adding path : Makefile ... done.\n     * adding path : button.c ... done.\n…\n$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile\n&lt;&lt;&lt; Started new transaction, based on original revision 1\n     * adding path : Makefile ... done.\n     * adding path : cal.c ... done.\n…\n$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile\n&lt;&lt;&lt; Started new transaction, based on original revision 1\n     * adding path : Makefile ... done.\n     * adding path : ss.c ... done.\n…\n$\n"
msgstr ""

#: en.xml:8160(para) 
msgid "Both of <command moreinfo=\"none\">svndumpfilter</command>'s subcommands accept options for deciding how to deal with <quote>empty</quote> revisions. If a given revision contained only changes to paths that were filtered out, that now-empty revision could be considered uninteresting or even unwanted. So to give the user control over what to do with those revisions, <command moreinfo=\"none\">svndumpfilter</command> provides the following command-line options:"
msgstr ""

#: en.xml:8171(option) 
msgid "--drop-empty-revs"
msgstr ""

#: en.xml:8173(para) 
msgid "Do not generate empty revisions at all—just omit them."
msgstr ""

#: en.xml:8178(option) 
msgid "--renumber-revs"
msgstr ""

#: en.xml:8180(para) 
msgid "If empty revisions are dropped (using the <option>--drop-empty-revs</option> option), change the revision numbers of the remaining revisions so that there are no gaps in the numeric sequence."
msgstr ""

#: en.xml:8187(option) 
msgid "--preserve-revprops"
msgstr ""

#: en.xml:8189(para) 
msgid "If empty revisions are not dropped, preserve the revision properties (log message, author, date, custom properties, etc.) for those empty revisions. Otherwise, empty revisions will only contain the original datestamp, and a generated log message that indicates that this revision was emptied by <command moreinfo=\"none\">svndumpfilter</command>."
msgstr ""

#: en.xml:8200(para) 
msgid "While <command moreinfo=\"none\">svndumpfilter</command> can be very useful, and a huge timesaver, there are unfortunately a couple of gotchas. First, this utility is overly sensitive to path semantics. Pay attention to whether paths in your dump file are specified with or without leading slashes. You'll want to look at the <literal moreinfo=\"none\">Node-path</literal> and <literal moreinfo=\"none\">Node-copyfrom-path</literal> headers."
msgstr ""

#: en.xml:8208(screen) 
#, no-wrap
msgid "\n…\nNode-path: spreadsheet/Makefile\n…\n"
msgstr ""

#: en.xml:8221(para) 
msgid "While <command moreinfo=\"none\">svnadmin dump</command> has a consistent leading slash policy—to not include them—other programs which generate dump data might not be so consistent."
msgstr ""

#: en.xml:8214(para) 
msgid "If the paths have leading slashes, you should include leading slashes in the paths you pass to <command moreinfo=\"none\">svndumpfilter include</command> and <command moreinfo=\"none\">svndumpfilter exclude</command> (and if they don't, you shouldn't). Further, if your dump file has an inconsistent usage of leading slashes for some reason, <footnote><placeholder-1/></footnote> you should probably normalize those paths so they all have, or lack, leading slashes."
msgstr ""

#: en.xml:8229(para) 
msgid "Also, copied paths can give you some trouble. Subversion supports copy operations in the repository, where a new path is created by copying some already existing path. It is possible that at some point in the lifetime of your repository, you might have copied a file or directory from some location that <command moreinfo=\"none\">svndumpfilter</command> is excluding, to a location that it is including. In order to make the dump data self-sufficient, <command moreinfo=\"none\">svndumpfilter</command> needs to still show the addition of the new path—including the contents of any files created by the copy—and not represent that addition as a copy from a source that won't exist in your filtered dump data stream. But because the Subversion repository dump format only shows what was changed in each revision, the contents of the copy source might not be readily available. If you suspect that you have any copies of this sort in your repository, you might want to rethink your set of included/excluded paths."
msgstr ""

#: en.xml:8251(title) 
msgid "Berkeley DB Utilities"
msgstr ""

#: en.xml:8253(para) 
msgid "If you're using a Berkeley DB repository, then all of your versioned filesystem's structure and data live in a set of database tables within the <filename moreinfo=\"none\">db</filename> subdirectory of your repository. This subdirectory is a regular Berkeley DB environment directory, and can therefore be used in conjunction with any of the Berkeley database tools (you can see the documentation for these tools at Sleepycat's website, <ulink url=\"http://www.sleepycat.com/\"/>)."
msgstr ""

#: en.xml:8263(para) 
msgid "For day-to-day Subversion use, these tools are unnecessary. Most of the functionality typically needed for Subversion repositories has been duplicated in the <command moreinfo=\"none\">svnadmin</command> tool. For example, <command moreinfo=\"none\">svnadmin list-unused-dblogs</command> and <command moreinfo=\"none\">svnadmin list-dblogs</command> perform a subset of what is provided by the Berkeley <command moreinfo=\"none\">db_archive</command> command, and <command moreinfo=\"none\">svnadmin recover</command> reflects the common use cases of the <command moreinfo=\"none\">db_recover</command> utility."
msgstr ""

#: en.xml:8274(para) 
msgid "There are still a few Berkeley DB utilities that you might find useful. The <command moreinfo=\"none\">db_dump</command> and <command moreinfo=\"none\">db_load</command> programs write and read, respectively, a custom file format which describes the keys and values in a Berkeley DB database. Since Berkeley databases are not portable across machine architectures, this format is a useful way to transfer those databases from machine to machine, irrespective of architecture or operating system. Also, the <command moreinfo=\"none\">db_stat</command> utility can provide useful information about the status of your Berkeley DB environment, including detailed statistics about the locking and storage subsystems."
msgstr ""

#: en.xml:8292(title) 
msgid "Repository Cleanup"
msgstr ""

#: en.xml:8294(para) 
msgid "Your Subversion repository will generally require very little attention once it is configured to your liking. However, there are times when some manual assistance from an administrator might be in order. The <command moreinfo=\"none\">svnadmin</command> utility provides some helpful functionality to assist you in performing such tasks as:"
msgstr ""

#: en.xml:8303(para) 
msgid "modifying commit log messages,"
msgstr ""

#: en.xml:8306(para) 
msgid "removing dead transactions,"
msgstr ""

#: en.xml:8309(para) 
msgid "recovering <quote>wedged</quote> repositories, and"
msgstr ""

#: en.xml:8312(para) 
msgid "migrating repository contents to a different repository."
msgstr ""

#: en.xml:8317(para) 
msgid "Perhaps the most commonly used of <command moreinfo=\"none\">svnadmin</command>'s subcommands is <literal moreinfo=\"none\">setlog</literal>. When a transaction is committed to the repository and promoted to a revision, the descriptive log message associated with that new revision (and provided by the user) is stored as an unversioned property attached to the revision itself. In other words, the repository remembers only the latest value of the property, and discards previous ones."
msgstr ""

#: en.xml:8327(para) 
msgid "Sometimes a user will have an error in her log message (a misspelling or some misinformation, perhaps). If the repository is configured (using the <literal moreinfo=\"none\">pre-revprop-change</literal> and <literal moreinfo=\"none\">post-revprop-change</literal> hooks; see <xref linkend=\"svn.reposadmin.create.hooks\"/>) to accept changes to this log message after the commit is finished, then the user can <quote>fix</quote> her log message remotely using the <command moreinfo=\"none\">svn</command> program's <literal moreinfo=\"none\">propset</literal> command (see <xref linkend=\"svn.ref\"/>). However, because of the potential to lose information forever, Subversion repositories are not, by default, configured to allow changes to unversioned properties—except by an administrator."
msgstr ""

#: en.xml:8340(para) 
msgid "If a log message needs to be changed by an administrator, this can be done using <command moreinfo=\"none\">svnadmin setlog</command>. This command changes the log message (the <literal moreinfo=\"none\">svn:log</literal> property) on a given revision of a repository, reading the new value from a provided file."
msgstr ""

#: en.xml:8346(screen) 
#, no-wrap
msgid "\n$ echo \"Here is the new, correct log message\" &gt; newlog.txt\n$ svnadmin setlog myrepos newlog.txt -r 388\n"
msgstr ""

#: en.xml:8351(para) 
msgid "The <command moreinfo=\"none\">svnadmin setlog</command> command alone is still bound by the same protections against modifying unversioned properties as a remote client is—the <literal moreinfo=\"none\">pre-</literal> and <literal moreinfo=\"none\">post-revprop-change</literal> hooks are still triggered, and therefore must be setup to accept changes of this nature. But an administrator can get around these protections by passing the <option>--bypass-hooks</option> option to the <command moreinfo=\"none\">svnadmin setlog</command> command."
msgstr ""

#: en.xml:8362(para) 
msgid "Remember, though, that by bypassing the hooks, you are likely avoiding such things as email notifications of property changes, backup systems which track unversioned property changes, and so on. In other words, be very careful about what you are changing, and how you change it."
msgstr ""

#: en.xml:8370(para) 
msgid "Another common use of <command moreinfo=\"none\">svnadmin</command> is to query the repository for outstanding—possibly dead—Subversion transactions. In the event that a commit should fail, the transaction is usually cleaned up. That is, the transaction itself is removed from the repository, and any data associated with (and only with) that transaction is removed as well. Occasionally, though, a failure occurs in such a way that the cleanup of the transaction never happens. This could happen for several reasons: perhaps the client operation was inelegantly terminated by the user, or a network failure might have occurred in the middle of an operation, etc. Regardless of the reason, dead transactions can happen. They don't do any real harm, other than consuming a small bit of disk space. A fastidious administrator may nonetheless want to remove them."
msgstr ""

#: en.xml:8387(para) 
msgid "You can use <command moreinfo=\"none\">svnadmin</command>'s <literal moreinfo=\"none\">lstxns</literal> command to list the names of the currently outstanding transactions."
msgstr ""

#: en.xml:8391(screen) 
#, no-wrap
msgid "\n$ svnadmin lstxns myrepos\n19\n3a1\na45\n$\n"
msgstr ""

#: en.xml:8399(para) 
msgid "Each item in the resultant output can then be used with <command moreinfo=\"none\">svnlook</command> (and its <option>--transaction</option> option) to determine who created the transaction, when it was created, what types of changes were made in the transaction—in other words, whether or not the transaction is a safe candidate for removal! If so, the transaction's name can be passed to <command moreinfo=\"none\">svnadmin rmtxns</command>, which will perform the cleanup of the transaction. In fact, the <literal moreinfo=\"none\">rmtxns</literal> subcommand can take its input directly from the output of <literal moreinfo=\"none\">lstxns</literal>!"
msgstr ""

#: en.xml:8411(screen) 
#, no-wrap
msgid "\n$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`\n$\n"
msgstr ""

#: en.xml:8416(para) 
msgid "If you use these two subcommands like this, you should consider making your repository temporarily inaccessible to clients. That way, no one can begin a legitimate transaction before you start your cleanup. The following is a little bit of shell-scripting that can quickly generate information about each outstanding transaction in your repository:"
msgstr ""

#: en.xml:8424(title) 
msgid "txn-info.sh (Reporting Outstanding Transactions)"
msgstr ""

#: en.xml:8426(programlisting) 
#, no-wrap
msgid "\n#!/bin/sh\n\n### Generate informational output for all outstanding transactions in\n### a Subversion repository.\n\nREPOS=\"${1}\"\nif [ \"x$REPOS\" = x ] ; then\n  echo \"usage: $0 REPOS_PATH\"\n  exit\nfi\n\nfor TXN in `svnadmin lstxns ${REPOS}`; do \n  echo \"---[ Transaction ${TXN} ]-------------------------------------------\"\n  svnlook info \"${REPOS}\" --transaction \"${TXN}\"\ndone\n"
msgstr ""

#: en.xml:8445(para) 
msgid "You can run the previous script using <command moreinfo=\"none\">/path/to/txn-info.sh /path/to/repos</command>. The output is basically a concatenation of several chunks of <command moreinfo=\"none\">svnlook info</command> output (see <xref linkend=\"svn.reposadmin.maint.tk.svnlook\"/>), and will look something like:"
msgstr ""

#: en.xml:8451(screen) 
#, no-wrap
msgid "\n$ txn-info.sh myrepos\n---[ Transaction 19 ]-------------------------------------------\nsally\n2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)\n0\n---[ Transaction 3a1 ]-------------------------------------------\nharry\n2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)\n39\nTrying to commit over a faulty network.\n---[ Transaction a45 ]-------------------------------------------\nsally\n2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)\n0\n$\n"
msgstr ""

#: en.xml:8469(para) 
msgid "A long-abandoned transaction usually represents some sort of failed or interrupted commit. A transaction's datestamp can provide interesting information—for example, how likely is it that an operation begun nine months ago is still active?"
msgstr ""

#: en.xml:8475(para) 
msgid "In short, transaction cleanup decisions need not be made unwisely. Various sources of information—including Apache's error and access logs, the logs of successful Subversion commits, and so on—can be employed in the decision-making process. Finally, an administrator can often simply communicate with a seemingly dead transaction's owner (via email, for example) to verify that the transaction is, in fact, in a zombie state."
msgstr ""

#: en.xml:8488(title) 
msgid "Managing Disk Space"
msgstr ""

#: en.xml:8490(para) 
msgid "While the cost of storage has dropped incredibly in the past few years, disk usage is still a valid concern for administrators seeking to version large amounts of data. Every additional byte consumed by the live repository is a byte that needs to be backed up offsite, perhaps multiple times as part of rotating backup schedules. If using a Berkeley DB repository, the primary storage mechanism is a complex database system, it is useful to know what pieces of data need to remain on the live site, which need to be backed up, and which can be safely removed. This section is specific to Berkeley DB; FSFS repositories have no extra data to be cleaned up or reclaimed."
msgstr ""

#: en.xml:8503(para) 
msgid "Until recently, the largest offender of disk space usage with respect to Subversion repositories was the log files to which Berkeley DB performs its pre-writes before modifying the actual database files. These files capture all the actions taken along the route of changing the database from one state to another—while the database files reflect at any given time some state, the log files contain all the many changes along the way between states. As such, they can start to accumulate quite rapidly."
msgstr ""

#: en.xml:8513(para) 
msgid "Fortunately, beginning with the 4.2 release of Berkeley DB, the database environment has the ability to remove its own unused log files without any external procedures. Any repositories created using an <command moreinfo=\"none\">svnadmin</command> which is compiled against Berkeley DB version 4.2 or greater will be configured for this automatic log file removal. If you don't want this feature enabled, simply pass the <option>--bdb-log-keep</option> option to the <command moreinfo=\"none\">svnadmin create</command> command. If you forget to do this, or change your mind at a later time, simple edit the <filename moreinfo=\"none\">DB_CONFIG</filename> file found in your repository's <filename moreinfo=\"none\">db</filename> directory, comment out the line which contains the <literal moreinfo=\"none\">set_flags DB_LOG_AUTOREMOVE</literal> directive, and then run <command moreinfo=\"none\">svnadmin recover</command> on your repository to force the configuration changes to take effect. See <xref linkend=\"svn.reposadmin.create.bdb\"/> for more information about database configuration."
msgstr ""

#: en.xml:8531(para) 
msgid "Without some sort of automatic log file removal in place, log files will accumulate as you use your repository. This is actually somewhat of a feature of the database system—you should be able to recreate your entire database using nothing but the log files, so these files can be useful for catastrophic database recovery. But typically, you'll want to archive the log files that are no longer in use by Berkeley DB, and then remove them from disk to conserve space. Use the <command moreinfo=\"none\">svnadmin list-unused-dblogs</command> command to list the unused log files:"
msgstr ""

#: en.xml:8543(screen) en.xml:21850(screen) 
#, no-wrap
msgid "\n$ svnadmin list-unused-dblogs /path/to/repos\n/path/to/repos/log.0000000031\n/path/to/repos/log.0000000032\n/path/to/repos/log.0000000033\n\n$ svnadmin list-unused-dblogs /path/to/repos | xargs rm\n## disk space reclaimed!\n"
msgstr ""

#: en.xml:8553(para) 
msgid "To keep the size of the repository as small as possible, Subversion uses <firstterm>deltification</firstterm> (or, <quote>deltified storage</quote>) within the repository itself. Deltification involves encoding the representation of a chunk of data as a collection of differences against some other chunk of data. If the two pieces of data are very similar, this deltification results in storage savings for the deltified chunk—rather than taking up space equal to the size of the original data, it only takes up enough space to say, <quote>I look just like this other piece of data over here, except for the following couple of changes</quote>. Specifically, each time a new version of a file is committed to the repository, Subversion encodes the previous version (actually, several previous versions) as a delta against the new version. The result is that most of the repository data that tends to be sizable—namely, the contents of versioned files—is stored at a much smaller size than the original <quote>fulltext</quote> representation of that data."
msgstr ""

#: en.xml:8574(para) 
msgid "Because all of the Subversion repository data that is subject to deltification is stored in a single Berkeley DB database file, reducing the size of the stored values will not necessarily reduce the size of the database file itself. Berkeley DB will, however, keep internal records of unused areas of the database file, and use those areas first before growing the size of the database file. So while deltification doesn't produce immediate space savings, it can drastically slow future growth of the database."
msgstr ""

#: en.xml:8590(title) 
msgid "Repository Recovery"
msgstr ""

#: en.xml:8592(para) 
msgid "As mentioned in <xref linkend=\"svn.reposadmin.basics.backends.bdb\"/>, a Berkeley DB repository can sometimes be left in frozen state if not closed properly. When this happens, an administrator needs to rewind the database back into a consistent state."
msgstr ""

#: en.xml:8598(para) 
msgid "In order to protect the data in your repository, Berkeley DB uses a locking mechanism. This mechanism ensures that portions of the database are not simultaneously modified by multiple database accessors, and that each process sees the data in the correct state when that data is being read from the database. When a process needs to change something in the database, it first checks for the existence of a lock on the target data. If the data is not locked, the process locks the data, makes the change it wants to make, and then unlocks the data. Other processes are forced to wait until that lock is removed before they are permitted to continue accessing that section of the database. (This has nothing to do with the locks that you, as a user, can apply to versioned files within the repository; see <xref linkend=\"svn.advanced.locking.meanings\"/> for more information.)"
msgstr ""

#: en.xml:8615(para) 
msgid "In the course of using your Subversion repository, fatal errors (such as running out of disk space or available memory) or interruptions can prevent a process from having the chance to remove the locks it has placed in the database. The result is that the back-end database system gets <quote>wedged</quote>. When this happens, any attempts to access the repository hang indefinitely (since each new accessor is waiting for a lock to go away—which isn't going to happen)."
msgstr ""

#: en.xml:8629(para) 
msgid "E.g.: hard drive + huge electromagnet = disaster."
msgstr ""

#: en.xml:8624(para) 
msgid "First, if this happens to your repository, don't panic. The Berkeley DB filesystem takes advantage of database transactions and checkpoints and pre-write journaling to ensure that only the most catastrophic of events <footnote><placeholder-1/></footnote> can permanently destroy a database environment. A sufficiently paranoid repository administrator will be making off-site backups of the repository data in some fashion, but don't call your system administrator to restore a backup tape just yet."
msgstr ""

#: en.xml:8637(para) 
msgid "Secondly, use the following recipe to attempt to <quote>unwedge</quote> your repository:"
msgstr ""

#: en.xml:8642(para) 
msgid "Make sure that there are no processes accessing (or attempting to access) the repository. For networked repositories, this means shutting down the Apache HTTP Server, too."
msgstr ""

#: en.xml:8648(para) 
msgid "Become the user who owns and manages the repository. This is important, as recovering a repository while running as the wrong user can tweak the permissions of the repository's files in such a way that your repository will still be inaccessible even after it is <quote>unwedged</quote>."
msgstr ""

#: en.xml:8656(para) 
msgid "Run the command <command moreinfo=\"none\">svnadmin recover /path/to/repos</command>. You should see output like this:"
msgstr ""

#: en.xml:8660(screen) 
#, no-wrap
msgid "\nRepository lock acquired.\nPlease wait; recovering the repository may take some time...\n\nRecovery completed.\nThe latest repos revision is 19.\n"
msgstr ""

#: en.xml:8667(para) 
msgid "This command may take many minutes to complete."
msgstr ""

#: en.xml:8670(para) 
msgid "Restart the Subversion server."
msgstr ""

#: en.xml:8674(para) 
msgid "This procedure fixes almost every case of repository lock-up. Make sure that you run this command as the user that owns and manages the database, not just as <literal moreinfo=\"none\">root</literal>. Part of the recovery process might involve recreating from scratch various database files (shared memory regions, for example). Recovering as <literal moreinfo=\"none\">root</literal> will create those files such that they are owned by <literal moreinfo=\"none\">root</literal>, which means that even after you restore connectivity to your repository, regular users will be unable to access it."
msgstr ""

#: en.xml:8685(para) 
msgid "If the previous procedure, for some reason, does not successfully unwedge your repository, you should do two things. First, move your broken repository out of the way and restore your latest backup of it. Then, send an email to the Subversion user list (at <email>users@subversion.tigris.org</email>) describing your problem in detail. Data integrity is an extremely high priority to the Subversion developers."
msgstr ""

#: en.xml:8698(title) 
msgid "Migrating a Repository"
msgstr ""

#: en.xml:8700(para) 
msgid "A Subversion filesystem has its data spread throughout various database tables in a fashion generally understood by (and of interest to) only the Subversion developers themselves. However, circumstances may arise that call for all, or some subset, of that data to be collected into a single, portable, flat file format. Subversion provides such a mechanism, implemented in a pair of <command moreinfo=\"none\">svnadmin</command> subcommands: <literal moreinfo=\"none\">dump</literal> and <literal moreinfo=\"none\">load</literal>."
msgstr ""

#: en.xml:8710(para) 
msgid "The most common reason to dump and load a Subversion repository is due to changes in Subversion itself. As Subversion matures, there are times when certain changes made to the back-end database schema cause Subversion to be incompatible with previous versions of the repository. Other reasons for dumping and loading might be to migrate a Berkeley DB repository to a new OS or CPU architecture, or to switch between Berkeley DB and FSFS back-ends. The recommended course of action is relatively simple:"
msgstr ""

#: en.xml:8722(para) 
msgid "Using your <emphasis>current</emphasis> version of <command moreinfo=\"none\">svnadmin</command>, dump your repositories to dump files."
msgstr ""

#: en.xml:8727(para) 
msgid "Upgrade to the new version of Subversion."
msgstr ""

#: en.xml:8730(para) 
msgid "Move your old repositories out of the way, and create new empty ones in their place using your <emphasis>new</emphasis><command moreinfo=\"none\">svnadmin</command>."
msgstr ""

#: en.xml:8735(para) 
msgid "Again using your <emphasis>new</emphasis><command moreinfo=\"none\">svnadmin</command>, load your dump files into their respective, just-created repositories."
msgstr ""

#: en.xml:8740(para) 
msgid "Be sure to copy any customizations from your old repositories to the new ones, including <filename moreinfo=\"none\">DB_CONFIG</filename> files and hook scripts. You'll want to pay attention to the release notes for the new release of Subversion to see if any changes since your last upgrade affect those hooks or configuration options."
msgstr ""

#: en.xml:8749(para) 
msgid "If the migration process made your repository accessible at a different URL (e.g. moved to a different computer, or is being accessed via a different schema), then you'll probably want to tell your users to run <command moreinfo=\"none\">svn switch --relocate</command> on their existing working copies. See <xref linkend=\"svn.ref.svn.c.switch\"/>."
msgstr ""

#: en.xml:8758(para) 
msgid "<command moreinfo=\"none\">svnadmin dump</command> will output a range of repository revisions that are formatted using Subversion's custom filesystem dump format. The dump format is printed to the standard output stream, while informative messages are printed to the standard error stream. This allows you to redirect the output stream to a file while watching the status output in your terminal window. For example:"
msgstr ""

#: en.xml:8766(screen) 
#, no-wrap
msgid "\n$ svnlook youngest myrepos\n26\n$ svnadmin dump myrepos &gt; dumpfile\n* Dumped revision 0.\n* Dumped revision 1.\n* Dumped revision 2.\n…\n* Dumped revision 25.\n* Dumped revision 26.\n"
msgstr ""

#: en.xml:8778(para) 
msgid "At the end of the process, you will have a single file (<filename moreinfo=\"none\">dumpfile</filename> in the previous example) that contains all the data stored in your repository in the requested range of revisions. Note that <command moreinfo=\"none\">svnadmin dump</command> is reading revision trees from the repository just like any other <quote>reader</quote> process would (<command moreinfo=\"none\">svn checkout</command>, for example). So it's safe to run this command at any time."
msgstr ""

#: en.xml:8787(para) 
msgid "The other subcommand in the pair, <command moreinfo=\"none\">svnadmin load</command>, parses the standard input stream as a Subversion repository dump file, and effectively replays those dumped revisions into the target repository for that operation. It also gives informative feedback, this time using the standard output stream:"
msgstr ""

#: en.xml:8794(screen) 
#, no-wrap
msgid "\n$ svnadmin load newrepos &lt; dumpfile\n&lt;&lt;&lt; Started new txn, based on original revision 1\n     * adding path : A ... done.\n     * adding path : A/B ... done.\n     …\n------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;\n\n&lt;&lt;&lt; Started new txn, based on original revision 2\n     * editing path : A/mu ... done.\n     * editing path : A/D/G/rho ... done.\n\n------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;\n\n…\n\n&lt;&lt;&lt; Started new txn, based on original revision 25\n     * editing path : A/D/gamma ... done.\n\n------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;\n\n&lt;&lt;&lt; Started new txn, based on original revision 26\n     * adding path : A/Z/zeta ... done.\n     * editing path : A/mu ... done.\n\n------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;\n\n"
msgstr ""

#: en.xml:8823(para) 
msgid "The result of a load is new revisions added to a repository—the same thing you get by making commits against that repository from a regular Subversion client. And just as in a commit, you can use hook scripts to perform actions before and after each of the commits made during a load process. By passing the <option>--use-pre-commit-hook</option> and <option>--use-post-commit-hook</option> options to <command moreinfo=\"none\">svnadmin load</command>, you can instruct Subversion to execute the pre-commit and post-commit hook scripts, respectively, for each loaded revision. You might use these, for example, to ensure that loaded revisions pass through the same validation steps that regular commits pass through. Of course, you should use these options with care—if your post-commit hook sends emails to a mailing list for each new commit, you might not want to spew hundreds or thousands of commit emails in rapid succession at that list for each of the loaded revisions! You can read more about the use of hook scripts in <xref linkend=\"svn.reposadmin.create.hooks\"/>."
msgstr ""

#: en.xml:8842(para) 
msgid "Note that because <command moreinfo=\"none\">svnadmin</command> uses standard input and output streams for the repository dump and load process, people who are feeling especially saucy can try things like this (perhaps even using different versions of <command moreinfo=\"none\">svnadmin</command> on each side of the pipe):"
msgstr ""

#: en.xml:8848(screen) 
#, no-wrap
msgid "\n$ svnadmin create newrepos\n$ svnadmin dump myrepos | svnadmin load newrepos\n"
msgstr ""

#: en.xml:8853(para) 
msgid "By default, the dump file will be quite large—much larger than the repository itself. That's because every version of every file is expressed as a full text in the dump file. This is the fastest and simplest behavior, and nice if you're piping the dump data directly into some other process (such as a compression program, filtering program, or into a loading process). But if you're creating a dump file for longer-term storage, you'll likely want to save disk space by using the <option>--deltas</option> switch. With this option, successive revisions of files will be output as compressed, binary differences—just as file revisions are stored in a repository. This option is slower, but results in a dump file much closer in size to the original repository."
msgstr ""

#: en.xml:8868(para) 
msgid "We mentioned previously that <command moreinfo=\"none\">svnadmin dump</command> outputs a range of revisions. Use the <option>--revision</option> option to specify a single revision to dump, or a range of revisions. If you omit this option, all the existing repository revisions will be dumped."
msgstr ""

#: en.xml:8875(screen) 
#, no-wrap
msgid "\n$ svnadmin dump myrepos --revision 23 &gt; rev-23.dumpfile\n$ svnadmin dump myrepos --revision 100:200 &gt; revs-100-200.dumpfile\n"
msgstr ""

#: en.xml:8880(para) 
msgid "As Subversion dumps each new revision, it outputs only enough information to allow a future loader to re-create that revision based on the previous one. In other words, for any given revision in the dump file, only the items that were changed in that revision will appear in the dump. The only exception to this rule is the first revision that is dumped with the current <command moreinfo=\"none\">svnadmin dump</command> command."
msgstr ""

#: en.xml:8889(para) 
msgid "By default, Subversion will not express the first dumped revision as merely differences to be applied to the previous revision. For one thing, there is no previous revision in the dump file! And secondly, Subversion cannot know the state of the repository into which the dump data will be loaded (if it ever, in fact, occurs). To ensure that the output of each execution of <command moreinfo=\"none\">svnadmin dump</command> is self-sufficient, the first dumped revision is by default a full representation of every directory, file, and property in that revision of the repository."
msgstr ""

#: en.xml:8900(para) 
msgid "However, you can change this default behavior. If you add the <option>--incremental</option> option when you dump your repository, <command moreinfo=\"none\">svnadmin</command> will compare the first dumped revision against the previous revision in the repository, the same way it treats every other revision that gets dumped. It will then output the first revision exactly as it does the rest of the revisions in the dump range—mentioning only the changes that occurred in that revision. The benefit of this is that you can create several small dump files that can be loaded in succession, instead of one large one, like so:"
msgstr ""

#: en.xml:8912(screen) 
#, no-wrap
msgid "\n$ svnadmin dump myrepos --revision 0:1000 &gt; dumpfile1\n$ svnadmin dump myrepos --revision 1001:2000 --incremental &gt; dumpfile2\n$ svnadmin dump myrepos --revision 2001:3000 --incremental &gt; dumpfile3\n"
msgstr ""

#: en.xml:8918(para) 
msgid "These dump files could be loaded into a new repository with the following command sequence:"
msgstr ""

#: en.xml:8921(screen) 
#, no-wrap
msgid "\n$ svnadmin load newrepos &lt; dumpfile1\n$ svnadmin load newrepos &lt; dumpfile2\n$ svnadmin load newrepos &lt; dumpfile3\n"
msgstr ""

#: en.xml:8927(para) 
msgid "Another neat trick you can perform with this <option>--incremental</option> option involves appending to an existing dump file a new range of dumped revisions. For example, you might have a <literal moreinfo=\"none\">post-commit</literal> hook that simply appends the repository dump of the single revision that triggered the hook. Or you might have a script that runs nightly to append dump file data for all the revisions that were added to the repository since the last time the script ran. Used like this, <command moreinfo=\"none\">svnadmin</command>'s <literal moreinfo=\"none\">dump</literal> and <literal moreinfo=\"none\">load</literal> commands can be a valuable means by which to backup changes to your repository over time in case of a system crash or some other catastrophic event."
msgstr ""

#: en.xml:8941(para) 
msgid "The dump format can also be used to merge the contents of several different repositories into a single repository. By using the <option>--parent-dir</option> option of <command moreinfo=\"none\">svnadmin load</command>, you can specify a new virtual root directory for the load process. That means if you have dump files for three repositories, say <filename moreinfo=\"none\">calc-dumpfile</filename>, <filename moreinfo=\"none\">cal-dumpfile</filename>, and <filename moreinfo=\"none\">ss-dumpfile</filename>, you can first create a new repository to hold them all:"
msgstr ""

#: en.xml:8951(screen) 
#, no-wrap
msgid "\n$ svnadmin create /path/to/projects\n$\n"
msgstr ""

#: en.xml:8956(para) 
msgid "Then, make new directories in the repository which will encapsulate the contents of each of the three previous repositories:"
msgstr ""

#: en.xml:8960(screen) 
#, no-wrap
msgid "\n$ svn mkdir -m \"Initial project roots\" \\\n      file:///path/to/projects/calc \\\n      file:///path/to/projects/calendar \\\n      file:///path/to/projects/spreadsheet\nCommitted revision 1.\n$ \n"
msgstr ""

#: en.xml:8969(para) 
msgid "Lastly, load the individual dump files into their respective locations in the new repository:"
msgstr ""

#: en.xml:8972(screen) 
#, no-wrap
msgid "\n$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile\n…\n$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile\n…\n$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile\n…\n$\n"
msgstr ""

#: en.xml:8988(para) 
msgid "The Subversion repository dump format resembles an RFC-822 format, the same type of format used for most email."
msgstr ""

#: en.xml:8982(para) 
msgid "We'll mention one final way to use the Subversion repository dump format—conversion from a different storage mechanism or version control system altogether. Because the dump file format is, for the most part, human-readable, <footnote><placeholder-1/></footnote> it should be relatively easy to describe generic sets of changes—each of which should be treated as a new revision—using this file format. In fact, the <command moreinfo=\"none\">cvs2svn</command> utility (see <xref linkend=\"svn.forcvs.convert\"/>) uses the dump format to represent the contents of a CVS repository so that those contents can be copied into a Subversion repository."
msgstr ""

#: en.xml:9003(title) 
msgid "Repository Backup"
msgstr ""

#: en.xml:9005(para) 
msgid "Despite numerous advances in technology since the birth of the modern computer, one thing unfortunately rings true with crystalline clarity—sometimes, things go very, very awry. Power outages, network connectivity dropouts, corrupt RAM and crashed hard drives are but a taste of the evil that Fate is poised to unleash on even the most conscientious administrator. And so we arrive at a very important topic—how to make backup copies of your repository data."
msgstr ""

#: en.xml:9015(para) 
msgid "There are generally two types of backup methods available for Subversion repository administrators—incremental and full. We discussed in an earlier section of this chapter how to use <command moreinfo=\"none\">svnadmin dump --incremental</command> to perform an incremental backup (see <xref linkend=\"svn.reposadmin.maint.migrate\"/>). Essentially, the idea is to only backup at a given time the changes to the repository since the last time you made a backup."
msgstr ""

#: en.xml:9023(para) 
msgid "A full backup of the repository is quite literally a duplication of the entire repository directory (which includes either Berkeley database or FSFS environment). Now, unless you temporarily disable all other access to your repository, simply doing a recursive directory copy runs the risk of generating a faulty backup, since someone might be currently writing to the database."
msgstr ""

#: en.xml:9031(para) 
msgid "In the case of Berkeley DB, Sleepycat documents describe a certain order in which database files can be copied that will guarantee a valid backup copy. And a similar ordering exists for FSFS data. Better still, you don't have to implement these algorithms yourself, because the Subversion development team has already done so. The <command moreinfo=\"none\">hot-backup.py</command> script is found in the <filename moreinfo=\"none\">tools/backup/</filename> directory of the Subversion source distribution. Given a repository path and a backup location, <command moreinfo=\"none\">hot-backup.py</command>—which is really just a more intelligent wrapper around the <command moreinfo=\"none\">svnadmin hotcopy</command> command—will perform the necessary steps for backing up your live repository—without requiring that you bar public repository access at all—and then will clean out the dead Berkeley log files from your live repository."
msgstr ""

#: en.xml:9048(para) 
msgid "Even if you also have an incremental backup, you might want to run this program on a regular basis. For example, you might consider adding <command moreinfo=\"none\">hot-backup.py</command> to a program scheduler (such as <command moreinfo=\"none\">cron</command> on Unix systems). Or, if you prefer fine-grained backup solutions, you could have your post-commit hook script call <command moreinfo=\"none\">hot-backup.py</command> (see <xref linkend=\"svn.reposadmin.create.hooks\"/>), which will then cause a new backup of your repository to occur with every new revision created. Simply add the following to the <filename moreinfo=\"none\">hooks/post-commit</filename> script in your live repository directory:"
msgstr ""

#: en.xml:9060(programlisting) 
#, no-wrap
msgid "\n(cd /path/to/hook/scripts; ./hot-backup.py ${REPOS} /path/to/backups &amp;)\n"
msgstr ""

#: en.xml:9064(para) 
msgid "The resulting backup is a fully functional Subversion repository, able to be dropped in as a replacement for your live repository should something go horribly wrong."
msgstr ""

#: en.xml:9068(para) 
msgid "There are benefits to both types of backup methods. The easiest is by far the full backup, which will always result in a perfect working replica of your repository. This again means that should something bad happen to your live repository, you can restore from the backup with a simple recursive directory copy. Unfortunately, if you are maintaining multiple backups of your repository, these full copies will each eat up just as much disk space as your live repository."
msgstr ""

#: en.xml:9078(para) 
msgid "Incremental backups using the repository dump format are excellent to have on hand if the database schema changes between successive versions of Subversion itself. Since a complete repository dump and load are generally required to upgrade your repository to the new schema, it's very convenient to already have half of that process (the dump part) finished. Unfortunately, the creation of—and restoration from—incremental backups takes longer, as each commit is effectively replayed into either the dump file or the repository."
msgstr ""

#: en.xml:9096(para) 
msgid "<command moreinfo=\"none\">svnadmin setlog</command> can be called in a way that bypasses the hook interface altogether."
msgstr ""

#: en.xml:9089(para) 
msgid "In either backup scenario, repository administrators need to be aware of how modifications to unversioned revision properties affect their backups. Since these changes do not themselves generate new revisions, they will not trigger post-commit hooks, and may not even trigger the pre-revprop-change and post-revprop-change hooks. <footnote><placeholder-1/></footnote> And since you can change revision properties without respect to chronological order—you can change any revision's properties at any time—an incremental backup of the latest few revisions might not catch a property modification to a revision that was included as part of a previous backup."
msgstr ""

#: en.xml:9106(para) 
msgid "Generally speaking, only the truly paranoid would need to backup their entire repository, say, every time a commit occurred. However, assuming that a given repository has some other redundancy mechanism in place with relatively fine granularity (like per-commit emails), a hot backup of the database might be something that a repository administrator would want to include as part of a system-wide nightly backup. For most repositories, archived commit emails alone provide sufficient redundancy as restoration sources, at least for the most recent few commits. But it's your data—protect it as much as you'd like."
msgstr ""

#: en.xml:9129(para) 
msgid "You know—the collective term for all of her <quote>fickle fingers</quote>."
msgstr ""

#: en.xml:9118(para) 
msgid "Often, the best approach to repository backups is a diversified one. You can leverage combinations of full and incremental backups, plus archives of commit emails. The Subversion developers, for example, back up the Subversion source code repository after every new revision is created, and keep an archive of all the commit and property change notification emails. Your solution might be similar, but should be catered to your needs and that delicate balance of convenience with paranoia. And while all of this might not save your hardware from the iron fist of Fate, <footnote><placeholder-1/></footnote> it should certainly help you recover from those trying times."
msgstr ""

#: en.xml:9143(title) 
msgid "Adding Projects"
msgstr ""

#: en.xml:9145(para) 
msgid "Once your repository is created and configured, all that remains is to begin using it. If you have a collection of existing data that is ready to be placed under version control, you will more than likely want to use the <command moreinfo=\"none\">svn</command> client program's <literal moreinfo=\"none\">import</literal> subcommand to accomplish that. Before doing this, though, you should carefully consider your long-term plans for the repository. In this section, we will offer some advice on how to plan the layout of your repository, and how to get your data arranged in that layout."
msgstr ""

#: en.xml:9158(title) 
msgid "Choosing a Repository Layout"
msgstr ""

#: en.xml:9160(para) 
msgid "While Subversion allows you to move around versioned files and directories without any loss of information, doing so can still disrupt the workflow of those who access the repository often and come to expect things to be at certain locations. Try to peer into the future a bit; plan ahead before placing your data under version control. By <quote>laying out</quote> the contents of your repositories in an effective manner the first time, you can prevent a load of future headaches."
msgstr ""

#: en.xml:9169(para) 
msgid "There are a few things to consider when setting up Subversion repositories. Let's assume that as repository administrator, you will be responsible for supporting the version control system for several projects. The first decision is whether to use a single repository for multiple projects, or to give each project its own repository, or some compromise of these two."
msgstr ""

#: en.xml:9177(para) 
msgid "There are benefits to using a single repository for multiple projects, most obviously the lack of duplicated maintenance. A single repository means that there is one set of hook scripts, one thing to routinely backup, one thing to dump and load if Subversion releases an incompatible new version, and so on. Also, you can move data between projects easily, and without losing any historical versioning information."
msgstr ""

#: en.xml:9186(para) 
msgid "The downside of using a single repository is that different projects may have different commit mailing lists or different authentication and authorization requirements. Also, remember that Subversion uses repository-global revision numbers. Some folks don't like the fact that even though no changes have been made to their project lately, the youngest revision number for the repository keeps climbing because other projects are actively adding new revisions."
msgstr ""

#: en.xml:9195(para) 
msgid "A middle-ground approach can be taken, too. For example, projects can be grouped by how well they relate to each other. You might have a few repositories with a handful of projects in each repository. That way, projects that are likely to want to share data can do so easily, and as new revisions are added to the repository, at least the developers know that those new revisions are at least remotely related to everyone who uses that repository."
msgstr ""

#: en.xml:9221(para) 
msgid "The <filename moreinfo=\"none\">trunk</filename>, <filename moreinfo=\"none\">tags</filename>, and <filename moreinfo=\"none\">branches</filename> trio are sometimes referred to as <quote>the TTB directories</quote>."
msgstr ""

#: en.xml:9204(para) 
msgid "After deciding how to organize your projects with respect to repositories, you'll probably want to think about directory hierarchies in the repositories themselves. Because Subversion uses regular directory copies for branching and tagging (see <xref linkend=\"svn.branchmerge\"/>), the Subversion community recommends that you choose a repository location for each <firstterm>project root</firstterm>—the <quote>top-most</quote> directory which contains data related to that project—and then create three subdirectories beneath that root: <filename moreinfo=\"none\">trunk</filename>, meaning the directory under which the main project development occurs; <filename moreinfo=\"none\">branches</filename>, which is a directory in which to create various named branches of the main development line; <filename moreinfo=\"none\">tags</filename>, which is a directory of branches that are created, and perhaps destroyed, but never changed. <footnote><placeholder-1/></footnote>"
msgstr ""

#: en.xml:9227(para) 
msgid "For example, your repository might look like:"
msgstr ""

#: en.xml:9229(screen) 
#, no-wrap
msgid "\n/\n   calc/\n      trunk/\n      tags/\n      branches/\n   calendar/\n      trunk/\n      tags/\n      branches/\n   spreadsheet/\n      trunk/\n      tags/\n      branches/\n   …\n"
msgstr ""

#: en.xml:9246(para) 
msgid "Note that it doesn't matter where in your repository each project root is. If you have only one project per repository, the logical place to put each project root is at the root of that project's respective repository. If you have multiple projects, you might want to arrange them in groups inside the repository, perhaps putting projects with similar goals or shared code in the same subdirectory, or maybe just grouping them alphabetically. Such an arrangement might look like:"
msgstr ""

#: en.xml:9256(screen) 
#, no-wrap
msgid "\n/\n   utils/\n      calc/\n         trunk/\n         tags/\n         branches/\n      calendar/\n         trunk/\n         tags/\n         branches/\n      …\n   office/\n      spreadsheet/\n         trunk/\n         tags/\n         branches/\n      …\n"
msgstr ""

#: en.xml:9276(para) 
msgid "Lay out your repository in whatever way you see fit. Subversion does not expect or enforce a layout schema—in its eyes, a directory is a directory is a directory. Ultimately, you should choose the repository arrangement that meets the needs of the people who work on the projects that live there."
msgstr ""

#: en.xml:9287(title) 
msgid "Creating the Layout, and Importing Initial Data"
msgstr ""

#: en.xml:9289(para) 
msgid "After deciding how to arrange the projects in your repository, you'll probably want to actually populate the repository with that layout and with initial project data. There are a couple of ways to do this in Subversion. You could use the <command moreinfo=\"none\">svn mkdir</command> command (see <xref linkend=\"svn.ref\"/>) to create each directory in your skeletal repository layout, one-by-one. A quicker way to accomplish the same task is to use the <command moreinfo=\"none\">svn import</command> command (see <xref linkend=\"svn.tour.other.import\"/>). By first creating the layout in a temporary location on your drive, you can import the whole layout tree into the repository in a single commit:"
msgstr ""

#: en.xml:9301(screen) 
#, no-wrap
msgid "\n$ mkdir tmpdir\n$ cd tmpdir\n$ mkdir projectA\n$ mkdir projectA/trunk\n$ mkdir projectA/branches\n$ mkdir projectA/tags\n$ mkdir projectB\n$ mkdir projectB/trunk\n$ mkdir projectB/branches\n$ mkdir projectB/tags\n…\n$ svn import . file:///path/to/repos --message \"Initial repository layout\"\nAdding         projectA\nAdding         projectA/trunk\nAdding         projectA/branches\nAdding         projectA/tags\nAdding         projectB\nAdding         projectB/trunk\nAdding         projectB/branches\nAdding         projectB/tags\n…\nCommitted revision 1.\n$ cd ..\n$ rm -rf tmpdir\n$\n"
msgstr ""

#: en.xml:9329(para) 
msgid "You can verify the results of the import by running the <command moreinfo=\"none\">svn list</command> command:"
msgstr ""

#: en.xml:9332(screen) 
#, no-wrap
msgid "\n$ svn list --verbose file:///path/to/repos\n      1 harry               May 08 21:48 projectA/\n      1 harry               May 08 21:48 projectB/\n…\n$\n"
msgstr ""

#: en.xml:9340(para) 
msgid "Once you have your skeletal layout in place, you can begin importing actual project data into your repository, if any such data exists yet. Once again, there are several ways to do this. You could use the <command moreinfo=\"none\">svn import</command> command. You could checkout a working copy from your new repository, move and arrange project data inside the working copy, and use the <command moreinfo=\"none\">svn add</command> and <command moreinfo=\"none\">svn commit</command> commands. But once we start talking about such things, we're no longer discussing repository administration. If you aren't already familiar with the <command moreinfo=\"none\">svn</command> client program, see <xref linkend=\"svn.tour\"/>."
msgstr ""

#: en.xml:9361(para) 
msgid "By now you should have a basic understanding of how to create, configure, and maintain Subversion repositories. We've introduced you to the various tools that will assist you with this task. Throughout the chapter, we've noted common administration pitfalls, and suggestions for avoiding them."
msgstr ""

#: en.xml:9368(para) 
msgid "All that remains is for you to decide what exciting data to store in your repository, and finally, how to make it available over a network. The next chapter is all about networking."
msgstr ""

#: en.xml:9382(title) 
msgid "Server Configuration"
msgstr ""

#: en.xml:9386(para) 
msgid "A Subversion repository can be accessed simultaneously by clients running on the same machine on which the repository resides using the <literal moreinfo=\"none\">file:///</literal> method. But the typical Subversion setup involves a single server machine being accessed from clients on computers all over the office—or, perhaps, all over the world."
msgstr ""

#: en.xml:9394(para) 
msgid "This section describes how to get your Subversion repository exposed outside its host machine for use by remote clients. We will cover Subversion's currently available server mechanisms, discussing the configuration and use of each. After reading this section, you should be able to decide which networking setup is right for your needs, and understand how to enable such a setup on your host computer."
msgstr ""

#: en.xml:9409(title) 
msgid "Overview"
msgstr ""

#: en.xml:9411(para) 
msgid "Subversion was designed with an abstract network layer. This means that a repository can be programmatically accessed by any sort of server process, and the client <quote>repository access</quote> API allows programmers to write plugins that speak relevant network protocols. In theory, Subversion can use an infinite number of network implementations. In practice, there are only two servers at the time of writing."
msgstr ""

#: en.xml:9419(para) 
msgid "Apache is an extremely popular webserver; using the <command moreinfo=\"none\">mod_dav_svn</command> module, Apache can access a repository and make it available to clients via the WebDAV/DeltaV protocol, which is an extension of HTTP. In the other corner is <command moreinfo=\"none\">svnserve</command>: a small, standalone server program that speaks a custom protocol with clients. <xref linkend=\"svn.serverconfig.overview.tbl-1\"/> presents a comparison of the two servers."
msgstr ""

#: en.xml:9428(para) 
msgid "Note that Subversion, as an open-source project, does not officially endorse any server as <quote>primary</quote> or <quote>official</quote>. Neither network implementation is treated as a second-class citizen; each server has advantages and disadvantages. In fact, it's possible for different servers to run in parallel, each accessing your repositories in its own way, and each without hindering the other (see <xref linkend=\"svn.serverconfig.multimethod\"/>). <xref linkend=\"svn.serverconfig.overview.tbl-1\"/> gives a brief overview and comparison of the two available Subversion servers—as an administrator, it's up to you to choose whatever works best for you and your users."
msgstr ""

#: en.xml:9440(title) 
msgid "Network Server Comparison"
msgstr ""

#: en.xml:9445(entry) 
msgid "Apache + mod_dav_svn"
msgstr ""

#: en.xml:9451(entry) 
msgid "Authentication options"
msgstr ""

#: en.xml:9453(entry) 
msgid "HTTP(S) basic auth, X.509 certificates, LDAP, NTLM, or any other mechanism available to Apache httpd"
msgstr ""

#: en.xml:9456(entry) 
msgid "CRAM-MD5 or SSH"
msgstr ""

#: en.xml:9460(entry) 
msgid "User account options"
msgstr ""

#: en.xml:9462(entry) 
msgid "private 'users' file"
msgstr ""

#: en.xml:9464(entry) 
msgid "private 'users' file, or existing system (SSH) accounts"
msgstr ""

#: en.xml:9469(entry) 
msgid "Authorization options"
msgstr ""

#: en.xml:9471(entry) 
msgid "blanket read/write access, or per-directory read/write control"
msgstr ""

#: en.xml:9474(entry) 
msgid "blanket read/write access, or per-directory write (but not read) control using a pre-commit hook"
msgstr ""

#: en.xml:9479(entry) 
msgid "Encryption"
msgstr ""

#: en.xml:9481(entry) 
msgid "via optional SSL"
msgstr ""

#: en.xml:9483(entry) 
msgid "via optional SSH tunnel"
msgstr ""

#: en.xml:9487(entry) 
msgid "Interoperability"
msgstr ""

#: en.xml:9489(entry) 
msgid "partially usable by other WebDAV clients"
msgstr ""

#: en.xml:9491(entry) 
msgid "not interoperable"
msgstr ""

#: en.xml:9495(entry) 
msgid "Web viewing"
msgstr ""

#: en.xml:9497(entry) 
msgid "limited built-in support, or via 3rd-party tools such as ViewVC"
msgstr ""

#: en.xml:9500(entry) 
msgid "via 3rd-party tools such as ViewVC"
msgstr ""

#: en.xml:9504(entry) 
msgid "Speed"
msgstr ""

#: en.xml:9506(entry) 
msgid "somewhat slower"
msgstr ""

#: en.xml:9508(entry) 
msgid "somewhat faster"
msgstr ""

#: en.xml:9512(entry) en.xml:10264(title) 
msgid "Initial setup"
msgstr ""

#: en.xml:9514(entry) 
msgid "somewhat complex"
msgstr ""

#: en.xml:9516(entry) 
msgid "fairly simple"
msgstr ""

#: en.xml:9530(title) 
msgid "Network Model"
msgstr ""

#: en.xml:9532(para) 
msgid "This section is a general discussion of how a Subversion client and server interact with one another, regardless of the network implementation you're using. After reading, you'll have a good understanding of how a server can behave and the different ways in which a client can be configured to respond."
msgstr ""

#: en.xml:9541(title) 
msgid "Requests and Responses"
msgstr ""

#: en.xml:9543(para) 
msgid "The Subversion client spends most of its time managing working copies. When it needs information from a repository, however, it makes a network request, and the server responds with an appropriate answer. The details of the network protocol are hidden from the user; the client attempts to access a URL, and depending on the URL schema, a particular protocol is used to contact the server (see <xref linkend=\"svn.basic.in-action.wc.sb-1\"/>). Users can run <command moreinfo=\"none\">svn --version</command> to see which URL schemas and protocols the client knows how to use."
msgstr ""

#: en.xml:9553(para) 
msgid "When the server process receives a client request, it typically demands that the client identify itself. It issues an authentication challenge to the client, and the client responds by providing <firstterm>credentials</firstterm> back to the server. Once authentication is complete, the server responds with the original information the client asked for. Notice that this system is different from systems like CVS, where the client pre-emptively offers credentials (<quote>logs in</quote>) to the server before ever making a request. In Subversion, the server <quote>pulls</quote> credentials by challenging the client at the appropriate moment, rather than the client <quote>pushing</quote> them. This makes certain operations more elegant. For example, if a server is configured to allow anyone in the world to read a repository, then the server will never issue an authentication challenge when a client attempts to <command moreinfo=\"none\">svn checkout</command>."
msgstr ""

#: en.xml:9580(para) 
msgid "This problem is actually a FAQ, resulting from a misconfigured server setup."
msgstr ""

#: en.xml:9571(para) 
msgid "If the client's network request writes new data to the repository (e.g. <command moreinfo=\"none\">svn commit</command>), then a new revision tree is created. If the client's request was authenticated, then the authenticated user's name is stored as the value of the <literal moreinfo=\"none\">svn:author</literal> property on the new revision (see <xref linkend=\"svn.reposadmin.basics.revprops\"/>). If the client was not authenticated (in other words, the server never issued an authentication challenge), then the revision's <literal moreinfo=\"none\">svn:author</literal> property is empty. <placeholder-1/>"
msgstr ""

#: en.xml:9587(title) 
msgid "Client Credentials Caching"
msgstr ""

#: en.xml:9589(para) 
msgid "Many servers are configured to require authentication on every request. This can become a big annoyance to users, who are forced to type their passwords over and over again."
msgstr ""

#: en.xml:9593(para) 
msgid "Happily, the Subversion client has a remedy for this: a built-in system for caching authentication credentials on disk. By default, whenever the command-line client successfully responds to a server's authentication challenge, it saves the credentials in the user's private runtime configuration area—in <filename moreinfo=\"none\">~/.subversion/auth/</filename> on Unix-like systems or <filename moreinfo=\"none\">%APPDATA%/Subversion/auth/</filename> on Windows. (The runtime area is covered in more detail in <xref linkend=\"svn.advanced.confarea\"/>.) Successful credentials are cached on disk, keyed on a combination of hostname, port, and authentication realm."
msgstr ""

#: en.xml:9606(para) 
msgid "When the client receives an authentication challenge, it first looks for the appropriate credentials in the user's disk cache; if not present, or if the cached credentials fail to authenticate, then the client simply prompts the user for the information."
msgstr ""

#: en.xml:9612(para) 
msgid "Security-conscious people may be thinking to themselves, <quote>Caching passwords on disk? That's terrible! You should never do that!</quote> Please remain calm, it's not as dangerous as it sounds."
msgstr ""

#: en.xml:9620(para) 
msgid "The <filename moreinfo=\"none\">auth/</filename> caching area is permission-protected so that only the user (owner) can read data from it, not the world at large. The operating system's own file permissions are protecting the password."
msgstr ""

#: en.xml:9628(para) 
msgid "On Windows 2000 and later, the Subversion client uses standard Windows cryptography services to encrypt the password on disk. Because the encryption key is managed by Windows and is tied to the user's own login credentials, only the user can decrypt the cached password. (Note: if the user's Windows account password is reset by an administrator, all of the cached passwords become undecipherable. The Subversion client will behave as if they don't exist, prompting for passwords when required.)"
msgstr ""

#: en.xml:9641(para) 
msgid "For the truly paranoid willing to sacrifice all convenience, it's possible to disable credential caching altogether."
msgstr ""

#: en.xml:9648(para) 
msgid "To disable caching for a single command, pass the <option>--no-auth-cache</option> option:"
msgstr ""

#: en.xml:9651(screen) 
#, no-wrap
msgid "\n$ svn commit -F log_msg.txt --no-auth-cache\nAuthentication realm: &lt;svn://host.example.com:3690&gt; example realm\nUsername:  joe\nPassword for 'joe':\n\nAdding         newfile\nTransmitting file data .\nCommitted revision 2324.\n\n# password was not cached, so a second commit still prompts us\n\n$ svn delete newfile\n$ svn commit -F new_msg.txt\nAuthentication realm: &lt;svn://host.example.com:3690&gt; example realm\nUsername:  joe\n…\n"
msgstr ""

#: en.xml:9670(para) 
msgid "Or, if you want to disable credential caching permanently, you can edit your runtime <filename moreinfo=\"none\">config</filename> file (located next to the <filename moreinfo=\"none\">auth/</filename> directory). Simply set <literal moreinfo=\"none\">store-auth-creds</literal> to <literal moreinfo=\"none\">no</literal>, and no credentials will be cached on disk, ever."
msgstr ""

#: en.xml:9677(screen) 
#, no-wrap
msgid "\n[auth]\nstore-auth-creds = no\n"
msgstr ""

#: en.xml:9682(para) 
msgid "Sometimes users will want to remove specific credentials from the disk cache. To do this, you need to navigate into the <filename moreinfo=\"none\">auth/</filename> area and manually delete the appropriate cache file. Credentials are cached in individual files; if you look inside each file, you will see keys and values. The <literal moreinfo=\"none\">svn:realmstring</literal> key describes the particular server realm that the file is associated with:"
msgstr ""

#: en.xml:9691(screen) 
#, no-wrap
msgid "\n$ ls ~/.subversion/auth/svn.simple/\n5671adf2865e267db74f09ba6f872c28        \n3893ed123b39500bca8a0b382839198e\n5c3c22968347b390f349ff340196ed39\n\n$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28\n\nK 8\nusername\nV 3\njoe\nK 8\npassword\nV 4\nblah\nK 15\nsvn:realmstring\nV 45\n&lt;https://svn.domain.com:443&gt; Joe's repository\nEND\n"
msgstr ""

#: en.xml:9714(para) 
msgid "Once you have located the proper cache file, just delete it."
msgstr ""

#: en.xml:9730(para) 
msgid "Again, a common mistake is to misconfigure a server so that it never issues an authentication challenge. When users pass <option>--username</option> and <option>--password</option> options to the client, they're surprised to see that they're never used, i.e. new revisions still appear to have been committed anonymously!"
msgstr ""

#: en.xml:9717(para) 
msgid "One last word about client authentication behavior: a bit of explanation about the <option>--username</option> and <option>--password</option> options is needed. Many client subcommands accept these options; however it is important to understand using these options <emphasis>does not</emphasis> automatically send credentials to the server. As discussed earlier, the server <quote>pulls</quote> credentials from the client when it deems necessary; the client cannot <quote>push</quote> them at will. If a username and/or password are passed as options, they will <emphasis>only</emphasis> be presented to the server if the server requests them. <placeholder-1/> Typically, these options are used when:"
msgstr ""

#: en.xml:9742(para) 
msgid "the user wants to authenticate as a different user than her system login name, or"
msgstr ""

#: en.xml:9746(para) 
msgid "a script wants to authenticate without using cached credentials."
msgstr ""

#: en.xml:9752(para) 
msgid "Here is a final summary that describes how a Subversion client behaves when it receives an authentication challenge:"
msgstr ""

#: en.xml:9758(para) 
msgid "Check whether the user specified any credentials as command-line options, via <option>--username</option> and/or <option>--password</option>. If not, or if these options fail to authenticate successfully, then"
msgstr ""

#: en.xml:9765(para) 
msgid "Look up the server's realm in the runtime <filename moreinfo=\"none\">auth/</filename> area, to see if the user already has the appropriate credentials cached. If not, or if the cached credentials fail to authenticate, then"
msgstr ""

#: en.xml:9772(para) 
msgid "Resort to prompting the user."
msgstr ""

#: en.xml:9776(para) 
msgid "If the client successfully authenticates by any of the methods listed above, it will attempt to cache the credentials on disk (unless the user has disabled this behavior, as mentioned earlier)."
msgstr ""

#: en.xml:9791(title) 
msgid "svnserve, a custom server"
msgstr ""

#: en.xml:9793(para) 
msgid "The <command moreinfo=\"none\">svnserve</command> program is a lightweight server, capable of speaking to clients over TCP/IP using a custom, stateful protocol. Clients contact an <command moreinfo=\"none\">svnserve</command> server by using URLs that begin with the <literal moreinfo=\"none\">svn://</literal> or <literal moreinfo=\"none\">svn+ssh://</literal> schema. This section will explain the different ways of running <command moreinfo=\"none\">svnserve</command>, how clients authenticate themselves to the server, and how to configure appropriate access control to your repositories."
msgstr ""

#: en.xml:9805(title) 
msgid "Invoking the Server"
msgstr ""

#: en.xml:9807(para) 
msgid "There are a few different ways to invoke the <command moreinfo=\"none\">svnserve</command> program. If invoked with no options, you'll see nothing but a help message. However, if you're planning to have <command moreinfo=\"none\">inetd</command> launch the process, then you can pass the <option>-i</option> (<option>--inetd</option>) option:"
msgstr ""

#: en.xml:9814(screen) 
#, no-wrap
msgid "\n$ svnserve -i\n( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )\n"
msgstr ""

#: en.xml:9819(para) 
msgid "When invoked with the <option>--inetd</option> option, <command moreinfo=\"none\">svnserve</command> attempts to speak with a Subversion client via <emphasis>stdin</emphasis> and <emphasis>stdout</emphasis> using a custom protocol. This is the standard behavior for a program being run via <command moreinfo=\"none\">inetd</command>. The IANA has reserved port 3690 for the Subversion protocol, so on a Unix-like system you can add lines to <filename moreinfo=\"none\">/etc/services</filename> like these (if they don't already exist):"
msgstr ""

#: en.xml:9829(screen) 
#, no-wrap
msgid "\nsvn           3690/tcp   # Subversion\nsvn           3690/udp   # Subversion\n"
msgstr ""

#: en.xml:9834(para) 
msgid "And if your system is using a classic Unix-like <command moreinfo=\"none\">inetd</command> daemon, you can add this line to <filename moreinfo=\"none\">/etc/inetd.conf</filename>:"
msgstr ""

#: en.xml:9838(screen) 
#, no-wrap
msgid "\nsvn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i\n"
msgstr ""

#: en.xml:9842(para) 
msgid "Make sure <quote>svnowner</quote> is a user which has appropriate permissions to access your repositories. Now, when a client connection comes into your server on port 3690, <command moreinfo=\"none\">inetd</command> will spawn an <command moreinfo=\"none\">svnserve</command> process to service it."
msgstr ""

#: en.xml:9848(para) 
msgid "On a Windows system, third-party tools exist to run <command moreinfo=\"none\">svnserve</command> as a service. Look on Subversion's website for a list of these tools."
msgstr ""

#: en.xml:9852(para) 
msgid "A second option is to run <command moreinfo=\"none\">svnserve</command> as a standalone <quote>daemon</quote> process. Use the <option>-d</option> option for this:"
msgstr ""

#: en.xml:9856(screen) 
#, no-wrap
msgid "\n$ svnserve -d\n$               # svnserve is now running, listening on port 3690\n"
msgstr ""

#: en.xml:9861(para) 
msgid "When running <command moreinfo=\"none\">svnserve</command> in daemon mode, you can use the <option>--listen-port=</option> and <option>--listen-host=</option> options to customize the exact port and hostname to <quote>bind</quote> to."
msgstr ""

#: en.xml:9866(para) 
msgid "There's still a third way to invoke <command moreinfo=\"none\">svnserve</command>, and that's in <quote>tunnel mode</quote>, with the <option>-t</option> option. This mode assumes that a remote-service program such as <command moreinfo=\"none\">RSH</command> or <command moreinfo=\"none\">SSH</command> has successfully authenticated a user and is now invoking a private <command moreinfo=\"none\">svnserve</command> process <emphasis>as that user</emphasis>. The <command moreinfo=\"none\">svnserve</command> program behaves normally (communicating via <emphasis>stdin</emphasis> and <emphasis>stdout</emphasis>), and assumes that the traffic is being automatically redirected over some sort of tunnel back to the client. When <command moreinfo=\"none\">svnserve</command> is invoked by a tunnel agent like this, be sure that the authenticated user has full read and write access to the repository database files. (See <xref linkend=\"svn.serverconfig.svnserve.invoking.sb-1\"/>.) It's essentially the same as a local user accessing the repository via <literal moreinfo=\"none\">file:///</literal> URLs."
msgstr ""

#: en.xml:9885(title) 
msgid "Servers and Permissions: A Word of Warning"
msgstr ""

#: en.xml:9887(para) 
msgid "First, remember that a Subversion repository is a collection of database files; any process which accesses the repository directly needs to have proper read and write permissions on the entire repository. If you're not careful, this can lead to a number of headaches, especially if you're using a Berkeley DB database rather than FSFS. Be sure to read <xref linkend=\"svn.serverconfig.multimethod\"/>."
msgstr ""

#: en.xml:9895(para) 
msgid "Secondly, when configuring <command moreinfo=\"none\">svnserve</command>, Apache <command moreinfo=\"none\">httpd</command>, or any other server process, keep in mind that you might not want to launch the server process as the user <literal moreinfo=\"none\">root</literal> (or as any other user with unlimited permissions). Depending on the ownership and permissions of the repositories you're exporting, it's often prudent to use a different—perhaps custom—user. For example, many administrators create a new user named <literal moreinfo=\"none\">svn</literal>, grant that user exclusive ownership and rights to the exported Subversion repositories, and only run their server processes as that user."
msgstr ""

#: en.xml:9910(para) 
msgid "Once the <command moreinfo=\"none\">svnserve</command> program is running, it makes every repository on your system available to the network. A client needs to specify an <emphasis>absolute</emphasis> path in the repository URL. For example, if a repository is located at <filename moreinfo=\"none\">/usr/local/repositories/project1</filename>, then a client would reach it via <systemitem class=\"url\" moreinfo=\"none\">svn://host.example.com/usr/local/repositories/project1 </systemitem>. To increase security, you can pass the <option>-r</option> option to <command moreinfo=\"none\">svnserve</command>, which restricts it to exporting only repositories below that path:"
msgstr ""

#: en.xml:9922(screen) 
#, no-wrap
msgid "\n$ svnserve -d -r /usr/local/repositories\n…\n"
msgstr ""

#: en.xml:9927(para) 
msgid "Using the <option>-r</option> option effectively modifies the location that the program treats as the root of the remote filesystem space. Clients then use URLs that have that path portion removed from them, leaving much shorter (and much less revealing) URLs:"
msgstr ""

#: en.xml:9933(screen) 
#, no-wrap
msgid "\n$ svn checkout svn://host.example.com/project1\n…\n"
msgstr ""

#: en.xml:9942(title) 
msgid "Built-in authentication and authorization"
msgstr ""

#: en.xml:9944(para) 
msgid "When a client connects to an <command moreinfo=\"none\">svnserve</command> process, the following things happen:"
msgstr ""

#: en.xml:9948(para) 
msgid "The client selects a specific repository."
msgstr ""

#: en.xml:9951(para) 
msgid "The server processes the repository's <filename moreinfo=\"none\">conf/svnserve.conf</filename> file, and begins to enforce any authentication and authorization policies defined therein."
msgstr ""

#: en.xml:9956(para) 
msgid "Depending on the situation and authorization policies,"
msgstr ""

#: en.xml:9960(para) 
msgid "the client may be allowed to make requests anonymously, without ever receiving an authentication challenge, OR"
msgstr ""

#: en.xml:9964(para) 
msgid "the client may be challenged for authentication at any time, OR"
msgstr ""

#: en.xml:9967(para) 
msgid "if operating in <quote>tunnel mode</quote>, the client will declare itself to be already externally authenticated."
msgstr ""

#: en.xml:9976(para) 
msgid "See RFC 2195."
msgstr ""

#: en.xml:9975(para) 
msgid "At the time of writing, the server only knows how to send a CRAM-MD5 <placeholder-1/> authentication challenge. In essence, the server sends a bit of data to the client. The client uses the MD5 hash algorithm to create a fingerprint of the data and password combined, then sends the fingerprint as a response. The server performs the same computation with the stored password to verify that the result is identical. <emphasis>At no point does the actual password travel over the network.</emphasis>"
msgstr ""

#: en.xml:9985(para) 
msgid "It's also possible, of course, for the client to be externally authenticated via a tunnel agent, such as <command moreinfo=\"none\">SSH</command>. In that case, the server simply examines the user it's running as, and uses it as the authenticated username. For more on this, see <xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>."
msgstr ""

#: en.xml:9991(para) 
msgid "As you've already guessed, a repository's <filename moreinfo=\"none\">svnserve.conf</filename> file is the central mechanism for controlling authentication and authorization policies. The file has the same format as other configuration files (see <xref linkend=\"svn.advanced.confarea\"/>): section names are marked by square brackets (<literal moreinfo=\"none\">[</literal> and <literal moreinfo=\"none\">]</literal>), comments begin with hashes (<literal moreinfo=\"none\">#</literal>), and each section contains specific variables that can be set (<literal moreinfo=\"none\">variable = value</literal>). Let's walk through this file and learn how to use them."
msgstr ""

#: en.xml:10004(title) 
msgid "Create a 'users' file and realm"
msgstr ""

#: en.xml:10006(para) 
msgid "For now, the <literal moreinfo=\"none\">[general]</literal> section of the <filename moreinfo=\"none\">svnserve.conf</filename> has all the variables you need. Begin by defining a file which contains usernames and passwords, and an authentication realm:"
msgstr ""

#: en.xml:10011(screen) 
#, no-wrap
msgid "\n[general]\npassword-db = userfile\nrealm = example realm\n"
msgstr ""

#: en.xml:10017(para) 
msgid "The <literal moreinfo=\"none\">realm</literal> is a name that you define. It tells clients which sort of <quote>authentication namespace</quote> they're connecting to; the Subversion client displays it in the authentication prompt, and uses it as a key (along with the server's hostname and port) for caching credentials on disk (see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>). The <literal moreinfo=\"none\">password-db</literal> variable points to a separate file that contains a list of usernames and passwords, using the same familiar format. For example:"
msgstr ""

#: en.xml:10027(screen) 
#, no-wrap
msgid "\n[users]\nharry = foopassword\nsally = barpassword\n"
msgstr ""

#: en.xml:10033(para) 
msgid "The value of <literal moreinfo=\"none\">password-db</literal> can be an absolute or relative path to the users file. For many admins, it's easy to keep the file right in the <filename moreinfo=\"none\">conf/</filename> area of the repository, alongside <filename moreinfo=\"none\">svnserve.conf</filename>. On the other hand, it's possible you may want to have two or more repositories share the same users file; in that case, the file should probably live in a more public place. The repositories sharing the users file should also be configured to have the same realm, since the list of users essentially defines an authentication realm. Wherever the file lives, be sure to set the file's read and write permissions appropriately. If you know which user(s) <command moreinfo=\"none\">svnserve</command> will run as, restrict read access to the user file as necessary."
msgstr ""

#: en.xml:10051(title) 
msgid "Set access controls"
msgstr ""

#: en.xml:10053(para) 
msgid "There are two more variables to set in the <filename moreinfo=\"none\">svnserve.conf</filename> file: they determine what unauthenticated (anonymous) and authenticated users are allowed to do. The variables <literal moreinfo=\"none\">anon-access</literal> and <literal moreinfo=\"none\">auth-access</literal> can be set to the values <literal moreinfo=\"none\">none</literal>, <literal moreinfo=\"none\">read</literal>, or <literal moreinfo=\"none\">write</literal>. Setting the value to <literal moreinfo=\"none\">none</literal> restricts all access of any kind; <literal moreinfo=\"none\">read</literal> allows read-only access to the repository, and <literal moreinfo=\"none\">write</literal> allows complete read/write access to the repository. For example:"
msgstr ""

#: en.xml:10065(screen) 
#, no-wrap
msgid "\n[general]\npassword-db = userfile\nrealm = example realm\n\n# anonymous users can only read the repository\nanon-access = read\n\n# authenticated users can both read and write\nauth-access = write\n"
msgstr ""

#: en.xml:10077(para) 
msgid "The example settings are, in fact, the default values of the variables, should you forget to define them. If you want to be even more conservative, you can block anonymous access completely:"
msgstr ""

#: en.xml:10082(screen) 
#, no-wrap
msgid "\n[general]\npassword-db = userfile\nrealm = example realm\n\n# anonymous users aren't allowed\nanon-access = none\n\n# authenticated users can both read and write\nauth-access = write\n"
msgstr ""

#: en.xml:10094(para) 
msgid "Notice that <command moreinfo=\"none\">svnserve</command> only understands <quote>blanket</quote> access control. A user either has universal read/write access, universal read access, or no access. There is no detailed control over access to specific paths within the repository. For many projects and sites, this level of access control is more than adequate. However, if you need per-directory access control, you'll need to use either use Apache with <command moreinfo=\"none\">mod_authz_svn</command> (see <xref linkend=\"svn.serverconfig.httpd.authz.perdir\"/>) or use a <command moreinfo=\"none\">pre-commit</command> hook script to control write access (see <xref linkend=\"svn.reposadmin.create.hooks\"/>). The Subversion distribution comes with <command moreinfo=\"none\">commit-access-control.pl</command> and the more sophisticated <command moreinfo=\"none\">svnperms.py</command> scripts for use in pre-commit scripts."
msgstr ""

#: en.xml:10115(title) 
msgid "SSH authentication and authorization"
msgstr ""

#: en.xml:10117(para) 
msgid "<command moreinfo=\"none\">svnserve</command>'s built-in authentication can be very handy, because it avoids the need to create real system accounts. On the other hand, some administrators already have well-established SSH authentication frameworks in place. In these situations, all of the project's users already have system accounts and the ability to <quote>SSH into</quote> the server machine."
msgstr ""

#: en.xml:10125(para) 
msgid "It's easy to use SSH in conjunction with <command moreinfo=\"none\">svnserve</command>. The client simply uses the <literal moreinfo=\"none\">svn+ssh://</literal> URL schema to connect:"
msgstr ""

#: en.xml:10129(screen) 
#, no-wrap
msgid "\n$ whoami\nharry\n\n$ svn list svn+ssh://host.example.com/repos/project\nharry@host.example.com's password:  *****\n\nfoo\nbar\nbaz\n…\n"
msgstr ""

#: en.xml:10142(para) 
msgid "In this example, the Subversion client is invoking a local <command moreinfo=\"none\">ssh</command> process, connecting to <literal moreinfo=\"none\">host.example.com</literal>, authenticating as the user <literal moreinfo=\"none\">harry</literal>, then spawning a private <command moreinfo=\"none\">svnserve</command> process on the remote machine running as the user <literal moreinfo=\"none\">harry</literal>. The <command moreinfo=\"none\">svnserve</command> command is being invoked in tunnel mode (<option>-t</option>) and its network protocol is being <quote>tunneled</quote> over the encrypted connection by <command moreinfo=\"none\">ssh</command>, the tunnel-agent. <command moreinfo=\"none\">svnserve</command> is aware that it's running as the user <literal moreinfo=\"none\">harry</literal>, and if the client performs a commit, the authenticated username will be attributed as the author of the new revision."
msgstr ""

#: en.xml:10157(para) 
msgid "The important thing to understand here is that the Subversion client is <emphasis>not</emphasis> connecting to a running <command moreinfo=\"none\">svnserve</command> daemon. This method of access doesn't require a daemon, nor does it notice one if present. It relies wholly on the ability of <command moreinfo=\"none\">ssh</command> to spawn a temporary <command moreinfo=\"none\">svnserve</command> process, which then terminates when the network connection is closed."
msgstr ""

#: en.xml:10166(para) 
msgid "When using <literal moreinfo=\"none\">svn+ssh://</literal> URLs to access a repository, remember that it's the <command moreinfo=\"none\">ssh</command> program prompting for authentication, and <emphasis>not</emphasis> the <command moreinfo=\"none\">svn</command> client program. That means there's no automatic password caching going on (see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>). The Subversion client often makes multiple connections to the repository, though users don't normally notice this due to the password caching feature. When using <literal moreinfo=\"none\">svn+ssh://</literal> URLs, however, users may be annoyed by <command moreinfo=\"none\">ssh</command> repeatedly asking for a password for every outbound connection. The solution is to use a separate SSH password-caching tool like <command moreinfo=\"none\">ssh-agent</command> on a Unix-like system, or <command moreinfo=\"none\">pageant</command> on Windows."
msgstr ""

#: en.xml:10182(para) 
msgid "When running over a tunnel, authorization is primarily controlled by operating system permissions to the repository's database files; it's very much the same as if Harry were accessing the repository directly via a <literal moreinfo=\"none\">file:///</literal> URL. If multiple system users are going to be accessing the repository directly, you may want to place them into a common group, and you'll need to be careful about umasks. (Be sure to read <xref linkend=\"svn.serverconfig.multimethod\"/>.) But even in the case of tunneling, the <filename moreinfo=\"none\">svnserve.conf</filename> file can still be used to block access, by simply setting <literal moreinfo=\"none\">auth-access = read</literal> or <literal moreinfo=\"none\">auth-access = none</literal>."
msgstr ""

#: en.xml:10195(para) 
msgid "You'd think that the story of SSH tunneling would end here, but it doesn't. Subversion allows you to create custom tunnel behaviors in your run-time <filename moreinfo=\"none\">config</filename> file (see <xref linkend=\"svn.advanced.confarea\"/>). For example, suppose you want to use RSH instead of SSH. In the <literal moreinfo=\"none\">[tunnels]</literal> section of your <filename moreinfo=\"none\">config</filename> file, simply define it like this:"
msgstr ""

#: en.xml:10204(screen) 
#, no-wrap
msgid "\n[tunnels]\nrsh = rsh\n"
msgstr ""

#: en.xml:10209(para) 
msgid "And now, you can use this new tunnel definition by using a URL schema that matches the name of your new variable: <literal moreinfo=\"none\">svn+rsh://host/path</literal>. When using the new URL schema, the Subversion client will actually be running the command <command moreinfo=\"none\">rsh host svnserve -t</command> behind the scenes. If you include a username in the URL (for example, <literal moreinfo=\"none\">svn+rsh://username@host/path</literal>) the client will also include that in its command (<command moreinfo=\"none\">rsh username@host svnserve -t</command>). But you can define new tunneling schemes to be much more clever than that:"
msgstr ""

#: en.xml:10220(screen) 
#, no-wrap
msgid "\n[tunnels]\njoessh = $JOESSH /opt/alternate/ssh -p 29934\n"
msgstr ""

#: en.xml:10225(para) 
msgid "This example demonstrates a couple of things. First, it shows how to make the Subversion client launch a very specific tunneling binary (the one located at <filename moreinfo=\"none\">/opt/alternate/ssh</filename>) with specific options. In this case, accessing a <literal moreinfo=\"none\">svn+joessh://</literal> URL would invoke the particular SSH binary with <option>-p 29934</option> as arguments—useful if you want the tunnel program to connect to a non-standard port."
msgstr ""

#: en.xml:10235(para) 
msgid "Second, it shows how to define a custom environment variable that can override the name of the tunneling program. Setting the <literal moreinfo=\"none\">SVN_SSH</literal> environment variable is a convenient way to override the default SSH tunnel agent. But if you need to have several different overrides for different servers, each perhaps contacting a different port or passing a different set of options to SSH, you can use the mechanism demonstrated in this example. Now if we were to set the <literal moreinfo=\"none\">JOESSH</literal> environment variable, its value would override the entire value of the tunnel variable—<command moreinfo=\"none\">$JOESSH</command> would be executed instead of <command moreinfo=\"none\">/opt/alternate/ssh -p 29934</command>."
msgstr ""

#: en.xml:10253(title) 
msgid "SSH configuration tricks"
msgstr ""

#: en.xml:10255(para) 
msgid "It's not only possible to control the way in which the client invokes <command moreinfo=\"none\">ssh</command>, but also to control the behavior of <command moreinfo=\"none\">sshd</command> on your server machine. In this section, we'll show how to control the exact <command moreinfo=\"none\">svnserve</command> command executed by <command moreinfo=\"none\">sshd</command>, as well as how to have multiple users share a single system account."
msgstr ""

#: en.xml:10266(para) 
msgid "To begin, locate the home directory of the account you'll be using to launch <command moreinfo=\"none\">svnserve</command>. Make sure the account has an SSH public/private keypair installed, and that the user can log in via public-key authentication. Password authentication will not work, since all of the following SSH tricks revolve around using the SSH <filename moreinfo=\"none\">authorized_keys</filename> file."
msgstr ""

#: en.xml:10274(para) 
msgid "If it doesn't already exist, create the <filename moreinfo=\"none\">authorized_keys</filename> file (on Unix, typically <filename moreinfo=\"none\">~/.ssh/authorized_keys</filename>). Each line in this file describes a public key that is allowed to connect. The lines are typically of the form:"
msgstr ""

#: en.xml:10281(screen) 
#, no-wrap
msgid "\n  ssh-dsa AAAABtce9euch… user@example.com\n"
msgstr ""

#: en.xml:10285(para) 
msgid "The first field describes the type of key, the second field is the uuencoded key itself, and the third field is a comment. However, it's a lesser known fact that the entire line can be preceded by a <literal moreinfo=\"none\">command</literal> field:"
msgstr ""

#: en.xml:10291(screen) 
#, no-wrap
msgid "\n  command=\"program\" ssh-dsa AAAABtce9euch… user@example.com\n"
msgstr ""

#: en.xml:10295(para) 
msgid "When the <literal moreinfo=\"none\">command</literal> field is set, the SSH daemon will run the named program instead of the typical <command moreinfo=\"none\">svnserve -t</command> invocation that the Subversion client asks for. This opens the door to a number of server-side tricks. In the following examples, we abbreviate the lines of the file as:"
msgstr ""

#: en.xml:10302(screen) 
#, no-wrap
msgid "\n  command=\"program\" TYPE KEY COMMENT\n"
msgstr ""

#: en.xml:10309(title) 
msgid "Controlling the invoked command"
msgstr ""

#: en.xml:10311(para) 
msgid "Because we can specify the executed server-side command, it's easy to name a specific <command moreinfo=\"none\">svnserve</command> binary to run and to pass it extra arguments:"
msgstr ""

#: en.xml:10315(screen) 
#, no-wrap
msgid "\n  command=\"/path/to/svnserve -t -r /virtual/root\" TYPE KEY COMMENT\n"
msgstr ""

#: en.xml:10319(para) 
msgid "In this example, <filename moreinfo=\"none\">/path/to/svnserve</filename> might be a custom wrapper script around <command moreinfo=\"none\">svnserve</command> which sets the umask (see <xref linkend=\"svn.serverconfig.multimethod\"/>). It also shows how to anchor <command moreinfo=\"none\">svnserve</command> in a virtual root directory, just as one often does when running <command moreinfo=\"none\">svnserve</command> as a daemon process. This might be done either to restrict access to parts of the system, or simply to relieve the user of having to type an absolute path in the <literal moreinfo=\"none\">svn+ssh://</literal> URL."
msgstr ""

#: en.xml:10331(para) 
msgid "It's also possible to have multiple users share a single account. Instead of creating a separate system account for each user, generate a public/private keypair for each person. Then place each public key into the <filename moreinfo=\"none\">authorized_users</filename> file, one per line, and use the <option>--tunnel-user</option> option:"
msgstr ""

#: en.xml:10339(screen) 
#, no-wrap
msgid "\n  command=\"svnserve -t --tunnel-user=harry\" TYPE1 KEY1 harry@example.com\n  command=\"svnserve -t --tunnel-user=sally\" TYPE2 KEY2 sally@example.com\n"
msgstr ""

#: en.xml:10344(para) 
msgid "This example allows both Harry and Sally to connect to the same account via public-key authentication. Each of them has a custom command that will be executed; the <option>--tunnel-user</option> option tells <command moreinfo=\"none\">svnserve -t</command> to assume that the named argument is the authenticated user. Without <option>--tunnel-user</option>, it would appear as though all commits were coming from the one shared system account."
msgstr ""

#: en.xml:10354(para) 
msgid "A final word of caution: giving a user access to the server via public-key in a shared account might still allow other forms of SSH access, even if you've set the <literal moreinfo=\"none\">command</literal> value in <filename moreinfo=\"none\">authorized_keys</filename>. For example, the user may still get shell access through SSH, or be able to perform X11 or general port-forwarding through your server. To give the user as little permission as possible, you may want to specify a number of restrictive options immediately after the <literal moreinfo=\"none\">command</literal>:"
msgstr ""

#: en.xml:10365(screen) 
#, no-wrap
msgid "\n  command=\"svnserve -t --tunnel-user=harry\",no-port-forwarding,\\\n           no-agent-forwarding,no-X11-forwarding,no-pty \\\n           TYPE1 KEY1 harry@example.com\n"
msgstr ""

#: en.xml:10383(title) 
msgid "httpd, the Apache HTTP server"
msgstr ""

#: en.xml:10399(para) 
msgid "They really hate doing that."
msgstr ""

#: en.xml:10385(para) 
msgid "The Apache HTTP Server is a <quote>heavy duty</quote> network server that Subversion can leverage. Via a custom module, <command moreinfo=\"none\">httpd</command> makes Subversion repositories available to clients via the WebDAV/DeltaV protocol, which is an extension to HTTP 1.1 (see <ulink url=\"http://www.webdav.org/\"/> for more information). This protocol takes the ubiquitous HTTP protocol that is the core of the World Wide Web, and adds writing—specifically, versioned writing—capabilities. The result is a standardized, robust system that is conveniently packaged as part of the Apache 2.0 software, is supported by numerous operating systems and third-party products, and doesn't require network administrators to open up yet another custom port. <footnote><placeholder-1/></footnote> While an Apache-Subversion server has more features than <command moreinfo=\"none\">svnserve</command>, it's also a bit more difficult to set up. With flexibility often comes more complexity."
msgstr ""

#: en.xml:10405(para) 
msgid "Much of the following discussion includes references to Apache configuration directives. While some examples are given of the use of these directives, describing them in full is outside the scope of this chapter. The Apache team maintains excellent documentation, publicly available on their website at <ulink url=\"http://httpd.apache.org\"/>. For example, a general reference for the configuration directives is located at <ulink url=\"       http://httpd.apache.org/docs-2.0/mod/directives.html\"/>."
msgstr ""

#: en.xml:10413(para) 
msgid "Also, as you make changes to your Apache setup, it is likely that somewhere along the way a mistake will be made. If you are not already familiar with Apache's logging subsystem, you should become aware of it. In your <filename moreinfo=\"none\">httpd.conf</filename> file are directives that specify the on-disk locations of the access and error logs generated by Apache (the <literal moreinfo=\"none\">CustomLog</literal> and <literal moreinfo=\"none\">ErrorLog</literal> directives, respectively). Subversion's mod_dav_svn uses Apache's error logging interface as well. You can always browse the contents of those files for information that might reveal the source of a problem that is not clearly noticeable otherwise."
msgstr ""

#: en.xml:10427(title) 
msgid "Why Apache 2?"
msgstr ""

#: en.xml:10429(para) 
msgid "If you're a system administrator, it's very likely that you're already running the Apache web server and have some prior experience with it. At the time of writing, Apache 1.3 is by far the most popular version of Apache. The world has been somewhat slow to upgrade to the Apache 2.X series for various reasons: some people fear change, especially changing something as critical as a web server. Other people depend on plug-in modules that only work against the Apache 1.3 API, and are waiting for a 2.X port. Whatever the reason, many people begin to worry when they first discover that Subversion's Apache module is written specifically for the Apache 2 API."
msgstr ""

#: en.xml:10441(para) 
msgid "The proper response to this problem is: don't worry about it. It's easy to run Apache 1.3 and Apache 2 side-by-side; simply install them to separate places, and use Apache 2 as a dedicated Subversion server that runs on a port other than 80. Clients can access the repository by placing the port number into the URL:"
msgstr ""

#: en.xml:10448(screen) 
#, no-wrap
msgid "\n$ svn checkout http://host.example.com:7382/repos/project\n…\n"
msgstr ""

#: en.xml:10457(title) 
msgid "Prerequisites"
msgstr ""

#: en.xml:10459(para) 
msgid "To network your repository over HTTP, you basically need four components, available in two packages. You'll need Apache <command moreinfo=\"none\">httpd</command> 2.0, the <command moreinfo=\"none\">mod_dav</command> DAV module that comes with it, Subversion, and the <command moreinfo=\"none\">mod_dav_svn</command> filesystem provider module distributed with Subversion. Once you have all of those components, the process of networking your repository is as simple as:"
msgstr ""

#: en.xml:10470(para) 
msgid "getting httpd 2.0 up and running with the mod_dav module,"
msgstr ""

#: en.xml:10474(para) 
msgid "installing the mod_dav_svn plugin to mod_dav, which uses Subversion's libraries to access the repository, and"
msgstr ""

#: en.xml:10479(para) 
msgid "configuring your <filename moreinfo=\"none\">httpd.conf</filename> file to export (or expose) the repository."
msgstr ""

#: en.xml:10484(para) 
msgid "You can accomplish the first two items either by compiling <command moreinfo=\"none\">httpd</command> and Subversion from source code, or by installing pre-built binary packages of them on your system. For the most up-to-date information on how to compile Subversion for use with the Apache HTTP Server, as well as how to compile and configure Apache itself for this purpose, see the <filename moreinfo=\"none\">INSTALL</filename> file in the top level of the Subversion source code tree."
msgstr ""

#: en.xml:10497(title) 
msgid "Basic Apache Configuration"
msgstr ""

#: en.xml:10499(para) 
msgid "Once you have all the necessary components installed on your system, all that remains is the configuration of Apache via its <filename moreinfo=\"none\">httpd.conf</filename> file. Instruct Apache to load the mod_dav_svn module using the <literal moreinfo=\"none\">LoadModule</literal> directive. This directive must precede any other Subversion-related configuration items. If your Apache was installed using the default layout, your <command moreinfo=\"none\">mod_dav_svn</command> module should have been installed in the <filename moreinfo=\"none\">modules</filename> subdirectory of the Apache install location (often <filename moreinfo=\"none\">/usr/local/apache2</filename>). The <literal moreinfo=\"none\">LoadModule</literal> directive has a simple syntax, mapping a named module to the location of a shared library on disk:"
msgstr ""

#: en.xml:10514(screen) 
#, no-wrap
msgid "\nLoadModule dav_svn_module     modules/mod_dav_svn.so\n"
msgstr ""

#: en.xml:10518(para) 
msgid "Note that if <command moreinfo=\"none\">mod_dav</command> was compiled as a shared object (instead of statically linked directly to the <command moreinfo=\"none\">httpd</command> binary), you'll need a similar <literal moreinfo=\"none\">LoadModule</literal> statement for it, too. Be sure that it comes before the <command moreinfo=\"none\">mod_dav_svn</command> line:"
msgstr ""

#: en.xml:10524(screen) 
#, no-wrap
msgid "\nLoadModule dav_module         modules/mod_dav.so\nLoadModule dav_svn_module     modules/mod_dav_svn.so\n"
msgstr ""

#: en.xml:10530(para) 
msgid "At a later location in your configuration file, you now need to tell Apache where you keep your Subversion repository (or repositories). The <literal moreinfo=\"none\">Location</literal> directive has an XML-like notation, starting with an opening tag, and ending with a closing tag, with various other configuration directives in the middle. The purpose of the <literal moreinfo=\"none\">Location</literal> directive is to instruct Apache to do something special when handling requests that are directed at a given URL or one of its children. In the case of Subversion, you want Apache to simply hand off support for URLs that point at versioned resources to the DAV layer. You can instruct Apache to delegate the handling of all URLs whose path portions (the part of the URL that follows the server's name and the optional port number) begin with <filename moreinfo=\"none\">/repos/</filename> to a DAV provider whose repository is located at <filename moreinfo=\"none\">/absolute/path/to/repository</filename> using the following <filename moreinfo=\"none\">httpd.conf</filename> syntax:"
msgstr ""

#: en.xml:10549(screen) 
#, no-wrap
msgid "\n&lt;Location /repos&gt;\n  DAV svn\n  SVNPath /absolute/path/to/repository\n&lt;/Location&gt;\n"
msgstr ""

#: en.xml:10556(para) 
msgid "If you plan to support multiple Subversion repositories that will reside in the same parent directory on your local disk, you can use an alternative directive, the <literal moreinfo=\"none\">SVNParentPath</literal> directive, to indicate that common parent directory. For example, if you know you will be creating multiple Subversion repositories in a directory <filename moreinfo=\"none\">/usr/local/svn</filename> that would be accessed via URLs like <systemitem class=\"url\" moreinfo=\"none\">http://my.server.com/svn/repos1</systemitem>, <systemitem class=\"url\" moreinfo=\"none\">http://my.server.com/svn/repos2</systemitem>, and so on, you could use the <filename moreinfo=\"none\">httpd.conf</filename> configuration syntax in the following example:"
msgstr ""

#: en.xml:10568(screen) 
#, no-wrap
msgid "\n&lt;Location /svn&gt;\n  DAV svn\n\n  # any \"/svn/foo\" URL will map to a repository /usr/local/svn/foo\n  SVNParentPath /usr/local/svn\n&lt;/Location&gt;\n"
msgstr ""

#: en.xml:10577(para) 
msgid "Using the previous syntax, Apache will delegate the handling of all URLs whose path portions begin with <filename moreinfo=\"none\">/svn/</filename> to the Subversion DAV provider, which will then assume that any items in the directory specified by the <literal moreinfo=\"none\">SVNParentPath</literal> directive are actually Subversion repositories. This is a particularly convenient syntax in that, unlike the use of the <literal moreinfo=\"none\">SVNPath</literal> directive, you don't have to restart Apache in order to create and network new repositories."
msgstr ""

#: en.xml:10588(para) 
msgid "Be sure that when you define your new <literal moreinfo=\"none\">Location</literal>, it doesn't overlap with other exported Locations. For example, if your main <literal moreinfo=\"none\">DocumentRoot</literal> is <filename moreinfo=\"none\">/www</filename>, do not export a Subversion repository in <literal moreinfo=\"none\">&lt;Location /www/repos&gt;</literal>. If a request comes in for the URI <filename moreinfo=\"none\">/www/repos/foo.c</filename>, Apache won't know whether to look for a file <filename moreinfo=\"none\">repos/foo.c</filename> in the <literal moreinfo=\"none\">DocumentRoot</literal>, or whether to delegate <command moreinfo=\"none\">mod_dav_svn</command> to return <filename moreinfo=\"none\">foo.c</filename> from the Subversion repository."
msgstr ""

#: en.xml:10602(title) 
msgid "Server Names and the COPY Request"
msgstr ""

#: en.xml:10604(para) 
msgid "Subversion makes use of the <literal moreinfo=\"none\">COPY</literal> request type to perform server-side copies of files and directories. As part of the sanity checking done by the Apache modules, the source of the copy is expected to be located on the same machine as the destination of the copy. To satisfy this requirement, you might need to tell mod_dav the name you use as the hostname of your server. Generally, you can use the <literal moreinfo=\"none\">ServerName</literal> directive in <filename moreinfo=\"none\">httpd.conf</filename> to accomplish this."
msgstr ""

#: en.xml:10614(screen) 
#, no-wrap
msgid "\nServerName svn.example.com\n"
msgstr ""

#: en.xml:10618(para) 
msgid "If you are using Apache's virtual hosting support via the <literal moreinfo=\"none\">NameVirtualHost</literal> directive, you may need to use the <literal moreinfo=\"none\">ServerAlias</literal> directive to specify additional names that your server is known by. Again, refer to the Apache documentation for full details."
msgstr ""

#: en.xml:10626(para) 
msgid "At this stage, you should strongly consider the question of permissions. If you've been running Apache for some time now as your regular web server, you probably already have a collection of content—web pages, scripts and such. These items have already been configured with a set of permissions that allows them to work with Apache, or more appropriately, that allows Apache to work with those files. Apache, when used as a Subversion server, will also need the correct permissions to read and write to your Subversion repository. (See <xref linkend=\"svn.serverconfig.svnserve.invoking.sb-1\"/>.)"
msgstr ""

#: en.xml:10637(para) 
msgid "You will need to determine a permission system setup that satisfies Subversion's requirements without messing up any previously existing web page or script installations. This might mean changing the permissions on your Subversion repository to match those in use by other things that Apache serves for you, or it could mean using the <literal moreinfo=\"none\">User</literal> and <literal moreinfo=\"none\">Group</literal> directives in <filename moreinfo=\"none\">httpd.conf</filename> to specify that Apache should run as the user and group that owns your Subversion repository. There is no single correct way to set up your permissions, and each administrator will have different reasons for doing things a certain way. Just be aware that permission-related problems are perhaps the most common oversight when configuring a Subversion repository for use with Apache."
msgstr ""

#: en.xml:10657(title) 
msgid "Authentication Options"
msgstr ""

#: en.xml:10659(para) 
msgid "At this point, if you configured <filename moreinfo=\"none\">httpd.conf</filename> to contain something like"
msgstr ""

#: en.xml:10662(screen) 
#, no-wrap
msgid "\n&lt;Location /svn&gt;\n  DAV svn\n  SVNParentPath /usr/local/svn\n&lt;/Location&gt;\n"
msgstr ""

#: en.xml:10669(para) 
msgid "…then your repository is <quote>anonymously</quote> accessible to the world. Until you configure some authentication and authorization policies, the Subversion repositories you make available via the <literal moreinfo=\"none\">Location</literal> directive will be generally accessible to everyone. In other words,"
msgstr ""

#: en.xml:10678(para) 
msgid "anyone can use their Subversion client to checkout a working copy of a repository URL (or any of its subdirectories),"
msgstr ""

#: en.xml:10683(para) 
msgid "anyone can interactively browse the repository's latest revision simply by pointing their web browser to the repository URL, and"
msgstr ""

#: en.xml:10688(para) 
msgid "anyone can commit to the repository."
msgstr ""

#: en.xml:10693(title) 
msgid "Basic HTTP Authentication"
msgstr ""

#: en.xml:10695(para) 
msgid "The easiest way to authenticate a client is via the HTTP Basic authentication mechanism, which simply uses a username and password to verify that a user is who she says she is. Apache provides an <command moreinfo=\"none\">htpasswd</command> utility for managing the list of acceptable usernames and passwords, those to whom you wish to grant special access to your Subversion repository. Let's grant commit access to Sally and Harry. First, we need to add them to the password file."
msgstr ""

#: en.xml:10705(screen) 
#, no-wrap
msgid "\n$ ### First time: use -c to create the file\n$ ### Use -m to use MD5 encryption of the password, which is more secure\n$ htpasswd -cm /etc/svn-auth-file harry\nNew password: ***** \nRe-type new password: *****\nAdding password for user harry\n$ htpasswd -m /etc/svn-auth-file sally\nNew password: *******\nRe-type new password: *******\nAdding password for user sally\n$\n"
msgstr ""

#: en.xml:10719(para) 
msgid "Next, you need to add some more <filename moreinfo=\"none\">httpd.conf</filename> directives inside your <literal moreinfo=\"none\">Location</literal> block to tell Apache what to do with your new password file. The <literal moreinfo=\"none\">AuthType</literal> directive specifies the type of authentication system to use. In this case, we want to specify the <literal moreinfo=\"none\">Basic</literal> authentication system. <literal moreinfo=\"none\">AuthName</literal> is an arbitrary name that you give for the authentication domain. Most browsers will display this name in the pop-up dialog box when the browser is querying the user for his name and password. Finally, use the <literal moreinfo=\"none\">AuthUserFile</literal> directive to specify the location of the password file you created using <command moreinfo=\"none\">htpasswd</command>."
msgstr ""

#: en.xml:10734(para) 
msgid "After adding these three directives, your <literal moreinfo=\"none\">&lt;Location&gt;</literal> block should look something like this:"
msgstr ""

#: en.xml:10738(screen) 
#, no-wrap
msgid "\n&lt;Location /svn&gt;\n  DAV svn\n  SVNParentPath /usr/local/svn\n  AuthType Basic\n  AuthName \"Subversion repository\"\n  AuthUserFile /etc/svn-auth-file\n&lt;/Location&gt;\n"
msgstr ""

#: en.xml:10748(para) 
msgid "This <literal moreinfo=\"none\">&lt;Location&gt;</literal> block is not yet complete, and will not do anything useful. It's merely telling Apache that whenever authorization is required, Apache should harvest a username and password from the Subversion client. What's missing here, however, are directives that tell Apache <emphasis>which</emphasis> sorts of client requests require authorization. Wherever authorization is required, Apache will demand authentication as well. The simplest thing to do is protect all requests. Adding <literal moreinfo=\"none\">Require valid-user</literal> tells Apache that all requests require an authenticated user:"
msgstr ""

#: en.xml:10761(screen) 
#, no-wrap
msgid "\n&lt;Location /svn&gt;\n  DAV svn\n  SVNParentPath /usr/local/svn\n  AuthType Basic\n  AuthName \"Subversion repository\"\n  AuthUserFile /etc/svn-auth-file\n  Require valid-user\n&lt;/Location&gt;\n"
msgstr ""

#: en.xml:10772(para) 
msgid "Be sure to read the next section (<xref linkend=\"svn.serverconfig.httpd.authz\"/>) for more detail on the <literal moreinfo=\"none\">Require</literal> directive and other ways to set authorization policies."
msgstr ""

#: en.xml:10785(para) 
msgid "While self-signed server certificates are still vulnerable to a <quote>man in the middle</quote> attack, such an attack is still much more difficult for a casual observer to pull off, compared to sniffing unprotected passwords."
msgstr ""

#: en.xml:10776(para) 
msgid "One word of warning: HTTP Basic Auth passwords pass in very nearly plain-text over the network, and thus are extremely insecure. If you're worried about password snooping, it may be best to use some sort of SSL encryption, so that clients authenticate via <literal moreinfo=\"none\">https://</literal> instead of <literal moreinfo=\"none\">http://</literal>; at a bare minimum, you can configure Apache to use a self-signed server certificate. <footnote><placeholder-1/></footnote> Consult Apache's documentation (and OpenSSL documentation) about how to do that."
msgstr ""

#: en.xml:10798(title) 
msgid "SSL Certificate Management"
msgstr ""

#: en.xml:10800(para) 
msgid "Businesses that need to expose their repositories for access outside the company firewall should be conscious of the possibility that unauthorized parties could be <quote>sniffing</quote> their network traffic. SSL makes that kind of unwanted attention less likely to result in sensitive data leaks."
msgstr ""

#: en.xml:10807(para) 
msgid "If a Subversion client is compiled to use OpenSSL, then it gains the ability to speak to an Apache server via <literal moreinfo=\"none\">https://</literal> URLs. The Neon library used by the Subversion client is not only able to verify server certificates, but can also supply client certificates when challenged. When the client and server have exchanged SSL certificates and successfully authenticated one another, all further communication is encrypted via a session key."
msgstr ""

#: en.xml:10816(para) 
msgid "It's beyond the scope of this book to describe how to generate client and server certificates, and how to configure Apache to use them. Many other books, including Apache's own documentation, describe this task. But what <emphasis>can</emphasis> be covered here is how to manage server and client certificates from an ordinary Subversion client."
msgstr ""

#: en.xml:10824(para) 
msgid "When speaking to Apache via <literal moreinfo=\"none\">https://</literal>, a Subversion client can receive two different types of information:"
msgstr ""

#: en.xml:10829(para) 
msgid "a server certificate"
msgstr ""

#: en.xml:10830(para) 
msgid "a demand for a client certificate"
msgstr ""

#: en.xml:10833(para) 
msgid "If the client receives a server certificate, it needs to verify that it trusts the certificate: is the server really who it claims to be? The OpenSSL library does this by examining the signer of the server certificate, or <firstterm>certifying authority</firstterm> (CA). If OpenSSL is unable to automatically trust the CA, or if some other problem occurs (such as an expired certificate or hostname mismatch), the Subversion command-line client will ask you whether you want to trust the server certificate anyway:"
msgstr ""

#: en.xml:10844(screen) 
#, no-wrap
msgid "\n$ svn list https://host.example.com/repos/project\n\nError validating server certificate for 'https://host.example.com:443':\n - The certificate is not issued by a trusted authority. Use the\n   fingerprint to validate the certificate manually!\nCertificate information:\n - Hostname: host.example.com\n - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT\n - Issuer: CA, example.com, Sometown, California, US\n - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b\n\n(R)eject, accept (t)emporarily or accept (p)ermanently?\n"
msgstr ""

#: en.xml:10859(para) 
msgid "This dialogue should look familiar; it's essentially the same question you've probably seen coming from your web browser (which is just another HTTP client like Subversion!). If you choose the (p)ermanent option, the server certificate will be cached in your private run-time <filename moreinfo=\"none\">auth/</filename> area in just the same way your username and password are cached (see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>). If cached, Subversion will automatically remember to trust this certificate in future negotiations."
msgstr ""

#: en.xml:10869(para) 
msgid "Your run-time <filename moreinfo=\"none\">servers</filename> file also gives you the ability to make your Subversion client automatically trust specific CAs, either globally or on a per-host basis. Simply set the <literal moreinfo=\"none\">ssl-authority-files</literal> variable to a semicolon-separated list of PEM-encoded CA certificates:"
msgstr ""

#: en.xml:10876(screen) 
#, no-wrap
msgid "\n[global]\nssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem\n"
msgstr ""

#: en.xml:10881(para) 
msgid "Many OpenSSL installations also have a pre-defined set of <quote>default</quote> CAs that are nearly universally trusted. To make the Subversion client automatically trust these standard authorities, set the <literal moreinfo=\"none\">ssl-trust-default-ca</literal> variable to <literal moreinfo=\"none\">true</literal>."
msgstr ""

#: en.xml:10888(para) 
msgid "When talking to Apache, a Subversion client might also receive a challenge for a client certificate. Apache is asking the client to identify itself: is the client really who it says it is? If all goes correctly, the Subversion client sends back a private certificate signed by a CA that Apache trusts. A client certificate is usually stored on disk in encrypted format, protected by a local password. When Subversion receives this challenge, it will ask you for both a path to the certificate and the password which protects it:"
msgstr ""

#: en.xml:10899(screen) 
#, no-wrap
msgid "\n$ svn list https://host.example.com/repos/project\n\nAuthentication realm: https://host.example.com:443\nClient certificate filename: /path/to/my/cert.p12\nPassphrase for '/path/to/my/cert.p12':  ********\n…\n"
msgstr ""

#: en.xml:10908(para) 
msgid "Notice that the client certificate is a <quote>p12</quote> file. To use a client certificate with Subversion, it must be in PKCS#12 format, which is a portable standard. Most web browsers are already able to import and export certificates in that format. Another option is to use the OpenSSL command-line tools to convert existing certificates into PKCS#12."
msgstr ""

#: en.xml:10916(para) 
msgid "Again, the runtime <filename moreinfo=\"none\">servers</filename> file allows you to automate this challenge on a per-host basis. Either or both pieces of information can be described in runtime variables:"
msgstr ""

#: en.xml:10921(screen) 
#, no-wrap
msgid "\n[groups]\nexamplehost = host.example.com\n\n[examplehost]\nssl-client-cert-file = /path/to/my/cert.p12\nssl-client-cert-password = somepassword\n"
msgstr ""

#: en.xml:10936(para) 
msgid "More security-conscious folk might not want to store the client certificate password in the runtime <filename moreinfo=\"none\">servers</filename> file."
msgstr ""

#: en.xml:10930(para) 
msgid "Once you've set the <literal moreinfo=\"none\">ssl-client-cert-file</literal> and <literal moreinfo=\"none\">ssl-client-cert-password</literal> variables, the Subversion client can automatically respond to a client certificate challenge without prompting you. <footnote><placeholder-1/></footnote>"
msgstr ""

#: en.xml:10948(title) 
msgid "Authorization Options"
msgstr ""

#: en.xml:10950(para) 
msgid "At this point, you've configured authentication, but not authorization. Apache is able to challenge clients and confirm identities, but it has not been told how to allow or restrict access to the clients bearing those identities. This section describes two strategies for controlling access to your repositories."
msgstr ""

#: en.xml:10958(title) 
msgid "Blanket Access Control"
msgstr ""

#: en.xml:10960(para) 
msgid "The simplest form of access control is to authorize certain users for either read-only access to a repository, or read/write access to a repository."
msgstr ""

#: en.xml:10964(para) 
msgid "You can restrict access on all repository operations by adding the <literal moreinfo=\"none\">Require valid-user</literal> directive to your <literal moreinfo=\"none\">&lt;Location&gt;</literal> block. Using our previous example, this would mean that only clients that claimed to be either <literal moreinfo=\"none\">harry</literal> or <literal moreinfo=\"none\">sally</literal>, and provided the correct password for their respective username, would be allowed to do anything with the Subversion repository:"
msgstr ""

#: en.xml:10973(screen) 
#, no-wrap
msgid "\n&lt;Location /svn&gt;\n  DAV svn\n  SVNParentPath /usr/local/svn\n\n  # how to authenticate a user\n  AuthType Basic\n  AuthName \"Subversion repository\"\n  AuthUserFile /path/to/users/file\n  \n  # only authenticated users may access the repository\n  Require valid-user\n&lt;/Location&gt;\n"
msgstr ""

#: en.xml:10988(para) 
msgid "Sometimes you don't need to run such a tight ship. For example, Subversion's own source code repository at <ulink url=\"http://svn.collab.net/repos/svn\"/> allows anyone in the world to perform read-only repository tasks (like checking out working copies and browsing the repository with a web browser), but restricts all write operations to authenticated users. To do this type of selective restriction, you can use the <literal moreinfo=\"none\">Limit</literal> and <literal moreinfo=\"none\">LimitExcept</literal> configuration directives. Like the <literal moreinfo=\"none\">Location</literal> directive, these blocks have starting and ending tags, and you would nest them inside your <literal moreinfo=\"none\">&lt;Location&gt;</literal> block."
msgstr ""

#: en.xml:11002(para) 
msgid "The parameters present on the <literal moreinfo=\"none\">Limit</literal> and <literal moreinfo=\"none\">LimitExcept</literal> directives are HTTP request types that are affected by that block. For example, if you wanted to disallow all access to your repository except the currently supported read-only operations, you would use the <literal moreinfo=\"none\">LimitExcept</literal> directive, passing the <literal moreinfo=\"none\">GET</literal>, <literal moreinfo=\"none\">PROPFIND</literal>, <literal moreinfo=\"none\">OPTIONS</literal>, and <literal moreinfo=\"none\">REPORT</literal> request type parameters. Then the previously mentioned <literal moreinfo=\"none\">Require valid-user</literal> directive would be placed inside the <literal moreinfo=\"none\">&lt;LimitExcept&gt;</literal> block instead of just inside the <literal moreinfo=\"none\">&lt;Location&gt;</literal> block."
msgstr ""

#: en.xml:11016(screen) 
#, no-wrap
msgid "\n&lt;Location /svn&gt;\n  DAV svn\n  SVNParentPath /usr/local/svn\n\n  # how to authenticate a user\n  AuthType Basic\n  AuthName \"Subversion repository\"\n  AuthUserFile /path/to/users/file\n\n  # For any operations other than these, require an authenticated user.\n  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;\n    Require valid-user\n  &lt;/LimitExcept&gt;\n&lt;/Location&gt;\n"
msgstr ""

#: en.xml:11033(para) 
msgid "These are only a few simple examples. For more in-depth information about Apache access control and the <literal moreinfo=\"none\">Require</literal> directive, take a look at the <literal moreinfo=\"none\">Security</literal> section of the Apache documentation's tutorials collection at <ulink url=\"http://httpd.apache.org/docs-2.0/misc/tutorials.html\"/>."
msgstr ""

#: en.xml:11043(title) 
msgid "Per-Directory Access Control"
msgstr ""

#: en.xml:11045(para) 
msgid "It's possible to set up finer-grained permissions using a second Apache httpd module, <command moreinfo=\"none\">mod_authz_svn</command>. This module grabs the various opaque URLs passing from client to server, asks <command moreinfo=\"none\">mod_dav_svn</command> to decode them, and then possibly vetoes requests based on access policies defined in a configuration file."
msgstr ""

#: en.xml:11053(para) 
msgid "If you've built Subversion from source code, <command moreinfo=\"none\">mod_authz_svn</command> is automatically built and installed alongside <command moreinfo=\"none\">mod_dav_svn</command>. Many binary distributions install it automatically as well. To verify that it's installed correctly, make sure it comes right after <command moreinfo=\"none\">mod_dav_svn</command>'s <literal moreinfo=\"none\">LoadModule</literal> directive in <filename moreinfo=\"none\">httpd.conf</filename>:"
msgstr ""

#: en.xml:11062(screen) 
#, no-wrap
msgid "\nLoadModule dav_module         modules/mod_dav.so\nLoadModule dav_svn_module     modules/mod_dav_svn.so\nLoadModule authz_svn_module   modules/mod_authz_svn.so\n"
msgstr ""

#: en.xml:11068(para) 
msgid "To activate this module, you need to configure your <literal moreinfo=\"none\">Location</literal> block to use the <literal moreinfo=\"none\">AuthzSVNAccessFile</literal> directive, which specifies a file containing the permissions policy for paths within your repositories. (In a moment, we'll discuss the format of that file.)"
msgstr ""

#: en.xml:11075(para) 
msgid "Apache is flexible, so you have the option to configure your block in one of three general patterns. To begin, choose one of these basic configuration patterns. (The examples below are very simple; look at Apache's own documentation for much more detail on Apache authentication and authorization options.)"
msgstr ""

#: en.xml:11082(para) 
msgid "The simplest block is to allow open access to everyone. In this scenario, Apache never sends authentication challenges, so all users are treated as <quote>anonymous</quote>."
msgstr ""

#: en.xml:11088(title) 
msgid "A sample configuration for anonymous access."
msgstr ""

#: en.xml:11089(programlisting) 
#, no-wrap
msgid "\n&lt;Location /repos&gt;\n  DAV svn\n  SVNParentPath /usr/local/svn\n\n  # our access control policy\n  AuthzSVNAccessFile /path/to/access/file                 \n&lt;/Location&gt;\n          "
msgstr ""

#: en.xml:11100(para) 
msgid "On the opposite end of the paranoia scale, you can configure your block to demand authentication from everyone. All clients must supply credentials to identify themselves. Your block unconditionally requires authentication via the <literal moreinfo=\"none\">Require valid-user</literal> directive, and defines a means to authenticate."
msgstr ""

#: en.xml:11108(title) 
msgid "A sample configuration for authenticated access."
msgstr ""

#: en.xml:11109(programlisting) 
#, no-wrap
msgid "\n&lt;Location /repos&gt;\n  DAV svn\n  SVNParentPath /usr/local/svn\n            \n  # our access control policy\n  AuthzSVNAccessFile /path/to/access/file                 \n            \n  # only authenticated users may access the repository\n  Require valid-user\n            \n  # how to authenticate a user\n  AuthType Basic\n  AuthName \"Subversion repository\"\n  AuthUserFile /path/to/users/file                  \n&lt;/Location&gt;\n          "
msgstr ""

#: en.xml:11128(para) 
msgid "A third very popular pattern is to allow a combination of authenticated and anonymous access. For example, many administrators want to allow anonymous users to read certain repository directories, but want only authenticated users to read (or write) more sensitive areas. In this setup, all users start out accessing the repository anonymously. If your access control policy demands a real username at any point, Apache will demand authentication from the client. To do this, you use both the <literal moreinfo=\"none\">Satisfy Any</literal> and <literal moreinfo=\"none\">Require valid-user</literal> directives together."
msgstr ""

#: en.xml:11141(title) 
msgid "A sample configuration for mixed authenticated/anonymous access."
msgstr ""

#: en.xml:11143(programlisting) 
#, no-wrap
msgid "\n&lt;Location /repos&gt;\n  DAV svn\n  SVNParentPath /usr/local/svn\n            \n  # our access control policy\n  AuthzSVNAccessFile /path/to/access/file                 \n            \n  # try anonymous access first, resort to real \n  # authentication if necessary.\n  Satisfy Any\n  Require valid-user\n            \n  # how to authenticate a user\n  AuthType Basic\n  AuthName \"Subversion repository\"\n  AuthUserFile /path/to/users/file                  \n&lt;/Location&gt;\n          "
msgstr ""

#: en.xml:11164(para) 
msgid "Once your basic <literal moreinfo=\"none\">Location</literal> block is configured, you can create an access file and define some authorization rules in it."
msgstr ""

#: en.xml:11168(para) 
msgid "The syntax of the access file is the same familiar one used by <command moreinfo=\"none\">svnserve.conf</command> and the runtime configuration files. Lines that start with a hash (<literal moreinfo=\"none\">#</literal>) are ignored. In its simplest form, each section names a repository and path within it, and the authenticated usernames are the option names within each section. The value of each option describes the user's level of access to the repository path: either <literal moreinfo=\"none\">r</literal> (read-only) or <literal moreinfo=\"none\">rw</literal> (read-write). If the user is not mentioned at all, no access is allowed."
msgstr ""

#: en.xml:11180(para) 
msgid "To be more specific: the value of the section-names are either of the form <literal moreinfo=\"none\">[repos-name:path]</literal> or the form <literal moreinfo=\"none\">[path]</literal>. If you're using the <literal moreinfo=\"none\">SVNParentPath</literal> directive, then it's important to specify the repository names in your sections. If you omit them, then a section like <literal moreinfo=\"none\">[/some/dir]</literal> will match the path <filename moreinfo=\"none\">/some/dir</filename> in <emphasis>every</emphasis> repository. If you're using the <literal moreinfo=\"none\">SVNPath</literal> directive, however, then it's fine to only define paths in your sections—after all, there's only one repository."
msgstr ""

#: en.xml:11193(screen) 
#, no-wrap
msgid "\n[calc:/branches/calc/bug-142]\nharry = rw\nsally = r\n"
msgstr ""

#: en.xml:11199(para) 
msgid "In this first example, the user <literal moreinfo=\"none\">harry</literal> has full read and write access on the <filename moreinfo=\"none\">/branches/calc/bug-142</filename> directory in the <literal moreinfo=\"none\">calc</literal> repository, but the user <literal moreinfo=\"none\">sally</literal> has read-only access. Any other users are blocked from accessing this directory."
msgstr ""

#: en.xml:11206(para) 
msgid "Of course, permissions are inherited from parent to child directory. That means that we can specify a subdirectory with a different access policy for Sally:"
msgstr ""

#: en.xml:11211(screen) 
#, no-wrap
msgid "\n[calc:/branches/calc/bug-142]\nharry = rw\nsally = r\n\n# give sally write access only to the 'testing' subdir\n[calc:/branches/calc/bug-142/testing]\nsally = rw\n"
msgstr ""

#: en.xml:11221(para) 
msgid "Now Sally can write to the <filename moreinfo=\"none\">testing</filename> subdirectory of the branch, but can still only read other parts. Harry, meanwhile, continues to have complete read-write access to the whole branch."
msgstr ""

#: en.xml:11226(para) 
msgid "It's also possible to explicitly deny permission to someone via inheritance rules, by setting the username variable to nothing:"
msgstr ""

#: en.xml:11230(screen) 
#, no-wrap
msgid "\n[calc:/branches/calc/bug-142]\nharry = rw\nsally = r\n\n[calc:/branches/calc/bug-142/secret]\nharry =\n"
msgstr ""

#: en.xml:11239(para) 
msgid "In this example, Harry has read-write access to the entire <filename moreinfo=\"none\">bug-142</filename> tree, but has absolutely no access at all to the <filename moreinfo=\"none\">secret</filename> subdirectory within it."
msgstr ""

#: en.xml:11244(para) 
msgid "The thing to remember is that the most specific path always matches first. The <command moreinfo=\"none\">mod_authz_svn</command> module tries to match the path itself, and then the parent of the path, then the parent of that, and so on. The net effect is that mentioning a specific path in the accessfile will always override any permissions inherited from parent directories."
msgstr ""

#: en.xml:11252(para) 
msgid "By default, nobody has any access to the repository at all. That means that if you're starting with an empty file, you'll probably want to give at least read permission to all users at the root of the repository. You can do this by using the asterisk variable (<literal moreinfo=\"none\">*</literal>), which means <quote>all users</quote>:"
msgstr ""

#: en.xml:11259(screen) 
#, no-wrap
msgid "\n[/]\n* = r\n"
msgstr ""

#: en.xml:11264(para) 
msgid "This is a common setup; notice that there's no repository name mentioned in the section name. This makes all repositories world readable to all users, whether you're using <literal moreinfo=\"none\">SVNPath</literal> or <literal moreinfo=\"none\">SVNParentPath</literal>. Once all users have read-access to the repositories, you can give explicit <literal moreinfo=\"none\">rw</literal> permission to certain users on specific subdirectories within specific repositories."
msgstr ""

#: en.xml:11273(para) 
msgid "The asterisk variable (<literal moreinfo=\"none\">*</literal>) is also worth special mention here: it's the <emphasis>only</emphasis> pattern which matches an anonymous user. If you've configured your <literal moreinfo=\"none\">Location</literal> block to allow a mixture of anonymous and authenticated access, all users start out accessing Apache anonymously. <command moreinfo=\"none\">mod_authz_svn</command> looks for a <literal moreinfo=\"none\">*</literal> value defined for the path being accessed; if it can't find one, then Apache demands real authentication from the client."
msgstr ""

#: en.xml:11284(para) 
msgid "The access file also allows you to define whole groups of users, much like the Unix <filename moreinfo=\"none\">/etc/group</filename> file:"
msgstr ""

#: en.xml:11288(screen) 
#, no-wrap
msgid "\n[groups]\ncalc-developers = harry, sally, joe\npaint-developers = frank, sally, jane\neveryone = harry, sally, joe, frank, sally, jane\n"
msgstr ""

#: en.xml:11295(para) 
msgid "Groups can be granted access control just like users. Distinguish them with an <quote>at</quote> (<literal moreinfo=\"none\">@</literal>) prefix:"
msgstr ""

#: en.xml:11299(screen) 
#, no-wrap
msgid "\n[calc:/projects/calc]\n@calc-developers = rw\n\n[paint:/projects/paint]\n@paint-developers = rw\njane = r \n"
msgstr ""

#: en.xml:11308(para) 
msgid "Groups can also be defined to contain other groups:"
msgstr ""

#: en.xml:11311(screen) 
#, no-wrap
msgid "\n[groups]\ncalc-developers = harry, sally, joe\npaint-developers = frank, sally, jane\neveryone = @calc-developers, @paint-developers\n"
msgstr ""

#: en.xml:11318(para) 
msgid "…and that's pretty much all there is to it."
msgstr ""

#: en.xml:11323(title) 
msgid "Disabling Path-based Checks"
msgstr ""

#: en.xml:11325(para) 
msgid "The <command moreinfo=\"none\">mod_dav_svn</command> module goes through a lot of work to make sure that data you've marked <quote>unreadable</quote> doesn't get accidentally leaked. This means that it needs to closely monitor all of the paths and file-contents returned by commands like <command moreinfo=\"none\">svn checkout</command> or <command moreinfo=\"none\">svn update</command> commands. If these commands encounter a path that isn't readable according to some authorization policy, then the path is typically omitted altogether. In the case of history or rename tracing—e.g. running a command like <command moreinfo=\"none\">svn cat -r OLD foo.c</command> on a file that was renamed long ago—the rename tracking will simply halt if one of the object's former names is determined to be read-restricted."
msgstr ""

#: en.xml:11340(para) 
msgid "All of this path-checking can sometimes be quite expensive, especially in the case of <command moreinfo=\"none\">svn log</command>. When retrieving a list revisions, the server looks at every changed path in each revision and checks it for readability. If an unreadable path is discovered, then it's omitted from the list of the revision's changed paths (normally seen with the <option>--verbose</option> option), and the whole log message is suppressed. Needless to say, this can be time-consuming on revisions that affect a large number of files. This is the cost of security: even if you haven't configured a module like <command moreinfo=\"none\">mod_authz_svn</command> at all, the <command moreinfo=\"none\">mod_dav_svn</command> module is still asking Apache <command moreinfo=\"none\">httpd</command> to run authorization checks on every path. The <command moreinfo=\"none\">mod_dav_svn</command> module has no idea what authorization modules have been installed, so all it can do is ask Apache to invoke whatever might be present."
msgstr ""

#: en.xml:11359(para) 
msgid "On the other hand, there's also an escape-hatch of sorts, one which allows you to trade security features for speed. If you're not enforcing any sort of per-directory authorization (i.e. not using <command moreinfo=\"none\">mod_authz_svn</command> or similar module), then you can disable all of this path-checking. In your <filename moreinfo=\"none\">httpd.conf</filename> file, use the <literal moreinfo=\"none\">SVNPathAuthz</literal> directive:"
msgstr ""

#: en.xml:11369(title) 
msgid "Disabling path checks altogether"
msgstr ""

#: en.xml:11370(programlisting) 
#, no-wrap
msgid "\n&lt;Location /repos&gt;\n  DAV svn\n  SVNParentPath /usr/local/svn\n            \n  SVNPathAuthz off\n&lt;/Location&gt;            \n          "
msgstr ""

#: en.xml:11380(para) 
msgid "The <literal moreinfo=\"none\">SVNPathAuthz</literal> directive is <quote>on</quote> by default. When set <quote>off</quote>, all path-based authorization checking is disabled; <command moreinfo=\"none\">mod_dav_svn</command> stops invoking authorization checks on every path it discovers."
msgstr ""

#: en.xml:11392(title) 
msgid "Extra Goodies"
msgstr ""

#: en.xml:11394(para) 
msgid "We've covered most of the authentication and authorization options for Apache and mod_dav_svn. But there are a few other nice features that Apache provides."
msgstr ""

#: en.xml:11399(title) 
msgid "Repository Browsing"
msgstr ""

#: en.xml:11401(para) 
msgid "One of the most useful benefits of an Apache/WebDAV configuration for your Subversion repository is that the youngest revisions of your versioned files and directories are immediately available for viewing via a regular web browser. Since Subversion uses URLs to identify versioned resources, those URLs used for HTTP-based repository access can be typed directly into a Web browser. Your browser will issue a <literal moreinfo=\"none\">GET</literal> request for that URL, and based on whether that URL represents a versioned directory or file, mod_dav_svn will respond with a directory listing or with file contents."
msgstr ""

#: en.xml:11413(para) 
msgid "Since the URLs do not contain any information about which version of the resource you wish to see, mod_dav_svn will always answer with the youngest version. This functionality has the wonderful side-effect that you can pass around Subversion URLs to your peers as references to documents, and those URLs will always point at the latest manifestation of that document. Of course, you can even use the URLs as hyperlinks from other web sites, too."
msgstr ""

#: en.xml:11422(para) 
msgid "You generally will get more use out of URLs to versioned files—after all, that's where the interesting content tends to lie. But you might have occasion to browse a Subversion directory listing, where you'll quickly note that the generated HTML used to display that listing is very basic, and certainly not intended to be aesthetically pleasing (or even interesting). To enable customization of these directory displays, Subversion provides an XML index feature. A single <literal moreinfo=\"none\">SVNIndexXSLT</literal> directive in your repository's <literal moreinfo=\"none\">Location</literal> block of <filename moreinfo=\"none\">httpd.conf</filename> will instruct mod_dav_svn to generate XML output when displaying a directory listing, and to reference the XSLT stylesheet of your choice:"
msgstr ""

#: en.xml:11436(screen) 
#, no-wrap
msgid "\n&lt;Location /svn&gt;\n  DAV svn\n  SVNParentPath /usr/local/svn\n  SVNIndexXSLT \"/svnindex.xsl\"\n  …\n&lt;/Location&gt;\n"
msgstr ""

#: en.xml:11445(para) 
msgid "Using the <literal moreinfo=\"none\">SVNIndexXSLT</literal> directive and a creative XSLT stylesheet, you can make your directory listings match the color schemes and imagery used in other parts of your website. Or, if you'd prefer, you can use the sample stylesheets provided in the Subversion source distribution's <filename moreinfo=\"none\">tools/xslt/</filename> directory. Keep in mind that the path provided to the <literal moreinfo=\"none\">SVNIndexXSLT</literal> directory is actually a URL path—browsers need to be able to read your stylesheets in order to make use of them!"
msgstr ""

#: en.xml:11457(title) 
msgid "Can I view older revisions?"
msgstr ""

#: en.xml:11459(para) 
msgid "With an ordinary web browser? In one word: nope. At least, not with <command moreinfo=\"none\">mod_dav_svn</command> as your only tool."
msgstr ""

#: en.xml:11463(para) 
msgid "Your web browser only speaks ordinary HTTP. That means it only knows how to GET public URLs, which represent the latest versions of files and directories. According to the WebDAV/DeltaV spec, each server defines a private URL syntax for older versions of resources, and that syntax is opaque to clients. To find an older version of a file, a client must follow a specific procedure to <quote>discover</quote> the proper URL; the procedure involves issuing a series of WebDAV PROPFIND requests and understanding DeltaV concepts. This is something your web browser simply can't do."
msgstr ""

#: en.xml:11485(para) 
msgid "Back then, it was called <quote>ViewCVS</quote>."
msgstr ""

#: en.xml:11475(para) 
msgid "So to answer the question, one obvious way to see older revisions of files and directories is by passing the <option>--revision</option> argument to the <command moreinfo=\"none\">svn list</command> and <command moreinfo=\"none\">svn cat</command> commands. To browse old revisions with your web browser, however, you can use third-party software. A good example of this is ViewVC (<ulink url=\"http://viewvc.tigris.org/\"/>). ViewVC was originally written to display CVS repositories through the web, <footnote><placeholder-1/></footnote> and the latest bleeding-edge versions (at the time of writing) are able to understand Subversion repositories as well."
msgstr ""

#: en.xml:11495(title) 
msgid "Other Features"
msgstr ""

#: en.xml:11497(para) 
msgid "Several of the features already provided by Apache in its role as a robust Web server can be leveraged for increased functionality or security in Subversion as well. Subversion communicates with Apache using Neon, which is a generic HTTP/WebDAV library with support for such mechanisms as SSL (the Secure Socket Layer, discussed earlier) and Deflate compression (the same algorithm used by the <command moreinfo=\"none\">gzip</command> and <command moreinfo=\"none\">PKZIP</command> programs to <quote>shrink</quote> files into smaller chunks of data). You need only to compile support for the features you desire into Subversion and Apache, and properly configure the programs to use those features."
msgstr ""

#: en.xml:11510(para) 
msgid "Deflate compression places a small burden on the client and server to compress and decompress network transmissions as a way to minimize the size of the actual transmission. In cases where network bandwidth is in short supply, this kind of compression can greatly increase the speed at which communications between server and client can be sent. In extreme cases, this minimized network transmission could be the difference between an operation timing out or completing successfully."
msgstr ""

#: en.xml:11520(para) 
msgid "Less interesting, but equally useful, are other features of the Apache and Subversion relationship, such as the ability to specify a custom port (instead of the default HTTP port 80) or a virtual domain name by which the Subversion repository should be accessed, or the ability to access the repository through a proxy. These things are all supported by Neon, so Subversion gets that support for free."
msgstr ""

#: en.xml:11529(para) 
msgid "Finally, because <command moreinfo=\"none\">mod_dav_svn</command> is speaking a semi-complete dialect of WebDAV/DeltaV, it's possible to access the repository via third-party DAV clients. Most modern operating systems (Win32, OS X, and Linux) have the built-in ability to mount a DAV server as a standard network <quote>share</quote>. This is a complicated topic; for details, read <xref linkend=\"svn.webdav\"/>."
msgstr ""

#: en.xml:11550(title) 
msgid "Supporting Multiple Repository Access Methods"
msgstr ""

#: en.xml:11552(para) 
msgid "You've seen how a repository can be accessed in many different ways. But is it possible—or safe—for your repository to be accessed by multiple methods simultaneously? The answer is yes, provided you use a bit of foresight."
msgstr ""

#: en.xml:11557(para) 
msgid "At any given time, these processes may require read and write access to your repository:"
msgstr ""

#: en.xml:11562(para) 
msgid "regular system users using a Subversion client (as themselves) to access the repository directly via <literal moreinfo=\"none\">file:///</literal> URLs;"
msgstr ""

#: en.xml:11567(para) 
msgid "regular system users connecting to SSH-spawned private <command moreinfo=\"none\">svnserve</command> processes (running as themselves) which access the repository;"
msgstr ""

#: en.xml:11572(para) 
msgid "an <command moreinfo=\"none\">svnserve</command> process—either a daemon or one launched by <command moreinfo=\"none\">inetd</command>—running as a particular fixed user;"
msgstr ""

#: en.xml:11578(para) 
msgid "an Apache <command moreinfo=\"none\">httpd</command> process, running as a particular fixed user."
msgstr ""

#: en.xml:11583(para) 
msgid "The most common problem administrators run into is repository ownership and permissions. Does every process (or user) in the previous list have the rights to read and write the Berkeley DB files? Assuming you have a Unix-like operating system, a straightforward approach might be to place every potential repository user into a new <literal moreinfo=\"none\">svn</literal> group, and make the repository wholly owned by that group. But even that's not enough, because a process may write to the database files using an unfriendly umask—one that prevents access by other users."
msgstr ""

#: en.xml:11594(para) 
msgid "So the next step beyond setting up a common group for repository users is to force every repository-accessing process to use a sane umask. For users accessing the repository directly, you can make the <command moreinfo=\"none\">svn</command> program into a wrapper script that first sets <command moreinfo=\"none\">umask 002</command> and then runs the real <command moreinfo=\"none\">svn</command> client program. You can write a similar wrapper script for the <command moreinfo=\"none\">svnserve</command> program, and add a <command moreinfo=\"none\">umask 002</command> command to Apache's own startup script, <filename moreinfo=\"none\">apachectl</filename>. For example:"
msgstr ""

#: en.xml:11605(screen) 
#, no-wrap
msgid "\n$ cat /usr/bin/svn\n\n#!/bin/sh\n\numask 002\n/usr/bin/svn-real \"$@\"\n\n"
msgstr ""

#: en.xml:11615(para) 
msgid "Another common problem is often encountered on Unix-like systems. As a repository is used, Berkeley DB occasionally creates new log files to journal its actions. Even if the repository is wholly owned by the <command moreinfo=\"none\">svn</command> group, these newly created files won't necessarily be owned by that same group, which then creates more permissions problems for your users. A good workaround is to set the group SUID bit on the repository's <filename moreinfo=\"none\">db</filename> directory. This causes all newly-created log files to have the same group owner as the parent directory."
msgstr ""

#: en.xml:11626(para) 
msgid "Once you've jumped through these hoops, your repository should be accessible by all the necessary processes. It may seem a bit messy and complicated, but the problems of having multiple users sharing write-access to common files are classic ones that are not often elegantly solved."
msgstr ""

#: en.xml:11632(para) 
msgid "Fortunately, most repository administrators will never <emphasis>need</emphasis> to have such a complex configuration. Users who wish to access repositories that live on the same machine are not limited to using <literal moreinfo=\"none\">file://</literal> access URLs—they can typically contact the Apache HTTP server or <command moreinfo=\"none\">svnserve</command> using <literal moreinfo=\"none\">localhost</literal> for the server name in their <literal moreinfo=\"none\">http://</literal> or <literal moreinfo=\"none\">svn://</literal> URLs. And to maintain multiple server processes for your Subversion repositories is likely to be more of a headache than necessary. We recommend you choose the server that best meets your needs and stick with it!"
msgstr ""

#: en.xml:11646(title) 
msgid "The svn+ssh:// server checklist"
msgstr ""

#: en.xml:11648(para) 
msgid "It can be quite tricky to get a bunch of users with existing SSH accounts to share a repository without permissions problems. If you're confused about all the things that you (as an administrator) need to do on a Unix-like system, here's a quick checklist that resummarizes some of things discussed in this section:"
msgstr ""

#: en.xml:11657(para) 
msgid "All of your SSH users need to be able to read and write to the repository. Put all the SSH users into a single group. Make the repository wholly owned by that group, and set the group permissions to read/write."
msgstr ""

#: en.xml:11664(para) 
msgid "Your users need to use a sane umask when accessing the repository. Make sure that <command moreinfo=\"none\">svnserve</command> (<filename moreinfo=\"none\">/usr/bin/svnserve</filename>, or wherever it lives in <literal moreinfo=\"none\">$PATH</literal>) is actually a wrapper script which sets <command moreinfo=\"none\">umask 002</command> and executes the real <command moreinfo=\"none\">svnserve</command> binary. Take similar measures when using <command moreinfo=\"none\">svnlook</command> and <command moreinfo=\"none\">svnadmin</command>. Either run them with a sane umask, or wrap them as described above."
msgstr ""

#: en.xml:11693(title) 
msgid "Advanced Topics"
msgstr ""

#: en.xml:11697(para) 
msgid "If you've been reading this book chapter by chapter, from start to finish, you should by now have acquired enough knowledge to use the Subversion client to perform the most common version control operations. You understand how to checkout a working copy from a Subversion repository. You are comfortable with submitting and receiving changes using the <command moreinfo=\"none\">svn commit</command> and <command moreinfo=\"none\">svn update</command> functions. You've probably even developed a reflex which causes you to run the <command moreinfo=\"none\">svn status</command> command almost unconsciously. For all intents and purposes, you are ready to use Subversion in a typical environment."
msgstr ""

#: en.xml:11709(para) 
msgid "But the Subversion feature set doesn't stop at <quote>common version control operations</quote>."
msgstr ""

#: en.xml:11712(para) 
msgid "This chapter highlights some of Subversion's features that aren't quite so regularly used. In it, we will discuss Subversion's property (or <quote>metadata</quote>) support, and how to modify Subversion's default behaviors by tweaking its run-time configuration area. We will describe how you can use externals definitions to instruct Subversion to pull data from multiple repositories. We'll cover in detail some of the additional client- and server-side tools that are part of the Subversion distribution."
msgstr ""

#: en.xml:11722(para) 
msgid "Before reading this chapter, you should be familiar with the basic file and directory versioning capabilities of Subversion. If you haven't already read about those, or if you need a refresher, we recommend that you check out <xref linkend=\"svn.basic\"/> and <xref linkend=\"svn.tour\"/>. Once you've mastered the basics and consumed this chapter, you'll be a Subversion power-user!"
msgstr ""

#: en.xml:11733(title) 
msgid "Runtime Configuration Area"
msgstr ""

#: en.xml:11735(para) 
msgid "Subversion provides many optional behaviors that can be controlled by the user. Many of these options are of the kind that a user would wish to apply to all Subversion operations. So, rather than forcing users to remember command-line arguments for specifying these options, and to use them for each and every operation they perform, Subversion uses configuration files, segregated into a Subversion configuration area."
msgstr ""

#: en.xml:11743(para) 
msgid "The Subversion <firstterm>configuration area</firstterm> is a two-tiered hierarchy of option names and their values. Usually, this boils down to a special directory that contains <firstterm>configuration files</firstterm> (the first tier), which are just text files in standard INI format (with <quote>sections</quote> providing the second tier). These files can be easily edited using your favorite text editor (such as Emacs or vi), and contain directives read by the client to determine which of several optional behaviors the user prefers."
msgstr ""

#: en.xml:11756(title) 
msgid "Configuration Area Layout"
msgstr ""

#: en.xml:11770(para) 
msgid "The <literal moreinfo=\"none\">APPDATA</literal> environment variable points to the <filename moreinfo=\"none\">Application Data</filename> area, so you can always refer to this folder as <filename moreinfo=\"none\">%APPDATA%\\Subversion</filename>."
msgstr ""

#: en.xml:11758(para) 
msgid "The first time that the <command moreinfo=\"none\">svn</command> command-line client is executed, it creates a per-user configuration area. On Unix-like systems, this area appears as a directory named <filename moreinfo=\"none\">.subversion</filename> in the user's home directory. On Win32 systems, Subversion creates a folder named <filename moreinfo=\"none\">Subversion</filename>, typically inside the <filename moreinfo=\"none\">Application Data</filename> area of the user's profile directory (which, by the way, is usually a hidden directory). However, on this platform the exact location differs from system to system, and is dictated by the Windows registry. <footnote><placeholder-1/></footnote> We will refer to the per-user configuration area using its Unix name, <filename moreinfo=\"none\">.subversion</filename>."
msgstr ""

#: en.xml:11778(para) 
msgid "In addition to the per-user configuration area, Subversion also recognizes the existence of a system-wide configuration area. This gives system administrators the ability to establish defaults for all users on a given machine. Note that the system-wide configuration area does not alone dictate mandatory policy—the settings in the per-user configuration area override those in the system-wide one, and command-line arguments supplied to the <command moreinfo=\"none\">svn</command> program have the final word on behavior. On Unix-like platforms, the system-wide configuration area is expected to be the <filename moreinfo=\"none\">/etc/subversion</filename> directory; on Windows machines, it looks for a <filename moreinfo=\"none\">Subversion</filename> directory inside the common <filename moreinfo=\"none\">Application Data</filename> location (again, as specified by the Windows Registry). Unlike the per-user case, the <command moreinfo=\"none\">svn</command> program does not attempt to create the system-wide configuration area."
msgstr ""

#: en.xml:11796(para) 
msgid "The configuration area currently contains three files—two configuration files (<filename moreinfo=\"none\">config</filename> and <filename moreinfo=\"none\">servers</filename>), and a <filename moreinfo=\"none\">README.txt</filename> file which describes the INI format. At the time of their creation, the files contain default values for each of the supported Subversion options, mostly commented out and grouped with textual descriptions about how the values for the key affect Subversion's behavior. To change a certain behavior, you need only to load the appropriate configuration file into a text editor, and modify the desired option's value. If at any time you wish to have the default configuration settings restored, you can simply remove (or rename) your configuration directory and then run some innocuous <command moreinfo=\"none\">svn</command> command, such as <command moreinfo=\"none\">svn --version</command>. A new configuration directory with the default contents will be created."
msgstr ""

#: en.xml:11813(para) 
msgid "The per-user configuration area also contains a cache of authentication data. The <filename moreinfo=\"none\">auth</filename> directory holds a set of subdirectories that contain pieces of cached information used by Subversion's various supported authentication methods. This directory is created in such a way that only the user herself has permission to read its contents."
msgstr ""

#: en.xml:11825(title) 
msgid "Configuration and the Windows Registry"
msgstr ""

#: en.xml:11827(para) 
msgid "In addition to the usual INI-based configuration area, Subversion clients running on Windows platforms may also use the Windows registry to hold the configuration data. The option names and their values are the same as in the INI files. The <quote>file/section</quote> hierarchy is preserved as well, though addressed in a slightly different fashion—in this schema, files and sections are just levels in the registry key tree."
msgstr ""

#: en.xml:11836(para) 
msgid "Subversion looks for system-wide configuration values under the <literal moreinfo=\"none\">HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion</literal> key. For example, the <literal moreinfo=\"none\">global-ignores</literal> option, which is in the <literal moreinfo=\"none\">miscellany</literal> section of the <filename moreinfo=\"none\">config</filename> file, would be found at <literal moreinfo=\"none\">HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Config\\Miscellany\\global-ignores</literal>. Per-user configuration values should be stored under <literal moreinfo=\"none\">HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion</literal>."
msgstr ""

#: en.xml:11847(para) 
msgid "Registry-based configuration options are parsed <emphasis>before</emphasis> their file-based counterparts, so are overridden by values found in the configuration files. In other words, configuration priority is granted in the following order on a Windows system:"
msgstr ""

#: en.xml:11855(para) 
msgid "Command-line options"
msgstr ""

#: en.xml:11858(para) 
msgid "The per-user INI files"
msgstr ""

#: en.xml:11861(para) 
msgid "The per-user Registry values"
msgstr ""

#: en.xml:11864(para) 
msgid "The system-wide INI files"
msgstr ""

#: en.xml:11867(para) 
msgid "The system-wide Registry values"
msgstr ""

#: en.xml:11871(para) 
msgid "Also, the Windows Registry doesn't really support the notion of something being <quote>commented out</quote>. However, Subversion will ignore any option key whose name begins with a hash (<literal moreinfo=\"none\">#</literal>) character. This allows you to effectively comment out a Subversion option without deleting the entire key from the Registry, obviously simplifying the process of restoring that option."
msgstr ""

#: en.xml:11879(para) 
msgid "The <command moreinfo=\"none\">svn</command> command-line client never attempts to write to the Windows Registry, and will not attempt to create a default configuration area there. You can create the keys you need using the <command moreinfo=\"none\">REGEDIT</command> program. Alternatively, you can create a <filename moreinfo=\"none\">.reg</filename> file, and then double-click on that file from the Explorer shell, which will cause the data to be merged into your registry."
msgstr ""

#: en.xml:11889(title) 
msgid "Sample Registration Entries (.reg) File."
msgstr ""

#: en.xml:11891(programlisting) 
#, no-wrap
msgid "\nREGEDIT4\n\n[HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Servers\\groups]\n\n[HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Servers\\global]\n\"#http-proxy-host\"=\"\"\n\"#http-proxy-port\"=\"\"\n\"#http-proxy-username\"=\"\"\n\"#http-proxy-password\"=\"\"\n\"#http-proxy-exceptions\"=\"\"\n\"#http-timeout\"=\"0\"\n\"#http-compression\"=\"yes\"\n\"#neon-debug-mask\"=\"\"\n\"#ssl-authority-files\"=\"\"\n\"#ssl-trust-default-ca\"=\"\"\n\"#ssl-client-cert-file\"=\"\"\n\"#ssl-client-cert-password\"=\"\"\n\n[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\auth]\n\"#store-auth-creds\"=\"no\"\n\n[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\helpers]\n\"#editor-cmd\"=\"notepad\"\n\"#diff-cmd\"=\"\"\n\"#diff3-cmd\"=\"\"\n\"#diff3-has-program-arg\"=\"\"\n\n[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\miscellany]\n\"#global-ignores\"=\"*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store\"\n\"#log-encoding\"=\"\"\n\"#use-commit-times\"=\"\"\n\"#template-root\"=\"\"\n\"#enable-auto-props\"=\"\"\n\n[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\tunnels]\n\n[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\auto-props]\n"
msgstr ""

#: en.xml:11932(para) 
msgid "The previous example shows the contents of a <filename moreinfo=\"none\">.reg</filename> file which contains some of the most commonly used configuration options and their default values. Note the presence of both system-wide (for network proxy-related options) and per-user settings (editor programs and password storage, among others). Also note that all the options are effectively commented out. You need only to remove the hash (<literal moreinfo=\"none\">#</literal>) character from the beginning of the option names, and set the values as you desire."
msgstr ""

#: en.xml:11947(title) 
msgid "Configuration Options"
msgstr ""

#: en.xml:11949(para) 
msgid "In this section, we will discuss the specific run-time configuration options that are currently supported by Subversion."
msgstr ""

#: en.xml:11954(title) 
msgid "Servers"
msgstr ""

#: en.xml:11956(para) 
msgid "The <filename moreinfo=\"none\">servers</filename> file contains Subversion configuration options related to the network layers. There are two special section names in this file—<literal moreinfo=\"none\">groups</literal> and <literal moreinfo=\"none\">global</literal>. The <literal moreinfo=\"none\">groups</literal> section is essentially a cross-reference table. The keys in this section are the names of other sections in the file; their values are <firstterm>globs</firstterm>—textual tokens which possibly contain wildcard characters—that are compared against the hostnames of the machine to which Subversion requests are sent."
msgstr ""

#: en.xml:11968(programlisting) 
#, no-wrap
msgid "\n[groups]\nbeanie-babies = *.red-bean.com\ncollabnet = svn.collab.net\n\n[beanie-babies]\n…\n\n[collabnet]\n…\n"
msgstr ""

#: en.xml:11980(para) 
msgid "When Subversion is used over a network, it attempts to match the name of the server it is trying to reach with a group name under the <literal moreinfo=\"none\">groups</literal> section. If a match is made, Subversion then looks for a section in the <filename moreinfo=\"none\">servers</filename> file whose name is the matched group's name. From that section it reads the actual network configuration settings."
msgstr ""

#: en.xml:11988(para) 
msgid "The <literal moreinfo=\"none\">global</literal> section contains the settings that are meant for all of the servers not matched by one of the globs under the <literal moreinfo=\"none\">groups</literal> section. The options available in this section are exactly the same as those valid for the other server sections in the file (except, of course, the special <literal moreinfo=\"none\">groups</literal> section), and are as follows:"
msgstr ""

#: en.xml:11999(literal) 
msgid "http-proxy-host"
msgstr ""

#: en.xml:12001(para) 
msgid "This specifies the hostname of the proxy computer through which your HTTP-based Subversion requests must pass. It defaults to an empty value, which means that Subversion will not attempt to route HTTP requests through a proxy computer, and will instead attempt to contact the destination machine directly."
msgstr ""

#: en.xml:12010(literal) 
msgid "http-proxy-port"
msgstr ""

#: en.xml:12012(para) 
msgid "This specifies the port number on the proxy host to use. It defaults to an empty value."
msgstr ""

#: en.xml:12017(literal) 
msgid "http-proxy-username"
msgstr ""

#: en.xml:12019(para) 
msgid "This specifies the username to supply to the proxy machine. It defaults to an empty value."
msgstr ""

#: en.xml:12024(literal) 
msgid "http-proxy-password"
msgstr ""

#: en.xml:12026(para) 
msgid "This specifies the password to supply to the proxy machine. It defaults to an empty value."
msgstr ""

#: en.xml:12031(literal) 
msgid "http-timeout"
msgstr ""

#: en.xml:12033(para) 
msgid "This specifies the amount of time, in seconds, to wait for a server response. If you experience problems with a slow network connection causing Subversion operations to timeout, you should increase the value of this option. The default value is <literal moreinfo=\"none\">0</literal>, which instructs the underlying HTTP library, Neon, to use its default timeout setting."
msgstr ""

#: en.xml:12044(literal) 
msgid "http-compression"
msgstr ""

#: en.xml:12046(para) 
msgid "This specifies whether or not Subversion should attempt to compress network requests made to DAV-ready servers. The default value is <literal moreinfo=\"none\">yes</literal> (though compression will only occur if that capability is compiled into the network layer). Set this to <literal moreinfo=\"none\">no</literal> to disable compression, such as when debugging network transmissions."
msgstr ""

#: en.xml:12056(literal) 
msgid "neon-debug-mask"
msgstr ""

#: en.xml:12058(para) 
msgid "This is an integer mask that the underlying HTTP library, Neon, uses for choosing what type of debugging output to yield. The default value is <literal moreinfo=\"none\">0</literal>, which will silence all debugging output. For more information about how Subversion makes use of Neon, see <xref linkend=\"svn.developer\"/>."
msgstr ""

#: en.xml:12067(literal) 
msgid "ssl-authority-files"
msgstr ""

#: en.xml:12069(para) 
msgid "This is a semicolon-delimited list of paths to files containing certificates of the certificate authorities (or CAs) that are accepted by the Subversion client when accessing the repository over HTTPS."
msgstr ""

#: en.xml:12077(literal) 
msgid "ssl-trust-default-ca"
msgstr ""

#: en.xml:12079(para) 
msgid "Set this variable to <literal moreinfo=\"none\">yes</literal> if you want Subversion to automatically trust the set of default CAs that ship with OpenSSL."
msgstr ""

#: en.xml:12085(literal) 
msgid "ssl-client-cert-file"
msgstr ""

#: en.xml:12087(para) 
msgid "If a host (or set of hosts) requires an SSL client certificate, you'll normally be prompted for a path to your certificate. By setting this variable to that same path, Subversion will be able to find your client certificate automatically without prompting you. There's no standard place to store your certificate on disk; Subversion will grab it from any path you specify."
msgstr ""

#: en.xml:12098(literal) 
msgid "ssl-client-cert-password"
msgstr ""

#: en.xml:12100(para) 
msgid "If your SSL client certificate file is encrypted by a passphrase, Subversion will prompt you for the passphrase whenever the certificate is used. If you find this annoying (and don't mind storing the password in the <filename moreinfo=\"none\">servers</filename> file), then you can set this variable to the certificate's passphrase. You won't be prompted anymore."
msgstr ""

#: en.xml:12113(title) 
msgid "Config"
msgstr ""

#: en.xml:12115(para) 
msgid "The <filename moreinfo=\"none\">config</filename> file contains the rest of the currently available Subversion run-time options, those not related to networking. There are only a few options in use at this time, but they are again grouped into sections in expectation of future additions."
msgstr ""

#: en.xml:12121(para) 
msgid "The <literal moreinfo=\"none\">auth</literal> section contains settings related to Subversion's authentication and authorization against the repository. It contains:"
msgstr ""

#: en.xml:12127(literal) 
msgid "store-passwords"
msgstr ""

#: en.xml:12129(para) 
msgid "This instructs Subversion to cache, or not to cache, passwords that are supplied by the user in response to server authentication challenges. The default value is <literal moreinfo=\"none\">yes</literal>. Set this to <literal moreinfo=\"none\">no</literal> to disable this on-disk password caching. You can override this option for a single instance of the <command moreinfo=\"none\">svn</command> command using the <option>--no-auth-cache</option> command-line parameter (for those subcommands that support it). For more information, see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>."
msgstr ""

#: en.xml:12142(literal) 
msgid "store-auth-creds"
msgstr ""

#: en.xml:12144(para) 
msgid "This setting is the same as <literal moreinfo=\"none\">store-passwords</literal>, except that it enables or disables disk-caching of <emphasis>all</emphasis> authentication information: usernames, passwords, server certificates, and any other types of cacheable credentials."
msgstr ""

#: en.xml:12154(para) 
msgid "The <literal moreinfo=\"none\">helpers</literal> section controls which external applications Subversion uses to accomplish its tasks. Valid options in this section are:"
msgstr ""

#: en.xml:12160(literal) 
msgid "editor-cmd"
msgstr ""

#: en.xml:12162(para) 
msgid "This specifies the program Subversion will use to query the user for a log message during a commit operation, such as when using <command moreinfo=\"none\">svn commit</command> without either the <option>--message</option> (<option>-m</option>) or <option>--file</option> (<option>-F</option>) options. This program is also used with the <command moreinfo=\"none\">svn propedit</command> command—a temporary file is populated with the current value of the property the user wishes to edit, and the edits take place right in the editor program (see <xref linkend=\"svn.advanced.props\"/>). This option's default value is empty. The order of priority for determining the editor command is:"
msgstr ""

#: en.xml:12177(para) 
msgid "Command-line option <literal moreinfo=\"none\">--editor-cmd</literal>"
msgstr ""

#: en.xml:12180(para) 
msgid "Environment variable <literal moreinfo=\"none\">SVN_EDITOR</literal>"
msgstr ""

#: en.xml:12183(para) 
msgid "Configuration option <literal moreinfo=\"none\">editor-cmd</literal>"
msgstr ""

#: en.xml:12186(para) 
msgid "Environment variable <literal moreinfo=\"none\">VISUAL</literal>"
msgstr ""

#: en.xml:12189(para) 
msgid "Environment variable <literal moreinfo=\"none\">EDITOR</literal>"
msgstr ""

#: en.xml:12192(para) 
msgid "Possibly, a default value built in to Subversion (not present in the official builds)"
msgstr ""

#: en.xml:12196(para) 
msgid "The value of any of these options or variables is (unlike <literal moreinfo=\"none\">diff-cmd</literal>) the beginning of a command line to be executed by the shell. Subversion appends a space and the pathname of the temporary file to be edited. The editor should modify the temporary file and return a zero exit code to indicate success."
msgstr ""

#: en.xml:12205(literal) 
msgid "diff-cmd"
msgstr ""

#: en.xml:12207(para) 
msgid "This specifies the absolute path of a differencing program, used when Subversion generates <quote>diff</quote> output (such as when using the <command moreinfo=\"none\">svn diff</command> command). By default Subversion uses an internal differencing library—setting this option will cause it to perform this task using an external program. See <xref linkend=\"svn.advanced.externaldifftools\"/> for more details on using such programs."
msgstr ""

#: en.xml:12219(literal) 
msgid "diff3-cmd"
msgstr ""

#: en.xml:12221(para) 
msgid "This specifies the absolute path of a three-way differencing program. Subversion uses this program to merge changes made by the user with those received from the repository. By default Subversion uses an internal differencing library—setting this option will cause it to perform this task using an external program. See <xref linkend=\"svn.advanced.externaldifftools\"/> for more details on using such programs."
msgstr ""

#: en.xml:12232(literal) 
msgid "diff3-has-program-arg"
msgstr ""

#: en.xml:12234(para) 
msgid "This flag should be set to <literal moreinfo=\"none\">true</literal> if the program specified by the <literal moreinfo=\"none\">diff3-cmd</literal> option accepts a <option>--diff-program</option> command-line parameter."
msgstr ""

#: en.xml:12243(para) 
msgid "The <literal moreinfo=\"none\">tunnels</literal> section allows you to define new tunnel schemes for use with <command moreinfo=\"none\">svnserve</command> and <literal moreinfo=\"none\">svn://</literal> client connections. For more details, see <xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>."
msgstr ""

#: en.xml:12251(para) 
msgid "Anyone for potluck dinner?"
msgstr ""

#: en.xml:12248(para) 
msgid "The <literal moreinfo=\"none\">miscellany</literal> section is where everything that doesn't belong elsewhere winds up. <footnote><placeholder-1/></footnote> In this section, you can find:"
msgstr ""

#: en.xml:12257(literal) 
msgid "global-ignores"
msgstr ""

#: en.xml:12259(para) 
msgid "When running the <command moreinfo=\"none\">svn status</command> command, Subversion lists unversioned files and directories along with the versioned ones, annotating them with a <literal moreinfo=\"none\">?</literal> character (see <xref linkend=\"svn.tour.cycle.examine.status\"/>). Sometimes, it can be annoying to see uninteresting, unversioned items—for example, object files that result from a program's compilation—in this display. The <literal moreinfo=\"none\">global-ignores</literal> option is a list of whitespace-delimited globs which describe the names of files and directories that Subversion should not display unless they are versioned. The default value is <literal moreinfo=\"none\">*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store</literal>."
msgstr ""

#: en.xml:12273(para) 
msgid "As well as <command moreinfo=\"none\">svn status</command>, the <command moreinfo=\"none\">svn add</command> and <command moreinfo=\"none\">svn import</command> commands also ignore files that match the list when they are scanning a directory. You can override this behaviour for a single instance of any of these commands by explicitly specifying the file name, or by using the <option>--no-ignore</option> command-line flag."
msgstr ""

#: en.xml:12281(para) 
msgid "For information on more fine-grained control of ignored items, see <xref linkend=\"svn.advanced.props.special.ignore\"/>."
msgstr ""

#: en.xml:12287(literal) 
msgid "enable-auto-props"
msgstr ""

#: en.xml:12289(para) 
msgid "This instructs Subversion to automatically set properties on newly added or imported files. The default value is <literal moreinfo=\"none\">no</literal>, so set this to <literal moreinfo=\"none\">yes</literal> to enable Auto-props. The <literal moreinfo=\"none\">auto-props</literal> section of this file specifies which properties are to be set on which files."
msgstr ""

#: en.xml:12299(literal) 
msgid "log-encoding"
msgstr ""

#: en.xml:12301(para) 
msgid "This variable sets the default character set encoding for commit log messages. It's a permanent form of the <option>--encoding</option> option (see <xref linkend=\"svn.ref.svn.sw\"/>). The Subversion repository stores log messages in UTF-8, and assumes that your log message is written using your operating system's native locale. You should specify a different encoding if your commit messages are written in any other encoding."
msgstr ""

#: en.xml:12314(literal) 
msgid "use-commit-times"
msgstr ""

#: en.xml:12316(para) 
msgid "Normally your working copy files have timestamps that reflect the last time they were touched by any process, whether that be your own editor or by some <command moreinfo=\"none\">svn</command> subcommand. This is generally convenient for people developing software, because build systems often look at timestamps as a way of deciding which files need to be recompiled."
msgstr ""

#: en.xml:12324(para) 
msgid "In other situations, however, it's sometimes nice for the working copy files to have timestamps that reflect the last time they were changed in the repository. The <command moreinfo=\"none\">svn export</command> command always places these <quote>last-commit timestamps</quote> on trees that it produces. By setting this config variable to <literal moreinfo=\"none\">yes</literal>, the <command moreinfo=\"none\">svn checkout</command>, <command moreinfo=\"none\">svn update</command>, <command moreinfo=\"none\">svn switch</command>, and <command moreinfo=\"none\">svn revert</command> commands will also set last-commit timestamps on files that they touch."
msgstr ""

#: en.xml:12343(para) 
msgid "The <literal moreinfo=\"none\">auto-props</literal> section controls the Subversion client's ability to automatically set properties on files when they are added or imported. It contains any number of key-value pairs in the format <literal moreinfo=\"none\">PATTERN = PROPNAME=PROPVALUE</literal> where <literal moreinfo=\"none\">PATTERN</literal> is a file pattern that matches a set of filenames and the rest of the line is the property and its value. Multiple matches on a file will result in multiple propsets for that file; however, there is no guarantee that auto-props will be applied in the order in which they are listed in the config file, so you can't have one rule <quote>override</quote> another. You can find several examples of auto-props usage in the <filename moreinfo=\"none\">config</filename> file. Lastly, don't forget to set <literal moreinfo=\"none\">enable-auto-props</literal> to <literal moreinfo=\"none\">yes</literal> in the <literal moreinfo=\"none\">miscellany</literal> section if you want to enable auto-props."
msgstr ""

#: en.xml:12371(title) en.xml:24357(term) 
msgid "Properties"
msgstr ""

#: en.xml:12373(para) 
msgid "We've already covered in detail how Subversion stores and retrieves various versions of files and directories in its repository. Whole chapters have been devoted to this most fundamental piece of functionality provided by the tool. And if the versioning support stopped there, Subversion would still be complete from a version control perspective. But it doesn't stop there."
msgstr ""

#: en.xml:12381(para) 
msgid "In addition to versioning your directories and files, Subversion provides interfaces for adding, modifying, and removing versioned metadata on each of your versioned directories and files. We refer to this metadata as <firstterm>properties</firstterm>, and they can be thought of as two-column tables that map property names to arbitrary values attached to each item in your working copy. Generally speaking, the names and values of the properties can be whatever you want them to be, with the constraint that the names must be human-readable text. And the best part about these properties is that they, too, are versioned, just like the textual contents of your files. You can modify, commit, and revert property changes as easily as committing textual changes. And you receive other people's property changes as you update your working copy."
msgstr ""

#: en.xml:12398(title) 
msgid "Other Properties in Subversion"
msgstr ""

#: en.xml:12400(para) 
msgid "Properties show up elsewhere in Subversion, too. Just as files and directories may have arbitrary property names and values attached to them, each revision as a whole may have arbitrary properties attached to it. The same constraints apply—human-readable, text names and anything-you-want, binary values—except that revision properties are not versioned. See <xref linkend=\"svn.reposadmin.basics.revprops\"/> for more information on these unversioned properties."
msgstr ""

#: en.xml:12410(para) 
msgid "In this section, we will examine the utility—both to users of Subversion, and to Subversion itself—of property support. You'll learn about the property-related <command moreinfo=\"none\">svn</command> subcommands, and how property modifications affect your normal Subversion workflow. Hopefully, you'll be convinced that Subversion properties can enhance your version control experience."
msgstr ""

#: en.xml:12420(title) 
msgid "Why Properties?"
msgstr ""

#: en.xml:12422(para) 
msgid "Properties can be very useful additions to your working copy. In fact, Subversion itself uses properties to house special information, and as a way to denote that certain special processing might be needed. Likewise, you can use properties for your own purposes. Of course, anything you can do with properties you could also do using regular versioned files, but consider the following example of Subversion property use."
msgstr ""

#: en.xml:12431(para) 
msgid "Say you wish to design a website that houses many digital photos, and displays them with captions and a datestamp. Now, your set of photos is constantly changing, so you'd like to have as much of this site automated as possible. These photos can be quite large, so as is common with sites of this nature, you want to provide smaller thumbnail images to your site visitors. You can do this with traditional files. That is, you can have your <filename moreinfo=\"none\">image123.jpg</filename> and an <filename moreinfo=\"none\">image123-thumbnail.jpg</filename> side-by-side in a directory. Or if you want to keep the filenames the same, you might have your thumbnails in a different directory, like <filename moreinfo=\"none\">thumbnails/image123.jpg</filename>. You can also store your captions and datestamps in a similar fashion, again separated from the original image file. Soon, your tree of files is a mess, and grows in multiples with each new photo added to the site."
msgstr ""

#: en.xml:12448(para) 
msgid "Now consider the same setup using Subversion's file properties. Imagine having a single image file, <filename moreinfo=\"none\">image123.jpg</filename>, and then properties set on that file named <literal moreinfo=\"none\">caption</literal>, <literal moreinfo=\"none\">datestamp</literal>, and even <literal moreinfo=\"none\">thumbnail</literal>. Now your working copy directory looks much more manageable—in fact, it looks like there are nothing but image files in it. But your automation scripts know better. They know that they can use <command moreinfo=\"none\">svn</command> (or better yet, they can use the Subversion language bindings—see <xref linkend=\"svn.developer.usingapi.otherlangs\"/>) to dig out the extra information that your site needs to display without having to read an index file or play path manipulation games."
msgstr ""

#: en.xml:12462(para) 
msgid "How (and if) you use Subversion properties is up to you. As we mentioned, Subversion has it own uses for properties, which we'll discuss a little later in this chapter. But first, let's discuss how to manipulate properties using the <command moreinfo=\"none\">svn</command> program."
msgstr ""

#: en.xml:12472(title) 
msgid "Manipulating Properties"
msgstr ""

#: en.xml:12474(para) 
msgid "The <command moreinfo=\"none\">svn</command> command affords a few ways to add or modify file and directory properties. For properties with short, human-readable values, perhaps the simplest way to add a new property is to specify the property name and value on the command-line of the <command moreinfo=\"none\">propset</command> subcommand."
msgstr ""

#: en.xml:12481(screen) 
#, no-wrap
msgid "\n$ svn propset copyright '(c) 2003 Red-Bean Software' calc/button.c\nproperty 'copyright' set on 'calc/button.c'\n$\n"
msgstr ""

#: en.xml:12487(para) 
msgid "But we've been touting the flexibility that Subversion offers for your property values. And if you are planning to have a multi-line textual, or even binary, property value, you probably do not want to supply that value on the command-line. So the <command moreinfo=\"none\">propset</command> subcommand takes a <option>--file</option> (<option>-F</option>) option for specifying the name of a file which contains the new property value."
msgstr ""

#: en.xml:12496(screen) 
#, no-wrap
msgid "\n$ svn propset license -F /path/to/LICENSE calc/button.c\nproperty 'license' set on 'calc/button.c'\n$\n"
msgstr ""

#: en.xml:12509(para) 
msgid "If you're familiar with XML, this is pretty much the ASCII subset of the syntax for XML \"Name\"."
msgstr ""

#: en.xml:12502(para) 
msgid "There are some restrictions on the names you can use for properties. A property name must start with a letter, a colon (<literal moreinfo=\"none\">:</literal>), or an underscore (<literal moreinfo=\"none\">_</literal>); after that, you can also use digits, hyphens (<literal moreinfo=\"none\">-</literal>), and periods (<literal moreinfo=\"none\">.</literal>). <footnote><placeholder-1/></footnote>"
msgstr ""

#: en.xml:12514(para) 
msgid "In addition to the <command moreinfo=\"none\">propset</command> command, the <command moreinfo=\"none\">svn</command> program supplies the <command moreinfo=\"none\">propedit</command> command. This command uses the configured editor program (see <xref linkend=\"svn.advanced.confarea.opts.config\"/>) to add or modify properties. When you run the command, <command moreinfo=\"none\">svn</command> invokes your editor program on a temporary file that contains the current value of the property (or which is empty, if you are adding a new property). Then, you just modify that value in your editor program until it represents the new value you wish to store for the property, save the temporary file, and then exit the editor program. If Subversion detects that you've actually changed the existing value of the property, it will accept that as the new property value. If you exit your editor without making any changes, no property modification will occur."
msgstr ""

#: en.xml:12530(screen) 
#, no-wrap
msgid "\n$ svn propedit copyright calc/button.c  ### exit the editor without changes\nNo changes to property 'copyright' on 'calc/button.c'\n$\n"
msgstr ""

#: en.xml:12536(para) 
msgid "We should note that, as with other <command moreinfo=\"none\">svn</command> subcommands, those related to properties can act on multiple paths at once. This enables you to modify properties on whole sets of files with a single command. For example, we could have done:"
msgstr ""

#: en.xml:12542(screen) 
#, no-wrap
msgid "\n$ svn propset copyright '(c) 2002 Red-Bean Software' calc/*\nproperty 'copyright' set on 'calc/Makefile'\nproperty 'copyright' set on 'calc/button.c'\nproperty 'copyright' set on 'calc/integer.c'\n…\n$\n"
msgstr ""

#: en.xml:12551(para) 
msgid "All of this property adding and editing isn't really very useful if you can't easily get the stored property value. So the <command moreinfo=\"none\">svn</command> program supplies two subcommands for displaying the names and values of properties stored on files and directories. The <command moreinfo=\"none\">svn proplist</command> command will list the names of properties that exist on a path. Once you know the names of the properties on the node, you can request their values individually using <command moreinfo=\"none\">svn propget</command>. This command will, given a path (or set of paths) and a property name, print the value of the property to the standard output stream."
msgstr ""

#: en.xml:12563(screen) 
#, no-wrap
msgid "\n$ svn proplist calc/button.c\nProperties on 'calc/button.c':\n  copyright\n  license\n$ svn propget copyright calc/button.c\n(c) 2003 Red-Bean Software\n"
msgstr ""

#: en.xml:12572(para) 
msgid "There's even a variation of the <command moreinfo=\"none\">proplist</command> command that will list both the name and value of all of the properties. Simply supply the <option>--verbose</option> (<option>-v</option>) option."
msgstr ""

#: en.xml:12577(screen) 
#, no-wrap
msgid "\n$ svn proplist --verbose calc/button.c\nProperties on 'calc/button.c':\n  copyright : (c) 2003 Red-Bean Software\n  license : ================================================================\nCopyright (c) 2003 Red-Bean Software.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions \nare met:\n\n1. Redistributions of source code must retain the above copyright\nnotice, this list of conditions, and the recipe for Fitz's famous\nred-beans-and-rice.\n…\n"
msgstr ""

#: en.xml:12594(para) 
msgid "The last property-related subcommand is <command moreinfo=\"none\">propdel</command>. Since Subversion allows you to store properties with empty values, you can't remove a property altogether using <command moreinfo=\"none\">propedit</command> or <command moreinfo=\"none\">propset</command>. For example, this command will <emphasis>not</emphasis> yield the desired effect:"
msgstr ""

#: en.xml:12601(screen) 
#, no-wrap
msgid "\n$ svn propset license '' calc/button.c\nproperty 'license' set on 'calc/button.c'\n$ svn proplist --verbose calc/button.c\nProperties on 'calc/button.c':\n  copyright : (c) 2003 Red-Bean Software\n  license : \n$\n"
msgstr ""

#: en.xml:12611(para) 
msgid "You need to use the <command moreinfo=\"none\">propdel</command> command to delete properties altogether. The syntax is similar to the other property commands:"
msgstr ""

#: en.xml:12615(screen) 
#, no-wrap
msgid "\n$ svn propdel license calc/button.c\nproperty 'license' deleted from 'calc/button.c'.\n$ svn proplist --verbose calc/button.c\nProperties on 'calc/button.c':\n  copyright : (c) 2003 Red-Bean Software\n$\n"
msgstr ""

#: en.xml:12624(para) 
msgid "Now that you are familiar with all of the property-related <command moreinfo=\"none\">svn</command> subcommands, let's see how property modifications affect the usual Subversion workflow. As we mentioned earlier, file and directory properties are versioned, just like your file contents. As a result, Subversion provides the same opportunities for merging—in cleanly or conflicting fashions—someone else's modifications into your own."
msgstr ""

#: en.xml:12634(title) 
msgid "Modifying Revision Properties"
msgstr ""

#: en.xml:12646(para) 
msgid "Fixing spelling errors, grammatical gotchas, and <quote>just-plain-wrongness</quote> in commit log messages is perhaps the most common use case for the <option>--revprop</option> option."
msgstr ""

#: en.xml:12636(para) 
msgid "Remember those unversioned revision properties? You can modify those, too, with the <command moreinfo=\"none\">svn</command> program. Simply add the <option>--revprop</option> command-line parameter, and specify the revision whose property you wish to modify. Since revisions are global, you don't need to specify a path in this case as long as you are positioned in the working copy of the repository whose revision property you wish to modify. For example, you might want to replace the commit log message of an existing revision. <footnote><placeholder-1/></footnote>"
msgstr ""

#: en.xml:12652(screen) 
#, no-wrap
msgid "\n$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop\nproperty 'svn:log' set on repository revision '11'\n$\n"
msgstr ""

#: en.xml:12658(para) 
msgid "Note that the ability to modify these unversioned properties must be explicitly added by the repository administrator (see <xref linkend=\"svn.reposadmin.create.hooks\"/>). Since the properties aren't versioned, you run the risk of losing information if you aren't careful with your edits. The repository administrator can setup methods to protect against this loss, and by default, modification of unversioned properties is disabled."
msgstr ""

#: en.xml:12669(para) 
msgid "And as with file contents, your property changes are local modifications, only made permanent when you commit them to the repository with <command moreinfo=\"none\">svn commit</command>. Your property changes can be easily unmade, too—the <command moreinfo=\"none\">svn revert</command> command will restore your files and directories to their un-edited states, contents, properties, and all. Also, you can receive interesting information about the state of your file and directory properties by using the <command moreinfo=\"none\">svn status</command> and <command moreinfo=\"none\">svn diff</command> commands."
msgstr ""

#: en.xml:12680(screen) 
#, no-wrap
msgid "\n$ svn status calc/button.c\n M     calc/button.c\n$ svn diff calc/button.c\nProperty changes on: calc/button.c\n___________________________________________________________________\nName: copyright\n   + (c) 2003 Red-Bean Software\n\n$\n"
msgstr ""

#: en.xml:12692(para) 
msgid "Notice how the <command moreinfo=\"none\">status</command> subcommand displays <literal moreinfo=\"none\">M</literal> in the second column instead of the first. That is because we have modified the properties on <filename moreinfo=\"none\">calc/button.c</filename>, but not modified its textual contents. Had we changed both, we would have seen <literal moreinfo=\"none\">M</literal> in the first column, too (see <xref linkend=\"svn.tour.cycle.examine.status\"/>)."
msgstr ""

#: en.xml:12700(title) 
msgid "Property Conflicts"
msgstr ""

#: en.xml:12702(para) 
msgid "As with file contents, local property modifications can conflict with changes committed by someone else. If you update your working copy directory and receive property changes on a versioned resource that clash with your own, Subversion will report that the resource is in a conflicted state."
msgstr ""

#: en.xml:12709(screen) 
#, no-wrap
msgid "\n% svn update calc\nM  calc/Makefile.in\n C calc/button.c\nUpdated to revision 143.\n$ \n"
msgstr ""

#: en.xml:12717(para) 
msgid "Subversion will also create, in the same directory as the conflicted resource, a file with a <filename moreinfo=\"none\">.prej</filename> extension which contains the details of the conflict. You should examine the contents of this file so you can decide how to resolve the conflict. Until the conflict is resolved, you will see a <literal moreinfo=\"none\">C</literal> in the second column of <command moreinfo=\"none\">svn status</command> output for that resource, and attempts to commit your local modifications will fail."
msgstr ""

#: en.xml:12727(screen) 
#, no-wrap
msgid "\n$ svn status calc\n C     calc/button.c\n?      calc/button.c.prej\n$ cat calc/button.c.prej \nprop 'linecount': user set to '1256', but update set to '1301'.\n$\n"
msgstr ""

#: en.xml:12736(para) 
msgid "To resolve property conflicts, simply ensure that the conflicting properties contain the values that they should, and then use the <command moreinfo=\"none\">svn resolved</command> command to alert Subversion that you have manually resolved the problem."
msgstr ""

#: en.xml:12744(para) 
msgid "You might also have noticed the non-standard way that Subversion currently displays property differences. You can still run <command moreinfo=\"none\">svn diff</command> and redirect the output to create a usable patch file. The <command moreinfo=\"none\">patch</command> program will ignore property patches—as a rule, it ignores any noise it can't understand. This does unfortunately mean that to fully apply a patch generated by <command moreinfo=\"none\">svn diff</command>, any property modifications will need to be applied by hand."
msgstr ""

#: en.xml:12754(para) 
msgid "As you can see, the presence of property modifications has no outstanding effect on the typical Subversion workflow. Your general patterns of updating your working copy, checking the status of your files and directories, reporting on the modifications you have made, and committing those modifications to the repository are completely immune to the presence or absence of properties. The <command moreinfo=\"none\">svn</command> program has some additional subcommands for actually making property changes, but that is the only noticeable asymmetry."
msgstr ""

#: en.xml:12769(title) 
msgid "Special Properties"
msgstr ""

#: en.xml:12771(para) 
msgid "Subversion has no particular policy regarding properties—you can use them for any purpose. Subversion asks only that you not use property names that begin with the prefix <literal moreinfo=\"none\">svn:</literal>. That's the namespace that it sets aside for its own use. In fact, Subversion defines certain properties that have magical effects on the files and directories to which they are attached. In this section, we'll untangle the mystery, and describe how these special properties make your life just a little easier."
msgstr ""

#: en.xml:12782(literal) en.xml:23561(literal) 
msgid "svn:executable"
msgstr ""

#: en.xml:12784(para) 
msgid "The <literal moreinfo=\"none\">svn:executable</literal> property is used to control a versioned file's filesystem-level execute permission bit in a semi-automated way. This property has no defined values—its mere presence indicates a desire that the execute permission bit be kept enabled by Subversion. Removing this property will restore full control of the execute bit back to the operating system."
msgstr ""

#: en.xml:12792(para) 
msgid "On many operating systems, the ability to execute a file as a command is governed by the presence of an execute permission bit. This bit usually defaults to being disabled, and must be explicitly enabled by the user for each file that needs it. In a working copy, new files are being created all the time as new versions of existing files are received during an update. This means that you might enable the execute bit on a file, then update your working copy, and if that file was changed as part of the update, its execute bit might get disabled. So, Subversion provides the <literal moreinfo=\"none\">svn:executable</literal> property as a way to keep the execute bit enabled."
msgstr ""

#: en.xml:12809(para) 
msgid "The Windows filesystems use file extensions (such as <literal moreinfo=\"none\">.EXE</literal>, <literal moreinfo=\"none\">.BAT</literal>, and <literal moreinfo=\"none\">.COM</literal>) to denote executable files."
msgstr ""

#: en.xml:12805(para) 
msgid "This property has no effect on filesystems that have no concept of an executable permission bit, such as FAT32 and NTFS. <footnote><placeholder-1/></footnote> Also, although it has no defined values, Subversion will force its value to <literal moreinfo=\"none\">*</literal> when setting this property. Finally, this property is valid only on files, not on directories."
msgstr ""

#: en.xml:12822(literal) en.xml:23572(literal) 
msgid "svn:mime-type"
msgstr ""

#: en.xml:12824(para) 
msgid "The <literal moreinfo=\"none\">svn:mime-type</literal> property serves many purposes in Subversion. Besides being a general-purpose storage location for a file's Multipurpose Internet Mail Extensions (MIME) classification, the value of this property determines some behavioral characteristics of Subversion itself."
msgstr ""

#: en.xml:12831(para) 
msgid "For example, if a file's <literal moreinfo=\"none\">svn:mime-type</literal> property is set to a non-text MIME type (generally, something that doesn't begin with <literal moreinfo=\"none\">text/</literal>, though there are exceptions), Subversion will assume that the file contains binary—that is, not human-readable—data. One of the benefits that Subversion typically provides is contextual, line-based merging of changes received from the server during an update into your working file. But for files believed to contain binary data, there is no concept of a <quote>line</quote>. So, for those files, Subversion does not attempt to perform contextual merges during updates. Instead, any time you have locally modified a binary working copy file that is also being updated, your file is renamed with a <filename moreinfo=\"none\">.orig</filename> extension, and then Subversion stores a new working copy file that contains the changes received during the update, but not your own local modifications, at the original filename. This behavior is really for the protection of the user against failed attempts at performing contextual merges on files that simply cannot be contextually merged."
msgstr ""

#: en.xml:12853(para) 
msgid "Also, if the <literal moreinfo=\"none\">svn:mime-type</literal> property is set, then the Subversion Apache module will use its value to populate the <literal moreinfo=\"none\">Content-type:</literal> HTTP header when responding to GET requests. This gives a crucial clue about how to display a file when perusing your repository with a web browser."
msgstr ""

#: en.xml:12863(literal) en.xml:23586(literal) 
msgid "svn:ignore"
msgstr ""

#: en.xml:12865(para) 
msgid "The <literal moreinfo=\"none\">svn:ignore</literal> property contains a list of file patterns which certain Subversion operations will ignore. Perhaps the most commonly used special property, it works in conjunction with the <literal moreinfo=\"none\">global-ignores</literal> run-time configuration option (see <xref linkend=\"svn.advanced.confarea.opts.config\"/>) to filter unversioned files and directories out of commands <command moreinfo=\"none\">svn status</command>, <command moreinfo=\"none\">svn add</command>, and <command moreinfo=\"none\">svn import</command>."
msgstr ""

#: en.xml:12875(para) 
msgid "The rationale behind the <literal moreinfo=\"none\">svn:ignore</literal> property is easily explained. Subversion does not assume that every file or subdirectory in a working copy directory is intended for version control. Resources must be explicitly placed under Subversion's management using the <command moreinfo=\"none\">svn add</command> or <command moreinfo=\"none\">svn import</command> commands. As a result, there are often many resources in a working copy that are not versioned."
msgstr ""

#: en.xml:12884(para) 
msgid "Now, the <command moreinfo=\"none\">svn status</command> command displays as part of its output every unversioned file or subdirectory in a working copy that is not already filtered out by the <literal moreinfo=\"none\">global-ignores</literal> option (or its built-in default value). This is done so that users can see if perhaps they've forgotten to add a resource to version control."
msgstr ""

#: en.xml:12892(para) 
msgid "But Subversion cannot possibly guess the names of every resource that should be ignored. Also, quite often there are things that should be ignored in <emphasis>every</emphasis> working copy of a particular repository. To force every user of that repository to add patterns for those resources to their run-time configuration areas would be not just a burden, but has the potential to clash with the configuration needs of other working copies that the user has checked out."
msgstr ""

#: en.xml:12902(para) 
msgid "The solution is to store ignore patterns that are unique to the resources likely to appear in a given directory with the directory itself. Common examples of unversioned resources that are basically unique to a directory, yet likely to appear there, include output from program compilations. Or—to use an example more appropriate to this book—the HTML, PDF, or PostScript files generated as the result of a conversion of some source DocBook XML files to a more legible output format."
msgstr ""

#: en.xml:12913(title) 
msgid "Ignore Patterns for CVS Users"
msgstr ""

#: en.xml:12915(para) 
msgid "The Subversion <literal moreinfo=\"none\">svn:ignore</literal> property is very similar in syntax and function to the CVS <filename moreinfo=\"none\">.cvsignore</filename> file. In fact, if you are migrating a CVS working copy to Subversion, you can directly migrate the ignore patterns by using the <filename moreinfo=\"none\">.cvsignore</filename> file as input file to the <command moreinfo=\"none\">svn propset</command> command:"
msgstr ""

#: en.xml:12923(screen) 
#, no-wrap
msgid "\n$ svn propset svn:ignore -F .cvsignore .\nproperty 'svn:ignore' set on '.'\n$\n"
msgstr ""

#: en.xml:12929(para) 
msgid "There are, however, some differences in the ways that CVS and Subversion handle ignore patterns. The two systems use the ignore patterns at some different times, and there are slight discrepancies in what the ignore patterns apply to. Also, Subversion does not recognize the use of the <literal moreinfo=\"none\">!</literal> pattern as a reset back to having no ignore patterns at all."
msgstr ""

#: en.xml:12945(para) 
msgid "The patterns are strictly for that directory—they do not carry recursively into subdirectories."
msgstr ""

#: en.xml:12939(para) 
msgid "For this purpose, the <literal moreinfo=\"none\">svn:ignore</literal> property is the solution. Its value is a multi-line collection of file patterns, one pattern per line. The property is set on the directory in which you wish the patterns to be applied. <footnote><placeholder-1/></footnote> For example, say you have the following output from <command moreinfo=\"none\">svn status</command>:"
msgstr ""

#: en.xml:12952(screen) 
#, no-wrap
msgid "\n$ svn status calc\n M     calc/button.c\n?      calc/calculator\n?      calc/data.c\n?      calc/debug_log\n?      calc/debug_log.1\n?      calc/debug_log.2.gz\n?      calc/debug_log.3.gz\n"
msgstr ""

#: en.xml:12973(para) 
msgid "Isn't that the whole point of a build system?"
msgstr ""

#: en.xml:12963(para) 
msgid "In this example, you have made some property modifications to <filename moreinfo=\"none\">button.c</filename>, but in your working copy you also have some unversioned files: the latest <filename moreinfo=\"none\">calculator</filename> program that you've compiled from your source code, a source file named <filename moreinfo=\"none\">data.c</filename>, and a set of debugging output log files. Now, you know that your build system always results in the <filename moreinfo=\"none\">calculator</filename> program being generated. <footnote><placeholder-1/></footnote> And you know that your test suite always leaves those debugging log files lying around. These facts are true for all working copies, not just your own. And you know that you aren't interested in seeing those things every time you run <command moreinfo=\"none\">svn status</command>. So you use <command moreinfo=\"none\">svn propedit svn:ignore calc</command> to add some ignore patterns to the <filename moreinfo=\"none\">calc</filename> directory. For example, you might add this as the new value of the <literal moreinfo=\"none\">svn:ignore</literal> property:"
msgstr ""

#: en.xml:12985(programlisting) 
#, no-wrap
msgid "\ncalculator\ndebug_log*\n"
msgstr ""

#: en.xml:12990(para) 
msgid "After you've added this property, you will now have a local property modification on the <filename moreinfo=\"none\">calc</filename> directory. But notice what else is different about your <command moreinfo=\"none\">svn status</command> output:"
msgstr ""

#: en.xml:12995(screen) 
#, no-wrap
msgid "\n$ svn status\n M     calc\n M     calc/button.c\n?      calc/data.c\n"
msgstr ""

#: en.xml:13002(para) 
msgid "Now, all the cruft is missing from the output! Of course, those files are still in your working copy. Subversion is simply not reminding you that they are present and unversioned. And now with all the trivial noise removed from the display, you are left with more interesting items—such as that source code file that you probably forgot to add to version control."
msgstr ""

#: en.xml:13010(para) 
msgid "If you want to see the ignored files, you can pass the <option>--no-ignore</option> option to Subversion:"
msgstr ""

#: en.xml:13013(screen) 
#, no-wrap
msgid "\n$ svn status --no-ignore\n M     calc/button.c\nI      calc/calculator\n?      calc/data.c\nI      calc/debug_log\nI      calc/debug_log.1\nI      calc/debug_log.2.gz\nI      calc/debug_log.3.gz\n"
msgstr ""

#: en.xml:13024(para) 
msgid "The list of patterns to ignore is also used by <command moreinfo=\"none\">svn add</command> and <command moreinfo=\"none\">svn import</command>. Both of these operations involve asking Subversion to begin managing some set of files and directories. Rather than force the user to pick and choose which files in a tree she wishes to start versioning, Subversion uses the ignore patterns to determine which files should not be swept into the version control system as part of a larger recursive addition or import operation."
msgstr ""

#: en.xml:13037(literal) en.xml:23599(literal) 
msgid "svn:keywords"
msgstr ""

#: en.xml:13039(para) 
msgid "Subversion has the ability to substitute <firstterm>keywords</firstterm>—pieces of useful, dynamic information about a versioned file—into the contents of the file itself. Keywords generally describe information about the last time the file was known to be modified. Because this information changes each time the file changes, and more importantly, just <emphasis>after</emphasis> the file changes, it is a hassle for any process except the version control system to keep the data completely up-to-date. Left to human authors, the information would inevitably grow stale."
msgstr ""

#: en.xml:13051(para) 
msgid "For example, say you have a document in which you would like to display the last date on which it was modified. You could burden every author of that document to, just before committing their changes, also tweak the part of the document that describes when it was last changed. But sooner or later, someone would forget to do that. Instead simply ask Subversion to perform keyword substitution on the <literal moreinfo=\"none\">LastChangedDate</literal> keyword. You control where the keyword is inserted into your document by placing a <firstterm>keyword anchor</firstterm> at the desired location in the file. This anchor is just a string of text formatted as <literal moreinfo=\"none\">$</literal><replaceable>KeywordName</replaceable><literal moreinfo=\"none\">$</literal>."
msgstr ""

#: en.xml:13065(para) 
msgid "All keywords are case-sensitive where they appear as anchors in files: you must use the correct capitalization in order for the keyword to be expanded. You should consider the value of the <literal moreinfo=\"none\">svn:keywords</literal> property to be case-sensitive too—certain keyword names will be recognized regardless of case, but this behavior is deprecated."
msgstr ""

#: en.xml:13072(para) 
msgid "Subversion defines the list of keywords available for substitution. That list contains the following five keywords, some of which have aliases that you can also use:"
msgstr ""

#: en.xml:13078(literal) 
msgid "Date"
msgstr ""

#: en.xml:13080(para) 
msgid "This keyword describes the last time the file was known to have been changed in the repository, and looks something like <literal moreinfo=\"none\">$Date: 2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002) $</literal>. It may also be specified as <literal moreinfo=\"none\">LastChangedDate</literal>."
msgstr ""

#: en.xml:13089(literal) en.xml:19161(para) 
msgid "Revision"
msgstr ""

#: en.xml:13091(para) 
msgid "This keyword describes the last known revision in which this file changed in the repository, and looks something like <literal moreinfo=\"none\">$Revision: 144 $</literal>. It may also be specified as <literal moreinfo=\"none\">LastChangedRevision</literal> or <literal moreinfo=\"none\">Rev</literal>."
msgstr ""

#: en.xml:13100(literal) 
msgid "Author"
msgstr ""

#: en.xml:13102(para) 
msgid "This keyword describes the last known user to change this file in the repository, and looks something like <literal moreinfo=\"none\">$Author: harry $</literal>. It may also be specified as <literal moreinfo=\"none\">LastChangedBy</literal>."
msgstr ""

#: en.xml:13110(literal) 
msgid "HeadURL"
msgstr ""

#: en.xml:13112(para) 
msgid "This keyword describes the full URL to the latest version of the file in the repository, and looks something like <literal moreinfo=\"none\">$HeadURL: http://svn.collab.net/repos/trunk/README $</literal>. It may be abbreviated as <literal moreinfo=\"none\">URL</literal>."
msgstr ""

#: en.xml:13121(literal) 
msgid "Id"
msgstr ""

#: en.xml:13123(para) 
msgid "This keyword is a compressed combination of the other keywords. Its substitution looks something like <literal moreinfo=\"none\">$Id: calc.c 148 2002-07-28 21:30:43Z sally $</literal>, and is interpreted to mean that the file <filename moreinfo=\"none\">calc.c</filename> was last changed in revision 148 on the evening of July 28, 2002 by the user <literal moreinfo=\"none\">sally</literal>."
msgstr ""

#: en.xml:13140(para) 
msgid "… or maybe even a section of a book …"
msgstr ""

#: en.xml:13134(para) 
msgid "Simply adding keyword anchor text to your file does nothing special. Subversion will never attempt to perform textual substitutions on your file contents unless explicitly asked to do so. After all, you might be writing a document <footnote><placeholder-1/></footnote> about how to use keywords, and you don't want Subversion to substitute your beautiful examples of un-substituted keyword anchors!"
msgstr ""

#: en.xml:13146(para) 
msgid "To tell Subversion whether or not to substitute keywords on a particular file, we again turn to the property-related subcommands. The <literal moreinfo=\"none\">svn:keywords</literal> property, when set on a versioned file, controls which keywords will be substituted on that file. The value is a space-delimited list of the keyword names or aliases found in the previous table."
msgstr ""

#: en.xml:13154(para) 
msgid "For example, say you have a versioned file named <filename moreinfo=\"none\">weather.txt</filename> that looks like this:"
msgstr ""

#: en.xml:13158(programlisting) 
#, no-wrap
msgid "\nHere is the latest report from the front lines.\n$LastChangedDate$\n$Rev$\nCumulus clouds are appearing more frequently as summer approaches.\n"
msgstr ""

#: en.xml:13165(para) 
msgid "With no <literal moreinfo=\"none\">svn:keywords</literal> property set on that file, Subversion will do nothing special. Now, let's enable substitution of the <literal moreinfo=\"none\">LastChangedDate</literal> keyword."
msgstr ""

#: en.xml:13170(screen) 
#, no-wrap
msgid "\n$ svn propset svn:keywords \"Date Author\" weather.txt\nproperty 'svn:keywords' set on 'weather.txt'\n$\n"
msgstr ""

#: en.xml:13176(para) 
msgid "Now you have made a local property modification on the <filename moreinfo=\"none\">weather.txt</filename> file. You will see no changes to the file's contents (unless you made some of your own prior to setting the property). Notice that the file contained a keyword anchor for the <literal moreinfo=\"none\">Rev</literal> keyword, yet we did not include that keyword in the property value we set. Subversion will happily ignore requests to substitute keywords that are not present in the file, and will not substitute keywords that are not present in the <literal moreinfo=\"none\">svn:keywords</literal> property value."
msgstr ""

#: en.xml:13188(title) 
msgid "Keywords and Spurious Differences"
msgstr ""

#: en.xml:13190(para) 
msgid "The user-visible result of keyword substitution might lead you to think that every version of a file with that feature in use differs from the previous version in at least the area where the keyword anchor was placed. However, this is actually not the case. While checking for local modifications during <command moreinfo=\"none\">svn diff</command>, and before transmitting those local modifications during <command moreinfo=\"none\">svn commit</command>, Subversion <quote>un-substitutes</quote> any keywords that it previously substituted. The result is that the versions of the file that are stored in the repository contain only the real modifications that users make to the file."
msgstr ""

#: en.xml:13206(para) 
msgid "Immediately after you commit this property change, Subversion will update your working file with the new substitute text. Instead of seeing your keyword anchor <literal moreinfo=\"none\">$LastChangedDate$</literal>, you'll see its substituted result. That result also contains the name of the keyword, and continues to be bounded by the dollar sign (<literal moreinfo=\"none\">$</literal>) characters. And as we predicted, the <literal moreinfo=\"none\">Rev</literal> keyword was not substituted because we didn't ask for it to be."
msgstr ""

#: en.xml:13216(para) 
msgid "Note also that we set the <literal moreinfo=\"none\">svn:keywords</literal> property to <quote>Date Author</quote> yet the keyword anchor used the alias <literal moreinfo=\"none\">$LastChangedDate$</literal> and still expanded correctly."
msgstr ""

#: en.xml:13221(screen) 
#, no-wrap
msgid "\nHere is the latest report from the front lines.\n$LastChangedDate: 2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002) $\n$Rev$\nCumulus clouds are appearing more frequently as summer approaches.\n"
msgstr ""

#: en.xml:13228(para) 
msgid "If someone else now commits a change to <filename moreinfo=\"none\">weather.txt</filename>, your copy of that file will continue to display the same substituted keyword value as before—until you update your working copy. At that time the keywords in your <filename moreinfo=\"none\">weather.txt</filename> file will be re-substituted with information that reflects the most recent known commit to that file."
msgstr ""

#: en.xml:13236(para) 
msgid "Subversion 1.2 introduced a new variant of the keyword syntax which brought additional, useful—though perhaps atypical—functionality. You can now tell Subversion to maintain a fixed length (in terms of the number of bytes consumed) for the substituted keyword. By using a double-colon (<literal moreinfo=\"none\">::</literal>) after the keyword name, followed by a number of space characters, you define that fixed width. When Subversion goes to substitute your keyword for the keyword and its value, it will essentially replace only those space characters, leaving the overall width of the keyword field unchanged. If the substituted value is shorter than the defined field width, there will be extra padding characters (spaces) at the end of the substituted field; if it is too long, it is truncated with a special hash (<literal moreinfo=\"none\">#</literal>) character just before the final dollar sign terminator."
msgstr ""

#: en.xml:13253(para) 
msgid "For example, say you have a document in which you have some section of tabular data reflecting the document's Subversion keywords. Using the original Subversion keyword substitution syntax, your file might look something like:"
msgstr ""

#: en.xml:13259(screen) 
#, no-wrap
msgid "\n$Rev$:     Revision of last commit\n$Author$:  Author of last commit\n$Date$:    Date of last commit\n"
msgstr ""

#: en.xml:13265(para) 
msgid "Now, that looks nice and tabular at the start of things. But when you then commit that file (with keyword substitution enabled, of course), you see:"
msgstr ""

#: en.xml:13269(screen) 
#, no-wrap
msgid "\n$Rev: 12 $:     Revision of last commit\n$Author: harry $:  Author of last commit\n$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Date of last commit\n"
msgstr ""

#: en.xml:13275(para) 
msgid "The result is not so beautiful. And you might be tempted to then adjust the file after the substitution so that it again looks tabular. But that only holds as long as the keyword values are the same width. If the last committed revision rolls into a new place value (say, from 99 to 100), or if another person with a longer username commits the file, stuff gets all crooked again. However, if you are using Subversion 1.2 or better, you can use the new fixed-length keyword syntax, define some field widths that seem sane, and now your file might look like this:"
msgstr ""

#: en.xml:13286(screen) 
#, no-wrap
msgid "\n$Rev::               $:  Revision of last commit\n$Author::            $:  Author of last commit\n$Date::              $:  Date of last commit\n"
msgstr ""

#: en.xml:13292(para) 
msgid "You commit this change to your file. This time, Subversion notices the new fixed-length keyword syntax, and maintains the width of the fields as defined by the padding you placed between the double-colon and the trailing dollar sign. After substitution, the width of the fields is completely unchanged—the short values for <literal moreinfo=\"none\">Rev</literal> and <literal moreinfo=\"none\">Author</literal> are padded with spaces, and the long <literal moreinfo=\"none\">Date</literal> field is truncated by a hash character:"
msgstr ""

#: en.xml:13302(screen) 
#, no-wrap
msgid "\n$Rev:: 13            $:  Revision of last commit\n$Author:: harry      $:  Author of last commit\n$Date:: 2006-03-15 0#$:  Date of last commit\n"
msgstr ""

#: en.xml:13308(para) 
msgid "The use of fixed-length keywords is especially handy when performing substitutions into complex file formats that themselves use fixed-length fields for data, or for which the stored size of a given data field is overbearingly difficult to modify from outside the format's native application (such as for Microsoft Office documents)."
msgstr ""

#: en.xml:13316(para) 
msgid "Be aware that because the width of a keyword field is measured in bytes, the potential for corruption of multi-byte values exists. For example, a username which contains some multi-byte UTF-8 characters might suffer truncation in the middle of the string of bytes which make up one of those characters. The result will be a mere truncation when viewed at the byte level, but will likely appear as a string with an incorrect or garbled final character when viewed as UTF-8 text. It is conceivable that certain applications, when asked to load the file, would notice the broken UTF-8 text and deem the entire file corrupt, refusing to operate on the file altogether."
msgstr ""

#: en.xml:13334(literal) en.xml:23611(literal) 
msgid "svn:eol-style"
msgstr ""

#: en.xml:13336(para) 
msgid "Unless otherwise noted using a versioned file's <literal moreinfo=\"none\">svn:mime-type</literal> property, Subversion assumes the file contains human-readable data. Generally speaking, Subversion only uses this knowledge to determine if contextual difference reports for that file are possible. Otherwise, to Subversion, bytes are bytes."
msgstr ""

#: en.xml:13343(para) 
msgid "This means that by default, Subversion doesn't pay any attention to the type of <firstterm>end-of-line (EOL) markers</firstterm> used in your files. Unfortunately, different operating systems use different tokens to represent the end of a line of text in a file. For example, the usual line ending token used by software on the Windows platform is a pair of ASCII control characters—carriage return (<literal moreinfo=\"none\">CR</literal>) and line feed (<literal moreinfo=\"none\">LF</literal>). Unix software, however, just uses the <literal moreinfo=\"none\">LF</literal> character to denote the end of a line."
msgstr ""

#: en.xml:13355(para) 
msgid "Not all of the various tools on these operating systems are prepared to understand files that contain line endings in a format that differs from the <firstterm>native line ending style</firstterm> of the operating system on which they are running. Common results are that Unix programs treat the <literal moreinfo=\"none\">CR</literal> character present in Windows files as a regular character (usually rendered as <literal moreinfo=\"none\">^M</literal>), and that Windows programs combine all of the lines of a Unix file into one giant line because no carriage return-linefeed (or <literal moreinfo=\"none\">CRLF</literal>) character combination was found to denote the end of line."
msgstr ""

#: en.xml:13368(para) 
msgid "This sensitivity to foreign EOL markers can become frustrating for folks who share a file across different operating systems. For example, consider a source code file, and developers that edit this file on both Windows and Unix systems. If all the developers always use tools which preserve the line ending style of the file, no problems occur."
msgstr ""

#: en.xml:13376(para) 
msgid "But in practice, many common tools either fail to properly read a file with foreign EOL markers, or they convert the file's line endings to the native style when the file is saved. If the former is true for a developer, he has to use an external conversion utility (such as <command moreinfo=\"none\">dos2unix</command> or its companion, <command moreinfo=\"none\">unix2dos</command>) to prepare the file for editing. The latter case requires no extra preparation. But both cases result in a file that differs from the original quite literally on every line! Prior to committing his changes, the user has two choices. Either he can use a conversion utility to restore the modified file to the same line ending style that it was in before his edits were made. Or, he can simply commit the file—new EOL markers and all."
msgstr ""

#: en.xml:13392(para) 
msgid "The result of scenarios like these include wasted time and unnecessary modifications to committed files. Wasted time is painful enough. But when commits change every line in a file, this complicates the job of determining which of those lines were changed in a non-trivial way. Where was that bug really fixed? On what line was a syntax error introduced?"
msgstr ""

#: en.xml:13400(para) 
msgid "The solution to this problem is the <literal moreinfo=\"none\">svn:eol-style</literal> property. When this property is set to a valid value, Subversion uses it to determine what special processing to perform on the file so that the file's line ending style isn't flip-flopping with every commit that comes from a different operating system. The valid values are:"
msgstr ""

#: en.xml:13410(literal) 
msgid "native"
msgstr ""

#: en.xml:13412(para) 
msgid "This causes the file to contain the EOL markers that are native to the operating system on which Subversion was run. In other words, if a user on a Windows machine checks out a working copy that contains a file with an <literal moreinfo=\"none\">svn:eol-style</literal> property set to <literal moreinfo=\"none\">native</literal>, that file will contain <literal moreinfo=\"none\">CRLF</literal> EOL markers. A Unix user checking out a working copy which contains the same file will see <literal moreinfo=\"none\">LF</literal> EOL markers in his copy of the file."
msgstr ""

#: en.xml:13424(para) 
msgid "Note that Subversion will actually store the file in the repository using normalized <literal moreinfo=\"none\">LF</literal> EOL markers regardless of the operating system. This is basically transparent to the user, though."
msgstr ""

#: en.xml:13432(literal) 
msgid "CRLF"
msgstr ""

#: en.xml:13434(para) 
msgid "This causes the file to contain <literal moreinfo=\"none\">CRLF</literal> sequences for EOL markers, regardless of the operating system in use."
msgstr ""

#: en.xml:13440(literal) 
msgid "LF"
msgstr ""

#: en.xml:13442(para) 
msgid "This causes the file to contain <literal moreinfo=\"none\">LF</literal> characters for EOL markers, regardless of the operating system in use."
msgstr ""

#: en.xml:13448(literal) 
msgid "CR"
msgstr ""

#: en.xml:13450(para) 
msgid "This causes the file to contain <literal moreinfo=\"none\">CR</literal> characters for EOL markers, regardless of the operating system in use. This line ending style is not very common. It was used on older Macintosh platforms (on which Subversion doesn't even run)."
msgstr ""

#: en.xml:13463(literal) en.xml:23623(literal) 
msgid "svn:externals"
msgstr ""

#: en.xml:13465(para) 
msgid "The <literal moreinfo=\"none\">svn:externals</literal> property contains instructions for Subversion to populate a versioned directory with one or more other checked-out Subversion working copies. For more information on this keyword and its use, see <xref linkend=\"svn.advanced.externals\"/>."
msgstr ""

#: en.xml:13474(literal) en.xml:23635(literal) 
msgid "svn:special"
msgstr ""

#: en.xml:13476(para) 
msgid "The <literal moreinfo=\"none\">svn:special</literal> property is the only <literal moreinfo=\"none\">svn:</literal> property that isn't meant to be directly set or modified by users. Subversion automatically sets this property whenever a <quote>special</quote> object is scheduled for addition, such as a symbolic link. The repository stores an <literal moreinfo=\"none\">svn:special</literal> object as an ordinary file. However, when a client sees this property during checkouts or updates, it interprets the contents of the file and translates the item back into the special type of object. In versions of Subversion current at the time of writing, only versioned symbolic links have this property attached, but in future versions of Subversion other special types of nodes will probably use this property as well."
msgstr ""

#: en.xml:13491(para) 
msgid "Note: Windows clients don't have symbolic links, and thus ignore any <literal moreinfo=\"none\">svn:special</literal> files coming from a repository that claim to be symbolic links. On Windows, the user ends up with an ordinary versioned file in the working copy."
msgstr ""

#: en.xml:13499(literal) en.xml:23647(literal) 
msgid "svn:needs-lock"
msgstr ""

#: en.xml:13501(para) 
msgid "This property is used to signify that the file it's attached to ought to be locked before editing. The value of the property is irrelevant; Subversion will normalize its value to <literal moreinfo=\"none\">*</literal>. When present, the file will be read-only <emphasis>unless</emphasis> the user has explicitly locked the file. When a lock-token is present (as a result of running <command moreinfo=\"none\">svn lock</command>), the file becomes read-write. When the lock is released, the file becomes read-only again."
msgstr ""

#: en.xml:13511(para) 
msgid "To learn more about how, when, and why this property should be used, see <xref linkend=\"svn.advanced.locking.lock-communication\"/>."
msgstr ""

#: en.xml:13520(title) 
msgid "Automatic Property Setting"
msgstr ""

#: en.xml:13522(para) 
msgid "Properties are a powerful feature of Subversion, acting as key components of many Subversion features discussed elsewhere in this and other chapters—textual diff and merge support, keyword substitution, newline translation, etc. But to get the full benefit of properties, they must be set on the right files and directories. Unfortunately, that can be a step easily forgotten in the routine of things, especially since failing to set a property doesn't usually result in an obvious error condition (at least compared to, say, failing to add a file to version control). To help your properties get applied to the places that need them, Subversion provides a couple of simple but useful features."
msgstr ""

#: en.xml:13535(para) 
msgid "Whenever you introduce a file to version control using the <command moreinfo=\"none\">svn add</command> or <command moreinfo=\"none\">svn import</command> commands, Subversion runs a very basic heuristic to determine if that file consists of human-readable or non-human-readable content. If the latter is the decision made, Subversion will automatically set the <literal moreinfo=\"none\">svn:mime-type</literal> property on that file to <literal moreinfo=\"none\">application/octet-stream</literal> (the generic <quote>this is a collection of bytes</quote> MIME type). Of course, if Subversion guesses incorrectly, or if you wish to set the <literal moreinfo=\"none\">svn:mime-type</literal> property to something more precise—perhaps <literal moreinfo=\"none\">image/png</literal> or <literal moreinfo=\"none\">application/x-shockwave-flash</literal>—you can always remove or edit that property."
msgstr ""

#: en.xml:13550(para) 
msgid "Subversion also provides the auto-props feature, which allows you to create mappings of filename patterns to property names and values. These mappings are made in your runtime configuration area. They again affect adds and imports, and not only can override any default MIME type decision made by Subversion during those operations, they can also set additional Subversion or custom properties, too. For example, you might create a mapping that says that any time you add JPEG files—ones that match the pattern <literal moreinfo=\"none\">*.jpg</literal>—Subversion should automatically set the <literal moreinfo=\"none\">svn:mime-type</literal> property on those files to <literal moreinfo=\"none\">image/jpeg</literal>. Or perhaps any files that match <literal moreinfo=\"none\">*.cpp</literal> should have <literal moreinfo=\"none\">svn:eol-style</literal> set to <literal moreinfo=\"none\">native</literal>, and <literal moreinfo=\"none\">svn:keywords</literal> set to <literal moreinfo=\"none\">Id</literal>. Auto-prop support is perhaps the handiest property related tool in the Subversion toolbox. See <xref linkend=\"svn.advanced.confarea.opts.config\"/> for more about configuring that support."
msgstr ""

#: en.xml:13577(title) en.xml:24377(term) 
msgid "Locking"
msgstr ""

#: en.xml:13579(para) 
msgid "Subversion's <quote>copy-modify-merge</quote> model is optimal when users are collaborating on projects that consist of line-based text files, such as program source code. However, as discussed in <xref linkend=\"svn.basic.vsn-models.copy-merge.sb-1\"/>, sometimes one has to use the <quote>lock-modify-unlock</quote> model instead of Subversion's standard concurrent model. When a file consists of binary data, it's often difficult or impossible to merge two sets of changes made in parallel by different users. For this reason, Subversion 1.2 and later offers a feature known as <firstterm>locking</firstterm>, often known as <quote>reserved checkouts</quote> in other version control systems."
msgstr ""

#: en.xml:13591(para) 
msgid "Subversion's locking feature has two main goals:"
msgstr ""

#: en.xml:13594(para) 
msgid "<emphasis>Serializing access to a resource</emphasis>. Allow a user to grab an exclusive right to change to a file in the repository. If Harry reserves the right to change <filename moreinfo=\"none\">foo.jpg</filename>, then Sally should not be able to commit a change to it."
msgstr ""

#: en.xml:13600(para) 
msgid "<emphasis>Aiding communication</emphasis>. Prevent users from wasting time on unmergeable changes. If Harry has reserved the right to change <filename moreinfo=\"none\">foo.jpg</filename>, then it should be easy for Sally to notice this fact and avoid working on the file."
msgstr ""

#: en.xml:13609(para) 
msgid "Subversion's locking feature is currently limited to files only—it's not yet possible to reserve access to a whole directory tree."
msgstr ""

#: en.xml:13614(title) 
msgid "Three meanings of <quote>lock</quote>"
msgstr ""

#: en.xml:13616(para) 
msgid "In this section, and almost everywhere in this book, the words <quote>lock</quote> and <quote>locking</quote> describe a mechanism for mutual exclusion between users to avoid clashing commits. Unfortunately, there are two other sorts of <quote>lock</quote> with which Subversion, and therefore this book, sometimes needs to be concerned."
msgstr ""

#: en.xml:13625(para) 
msgid "<firstterm>Working copy locks</firstterm>, used internally by Subversion to prevent clashes between multiple Subversion clients operating on the same working copy. This is the sort of lock indicated by an <computeroutput moreinfo=\"none\">L</computeroutput> in the third column of <command moreinfo=\"none\">svn status</command> output, and removed by the <command moreinfo=\"none\">svn cleanup</command> command, as described in <xref linkend=\"svn.tour.other.cleanup\"/>."
msgstr ""

#: en.xml:13635(para) 
msgid "<firstterm>Database locks</firstterm>, used internally by the Berkeley DB backend to prevent clashes between multiple programs trying to access the database. This is the sort of lock whose unwanted persistence after an error can cause a repository to be <quote>wedged</quote>, as described in <xref linkend=\"svn.reposadmin.maint.recovery\"/>."
msgstr ""

#: en.xml:13646(para) 
msgid "You can generally forget about these other sorts of lock, until something goes wrong that requires you to care about them. In this book, <quote>lock</quote> means the first sort unless the contrary is either clear from context or explicitly stated."
msgstr ""

#: en.xml:13655(title) 
msgid "Creating locks"
msgstr ""

#: en.xml:13657(para) 
msgid "In the Subversion repository, a <firstterm>lock</firstterm> is a piece of metadata which grants exclusive access to one user to change a file. This user is said to be the <firstterm>lock owner</firstterm>. Each lock also has a unique identifier, typically a long string of characters, known as the <firstterm>lock token</firstterm>. The repository manages locks in a separate table, and enforces locks during a commit operation. If any commit transaction attempts to modify or delete the file (or delete a parent of the file), the repository will demand two pieces of information:"
msgstr ""

#: en.xml:13670(para) 
msgid "<emphasis role=\"bold\">User authentication</emphasis>. The client performing the commit must be authenticated as the lock owner."
msgstr ""

#: en.xml:13674(para) 
msgid "<emphasis role=\"bold\">Software authorization</emphasis>. The user's working copy must send the lock token with the commit, proving that it knows exactly which lock it's using."
msgstr ""

#: en.xml:13681(para) 
msgid "An example is in order, to demonstrate. Let's say that Harry has decided to change a JPEG image. To prevent other people from committing changes to the file, he locks the file in the repository using the <command moreinfo=\"none\">svn lock</command> command:"
msgstr ""

#: en.xml:13687(screen) 
#, no-wrap
msgid "\n$ svn lock banana.jpg --message \"Editing file for tomorrow's release.\"\n'banana.jpg' locked by user 'harry'.\n\n$ svn status\n     K banana.jpg\n\n$ svn info banana.jpg\nPath: banana.jpg\nName: banana.jpg\nURL: http://svn.example.com/repos/project/banana.jpg\nRepository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec\nRevision: 2198\nNode Kind: file\nSchedule: normal\nLast Changed Author: frank\nLast Changed Rev: 1950\nLast Changed Date: 2005-03-15 12:43:04 -0600 (Tue, 15 Mar 2005)\nText Last Updated: 2005-06-08 19:23:07 -0500 (Wed, 08 Jun 2005)\nProperties Last Updated: 2005-06-08 19:23:07 -0500 (Wed, 08 Jun 2005)\nChecksum: 3b110d3b10638f5d1f4fe0f436a5a2a5\nLock Token: opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e\nLock Owner: harry\nLock Created: 2005-06-14 17:20:31 -0500 (Tue, 14 Jun 2005)\nLock Comment (1 line):\nEditing file for tomorrow's release.\n\n"
msgstr ""

#: en.xml:13716(para) 
msgid "There are a number of new things demonstrated in the previous example. First, notice that Harry passed the <option>--message</option> option to <command moreinfo=\"none\">svn lock</command>. Similar to <command moreinfo=\"none\">svn commit</command>, the <command moreinfo=\"none\">svn lock</command> command can take comments (either via <option>--message (-m)</option> or <option>--file (-F)</option>) to describe the reason for locking the file. Unlike <command moreinfo=\"none\">svn commit</command>, however, <command moreinfo=\"none\">svn lock</command> will not demand a message by launching your preferred text editor. Lock comments are optional, but still recommended to aid communication."
msgstr ""

#: en.xml:13729(para) 
msgid "Second, the lock attempt succeeded. This means that the file wasn't already locked, and that Harry had the latest version of the file. If Harry's working copy of the file had been out-of-date, the repository would have rejected the request, forcing harry to <command moreinfo=\"none\">svn update</command> and reattempt the locking command."
msgstr ""

#: en.xml:13736(para) 
msgid "Also notice that after creating the lock in the repository, the working copy has cached information about the lock—most importantly, the lock token. The presence of the lock token is critical. It gives the working copy authorization to make use of the lock later on. The <command moreinfo=\"none\">svn status</command> command shows a <literal moreinfo=\"none\">K</literal> next to the file (short for locKed), indicating that the lock token is present."
msgstr ""

#: en.xml:13746(title) 
msgid "Regarding lock tokens"
msgstr ""

#: en.xml:13748(para) 
msgid "A lock token isn't an authentication token, so much as an <emphasis>authorization</emphasis> token. The token isn't a protected secret. In fact, a lock's unique token is discoverable by anyone who runs <command moreinfo=\"none\">svn info URL</command>."
msgstr ""

#: en.xml:13754(para) 
msgid "A lock token is special only when it lives inside a working copy. It's proof that the lock was created in that particular working copy, and not somewhere else by some other client. Merely authenticating as the lock owner isn't enough to prevent accidents."
msgstr ""

#: en.xml:13760(para) 
msgid "For example: suppose you lock a file using a computer at your office, perhaps as part of a changeset in progress. It should not be possible for a working copy (or alternate Subversion client) on your home computer to accidentally commit a change to that same file, just because you've authenticated as the lock's owner. In other words, the lock token prevents one piece of Subversion-related software from undermining the work of another. (In our example, if you really need to change the file from an alternate working copy, you would need to break the lock and re-lock the file.)"
msgstr ""

#: en.xml:13773(para) 
msgid "Now that Harry has locked <filename moreinfo=\"none\">banana.jpg</filename>, Sally is unable to change or delete that file:"
msgstr ""

#: en.xml:13776(screen) 
#, no-wrap
msgid "\n$ whoami\nsally\n\n$ svn delete banana.jpg\nD         banana.jpg\n\n$ svn commit -m \"Delete useless file.\"\nDeleting       banana.jpg\nsvn: Commit failed (details follow):\nsvn: DELETE of\n'/repos/project/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc35d/banana.jpg':\n423 Locked (http://svn.example.com)\n\n"
msgstr ""

#: en.xml:13792(para) 
msgid "But Harry, after touching up the banana's shade of yellow, is able to commit his changes to the file. That's because he authenticates as the lock owner, and also because his working copy holds the correct lock token:"
msgstr ""

#: en.xml:13797(screen) 
#, no-wrap
msgid "\n$ whoami\nharry\n\n$ svn status\nM    K banana.jpg\n\n$ svn commit -m \"Make banana more yellow\"\nSending        banana.jpg\nTransmitting file data .\nCommitted revision 2201.\n\n$ svn status\n$\n"
msgstr ""

#: en.xml:13813(para) 
msgid "Notice that after the commit is finished, <command moreinfo=\"none\">svn status</command> shows that the lock token is no longer present in working copy. This is the standard behavior of <command moreinfo=\"none\">svn commit</command>: it walks the working copy (or list of targets, if you provide such a list), and sends all lock tokens it encounters to the server as part of the commit transaction. After the commit completes successfully, all of the repository locks that were mentioned are released—<emphasis>even on files that weren't committed.</emphasis> The rationale here is to discourage users from being sloppy about locking, or from holding locks for too long. For example, suppose Harry were to haphazardly lock thirty files in a directory named <filename moreinfo=\"none\">images</filename>, because he's unsure of which files he needs to change. He ends up making changes to only four files. When he runs <command moreinfo=\"none\">svn commit images</command>, the process would still release all thirty locks."
msgstr ""

#: en.xml:13832(para) 
msgid "This behavior of automatically releasing locks can be overridden with the <option>--no-unlock</option> option to <command moreinfo=\"none\">svn commit</command>. This is best used for those times when you want to commit changes, but still plan to make more changes and thus need to retain existing locks. This behavior is also semi-permanently tweakable, by setting <literal moreinfo=\"none\">no-unlock = yes</literal> in your run-time <filename moreinfo=\"none\">config</filename> file (see <xref linkend=\"svn.advanced.confarea\"/>)."
msgstr ""

#: en.xml:13841(para) 
msgid "Of course, locking a file doesn't oblige one to commit a change to it. The lock can be released at any time with a simple <command moreinfo=\"none\">svn unlock</command> command:"
msgstr ""

#: en.xml:13846(screen) 
#, no-wrap
msgid "\n$ svn unlock banana.c\n'banana.c' unlocked.\n"
msgstr ""

#: en.xml:13855(title) 
msgid "Discovering locks"
msgstr ""

#: en.xml:13857(para) 
msgid "When a commit fails due to someone else's locks, it's fairly easy to learn about them. The easiest of these is <command moreinfo=\"none\">svn status --show-updates</command>:"
msgstr ""

#: en.xml:13861(screen) 
#, no-wrap
msgid "\n$ whoami\nsally\n\n$ svn status --show-updates\nM              23   bar.c\nM    O         32   raisin.jpg\n       *       72   foo.h\nStatus against revision:     105\n"
msgstr ""

#: en.xml:13872(para) 
msgid "In this example, Sally can see not only that her copy of <filename moreinfo=\"none\">foo.h</filename> is out-of-date, but that one of the two modified files she plans to commit is locked in the repository. The <literal moreinfo=\"none\">O</literal> symbol stands for <quote>Other</quote>, meaning that a lock exists on the file, and was created by somebody else. If she were to attempt a commit, the lock on <filename moreinfo=\"none\">raisin.jpg</filename> would prevent it. Sally is left wondering who made the lock, when, and why. Once again, <command moreinfo=\"none\">svn info</command> has the answers:"
msgstr ""

#: en.xml:13883(screen) 
#, no-wrap
msgid "\n$ svn info http://svn.example.com/repos/project/raisin.jpg\nPath: raisin.jpg\nName: raisin.jpg\nURL: http://svn.example.com/repos/project/raisin.jpg\nRepository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec\nRevision: 105\nNode Kind: file\nLast Changed Author: sally\nLast Changed Rev: 32\nLast Changed Date: 2005-01-25 12:43:04 -0600 (Tue, 25 Jan 2005)\nLock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b\nLock Owner: harry\nLock Created: 2005-02-16 13:29:18 -0500 (Wed, 16 Feb 2005)\nLock Comment (1 line):\nNeed to make a quick tweak to this image.\n"
msgstr ""

#: en.xml:13901(para) 
msgid "Just as <command moreinfo=\"none\">svn info</command> can be used to examine objects in the working copy, it can also be used to examine objects in the repository. If the main argument to <command moreinfo=\"none\">svn info</command> is a working copy path, then all of the working copy's cached information is displayed; any mention of a lock means that the working copy is holding a lock token (if a file is locked by another user or in another working copy, <command moreinfo=\"none\">svn info</command> on a working copy path will show no lock information at all). If the main argument to <command moreinfo=\"none\">svn info</command> is a URL, then the information reflects the latest version of an object in the repository; any mention of a lock describes the current lock on the object."
msgstr ""

#: en.xml:13915(para) 
msgid "So in this particular example, Sally can see that Harry locked the file on February 16th to <quote>make a quick tweak</quote>. It being June, she suspects that he probably forgot all about the lock. She might phone Harry to complain and ask him to release the lock. If he's unavailable, she might try to forcibly break the lock herself or ask an administrator to do so."
msgstr ""

#: en.xml:13927(title) 
msgid "Breaking and stealing locks"
msgstr ""

#: en.xml:13929(para) 
msgid "A repository lock isn't sacred; it can be released not only by the person who created it, but by anyone at all. When somebody other than the original lock creator destroys a lock, we refer to this as <firstterm>breaking</firstterm> the lock."
msgstr ""

#: en.xml:13935(para) 
msgid "From the administrator's chair, it's simple to break locks. The <command moreinfo=\"none\">svnlook</command> and <command moreinfo=\"none\">svnadmin</command> programs have the ability to display and remove locks directly from the repository. (For more information about these tools, see <xref linkend=\"svn.reposadmin.maint.tk\"/>.)"
msgstr ""

#: en.xml:13942(screen) 
#, no-wrap
msgid "\n$ svnadmin lslocks /usr/local/svn/repos\nPath: /project2/images/banana.jpg\nUUID Token: opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923\nOwner: frank\nCreated: 2005-06-15 13:29:18 -0500 (Wed, 15 Jun 2005)\nExpires: \nComment (1 line):\nStill improving the yellow color.\n\nPath: /project/raisin.jpg\nUUID Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b\nOwner: harry\nCreated: 2005-02-16 13:29:18 -0500 (Wed, 16 Feb 2005)\nExpires: \nComment (1 line):\nNeed to make a quick tweak to this image.\n\n$ svnadmin rmlocks /usr/local/svn/repos /project/raisin.jpg\nRemoved lock on '/project/raisin.jpg'.\n"
msgstr ""

#: en.xml:13964(para) 
msgid "The more interesting option is allowing users to break each other's locks over the network. To do this, one simply needs to pass the <option>--force</option> to the unlock command:"
msgstr ""

#: en.xml:13969(screen) 
#, no-wrap
msgid "\n$ whoami\nsally\n\n$ svn status --show-updates\nM              23   bar.c\nM    O         32   raisin.jpg\n       *       72   foo.h\nStatus against revision:     105\n\n$ svn unlock raisin.jpg\nsvn: 'raisin.jpg' is not locked in this working copy\n\n$ svn info raisin.jpg | grep URL\nURL: http://svn.example.com/repos/project/raisin.jpg\n\n$ svn unlock http://svn.example.com/repos/project/raisin.jpg\nsvn: Unlock request failed: 403 Forbidden (http://svn.example.com)\n\n$ svn unlock --force http://svn.example.com/repos/project/raisin.jpg\n'raisin.jpg' unlocked.\n"
msgstr ""

#: en.xml:13992(para) 
msgid "Sally's initial attempt to unlock failed because she ran <command moreinfo=\"none\">svn unlock</command> directly on her working copy of the file, and no lock token was present. To remove the lock directly from the repository, she needs to pass a URL to <command moreinfo=\"none\">svn unlock</command>. Her first attempt to unlock the URL fails, because she can't authenticate as the lock owner (nor does she have the lock token). But when she passes <option>--force</option>, the authentication and authorization requirements are ignored, and the remote lock is broken."
msgstr ""

#: en.xml:14003(para) 
msgid "Of course, simply breaking a lock may not be enough. In the running example, Sally may not only want to break Harry's long-forgotten lock, but re-lock the file for her own use. She can accomplish this by running <command moreinfo=\"none\">svn unlock --force</command> and then <command moreinfo=\"none\">svn lock</command> back-to-back, but there's a small chance that somebody else might lock the file between the two commands. The simpler thing to is <firstterm>steal</firstterm> the lock, which involves breaking and re-locking the file all in one atomic step. To do this, pass the <option>--force</option> option to <command moreinfo=\"none\">svn lock</command>:"
msgstr ""

#: en.xml:14015(screen) 
#, no-wrap
msgid "\n$ svn lock raisin.jpg\nsvn: Lock request failed: 423 Locked (http://svn.example.com)\n\n$ svn lock --force raisin.jpg\n'raisin.jpg' locked by user 'sally'.\n"
msgstr ""

#: en.xml:14023(para) 
msgid "In any case, whether the lock is broken or stolen, Harry may be in for a surprise. Harry's working copy still contains the original lock token, but that lock no longer exists. The lock token is said to be <firstterm>defunct</firstterm>. The lock represented by the lock-token has either been broken (no longer in the repository), or stolen (replaced with a different lock). Either way, Harry can see this by asking <command moreinfo=\"none\">svn status</command> to contact the repository:"
msgstr ""

#: en.xml:14033(screen) 
#, no-wrap
msgid "\n$ whoami\nharry\n\n$ svn status\n     K raisin.jpg\n\n$ svn status --show-updates\n     B         32   raisin.jpg\n\n$ svn update\n  B  raisin.jpg\n\n$ svn status\n\n$\n"
msgstr ""

#: en.xml:14051(para) 
msgid "If the repository lock was broken, then <command moreinfo=\"none\">svn status --show-updates</command> displays a <literal moreinfo=\"none\">B</literal> (Broken) symbol next to the file. If a new lock exists in place of the old one, then a <literal moreinfo=\"none\">T</literal> (sTolen) symbol is shown. Finally, <command moreinfo=\"none\">svn update</command> notices any defunct lock tokens and removes them from the working copy."
msgstr ""

#: en.xml:14060(title) 
msgid "Locking Policies"
msgstr ""

#: en.xml:14062(para) 
msgid "Different systems have different notions of how strict a lock should be. Some folks argue that locks must be strictly enforced at all costs, releasable only by the original creator or administrator. They argue that if anyone can break a lock, then chaos breaks loose and the whole point of locking is defeated. The other side argues that locks are first and foremost a communication tool. If users are constantly breaking each others' locks, then it represents a cultural failure within the team and the problem falls outside the scope of software enforcement."
msgstr ""

#: en.xml:14074(para) 
msgid "Subversion defaults to the <quote>softer</quote> approach, but still allows administrators to create stricter enforcement policies through the use of hook scripts. In particular, the <filename moreinfo=\"none\">pre-lock</filename> and <filename moreinfo=\"none\">pre-unlock</filename> hooks allow administrators to decide when lock creation and lock releases are allowed to happen. Depending on whether or not a lock already exists, these two hooks can decide whether or not to allow a certain user to break or steal a lock. The <filename moreinfo=\"none\">post-lock</filename> and <filename moreinfo=\"none\">post-unlock</filename> hooks are also available, and can be used to send email after locking actions."
msgstr ""

#: en.xml:14088(para) 
msgid "To learn more about repository hooks, see <xref linkend=\"svn.reposadmin.create.hooks\"/>."
msgstr ""

#: en.xml:14096(title) 
msgid "Lock Communication"
msgstr ""

#: en.xml:14098(para) 
msgid "We've seen how <command moreinfo=\"none\">svn lock</command> and <command moreinfo=\"none\">svn unlock</command> can be used to create, release, break, and steal locks. This satisfies the goal of serializing commit access to a file. But what about the larger problem of preventing wasted time?"
msgstr ""

#: en.xml:14104(para) 
msgid "For example, suppose Harry locks an image file and then begins editing it. Meanwhile, miles away, Sally wants to do the same thing. She doesn't think to run <command moreinfo=\"none\">svn status --show-updates</command>, so she has no idea that Harry has already locked the file. She spends hours editing the file, and when she tries to commit her change, she discovers that either the file is locked or that she's out-of-date. Regardless, her changes aren't mergeable with Harry's. One of these two people has to throw away their work, and a lot of time has been wasted."
msgstr ""

#: en.xml:14115(para) 
msgid "Subversion's solution to this problem is provide a mechanism to remind users that a file ought to be locked <emphasis>before</emphasis> the editing begins."
msgstr ""

#: en.xml:14119(para) 
msgid "The mechanism is a special property, <literal moreinfo=\"none\">svn:needs-lock</literal>. If the property is attached to a file (the value is irrelevant), then the file will have read-only permissions. When the user locks the file and receives a lock token, the file becomes read-write. When the lock is released—either explicitly unlocked, or released via commit—the file returns to read-only again."
msgstr ""

#: en.xml:14128(para) 
msgid "The theory, then, is that if the image file has this property attached, then Sally would immediately notice something is strange when she opens the file for editing. Her application would be unable to save changes, or (better yet) tell her that the file is read-only. This reminds her to lock the file before editing, whereby she discovers the pre-existing lock:"
msgstr ""

#: en.xml:14136(screen) 
#, no-wrap
msgid "\n$ /usr/local/bin/gimp raisin.jpg\ngimp: error: file is read-only!\n\n$ ls -l raisin.jpg\n-r--r--r--   1 sally   sally   215589 Jun  8 19:23 raisin.jpg\n\n$ svn lock raisin.jpg\nsvn: Lock request failed: 423 Locked (http://svn.example.com)\n\n$ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock\nLock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b\nLock Owner: harry\nLock Created: 2005-06-08 07:29:18 -0500 (Thu, 08 June 2005)\nLock Comment (1 line):\nMaking some tweaks.  Locking for the next two hours.\n\n"
msgstr ""

#: en.xml:14155(para) 
msgid "As a matter of <quote>best practice</quote>, both users and administrators are encouraged to attach the <literal moreinfo=\"none\">svn:needs-lock</literal> property to any file which cannot be contextually merged. It's the main technique for encouraging good locking habits and preventing wasted effort."
msgstr ""

#: en.xml:14162(para) 
msgid "Note that this property is a communication tool which works independently from the locking system. In other words, any file can be locked, whether or not this property is present. And conversely, the presence of this property doesn't make the repository require a lock when committing."
msgstr ""

#: en.xml:14169(para) 
msgid "The system isn't flawless, either. It's possible that even when a file has the property, the read-only reminder won't always work. Sometimes applications misbehave and <quote>hijack</quote> the read-only file, silently allowing users to edit and save the file anyway. Unfortunately, there's not much Subversion can do about this."
msgstr ""

#: en.xml:14185(title) 
msgid "Peg and Operative Revisions"
msgstr ""

#: en.xml:14187(para) 
msgid "We make use of the ability to copy, move, rename, and completely replace files and directories on our computers all that time. And your version control system shouldn't get in the way of your doing these things with your version controlled files and directories, either. Subversion's file management support is quite liberating, affording almost as much flexibility for versioned files that you'd expect when manipulating your unversioned ones. But that flexibility means that across the lifetime of your repository, a given versioned resource might have many paths, and a given path might represent several entirely different versioned resources. And this introduces a certain level of complexity to your interactions with those paths and resources."
msgstr ""

#: en.xml:14201(para) 
msgid "Subversion is pretty smart about noticing when an object's version history includes such <quote>changes of address</quote>. For example, if you ask for all the logs of a particular file that was renamed last week, Subversion happily provides all those logs—the revision in which the rename itself happened, plus the logs of relevant revisions both before and after that rename. So, most of the time, you don't even have to think about such things. But occasionally, Subversion needs your help to clear up ambiguities."
msgstr ""

#: en.xml:14211(para) 
msgid "The simplest example of this occurs when a directory or file is deleted from version control, and then a new directory or file is created with the same name and added to version control. Clearly the thing you deleted and the thing you later added aren't the same thing, they merely happen to have had the same path, which we'll call <filename moreinfo=\"none\">/trunk/object</filename>. What, then, does it mean to ask Subversion about the history of <filename moreinfo=\"none\">/trunk/object</filename>? Are you asking about the thing currently at that location, or the old thing you deleted from that location? Are you asking about the operations that have happened to all the objects that have lived at that path? Clearly, Subversion needs a hint about what you are really asking."
msgstr ""

#: en.xml:14233(para) 
msgid "<quote>You're not supposed to name it. Once you name it, you start getting attached to it.</quote> — Mike Wazowski"
msgstr ""

#: en.xml:14225(para) 
msgid "And thanks to moves, versioned resource history can get far more twisted than that, even. For example, you might have a directory named <filename moreinfo=\"none\">concept</filename>, containing some nascent software project you've been toying with. Eventually, though, that project matures to the point that the idea seems to actually have some wings, so you do the unthinkable and decide to give the project a name. <footnote><placeholder-1/></footnote> Let's say you called your software Frabnaggilywort. At this point, it makes sense to rename the directory to reflect the project's new name, so <filename moreinfo=\"none\">concept</filename> is renamed to <filename moreinfo=\"none\">frabnaggilywort</filename>. Life goes on, Frabnaggilywort releases a 1.0 version, and is downloaded and used daily by hordes of people aiming to improve their lives."
msgstr ""

#: en.xml:14245(para) 
msgid "It's a nice story, really, but it doesn't end there. Entrepreneur that you are, you've already got another think in the tank. So you make a new directory, <filename moreinfo=\"none\">concept</filename>, and the cycle begins again. In fact, the cycle begins again many times over the years, each time starting with that old <filename moreinfo=\"none\">concept</filename> directory, then sometimes seeing that directory renamed as the idea cures, sometimes seeing it deleted when you scrap the idea. Or, to get really sick, maybe you rename <filename moreinfo=\"none\">concept</filename> to something else for a while, but later rename the thing back to <filename moreinfo=\"none\">concept</filename> for some reason."
msgstr ""

#: en.xml:14258(para) 
msgid "When scenarios like these occur, attempting to instruct Subversion to work with these re-used paths can be a little like instructing a motorist in Chicago's West Suburbs to drive east down Roosevelt Road and turn left onto Main Street. In a mere twenty minutes, you can cross <quote>Main Street</quote> in Wheaton, Glen Ellyn, and Lombard. And no, they aren't the same street. Our motorist—and our Subversion—need a little more detail in order to do the right thing."
msgstr ""

#: en.xml:14267(para) 
msgid "In version 1.1, Subversion introduced a way for you to tell it exactly which Main Street you meant. It's called the <firstterm>peg revision</firstterm>, and it is a revision provided to Subversion for the sole purpose of identifying a unique line of history. Because at most one versioned resource may occupy a path at any given time—or, more precisely, in any one revision—the combination of a path and a peg revision is all that is needed to refer to a specific line of history. Peg revisions are specified to the Subversion command-line client using <firstterm>at syntax</firstterm>, so called because the syntax involves appending an <quote>at sign</quote> (<literal moreinfo=\"none\">@</literal>) and the peg revision to the end of the path with which the revision is associated."
msgstr ""

#: en.xml:14291(para) 
msgid "606 N. Main Street, Wheaton, Illinois, is the home of the Wheaton History Center. Get it—<quote>History Center</quote>? It seemed appropriate…."
msgstr ""

#: en.xml:14281(para) 
msgid "But what of the <option>--revision (-r)</option> of which we've spoken so much in this book? That revision (or set of revisions) is called the <firstterm>operative revision</firstterm> (or <firstterm>operative revision range</firstterm>). Once a particular line of history has been identified using a path and peg revision, Subversion performs the requested operation using the operative revision(s). To map this to our Chicagoland streets analogy, if we are told to go to 606 N. Main Street in Wheaton, <footnote><placeholder-1/></footnote> we can think of <quote>Main Street</quote> as our path and <quote>Wheaton</quote> as our peg revision. These two pieces of information identify a unique path which can travelled (north or south on Main Street), and will keep us from travelling up and down the wrong Main Street in search of our destination. Now we throw in <quote>606 N.</quote> as our operative revision, of sorts, and we know <emphasis>exactly</emphasis> where to go."
msgstr ""

#: en.xml:14305(title) 
msgid "The \"peg-revision\" algorithm"
msgstr ""

#: en.xml:14307(para) 
msgid "When the commandline client sees a command of the form:"
msgstr ""

#: en.xml:14311(replaceable) 
msgid "command"
msgstr ""

#: en.xml:14311(replaceable) 
msgid "OPERATIVE-REV"
msgstr ""

#: en.xml:14311(replaceable) 
msgid "PEG-REV"
msgstr ""

#: en.xml:14310(screen) 
#, no-wrap
msgid "\n$ svn <placeholder-1/> -r <placeholder-2/> item@<placeholder-3/>\n"
msgstr ""

#: en.xml:14314(para) 
msgid "…it performs the following algorithm:"
msgstr ""

#: en.xml:14319(para) 
msgid "Go to revision <replaceable>PEG-REV</replaceable>, and find <replaceable>item</replaceable>. This locates a unique object in the repository."
msgstr ""

#: en.xml:14325(para) 
msgid "Trace the object's history backwards (through any possible renames) to its ancestor in revision <replaceable>OPERATIVE-REV</replaceable>."
msgstr ""

#: en.xml:14331(para) 
msgid "Perform the requested action on that ancestor, wherever it is located, or whatever its name might be."
msgstr ""

#: en.xml:14338(para) 
msgid "Remember that even when you don't explicitly supply a peg-revision, it's still present. It defaults to BASE for working copy items, and to HEAD for URLs."
msgstr ""

#: en.xml:14344(para) 
msgid "Say that long ago we created our repository, and in revision 1 added our first <filename moreinfo=\"none\">concept</filename> directory, plus an <filename moreinfo=\"none\">IDEA</filename> file in that directory talking about the concept. After several revisions in which real code was added and tweaked, we, in revision 20, renamed this directory to <filename moreinfo=\"none\">frabnaggilywort</filename>. By revision 27, we had a new concept, a new <filename moreinfo=\"none\">concept</filename> directory to hold it, and a new <filename moreinfo=\"none\">IDEA</filename> file to describe it. And then five years and twenty thousand revisions flew by, just like they would in any good romance story."
msgstr ""

#: en.xml:14355(para) 
msgid "Now, years later, we wonder what the <filename moreinfo=\"none\">IDEA</filename> file looked like back in revision 1. But Subversion needs to know if we are asking about how the <emphasis>current</emphasis> file looked back in revision 1, or are we asking for the contents of whatever file lived at <filename moreinfo=\"none\">concepts/IDEA</filename> in revision 1? Certainly those questions have different answers, and because of peg revisions, you can ask either of them. To find out how the current <filename moreinfo=\"none\">IDEA</filename> file looked in that old revision, you run:"
msgstr ""

#: en.xml:14366(screen) 
#, no-wrap
msgid "\n$ svn cat -r 1 concept/IDEA \nsubversion/libsvn_client/ra.c:775: (apr_err=20014)\nsvn: Unable to find repository location for 'concept/IDEA' in revision 1\n"
msgstr ""

#: en.xml:14372(para) 
msgid "Of course, in this example, the current <filename moreinfo=\"none\">IDEA</filename> file didn't exist yet in revision 1, so Subversion gives an error. The command above is shorthand for a longer notation which explicitly lists a peg revision. The expanded notation is:"
msgstr ""

#: en.xml:14378(screen) 
#, no-wrap
msgid "\n$ svn cat -r 1 concept/IDEA@BASE\nsubversion/libsvn_client/ra.c:775: (apr_err=20014)\nsvn: Unable to find repository location for 'concept/IDEA' in revision 1\n"
msgstr ""

#: en.xml:14384(para) 
msgid "And when executed, it has the expected results. Peg revisions generally default to a value of <literal moreinfo=\"none\">BASE</literal> (the revision currently present in the working copy) when applied to working copy paths, and of <literal moreinfo=\"none\">HEAD</literal> when applied to URLs."
msgstr ""

#: en.xml:14390(para) 
msgid "Let's ask the other question, then—in revision 1, what were the contents of whatever file occupied the address <filename moreinfo=\"none\">concepts/IDEA</filename> at the time? We'll use an explicit peg revision to help us out."
msgstr ""

#: en.xml:14395(screen) 
#, no-wrap
msgid "\n$ svn cat concept/IDEA@1\nThe idea behind this project is to come up with a piece of software\nthat can frab a naggily wort.  Frabbing naggily worts is tricky\nbusiness, and doing it incorrectly can have serious ramifications, so\nwe need to employ over-the-top input validation and data verification\nmechanisms.\n"
msgstr ""

#: en.xml:14404(para) 
msgid "This appears to be the right output. The text even mentions frabbing naggily worts, so this is almost certainly the file which describes the software now called Frabnaggilywort. In fact, we can verify this using the combination of an explicit peg revision and explicit operative revision. We know that in <literal moreinfo=\"none\">HEAD</literal>, the Frabnaggilywort project is located in the <filename moreinfo=\"none\">frabnaggilywort</filename> directory. So we specify that we want to see how the line of history identified in <literal moreinfo=\"none\">HEAD</literal> as the path <filename moreinfo=\"none\">frabnaggilywort/IDEA</filename> looked in revision 1."
msgstr ""

#: en.xml:14416(screen) 
#, no-wrap
msgid "\n$ svn cat -r 1 frabnaggilywort/IDEA@HEAD\nThe idea behind this project is to come up with a piece of software\nthat can frab a naggily wort.  Frabbing naggily worts is tricky\nbusiness, and doing it incorrectly can have serious ramifications, so\nwe need to employ over-the-top input validation and data verification\nmechanisms.\n"
msgstr ""

#: en.xml:14425(para) 
msgid "And the peg and operative revisions need not be so trivial, either. For example, say <filename moreinfo=\"none\">frabnaggilywort</filename> had been deleted from <literal moreinfo=\"none\">HEAD</literal>, but we know it existed in revision 20, and we want to see the diffs for its <filename moreinfo=\"none\">IDEA</filename> file between revisions 4 and 10. We can use the peg revision 20 in conjunction with the URL that would have held Frabnaggilywort's <filename moreinfo=\"none\">IDEA</filename> file in revision 20, and then use 4 and 10 as our operative revision range."
msgstr ""

#: en.xml:14435(screen) 
#, no-wrap
msgid "\n$ svn diff -r 4:10 http://svn.red-bean.com/projects/frabnaggilywort/IDEA@20\nIndex: frabnaggilywort/IDEA\n===================================================================\n--- frabnaggilywort/IDEA\t(revision 4)\n+++ frabnaggilywort/IDEA\t(revision 10)\n@@ -1,5 +1,5 @@\n-The idea behind this project is to come up with a piece of software\n-that can frab a naggily wort.  Frabbing naggily worts is tricky\n-business, and doing it incorrectly can have serious ramifications, so\n-we need to employ over-the-top input validation and data verification\n-mechanisms.\n+The idea behind this project is to come up with a piece of\n+client-server software that can remotely frab a naggily wort.\n+Frabbing naggily worts is tricky business, and doing it incorrectly\n+can have serious ramifications, so we need to employ over-the-top\n+input validation and data verification mechanisms.\n"
msgstr ""

#: en.xml:14454(para) 
msgid "Fortunately, most folks aren't faced with such complex situations. But when you are, remember that peg revisions are that extra hint Subversion needs to clear up ambiguity."
msgstr ""

#: en.xml:14464(title) 
msgid "Externals Definitions"
msgstr ""

#: en.xml:14466(para) 
msgid "Sometimes it is useful to construct a working copy that is made out of a number of different checkouts. For example, you may want different subdirectories to come from different locations in a repository, or perhaps from different repositories altogether. You could certainly setup such a scenario by hand—using <command moreinfo=\"none\">svn checkout</command> to create the sort of nested working copy structure you are trying to achieve. But if this layout is important for everyone who uses your repository, every other user will need to perform the same checkout operations that you did."
msgstr ""

#: en.xml:14477(para) 
msgid "Fortunately, Subversion provides support for <firstterm>externals definitions</firstterm>. An externals definition is a mapping of a local directory to the URL—and possibly a particular revision—of a versioned resource. In Subversion, you declare externals definitions in groups using the <literal moreinfo=\"none\">svn:externals</literal> property. You can create or modify this property using <command moreinfo=\"none\">svn propset</command> or <command moreinfo=\"none\">svn propedit</command> (see <xref linkend=\"svn.advanced.props.why\"/>). It can be set on any versioned directory, and its value is a multi-line table of subdirectories (relative to the versioned directory on which the property is set) and fully qualified, absolute Subversion repository URLs."
msgstr ""

#: en.xml:14491(screen) 
#, no-wrap
msgid "\n$ svn propget svn:externals calc\nthird-party/sounds             http://sounds.red-bean.com/repos\nthird-party/skins              http://skins.red-bean.com/repositories/skinproj\nthird-party/skins/toolkit -r21 http://svn.red-bean.com/repos/skin-maker\n"
msgstr ""

#: en.xml:14498(para) 
msgid "The convenience of the <literal moreinfo=\"none\">svn:externals</literal> property is that once it is set on a versioned directory, everyone who checks out a working copy with that directory also gets the benefit of the externals definition. In other words, once one person has made the effort to define those nested working copy checkouts, no one else has to bother—Subversion will, upon checkout of the original working copy, also checkout the external working copies."
msgstr ""

#: en.xml:14507(para) 
msgid "Note the previous externals definition example. When someone checks out a working copy of the <filename moreinfo=\"none\">calc</filename> directory, Subversion also continues to checkout the items found in its externals definition."
msgstr ""

#: en.xml:14512(screen) 
#, no-wrap
msgid "\n$ svn checkout http://svn.example.com/repos/calc\nA  calc\nA  calc/Makefile\nA  calc/integer.c\nA  calc/button.c\nChecked out revision 148.\n\nFetching external item into calc/third-party/sounds\nA  calc/third-party/sounds/ding.ogg\nA  calc/third-party/sounds/dong.ogg\nA  calc/third-party/sounds/clang.ogg\n…\nA  calc/third-party/sounds/bang.ogg\nA  calc/third-party/sounds/twang.ogg\nChecked out revision 14.\n\nFetching external item into calc/third-party/skins\n…\n"
msgstr ""

#: en.xml:14533(para) 
msgid "If you need to change the externals definition, you can do so using the regular property modification subcommands. When you commit a change to the <literal moreinfo=\"none\">svn:externals</literal> property, Subversion will synchronize the checked-out items against the changed externals definition when you next run <command moreinfo=\"none\">svn update</command>. The same thing will happen when others update their working copies and receive your changes to the externals definition."
msgstr ""

#: en.xml:14542(para) 
msgid "The <command moreinfo=\"none\">svn status</command> command also recognizes externals definitions, displaying a status code of <literal moreinfo=\"none\">X</literal> for the disjoint subdirectories into which externals are checked out, and then recursing into those subdirectories to display the status of the external items themselves."
msgstr ""

#: en.xml:14550(para) 
msgid "You should strongly consider using explicit revision numbers in all of your externals definitions. Doing so means that you get to decide when to pull down a different snapshot of external information, and exactly which snapshot to pull. Besides the common sense aspect of not being surprised by changes to third-party repositories that you might not have any control over, using explicit revision numbers also means that as you backdate your working copy to a previous revision, your externals definitions will also revert to the way they looked in that previous revision, which in turn means that the external working copies will be updated to match they way <emphasis>they</emphasis> looked back when your repository was at that previous revision. For software projects, this could be the difference between a successful and a failed build of an older snapshot of your complex codebase."
msgstr ""

#: en.xml:14567(para) 
msgid "The support that exists for externals definitions in Subversion today can be a little misleading, though. First, an externals definition can only point to directories, not files. Second, the externals definition cannot point to relative paths (paths like <filename moreinfo=\"none\">../../skins/myskin</filename>). Third, the working copies created via the externals definition support are still disconnected from the primary working copy (on whose versioned directories the <literal moreinfo=\"none\">svn:externals</literal> property was actually set). And Subversion still only truly operates on non-disjoint working copies. So, for example, if you want to commit changes that you've made in one or more of those external working copies, you must run <command moreinfo=\"none\">svn commit</command> explicitly on those working copies—committing on the primary working copy will not recurse into any external ones."
msgstr ""

#: en.xml:14583(para) 
msgid "Also, since the definitions themselves use absolute URLs, moving or copying a directory to which they are attached will not affect what gets checked out as an external (though the relative local target subdirectory will, of course, move with renamed directory). This can be confusing—even frustrating—in certain situations. For example, if you use externals definitions on a directory in your <filename moreinfo=\"none\">/trunk</filename> development line which point to other areas of that same line, and then you use <command moreinfo=\"none\">svn copy</command> to branch that line to some new location <filename moreinfo=\"none\">/branches/my-branch</filename>, the externals definitions on items in your new branch will still refer to versioned resources in <filename moreinfo=\"none\">/trunk</filename>. Be aware, too, that if you need to re-parent your working copy (using <command moreinfo=\"none\">svn switch --relocate</command>), externals definitions will <emphasis>not</emphasis> also be re-parented."
msgstr ""

#: en.xml:14600(para) 
msgid "Finally, there might be times when you would prefer that <command moreinfo=\"none\">svn</command> subcommands would not recognize or otherwise operate on the external working copies created as the result of externals definition handling. In those instances, you can pass the <option>--ignore-externals</option> option to the subcommand."
msgstr ""

#: en.xml:14612(title) 
msgid "Vendor branches"
msgstr ""

#: en.xml:14614(para) 
msgid "As is especially the case when developing software, the data that you maintain under version control is often closely related to, or perhaps dependent upon, someone else's data. Generally, the needs of your project will dictate that you stay as up-to-date as possible with the data provided by that external entity without sacrificing the stability of your own project. This scenario plays itself out all the time—anywhere that the information generated by one group of people has a direct effect on that which is generated by another group."
msgstr ""

#: en.xml:14624(para) 
msgid "For example, software developers might be working on an application which makes use of a third-party library. Subversion has just such a relationship with the Apache Portable Runtime library (see <xref linkend=\"svn.developer.usingapi.apr\"/>). The Subversion source code depends on the APR library for all its portability needs. In earlier stages of Subversion's development, the project closely tracked APR's changing API, always sticking to the <quote>bleeding edge</quote> of the library's code churn. Now that both APR and Subversion have matured, Subversion attempts to synchronize with APR's library API only at well-tested, stable release points."
msgstr ""

#: en.xml:14636(para) 
msgid "Now, if your project depends on someone else's information, there are several ways that you could attempt to synchronize that information with your own. Most painfully, you could issue oral or written instructions to all the contributors of your project, telling them to make sure that they have the specific versions of that third-party information that your project needs. If the third-party information is maintained in a Subversion repository, you could also use Subversion's externals definitions to effectively <quote>pin down</quote> specific versions of that information to some location in your own working copy directory (see <xref linkend=\"svn.advanced.externals\"/>)."
msgstr ""

#: en.xml:14648(para) 
msgid "But sometimes you want to maintain custom modifications to third-party data in your own version control system. Returning to the software development example, programmers might need to make modifications to that third-party library for their own purposes. These modifications might include new functionality or bug fixes, maintained internally only until they become part of an official release of the third-party library. Or the changes might never be relayed back to the library maintainers, existing solely as custom tweaks to make the library further suit the needs of the software developers."
msgstr ""

#: en.xml:14659(para) 
msgid "Now you face an interesting situation. Your project could house its custom modifications to the third-party data in some disjointed fashion, such as using patch files or full-fledged alternate versions of files and directories. But these quickly become maintenance headaches, requiring some mechanism by which to apply your custom changes to the third-party data, and necessitating regeneration of those changes with each successive version of the third-party data that you track."
msgstr ""

#: en.xml:14668(para) 
msgid "The solution to this problem is to use <firstterm>vendor branches</firstterm>. A vendor branch is a directory tree in your own version control system that contains information provided by a third-party entity, or vendor. Each version of the vendor's data that you decide to absorb into your project is called a <firstterm>vendor drop</firstterm>."
msgstr ""

#: en.xml:14675(para) 
msgid "Vendor branches provide two key benefits. First, by storing the currently supported vendor drop in your own version control system, the members of your project never need to question whether they have the right version of the vendor's data. They simply receive that correct version as part of their regular working copy updates. Secondly, because the data lives in your own Subversion repository, you can store your custom changes to it in-place—you have no more need of an automated (or worse, manual) method for swapping in your customizations."
msgstr ""

#: en.xml:14687(title) 
msgid "General Vendor Branch Management Procedure"
msgstr ""

#: en.xml:14689(para) 
msgid "Managing vendor branches generally works like this. You create a top-level directory (such as <filename moreinfo=\"none\">/vendor</filename>) to hold the vendor branches. Then you import the third party code into a subdirectory of that top-level directory. You then copy that subdirectory into your main development branch (for example, <filename moreinfo=\"none\">/trunk</filename>) at the appropriate location. You always make your local changes in the main development branch. With each new release of the code you are tracking you bring it into the vendor branch and merge the changes into <filename moreinfo=\"none\">/trunk</filename>, resolving whatever conflicts occur between your local changes and the upstream changes."
msgstr ""

#: en.xml:14703(para) 
msgid "Perhaps an example will help to clarify this algorithm. We'll use a scenario where your development team is creating a calculator program that links against a third-party complex number arithmetic library, libcomplex. We'll begin with the initial creation of the vendor branch, and the import of the first vendor drop. We'll call our vendor branch directory <filename moreinfo=\"none\">libcomplex</filename>, and our code drops will go into a subdirectory of our vendor branch called <filename moreinfo=\"none\">current</filename>. And since <command moreinfo=\"none\">svn import</command> creates all the intermediate parent directories it needs, we can actually accomplish both of these steps with a single command."
msgstr ""

#: en.xml:14716(screen) 
#, no-wrap
msgid "\n$ svn import /path/to/libcomplex-1.0 \\\n             http://svn.example.com/repos/vendor/libcomplex/current \\\n             -m 'importing initial 1.0 vendor drop'\n…\n"
msgstr ""

#: en.xml:14723(para) 
msgid "We now have the current version of the libcomplex source code in <filename moreinfo=\"none\">/vendor/libcomplex/current</filename>. Now, we tag that version (see <xref linkend=\"svn.branchmerge.tags\"/>) and then copy it into the main development branch. Our copy will create a new directory called <filename moreinfo=\"none\">libcomplex</filename> in our existing <filename moreinfo=\"none\">calc</filename> project directory. It is in this copied version of the vendor data that we will make our customizations."
msgstr ""

#: en.xml:14733(screen) 
#, no-wrap
msgid "\n$ svn copy http://svn.example.com/repos/vendor/libcomplex/current  \\\n           http://svn.example.com/repos/vendor/libcomplex/1.0      \\\n           -m 'tagging libcomplex-1.0'\n…\n$ svn copy http://svn.example.com/repos/vendor/libcomplex/1.0  \\\n           http://svn.example.com/repos/calc/libcomplex        \\\n           -m 'bringing libcomplex-1.0 into the main branch'\n…\n"
msgstr ""

#: en.xml:14750(para) 
msgid "And entirely bug-free, of course!"
msgstr ""

#: en.xml:14744(para) 
msgid "We check out our project's main branch—which now includes a copy of the first vendor drop—and we get to work customizing the libcomplex code. Before we know it, our modified version of libcomplex is now completely integrated into our calculator program. <footnote><placeholder-1/></footnote>"
msgstr ""

#: en.xml:14754(para) 
msgid "A few weeks later, the developers of libcomplex release a new version of their library—version 1.1—which contains some features and functionality that we really want. We'd like to upgrade to this new version, but without losing the customizations we made to the existing version. What we essentially would like to do is to replace our current baseline version of libcomplex 1.0 with a copy of libcomplex 1.1, and then re-apply the custom modifications we previously made to that library to the new version. But we actually approach the problem from the other direction, applying the changes made to libcomplex between versions 1.0 and 1.1 to our modified copy of it."
msgstr ""

#: en.xml:14767(para) 
msgid "To perform this upgrade, we checkout a copy of our vendor branch, and replace the code in the <filename moreinfo=\"none\">current</filename> directory with the new libcomplex 1.1 source code. We quite literally copy new files on top of existing files, perhaps exploding the libcomplex 1.1 release tarball atop our existing files and directories. The goal here is to make our <filename moreinfo=\"none\">current</filename> directory contain only the libcomplex 1.1 code, and to ensure that all that code is under version control. Oh, and we want to do this with as little version control history disturbance as possible."
msgstr ""

#: en.xml:14779(para) 
msgid "After replacing the 1.0 code with 1.1 code, <command moreinfo=\"none\">svn status</command> will show files with local modifications as well as, perhaps, some unversioned or missing files. If we did what we were supposed to do, the unversioned files are only those new files introduced in the 1.1 release of libcomplex—we run <command moreinfo=\"none\">svn add</command> on those to get them under version control. The missing files are files that were in 1.0 but not in 1.1, and on those paths we run <command moreinfo=\"none\">svn delete</command>. Finally, once our <filename moreinfo=\"none\">current</filename> working copy contains only the libcomplex 1.1 code, we commit the changes we made to get it looking that way."
msgstr ""

#: en.xml:14792(para) 
msgid "Our <filename moreinfo=\"none\">current</filename> branch now contains the new vendor drop. We tag the new version (in the same way we previously tagged the version 1.0 vendor drop), and then merge the differences between the tag of the previous version and the new current version into our main development branch."
msgstr ""

#: en.xml:14799(screen) 
#, no-wrap
msgid "\n$ cd working-copies/calc\n$ svn merge http://svn.example.com/repos/vendor/libcomplex/1.0      \\\n            http://svn.example.com/repos/vendor/libcomplex/current  \\\n            libcomplex\n… # resolve all the conflicts between their changes and our changes\n$ svn commit -m 'merging libcomplex-1.1 into the main branch'\n…\n"
msgstr ""

#: en.xml:14809(para) 
msgid "In the trivial use case, the new version of our third-party tool would look, from a files-and-directories point of view, just like the previous version. None of the libcomplex source files would have been deleted, renamed or moved to different locations—the new version would contain only textual modifications against the previous one. In a perfect world, our modifications would apply cleanly to the new version of the library, with absolutely no complications or conflicts."
msgstr ""

#: en.xml:14819(para) 
msgid "But things aren't always that simple, and in fact it is quite common for source files to get moved around between releases of software. This complicates the process of ensuring that our modifications are still valid for the new version of code, and can quickly degrade into a situation where we have to manually recreate our customizations in the new version. Once Subversion knows about the history of a given source file—including all its previous locations—the process of merging in the new version of the library is pretty simple. But we are responsible for telling Subversion how the source file layout changed from vendor drop to vendor drop."
msgstr ""

#: en.xml:14841(command) 
msgid "svn_load_dirs.pl"
msgstr ""

#: en.xml:14843(para) 
msgid "Vendor drops that contain more than a few deletes, additions and moves complicate the process of upgrading to each successive version of the third-party data. So Subversion supplies the <command moreinfo=\"none\">svn_load_dirs.pl</command> script to assist with this process. This script automates the importing steps we mentioned in the general vendor branch management procedure to make sure that mistakes are minimized. You will still be responsible for using the merge commands to merge the new versions of the third-party data into your main development branch, but <command moreinfo=\"none\">svn_load_dirs.pl</command> can help you more quickly and easily arrive at that stage."
msgstr ""

#: en.xml:14856(para) 
msgid "In short, <command moreinfo=\"none\">svn_load_dirs.pl</command> is an enhancement to <command moreinfo=\"none\">svn import</command> that has several important characteristics:"
msgstr ""

#: en.xml:14862(para) 
msgid "It can be run at any point in time to bring an existing directory in the repository to exactly match an external directory, performing all the necessary adds and deletes, and optionally performing moves, too."
msgstr ""

#: en.xml:14868(para) 
msgid "It takes care of complicated series of operations between which Subversion requires an intermediate commit—such as before renaming a file or directory twice."
msgstr ""

#: en.xml:14873(para) 
msgid "It will optionally tag the newly imported directory."
msgstr ""

#: en.xml:14876(para) 
msgid "It will optionally add arbitrary properties to files and directories that match a regular expression."
msgstr ""

#: en.xml:14881(para) 
msgid "<command moreinfo=\"none\">svn_load_dirs.pl</command> takes three mandatory arguments. The first argument is the URL to the base Subversion directory to work in. This argument is followed by the URL—relative to the first argument—into which the current vendor drop will be imported. Finally, the third argument is the local directory to import. Using our previous example, a typical run of <command moreinfo=\"none\">svn_load_dirs.pl</command> might look like:"
msgstr ""

#: en.xml:14890(screen) 
#, no-wrap
msgid "\n$ svn_load_dirs.pl http://svn.example.com/repos/vendor/libcomplex \\\n                   current                                        \\\n                   /path/to/libcomplex-1.1\n…\n"
msgstr ""

#: en.xml:14897(para) 
msgid "You can indicate that you'd like <command moreinfo=\"none\">svn_load_dirs.pl</command> to tag the new vendor drop by passing the <option>-t</option> command-line option and specifying a tag name. This tag is another URL relative to the first program argument."
msgstr ""

#: en.xml:14903(screen) 
#, no-wrap
msgid "\n$ svn_load_dirs.pl -t libcomplex-1.1                              \\\n                   http://svn.example.com/repos/vendor/libcomplex \\\n                   current                                        \\\n                   /path/to/libcomplex-1.1\n…\n"
msgstr ""

#: en.xml:14911(para) 
msgid "When you run <command moreinfo=\"none\">svn_load_dirs.pl</command>, it examines the contents of your existing <quote>current</quote> vendor drop, and compares them with the proposed new vendor drop. In the trivial case, there will be no files that are in one version and not the other, and the script will perform the new import without incident. If, however, there are discrepancies in the file layouts between versions, <command moreinfo=\"none\">svn_load_dirs.pl</command> will prompt you for how you would like to resolve those differences. For example, you will have the opportunity to tell the script that you know that the file <filename moreinfo=\"none\">math.c</filename> in version 1.0 of libcomplex was renamed to <filename moreinfo=\"none\">arithmetic.c</filename> in libcomplex 1.1. Any discrepancies not explained by moves are treated as regular additions and deletions."
msgstr ""

#: en.xml:14926(para) 
msgid "The script also accepts a separate configuration file for setting properties on files and directories matching a regular expression that are <emphasis>added</emphasis> to the repository. This configuration file is specified to <command moreinfo=\"none\">svn_load_dirs.pl</command> using the <option>-p</option> command-line option. Each line of the configuration file is a whitespace-delimited set of two or four values: a Perl-style regular expression to match the added path against, a control keyword (either <literal moreinfo=\"none\">break</literal> or <literal moreinfo=\"none\">cont</literal>), and then optionally a property name and value."
msgstr ""

#: en.xml:14938(screen) 
#, no-wrap
msgid "\n\\.png$              break   svn:mime-type   image/png\n\\.jpe?g$            break   svn:mime-type   image/jpeg\n\\.m3u$              cont    svn:mime-type   audio/x-mpegurl\n\\.m3u$              break   svn:eol-style   LF\n.*                  break   svn:eol-style   native\n"
msgstr ""

#: en.xml:14946(para) 
msgid "For each added path, the configured property changes whose regular expression matches the path are applied in order, unless the control specification is <literal moreinfo=\"none\">break</literal> (which means that no more property changes should be applied to that path). If the control specification is <literal moreinfo=\"none\">cont</literal>—an abbreviation for <literal moreinfo=\"none\">continue</literal>—then matching will continue with the next line of the configuration file."
msgstr ""

#: en.xml:14955(para) 
msgid "Any whitespace in the regular expression, property name, or property value must be surrounded by either single or double quote characters. You can escape quote characters that are not used for wrapping whitespace by preceding them with a backslash (<literal moreinfo=\"none\">\\</literal>) character. The backslash escapes only quotes when parsing the configuration file, so do not protect any other characters beyond what is necessary for the regular expression."
msgstr ""

#: en.xml:14971(title) 
msgid "Localization"
msgstr ""

#: en.xml:14973(para) 
msgid "<firstterm>Localization</firstterm> is the act of making programs behave in a region-specific way. When a program formats numbers or dates in a way specific to your part of the world, or prints messages (or accepts input) in your native language, the program is said to be <firstterm>localized</firstterm>. This section describes steps Subversion has made towards localization."
msgstr ""

#: en.xml:14983(title) 
msgid "Understanding locales"
msgstr ""

#: en.xml:14985(para) 
msgid "Most modern operating systems have a notion of the <quote>current locale</quote>—that is, the region or country whose localization conventions are honored. These conventions—typically chosen by some runtime configuration mechanism on the computer—affect the way in which programs present data to the user, as well as the way in which they accept user input."
msgstr ""

#: en.xml:14993(para) 
msgid "On Unix-like systems, you can check the values of the locale-related runtime configuration options by running the <command moreinfo=\"none\">locale</command> command:"
msgstr ""

#: en.xml:14997(screen) 
#, no-wrap
msgid "\n$ locale\nLANG=\nLC_COLLATE=\"C\"\nLC_CTYPE=\"C\"\nLC_MESSAGES=\"C\"\nLC_MONETARY=\"C\"\nLC_NUMERIC=\"C\"\nLC_TIME=\"C\"\nLC_ALL=\"C\"\n"
msgstr ""

#: en.xml:15009(para) 
msgid "The output is a list of locale-related environment variables and their current values. In this example, the variables are all set to the default <literal moreinfo=\"none\">C</literal> locale, but users can set these variables to specific country/language code combinations. For example, if one were to set the <literal moreinfo=\"none\">LC_TIME</literal> variable to <literal moreinfo=\"none\">fr_CA</literal>, then programs would know to present time and date information formatted according a French-speaking Canadian's expectations. And if one were to set the <literal moreinfo=\"none\">LC_MESSAGES</literal> variable to <literal moreinfo=\"none\">zh_TW</literal>, then programs would know to present human-readable messages in Traditional Chinese. Setting the <literal moreinfo=\"none\">LC_ALL</literal> variable has the effect of changing every locale variable to the same value. The value of <literal moreinfo=\"none\">LANG</literal> is used as a default value for any locale variable that is unset. To see the list of available locales on a Unix system, run the command <command moreinfo=\"none\">locale -a</command>."
msgstr ""

#: en.xml:15028(para) 
msgid "On Windows, locale configuration is done via the <quote>Regional and Language Options</quote> control panel item. There you can view and select the values of individual settings from the available locales, and even customize (at a sickening level of detail) several of the display formatting conventions."
msgstr ""

#: en.xml:15039(title) 
msgid "Subversion's use of locales"
msgstr ""

#: en.xml:15041(para) 
msgid "The Subversion client, <command moreinfo=\"none\">svn</command>, honors the current locale configuration in two ways. First, it notices the value of the <literal moreinfo=\"none\">LC_MESSAGES</literal> variable and attempts to print all messages in the specified language. For example:"
msgstr ""

#: en.xml:15047(screen) 
#, no-wrap
msgid "\n$ export LC_MESSAGES=de_DE\n$ svn help cat\ncat: Gibt den Inhalt der angegebenen Dateien oder URLs aus.\nAufruf: cat ZIEL[@REV]...\n…\n"
msgstr ""

#: en.xml:15055(para) 
msgid "This behavior works identically on both Unix and Windows systems. Note, though, that while your operating system might have support for a certain locale, the Subversion client still may not be able to speak the particular language. In order to produce localized messages, human volunteers must provide translations for each language. The translations are written using the GNU gettext package, which results in translation modules that end with the <filename moreinfo=\"none\">.mo</filename> filename extension. For example, the German translation file is named <filename moreinfo=\"none\">de.mo</filename>. These translation files are installed somewhere on your system. On Unix, they typically live in <filename moreinfo=\"none\">/usr/share/locale/</filename>, while on Windows they're often found in the <filename moreinfo=\"none\">\\share\\locale\\</filename> folder in Subversion's installation area. Once installed, a module is named after the program it provides translations for. For example, the <filename moreinfo=\"none\">de.mo</filename> file may ultimately end up installed as <filename moreinfo=\"none\">/usr/share/locale/de/LC_MESSAGES/subversion.mo</filename>. By browsing the installed <filename moreinfo=\"none\">.mo</filename> files, you can see which languages the Subversion client is able to speak."
msgstr ""

#: en.xml:15078(para) 
msgid "The second way in which the locale is honored involves how <command moreinfo=\"none\">svn</command> interprets your input. The repository stores all paths, filenames, and log messages in Unicode, encoded as UTF-8. In that sense, the repository is <firstterm>internationalized</firstterm>—that is, the repository is ready to accept input in any human language. This means, however, that the Subversion client is responsible for sending only UTF-8 filenames and log messages into the repository. In order to do this, it must convert the data from the native locale into UTF-8."
msgstr ""

#: en.xml:15089(para) 
msgid "For example, suppose you create a file named<filename moreinfo=\"none\">caffè.txt</filename>, and then when committing the file, you write the log message as <quote>Adesso il caffè è più forte</quote>. Both the filename and log message contain non-ASCII characters, but because your locale is set to <literal moreinfo=\"none\">it_IT</literal>, the Subversion client knows to interpret them as Italian. It uses an Italian character set to convert the data to UTF-8 before sending them off to the repository."
msgstr ""

#: en.xml:15099(para) 
msgid "Note that while the repository demands UTF-8 filenames and log messages, it <emphasis>does not</emphasis> pay attention to file contents. Subversion treats file contents as opaque strings of bytes, and neither client nor server makes an attempt to understand the character set or encoding of the contents."
msgstr ""

#: en.xml:15107(title) 
msgid "Character set conversion errors"
msgstr ""

#: en.xml:15109(para) 
msgid "While using Subversion, you might get hit with an error related to character set conversions:"
msgstr ""

#: en.xml:15112(screen) 
#, no-wrap
msgid "\nsvn: Can't convert string from native encoding to 'UTF-8':\n…\nsvn: Can't convert string from 'UTF-8' to native encoding:\n…\n"
msgstr ""

#: en.xml:15119(para) 
msgid "Errors like this typically occur when the Subversion client has received a UTF-8 string from the repository, but not all of the characters in that string can be represented using the encoding of the current locale. For example, if your locale is <literal moreinfo=\"none\">en_US</literal> but a collaborator has committed a Japanese filename, you're likely to see this error when you receive the file during an <command moreinfo=\"none\">svn update</command>."
msgstr ""

#: en.xml:15128(para) 
msgid "The solution is either to set your locale to something which <emphasis>can</emphasis> represent the incoming UTF-8 data, or to change the filename or log message in the repository. (And don't forget to slap your collaborator's hand—projects should decide on common languages ahead of time, so that all participants are using the same locale.)"
msgstr ""

#: en.xml:15145(title) 
msgid "Using External Differencing Tools"
msgstr ""

#: en.xml:15147(para) 
msgid "The presence of <option>--diff-cmd</option> and <option>--diff3-cmd</option> options, and similarly named runtime configuration parameters (see <xref linkend=\"svn.advanced.confarea.opts.config\"/>), can lead to a false notion of how easy it is to use external differencing (or <quote>diff</quote>) and merge tools with Subversion. While Subversion can use most of popular such tools available, the effort invested in setting this up often turns out to be non-trivial."
msgstr ""

#: en.xml:15167(para) 
msgid "Subversion developers are good, but even the best make mistakes."
msgstr ""

#: en.xml:15156(para) 
msgid "The interface between Subversion and external diff and merge tools harkens back to a time when Subversion's only contextual differencing capabilities were built around invocations of the GNU diffutils toolchain, specifically the <command moreinfo=\"none\">diff</command> and <command moreinfo=\"none\">diff3</command> utilities. To get the kind of behavior Subversion needed, it called these utilities with more than a handful of options and parameters, most of which were quite specific to the utilities. Some time later, Subversion grew its own internal differencing library, and as a failover mechanism, <footnote><placeholder-1/></footnote> the <option>--diff-cmd</option> and <option>--diff3-cmd</option> options were added to the Subversion command-line client so users could more easily indicate that they preferred to use the GNU diff and diff3 utilities instead of the newfangled internal diff library. If those options were used, Subversion would simply ignore the internal diff library, and fall back to running those external programs, lengthy argument lists and all. And that's where things remain today."
msgstr ""

#: en.xml:15179(para) 
msgid "It didn't take long for folks to realize that having such easy configuration mechanisms for specifying that Subversion should use the external GNU diff and diff3 utilities located at a particular place on the system could be applied toward the use of other diff and merge tools, too. After all, Subversion didn't actually verify that the things it was being told to run were members of the GNU diffutils toolchain. But the only configurable aspect of using those external tools is their location on the system—not the option set, parameter order, etc. Subversion continues throwing all those GNU utility options at your external diff tool regardless of whether or not that program can understand those options. And that's where things get unintuitive for most users."
msgstr ""

#: en.xml:15193(para) 
msgid "The key to using external diff and merge tools (other than GNU diff and diff3, of course) with Subversion is to use wrapper scripts which convert the input from Subversion into something that your differencing tool can understand, and then to convert the output of your tool back into a format which Subversion expects—the format that the GNU tools would have used. The following sections cover the specifics of those expectations."
msgstr ""

#: en.xml:15203(para) 
msgid "The decision on when to fire off a contextual diff or merge as part of a larger Subversion operation is made entirely by Subversion, and is affected by, among other things, whether or not the files being operated on are human-readable as determined by their <literal moreinfo=\"none\">svn:mime-type</literal> property. This means, for example, that even if you had the niftiest Microsoft Word-aware differencing or merging tool in the Universe, it would never be invoked by Subversion so long as your versioned Word documents had a configured MIME type that denoted that they were not human-readable (such as <literal moreinfo=\"none\">application/msword</literal>). For more about MIME type settings, see <xref linkend=\"svn.advanced.props.special.mime-type\"/>"
msgstr ""

#: en.xml:15220(title) 
msgid "External diff"
msgstr ""

#: en.xml:15237(para) 
msgid "The GNU diff manual page puts it this way: <quote>An exit status of 0 means no differences were found, 1 means some differences were found, and 2 means trouble.</quote>"
msgstr ""

#: en.xml:15222(para) 
msgid "Subversion calls external diff programs with parameters suitable for the GNU diff utility, and expects only that the external program return with a successful error code. For most alternative diff program, only the sixth and seventh arguments, the paths of the files which represent the left and right sides of the diff, respectively, are of interest. Note that Subversion runs the diff program once per modified file covered by the Subversion operation, so if your program runs in an asynchronous fashion (or <quote>backgrounded</quote>), you might have several instances of it all running simultaneously. Finally, Subversion expects that your program return an errorcode of 1 if your program detected differences, or 0 if it did not—any other errorcode is considered a fatal error. <footnote><placeholder-1/></footnote>"
msgstr ""

#: en.xml:15243(para) 
msgid "<xref linkend=\"svn.advanced.externaldifftools.diff.ex-1\"/> and <xref linkend=\"svn.advanced.externaldifftools.diff.ex-2\"/> are templates for external diff tool wrappers in the Bourne shell and Windows batch scripting languages, respectively."
msgstr ""

#: en.xml:15250(title) 
msgid "diffwrap.sh"
msgstr ""

#: en.xml:15251(programlisting) 
#, no-wrap
msgid "\n#!/bin/sh\n\n# Configure your favorite diff program here.\nDIFF=\"/usr/local/bin/my-diff-tool\"\n\n# Subversion provides the paths we need as the sixth and seventh \n# parameters.\nLEFT=${6}\nRIGHT=${7}\n\n# Call the diff command (change the following line to make sense for\n# your merge program).\n$DIFF --left $LEFT --right $RIGHT\n\n# Return an errorcode of 0 if no differences were detected, 1 if some were.\n# Any other errorcode will be treated as fatal.\n"
msgstr ""

#: en.xml:15272(title) 
msgid "diffwrap.bat"
msgstr ""

#: en.xml:15273(programlisting) 
#, no-wrap
msgid "\n@ECHO OFF\n\nREM Configure your favorite diff program here.\nSET DIFF=\"C:\\Program Files\\Funky Stuff\\My Diff Tool.exe\"\n\nREM Subversion provides the paths we need as the sixth and seventh \nREM parameters.\nSET LEFT=%6\nSET RIGHT=%7\n\nREM Call the diff command (change the following line to make sense for\nREM your merge program).\n%DIFF% --left %LEFT% --right %RIGHT%\n\nREM Return an errorcode of 0 if no differences were detected, 1 if some were.\nREM Any other errorcode will be treated as fatal.\n"
msgstr ""

#: en.xml:15296(title) 
msgid "External diff3"
msgstr ""

#: en.xml:15298(para) 
msgid "Subversion calls external merge programs with parameters suitable for the GNU diff3 utility, expecting that the external program return with a successful error code and that the full file contents which result from the completed merge operation are printed on the standard output stream (so that Subversion can redirect them into the appropriate version controlled file). For most alternative merge programs, only the ninth, tenth, and eleventh arguments, the paths of the files which represent the <quote>mine</quote>, <quote>older</quote>, and <quote>yours</quote> inputs, respectively, are of interest. Note that because Subversion depends on the output of your merge program, you wrapper script must not exit before that output has been delivered to Subversion. When it finally does exit, it should return an errorcode of 0 if the merge was successful, or 1 if unresolved conflicts remain in the output—any other errorcode is considered a fatal error."
msgstr ""

#: en.xml:15316(para) 
msgid "<xref linkend=\"svn.advanced.externaldifftools.diff3.ex-1\"/> and <xref linkend=\"svn.advanced.externaldifftools.diff3.ex-2\"/> are templates for external merge tool wrappers in the Bourne shell and Windows batch scripting languages, respectively."
msgstr ""

#: en.xml:15322(title) 
msgid "diff3wrap.sh"
msgstr ""

#: en.xml:15323(programlisting) 
#, no-wrap
msgid "\n#!/bin/sh\n\n# Configure your favorite diff3/merge program here.\nDIFF3=\"/usr/local/bin/my-merge-tool\"\n\n# Subversion provides the paths we need as the ninth, tenth, and eleventh \n# parameters.\nMINE=${9}\nOLDER=${10}\nYOURS=${11}\n\n# Call the merge command (change the following line to make sense for\n# your merge program).\n$DIFF3 --older $OLDER --mine $MINE --yours $YOURS\n\n# After performing the merge, this script needs to print the contents\n# of the merged file to stdout.  Do that in whatever way you see fit.\n# Return an errorcode of 0 on successful merge, 1 if unresolved conflicts\n# remain in the result.  Any other errorcode will be treated as fatal.\n"
msgstr ""

#: en.xml:15347(title) 
msgid "diff3wrap.bat"
msgstr ""

#: en.xml:15348(programlisting) 
#, no-wrap
msgid "\n@ECHO OFF\n\nREM Configure your favorite diff3/merge program here.\nSET DIFF3=\"C:\\Program Files\\Funky Stuff\\My Merge Tool.exe\"\n\nREM Subversion provides the paths we need as the ninth, tenth, and eleventh \nREM parameters.  But we only have access to nine parameters at a time, so we\nREM shift our nine-parameter window twice to let us get to what we need.\nSHIFT\nSHIFT\nSET MINE=%7\nSET OLDER=%8\nSET YOURS=%9\n\nREM Call the merge command (change the following line to make sense for\nREM your merge program).\n%DIFF3% --older %OLDER% --mine %MINE% --yours %YOURS%\n\nREM After performing the merge, this script needs to print the contents\nREM of the merged file to stdout.  Do that in whatever way you see fit.\nREM Return an errorcode of 0 on successful merge, 1 if unresolved conflicts\nREM remain in the result.  Any other errorcode will be treated as fatal.\n"
msgstr ""

#: en.xml:15381(title) 
msgid "Subversion Repository URLs"
msgstr ""

#: en.xml:15383(para) 
msgid "As illustrated throughout this book, Subversion uses URLs to identify versioned resources in Subversion repositories. For the most part, these URLs use the standard syntax, allowing for server names and port numbers to be specified as part of the URL:"
msgstr ""

#: en.xml:15389(screen) 
#, no-wrap
msgid "\n$ svn checkout http://svn.example.com:9834/repos\n…\n"
msgstr ""

#: en.xml:15394(para) 
msgid "But there are some nuances in Subversion's handling of URLs that are notable. For example, URLs containing the <literal moreinfo=\"none\">file:</literal> access method (used for local repositories) must, in accordance with convention, have either a server name of <literal moreinfo=\"none\">localhost</literal> or no server name at all:"
msgstr ""

#: en.xml:15401(screen) 
#, no-wrap
msgid "\n$ svn checkout file:///path/to/repos\n…\n$ svn checkout file://localhost/path/to/repos\n…\n"
msgstr ""

#: en.xml:15408(para) 
msgid "Also, users of the <literal moreinfo=\"none\">file:</literal> scheme on Windows platforms will need to use an unofficially <quote>standard</quote> syntax for accessing repositories that are on the same machine, but on a different drive than the client's current working drive. Either of the two following URL path syntaxes will work where <literal moreinfo=\"none\">X</literal> is the drive on which the repository resides:"
msgstr ""

#: en.xml:15417(screen) 
#, no-wrap
msgid "\nC:\\&gt; svn checkout file:///X:/path/to/repos\n…\nC:\\&gt; svn checkout \"file:///X|/path/to/repos\"\n…\n"
msgstr ""

#: en.xml:15424(para) 
msgid "In the second syntax, you need to quote the URL so that the vertical bar character is not interpreted as a pipe. Also, note that a URL uses ordinary slashes even though the native (non-URL) form of a path on Windows uses backslashes."
msgstr ""

#: en.xml:15429(para) 
msgid "Finally, it should be noted that the Subversion client will automatically encode URLs as necessary, just like a web browser does. For example, if a URL contains a space or upper-ASCII character:"
msgstr ""

#: en.xml:15434(screen) 
#, no-wrap
msgid "\n$ svn checkout \"http://host/path with space/project/españa\"\n"
msgstr ""

#: en.xml:15438(para) 
msgid "…then Subversion will escape the unsafe characters and behave as if you had typed:"
msgstr ""

#: en.xml:15441(screen) 
#, no-wrap
msgid "\n$ svn checkout http://host/path%20with%20space/project/espa%C3%B1a\n"
msgstr ""

#: en.xml:15445(para) 
msgid "If the URL contains spaces, be sure to place it within quote marks, so that your shell treats the whole thing as a single argument to the <command moreinfo=\"none\">svn</command> program."
msgstr ""

#: en.xml:15460(title) 
msgid "Developer Information"
msgstr ""

#: en.xml:15463(para) 
msgid "Subversion is an open-source software project developed under an Apache-style software license. The project is financially backed by CollabNet, Inc., a California-based software development company. The community that has formed around the development of Subversion always welcomes new members who can donate their time and attention to the project. Volunteers are encouraged to assist in any way they can, whether that means finding and diagnosing bugs, refining existing source code, or fleshing out whole new features."
msgstr ""

#: en.xml:15473(para) 
msgid "This chapter is for those who wish to assist in the continued evolution of Subversion by actually getting their hands dirty with the source code. We will cover some of the software's more intimate details, the kind of technical nitty-gritty that those developing Subversion itself—or writing entirely new tools based on the Subversion libraries—should be aware of. If you don't foresee yourself participating with the software at such a level, feel free to skip this chapter with confidence that your experience as a Subversion user will not be affected."
msgstr ""

#: en.xml:15490(title) 
msgid "Layered Library Design"
msgstr ""

#: en.xml:15492(para) 
msgid "Subversion has a modular design, implemented as a collection of C libraries. Each library has a well-defined purpose and interface, and most modules are said to exist in one of three main layers—the Repository Layer, the Repository Access (RA) Layer, or the Client Layer. We will examine these layers shortly, but first, see our brief inventory of Subversion's libraries in <xref linkend=\"svn.developer.layerlib.tbl-1\"/>. For the sake of consistency, we will refer to the libraries by their extensionless Unix library names (e.g.: libsvn_fs, libsvn_wc, mod_dav_svn)."
msgstr ""

#: en.xml:15504(title) 
msgid "A Brief Inventory of the Subversion Libraries"
msgstr ""

#: en.xml:15508(entry) 
msgid "Library"
msgstr ""

#: en.xml:15509(entry) en.xml:17811(title) en.xml:17910(title) en.xml:17973(title) en.xml:18050(title) en.xml:18180(title) en.xml:18251(title) en.xml:18385(title) en.xml:18552(title) en.xml:18658(title) en.xml:18902(title) en.xml:19008(title) en.xml:19054(title) en.xml:19149(title) en.xml:19302(title) en.xml:19409(title) en.xml:19501(title) en.xml:19740(title) en.xml:19852(title) en.xml:19930(title) en.xml:20038(title) en.xml:20110(title) en.xml:20178(title) en.xml:20253(title) en.xml:20334(title) en.xml:20461(title) en.xml:20542(title) en.xml:20639(title) en.xml:21041(title) en.xml:21190(title) en.xml:21276(title) en.xml:21555(title) en.xml:21611(title) en.xml:21644(title) en.xml:21747(title) en.xml:21773(title) en.xml:21809(title) en.xml:21834(title) en.xml:21874(title) en.xml:21932(title) en.xml:21973(title) en.xml:22012(title) en.xml:22082(title) en.xml:22120(title) en.xml:22167(title) en.xml:22220(title) en.xml:22347(title) en.xml:22386(title) en.xml:22437(title) en.xml:22529(title) en.xml:22568(title) en.xml:22632(title) en.xml:22671(title) en.xml:22698(title) en.xml:22755(title) en.xml:22799(title) en.xml:22843(title) en.xml:22882(title) en.xml:22930(title) en.xml:22988(title) en.xml:23036(title) en.xml:23067(title) en.xml:23269(title) en.xml:23397(title) en.xml:23542(title) en.xml:24717(entry) 
msgid "Description"
msgstr ""

#: en.xml:15514(entry) 
msgid "libsvn_client"
msgstr ""

#: en.xml:15515(entry) 
msgid "Primary interface for client programs"
msgstr ""

#: en.xml:15518(entry) 
msgid "libsvn_delta"
msgstr ""

#: en.xml:15519(entry) 
msgid "Tree and byte-stream differencing routines"
msgstr ""

#: en.xml:15522(entry) 
msgid "libsvn_diff"
msgstr ""

#: en.xml:15523(entry) 
msgid "Contextual differencing and merging routines"
msgstr ""

#: en.xml:15526(entry) 
msgid "libsvn_fs"
msgstr ""

#: en.xml:15527(entry) 
msgid "Filesystem commons and module loader"
msgstr ""

#: en.xml:15530(entry) 
msgid "libsvn_fs_base"
msgstr ""

#: en.xml:15531(entry) 
msgid "The Berkeley DB filesystem back-end"
msgstr ""

#: en.xml:15534(entry) 
msgid "libsvn_fs_fs"
msgstr ""

#: en.xml:15535(entry) 
msgid "The native filesystem (FSFS) back-end"
msgstr ""

#: en.xml:15538(entry) 
msgid "libsvn_ra"
msgstr ""

#: en.xml:15539(entry) 
msgid "Repository Access commons and module loader"
msgstr ""

#: en.xml:15542(entry) 
msgid "libsvn_ra_dav"
msgstr ""

#: en.xml:15543(entry) 
msgid "The WebDAV Repository Access module"
msgstr ""

#: en.xml:15546(entry) 
msgid "libsvn_ra_local"
msgstr ""

#: en.xml:15547(entry) 
msgid "The local Repository Access module"
msgstr ""

#: en.xml:15550(entry) 
msgid "libsvn_ra_svn"
msgstr ""

#: en.xml:15551(entry) 
msgid "The custom protocol Repository Access module"
msgstr ""

#: en.xml:15554(entry) 
msgid "libsvn_repos"
msgstr ""

#: en.xml:15555(entry) 
msgid "Repository interface"
msgstr ""

#: en.xml:15558(entry) 
msgid "libsvn_subr"
msgstr ""

#: en.xml:15559(entry) 
msgid "Miscellaneous helpful subroutines"
msgstr ""

#: en.xml:15562(entry) 
msgid "libsvn_wc"
msgstr ""

#: en.xml:15563(entry) 
msgid "The working copy management library"
msgstr ""

#: en.xml:15566(entry) 
msgid "mod_authz_svn"
msgstr ""

#: en.xml:15567(entry) 
msgid "Apache authorization module for Subversion repositories access via WebDAV"
msgstr ""

#: en.xml:15572(entry) 
msgid "Apache module for mapping WebDAV operations to Subversion ones"
msgstr ""

#: en.xml:15579(para) 
msgid "The fact that the word <quote>miscellaneous</quote> only appears once in <xref linkend=\"svn.developer.layerlib.tbl-1\"/> is a good sign. The Subversion development team is serious about making sure that functionality lives in the right layer and libraries. Perhaps the greatest advantage of the modular design is its lack of complexity from a developer's point of view. As a developer, you can quickly formulate that kind of <quote>big picture</quote> that allows you to pinpoint the location of certain pieces of functionality with relative ease."
msgstr ""

#: en.xml:15589(para) 
msgid "Another benefit of modularity is the ability to replace a given module with a whole new library that implements the same API without affecting the rest of the code base. In some sense, this happens within Subversion already. The libsvn_ra_dav, libsvn_ra_local, and libsvn_ra_svn all implement the same interface. And all three communicate with the Repository Layer—libsvn_ra_dav and libsvn_ra_svn do so across a network, and libsvn_ra_local connects to it directly. The libsvn_fs_base and libsvn_fs_fs libraries are another example of this."
msgstr ""

#: en.xml:15600(para) 
msgid "The client itself also highlights modularity in the Subversion design. While Subversion itself comes with only a command-line client program, there are several third party programs which provide various forms of client GUI. These GUIs use the same APIs that the stock command-line client does. Subversion's libsvn_client library is the one-stop shop for most of the functionality necessary for designing a working Subversion client (see <xref linkend=\"svn.developer.layerlib.client\"/>)."
msgstr ""

#: en.xml:15611(title) 
msgid "Repository Layer"
msgstr ""

#: en.xml:15613(para) 
msgid "When referring to Subversion's Repository Layer, we're generally talking about two libraries—the repository library, and the filesystem library. These libraries provide the storage and reporting mechanisms for the various revisions of your version-controlled data. This layer is connected to the Client Layer via the Repository Access Layer, and is, from the perspective of the Subversion user, the stuff at the <quote>other end of the line.</quote>"
msgstr ""

#: en.xml:15622(para) 
msgid "The Subversion Filesystem is accessed via the libsvn_fs API, and is not a kernel-level filesystem that one would install in an operating system (like the Linux ext2 or NTFS), but a virtual filesystem. Rather than storing <quote>files</quote> and <quote>directories</quote> as real files and directories (as in, the kind you can navigate through using your favorite shell program), it uses one of two available abstract storage backends—either a Berkeley DB database environment, or a flat-file representation. (To learn more about the two repository back-ends, see <xref linkend=\"svn.reposadmin.basics.backends\"/>.) However, there has been considerable interest by the development community in giving future releases of Subversion the ability to use other back-end database systems, perhaps through a mechanism such as Open Database Connectivity (ODBC)."
msgstr ""

#: en.xml:15637(para) 
msgid "The filesystem API exported by libsvn_fs contains the kinds of functionality you would expect from any other filesystem API: you can create and remove files and directories, copy and move them around, modify file contents, and so on. It also has features that are not quite as common, such as the ability to add, modify, and remove metadata (<quote>properties</quote>) on each file or directory. Furthermore, the Subversion Filesystem is a versioning filesystem, which means that as you make changes to your directory tree, Subversion remembers what your tree looked like before those changes. And before the previous changes. And the previous ones. And so on, all the way back through versioning time to (and just beyond) the moment you first started adding things to the filesystem."
msgstr ""

#: en.xml:15652(para) 
msgid "All the modifications you make to your tree are done within the context of a Subversion transaction. The following is a simplified general routine for modifying your filesystem:"
msgstr ""

#: en.xml:15659(para) 
msgid "Begin a Subversion transaction."
msgstr ""

#: en.xml:15662(para) 
msgid "Make your changes (adds, deletes, property modifications, etc.)."
msgstr ""

#: en.xml:15666(para) 
msgid "Commit your transaction."
msgstr ""

#: en.xml:15670(para) 
msgid "Once you have committed your transaction, your filesystem modifications are permanently stored as historical artifacts. Each of these cycles generates a single new revision of your tree, and each revision is forever accessible as an immutable snapshot of <quote>the way things were.</quote>"
msgstr ""

#: en.xml:15677(title) 
msgid "The Transaction Distraction"
msgstr ""

#: en.xml:15679(para) 
msgid "The notion of a Subversion transaction, especially given its close proximity to the database code in libsvn_fs, can become easily confused with the transaction support provided by the underlying database itself. Both types of transaction exist to provide atomicity and isolation. In other words, transactions give you the ability to perform a set of actions in an <quote>all or nothing</quote> fashion—either all the actions in the set complete with success, or they all get treated as if <emphasis>none</emphasis> of them ever happened—and in a way that does not interfere with other processes acting on the data."
msgstr ""

#: en.xml:15692(para) 
msgid "Database transactions generally encompass small operations related specifically to the modification of data in the database itself (such as changing the contents of a table row). Subversion transactions are larger in scope, encompassing higher-level operations like making modifications to a set of files and directories which are intended to be stored as the next revision of the filesystem tree. If that isn't confusing enough, consider this: Subversion uses a database transaction during the creation of a Subversion transaction (so that if the creation of Subversion transaction fails, the database will look as if we had never attempted that creation in the first place)!"
msgstr ""

#: en.xml:15706(para) 
msgid "Fortunately for users of the filesystem API, the transaction support provided by the database system itself is hidden almost entirely from view (as should be expected from a properly modularized library scheme). It is only when you start digging into the implementation of the filesystem itself that such things become visible (or interesting)."
msgstr ""

#: en.xml:15716(para) 
msgid "Most of the functionality provided by the filesystem interface comes as an action that occurs on a filesystem path. That is, from outside of the filesystem, the primary mechanism for describing and accessing the individual revisions of files and directories comes through the use of path strings like <filename moreinfo=\"none\">/foo/bar</filename>, just as if you were addressing files and directories through your favorite shell program. You add new files and directories by passing their paths-to-be to the right API functions. You query for information about them by the same mechanism."
msgstr ""

#: en.xml:15727(para) 
msgid "Unlike most filesystems, though, a path alone is not enough information to identify a file or directory in Subversion. Think of a directory tree as a two-dimensional system, where a node's siblings represent a sort of left-and-right motion, and descending into subdirectories a downward motion. <xref linkend=\"svn.developer.layerlib.repos.dia-1\"/> shows a typical representation of a tree as exactly that."
msgstr ""

#: en.xml:15736(title) 
msgid "Files and directories in two dimensions"
msgstr ""

#: en.xml:15743(para) 
msgid "We understand that this may come as a shock to sci-fi fans who have long been under the impression that Time was actually the <emphasis>fourth</emphasis> dimension, and we apologize for any emotional trauma induced by our assertion of a different theory."
msgstr ""

#: en.xml:15740(para) 
msgid "Of course, the Subversion filesystem has a nifty third dimension that most filesystems do not have—Time! <footnote><placeholder-1/></footnote> In the filesystem interface, nearly every function that has a <parameter moreinfo=\"none\">path</parameter> argument also expects a <parameter moreinfo=\"none\">root</parameter> argument. This <structname>svn_fs_root_t</structname> argument describes either a revision or a Subversion transaction (which is usually just a revision-to-be), and provides that third-dimensional context needed to understand the difference between <filename moreinfo=\"none\">/foo/bar</filename> in revision 32, and the same path as it exists in revision 98. <xref linkend=\"svn.developer.layerlib.repos.dia-2\"/> shows revision history as an added dimension to the Subversion filesystem universe."
msgstr ""

#: en.xml:15761(title) 
msgid "Versioning time—the third dimension!"
msgstr ""

#. Perhaps dig into the DAG/tree layers a bit here, talking
#.            about the hard-link design and how that affords such
#.            pleasures as cheap copies.  If "bubble-up" isn't covered
#.            twelve other times in the book, maybe give it a go here.
#: en.xml:15770(para) 
msgid "As we mentioned earlier, the libsvn_fs API looks and feels like any other filesystem, except that it has this wonderful versioning capability. It was designed to be usable by any program interested in a versioning filesystem. Not coincidentally, Subversion itself is interested in that functionality. But while the filesystem API should be sufficient for basic file and directory versioning support, Subversion wants more—and that is where libsvn_repos comes in."
msgstr ""

#: en.xml:15780(para) 
msgid "The Subversion repository library (libsvn_repos) is basically a wrapper library around the filesystem functionality. This library is responsible for creating the repository layout, making sure that the underlying filesystem is initialized, and so on. Libsvn_repos also implements a set of hooks—scripts that are executed by the repository code when certain actions take place. These scripts are useful for notification, authorization, or whatever purposes the repository administrator desires. This type of functionality, and other utilities provided by the repository library, are not strictly related to implementing a versioning filesystem, which is why it was placed into its own library."
msgstr ""

#: en.xml:15794(para) 
msgid "Developers who wish to use the libsvn_repos API will find that it is not a complete wrapper around the filesystem interface. That is, only certain major events in the general cycle of filesystem activity are wrapped by the repository interface. Some of these include the creation and commit of Subversion transactions, and the modification of revision properties. These particular events are wrapped by the repository layer because they have hooks associated with them. In the future, other events may be wrapped by the repository API. All of the remaining filesystem interaction will continue to occur directly via the libsvn_fs API, though."
msgstr ""

#: en.xml:15806(para) 
msgid "For example, here is a code segment that illustrates the use of both the repository and filesystem interfaces to create a new revision of the filesystem in which a directory is added. Note that in this example (and all others throughout this book), the <function moreinfo=\"none\">SVN_ERR()</function> macro simply checks for a non-successful error return from the function it wraps, and returns that error if it exists."
msgstr ""

#: en.xml:15815(title) 
msgid "Using the Repository Layer"
msgstr ""

#: en.xml:15817(programlisting) 
#, no-wrap
msgid "\n/* Create a new directory at the path NEW_DIRECTORY in the Subversion\n   repository located at REPOS_PATH.  Perform all memory allocation in\n   POOL.  This function will create a new revision for the addition of\n   NEW_DIRECTORY.  */\nstatic svn_error_t *\nmake_new_directory (const char *repos_path,\n                    const char *new_directory,\n                    apr_pool_t *pool)\n{\n  svn_error_t *err;\n  svn_repos_t *repos;\n  svn_fs_t *fs;\n  svn_revnum_t youngest_rev;\n  svn_fs_txn_t *txn;\n  svn_fs_root_t *txn_root;\n  const char *conflict_str;\n\n  /* Open the repository located at REPOS_PATH.  */\n  SVN_ERR (svn_repos_open (&amp;repos, repos_path, pool));\n\n  /* Get a pointer to the filesystem object that is stored in\n     REPOS.  */\n  fs = svn_repos_fs (repos);\n\n  /* Ask the filesystem to tell us the youngest revision that\n     currently exists.  */\n  SVN_ERR (svn_fs_youngest_rev (&amp;youngest_rev, fs, pool));\n\n  /* Begin a new transaction that is based on YOUNGEST_REV.  We are\n     less likely to have our later commit rejected as conflicting if we\n     always try to make our changes against a copy of the latest snapshot\n     of the filesystem tree.  */\n  SVN_ERR (svn_fs_begin_txn (&amp;txn, fs, youngest_rev, pool));\n\n  /* Now that we have started a new Subversion transaction, get a root\n     object that represents that transaction.  */\n  SVN_ERR (svn_fs_txn_root (&amp;txn_root, txn, pool));\n  \n  /* Create our new directory under the transaction root, at the path\n     NEW_DIRECTORY.  */\n  SVN_ERR (svn_fs_make_dir (txn_root, new_directory, pool));\n\n  /* Commit the transaction, creating a new revision of the filesystem\n     which includes our added directory path.  */\n  err = svn_repos_fs_commit_txn (&amp;conflict_str, repos, \n                                 &amp;youngest_rev, txn, pool);\n  if (! err)\n    {\n      /* No error?  Excellent!  Print a brief report of our success.  */\n      printf (\"Directory '%s' was successfully added as new revision \"\n              \"'%ld'.\\n\", new_directory, youngest_rev);\n    }\n  else if (err-&gt;apr_err == SVN_ERR_FS_CONFLICT)\n    {\n      /* Uh-oh.  Our commit failed as the result of a conflict\n         (someone else seems to have made changes to the same area \n         of the filesystem that we tried to modify).  Print an error\n         message.  */\n      printf (\"A conflict occurred at path '%s' while attempting \"\n              \"to add directory '%s' to the repository at '%s'.\\n\", \n              conflict_str, new_directory, repos_path);\n    }\n  else\n    {\n      /* Some other error has occurred.  Print an error message.  */\n      printf (\"An error occurred while attempting to add directory '%s' \"\n              \"to the repository at '%s'.\\n\", \n              new_directory, repos_path);\n    }\n\n  /* Return the result of the attempted commit to our caller.  */\n  return err;\n} \n"
msgstr ""

#: en.xml:15894(para) 
msgid "In the previous code segment, calls were made to both the repository and filesystem interfaces. We could just as easily have committed the transaction using <function moreinfo=\"none\">svn_fs_commit_txn()</function>. But the filesystem API knows nothing about the repository library's hook mechanism. If you want your Subversion repository to automatically perform some set of non-Subversion tasks every time you commit a transaction (like, for example, sending an email that describes all the changes made in that transaction to your developer mailing list), you need to use the libsvn_repos-wrapped version of that function—<function moreinfo=\"none\">svn_repos_fs_commit_txn()</function>. This function will actually first run the <literal moreinfo=\"none\">pre-commit</literal> hook script if one exists, then commit the transaction, and finally will run a <literal moreinfo=\"none\">post-commit</literal> hook script. The hooks provide a special kind of reporting mechanism that does not really belong in the core filesystem library itself. (For more information regarding Subversion's repository hooks, see <xref linkend=\"svn.reposadmin.create.hooks\"/>.)"
msgstr ""

#: en.xml:15914(para) 
msgid "The hook mechanism requirement is but one of the reasons for the abstraction of a separate repository library from the rest of the filesystem code. The libsvn_repos API provides several other important utilities to Subversion. These include the abilities to:"
msgstr ""

#: en.xml:15922(para) 
msgid "create, open, destroy, and perform recovery steps on a Subversion repository and the filesystem included in that repository."
msgstr ""

#: en.xml:15927(para) 
msgid "describe the differences between two filesystem trees."
msgstr ""

#: en.xml:15931(para) 
msgid "query for the commit log messages associated with all (or some) of the revisions in which a set of files was modified in the filesystem."
msgstr ""

#: en.xml:15936(para) 
msgid "generate a human-readable <quote>dump</quote> of the filesystem, a complete representation of the revisions in the filesystem."
msgstr ""

#: en.xml:15941(para) 
msgid "parse that dump format, loading the dumped revisions into a different Subversion repository."
msgstr ""

#: en.xml:15946(para) 
msgid "As Subversion continues to evolve, the repository library will grow with the filesystem library to offer increased functionality and configurable option support."
msgstr ""

#: en.xml:15954(title) 
msgid "Repository Access Layer"
msgstr ""

#: en.xml:15956(para) 
msgid "If the Subversion Repository Layer is at <quote>the other end of the line</quote>, the Repository Access Layer is the line itself. Charged with marshalling data between the client libraries and the repository, this layer includes the libsvn_ra module loader library, the RA modules themselves (which currently includes libsvn_ra_dav, libsvn_ra_local, and libsvn_ra_svn), and any additional libraries needed by one or more of those RA modules, such as the mod_dav_svn Apache module with which libsvn_ra_dav communicates or libsvn_ra_svn's server, <command moreinfo=\"none\">svnserve</command>."
msgstr ""

#: en.xml:15967(para) 
msgid "Since Subversion uses URLs to identify its repository resources, the protocol portion of the URL schema (usually <literal moreinfo=\"none\">file:</literal>, <literal moreinfo=\"none\">http:</literal>, <literal moreinfo=\"none\">https:</literal>, or <literal moreinfo=\"none\">svn:</literal>) is used to determine which RA module will handle the communications. Each module registers a list of the protocols it knows how to <quote>speak</quote> so that the RA loader can, at runtime, determine which module to use for the task at hand. You can determine which RA modules are available to the Subversion command-line client, and what protocols they claim to support, by running <command moreinfo=\"none\">svn --version</command>:"
msgstr ""

#: en.xml:15979(screen) 
#, no-wrap
msgid "\n$ svn --version\nsvn, version 1.2.3 (r15833)\n   compiled Sep 13 2005, 22:45:22\n\nCopyright (C) 2000-2005 CollabNet.\nSubversion is open source software, see http://subversion.tigris.org/\nThis product includes software developed by CollabNet (http://www.Collab.Net/).\n\nThe following repository access (RA) modules are available:\n\n* ra_dav : Module for accessing a repository via WebDAV (DeltaV) protocol.\n  - handles 'http' scheme\n  - handles 'https' scheme\n* ra_svn : Module for accessing a repository using the svn network protocol.\n  - handles 'svn' scheme\n* ra_local : Module for accessing a repository on local disk.\n  - handles 'file' scheme\n\n"
msgstr ""

#: en.xml:16001(title) 
msgid "RA-DAV (Repository Access Using HTTP/DAV)"
msgstr ""

#: en.xml:16003(para) 
msgid "The libsvn_ra_dav library is designed for use by clients that are being run on different machines than the servers with which they communicating, specifically servers reached using URLs that contain the <literal moreinfo=\"none\">http:</literal> or <literal moreinfo=\"none\">https:</literal> protocol portions. To understand how this module works, we should first mention a couple of other key components in this particular configuration of the Repository Access Layer—the powerful Apache HTTP Server, and the Neon HTTP/WebDAV client library."
msgstr ""

#: en.xml:16013(para) 
msgid "Subversion's primary network server is the Apache HTTP Server. Apache is a time-tested, extensible open-source server process that is ready for serious use. It can sustain a high network load and runs on many platforms. The Apache server supports a number of different standard authentication protocols, and can be extended through the use of modules to support many others. It also supports optimizations like network pipelining and caching. By using Apache as a server, Subversion gets all of these features for free. And since most firewalls already allow HTTP traffic to pass through, system administrators typically don't even have to change their firewall configurations to allow Subversion to work."
msgstr ""

#: en.xml:16027(para) 
msgid "Subversion uses HTTP and WebDAV (with DeltaV) to communicate with an Apache server. You can read more about this in the WebDAV section of this chapter, but in short, WebDAV and DeltaV are extensions to the standard HTTP 1.1 protocol that enable sharing and versioning of files over the web. Apache 2.0 and later versions come with mod_dav, an Apache module that understands the DAV extensions to HTTP. Subversion itself supplies mod_dav_svn, though, which is another Apache module that works in conjunction with (really, as a back-end to) mod_dav to provide Subversion's specific implementations of WebDAV and DeltaV."
msgstr ""

#: en.xml:16039(para) 
msgid "When communicating with a repository over HTTP, the RA loader library chooses libsvn_ra_dav as the proper access module. The Subversion client makes calls into the generic RA interface, and libsvn_ra_dav maps those calls (which embody rather large-scale Subversion actions) to a set of HTTP/WebDAV requests. Using the Neon library, libsvn_ra_dav transmits those requests to the Apache server. Apache receives these requests (exactly as it does generic HTTP requests that your web browser might make), notices that the requests are directed at a URL that is configured as a DAV location (using the <literal moreinfo=\"none\">&lt;Location&gt;</literal> directive in <filename moreinfo=\"none\">httpd.conf</filename>), and hands the request off to its own mod_dav module. When properly configured, mod_dav knows to use Subversion's mod_dav_svn for any filesystem-related needs, as opposed to the generic mod_dav_fs that comes with Apache. So ultimately, the client is communicating with mod_dav_svn, which binds directly to the Subversion Repository Layer."
msgstr ""

#: en.xml:16058(para) 
msgid "That was a simplified description of the actual exchanges taking place, though. For example, the Subversion repository might be protected by Apache's authorization directives. This could result in initial attempts to communicate with the repository being rejected by Apache on authorization grounds. At this point, libsvn_ra_dav gets back the notice from Apache that insufficient identification was supplied, and calls back into the Client Layer to get some updated authentication data. If the data is supplied correctly, and the user has the permissions that Apache seeks, libsvn_ra_dav's next automatic attempt at performing the original operation will be granted, and all will be well. If sufficient authentication information cannot be supplied, the request will ultimately fail, and the client will report the failure to the user."
msgstr ""

#. A diagram here?
#: en.xml:16076(para) 
msgid "By using Neon and Apache, Subversion gets free functionality in several other complex areas, too. For example, if Neon finds the OpenSSL libraries, it allows the Subversion client to attempt to use SSL-encrypted communications with the Apache server (whose own mod_ssl can <quote>speak the language</quote>). Also, both Neon itself and Apache's mod_deflate can understand the <quote>deflate</quote> algorithm (the same one used by the PKZIP and gzip programs), so requests can be sent in smaller, compressed chunks across the wire. Other complex features that Subversion hopes to support in the future include the ability to automatically handle server-specified redirects (for example, when a repository has been moved to a new canonical URL) and taking advantage of HTTP pipelining."
msgstr ""

#: en.xml:16103(title) 
msgid "RA-SVN (Custom Protocol Repository Access)"
msgstr ""

#: en.xml:16105(para) 
msgid "In addition to the standard HTTP/WebDAV protocol, Subversion also provides an RA implementation that uses a custom protocol. The libsvn_ra_svn module implements its own network socket connectivity, and communicates with a stand-alone server—the <filename moreinfo=\"none\">svnserve</filename> program—on the machine that hosts the repository. Clients access the repository using the <literal moreinfo=\"none\">svn://</literal> schema."
msgstr ""

#: en.xml:16114(para) 
msgid "This RA implementation lacks most of the advantages of Apache mentioned in the previous section; however, it may be appealing to some system administrators nonetheless. It is dramatically easier to configure and run; setting up an <filename moreinfo=\"none\">svnserve</filename> process is nearly instantaneous. It is also much smaller (in terms of lines of code) than Apache, making it much easier to audit, for security reasons or otherwise. Furthermore, some system administrators may already have an SSH security infrastructure in place, and want Subversion to use it. Clients using ra_svn can easily tunnel the protocol over SSH."
msgstr ""

#: en.xml:16130(title) 
msgid "RA-Local (Direct Repository Access)"
msgstr ""

#: en.xml:16132(para) 
msgid "Not all communications with a Subversion repository require a powerhouse server process and a network layer. For users who simply wish to access the repositories on their local disk, they may do so using <literal moreinfo=\"none\">file:</literal> URLs and the functionality provided by libsvn_ra_local. This RA module binds directly with the repository and filesystem libraries, so no network communication is required at all."
msgstr ""

#: en.xml:16141(para) 
msgid "Subversion requires that the server name included as part of the <literal moreinfo=\"none\">file:</literal> URL be either <literal moreinfo=\"none\">localhost</literal> or empty, and that there be no port specification. In other words, your URLs should look like either <literal moreinfo=\"none\">file://localhost/path/to/repos</literal> or <literal moreinfo=\"none\">file:///path/to/repos</literal>."
msgstr ""

#: en.xml:16149(para) 
msgid "Also, be aware that Subversion's <literal moreinfo=\"none\">file:</literal> URLs cannot be used in a regular web browser the way typical <literal moreinfo=\"none\">file:</literal> URLs can. When you attempt to view a <literal moreinfo=\"none\">file:</literal> URL in a regular web browser, it reads and displays the contents of the file at that location by examining the filesystem directly. However, Subversion's resources exist in a virtual filesystem (see <xref linkend=\"svn.developer.layerlib.repos\"/>), and your browser will not understand how to read that filesystem."
msgstr ""

#: en.xml:16162(title) 
msgid "Your RA Library Here"
msgstr ""

#: en.xml:16164(para) 
msgid "For those who wish to access a Subversion repository using still another protocol, that is precisely why the Repository Access Layer is modularized! Developers can simply write a new library that implements the RA interface on one side and communicates with the repository on the other. Your new library can use existing network protocols, or you can invent your own. You could use inter-process communication (IPC) calls, or—let's get crazy, shall we?—you could even implement an email-based protocol. Subversion supplies the APIs; you supply the creativity."
msgstr ""

#: en.xml:16180(title) 
msgid "Client Layer"
msgstr ""

#: en.xml:16182(para) 
msgid "On the client side, the Subversion working copy is where all the action takes place. The bulk of functionality implemented by the client-side libraries exists for the sole purpose of managing working copies—directories full of files and other subdirectories which serve as a sort of local, editable <quote>reflection</quote> of one or more repository locations—and propagating changes to and from the Repository Access layer."
msgstr ""

#: en.xml:16191(para) 
msgid "Subversion's working copy library, libsvn_wc, is directly responsible for managing the data in the working copies. To accomplish this, the library stores administrative information about each working copy directory within a special subdirectory. This subdirectory, named <filename moreinfo=\"none\">.svn</filename>, is present in each working copy directory and contains various other files and directories which record state and provide a private workspace for administrative action. For those familiar with CVS, this <filename moreinfo=\"none\">.svn</filename> subdirectory is similar in purpose to the <filename moreinfo=\"none\">CVS</filename> administrative directories found in CVS working copies. For more information about the <filename moreinfo=\"none\">.svn</filename> administrative area, see <xref linkend=\"svn.developer.insidewc\"/>in this chapter."
msgstr ""

#: en.xml:16205(para) 
msgid "The Subversion client library, libsvn_client, has the broadest responsibility; its job is to mingle the functionality of the working copy library with that of the Repository Access Layer, and then to provide the highest-level API to any application that wishes to perform general revision control actions. For example, the function <function moreinfo=\"none\">svn_client_checkout()</function> takes a URL as an argument. It passes this URL to the RA layer and opens an authenticated session with a particular repository. It then asks the repository for a certain tree, and sends this tree into the working copy library, which then writes a full working copy to disk (<filename moreinfo=\"none\">.svn</filename> directories and all)."
msgstr ""

#: en.xml:16219(para) 
msgid "The client library is designed to be used by any application. While the Subversion source code includes a standard command-line client, it should be very easy to write any number of GUI clients on top of the client library. New GUIs (or any new client, really) for Subversion need not be clunky wrappers around the included command-line client—they have full access via the libsvn_client API to same functionality, data, and callback mechanisms that the command-line client uses."
msgstr ""

#: en.xml:16230(title) 
msgid "Binding Directly—A Word About Correctness"
msgstr ""

#: en.xml:16232(para) 
msgid "Why should your GUI program bind directly with a libsvn_client instead of acting as a wrapper around a command-line program? Besides simply being more efficient, this can address potential correctness issues as well. A command-line program (like the one supplied with Subversion) that binds to the client library needs to effectively translate feedback and requested data bits from C types to some form of human-readable output. This type of translation can be lossy. That is, the program may not display all of the information harvested from the API, or may combine bits of information for compact representation."
msgstr ""

#: en.xml:16244(para) 
msgid "If you wrap such a command-line program with yet another program, the second program has access only to already-interpreted (and as we mentioned, likely incomplete) information, which it must <emphasis>again</emphasis> translate into <emphasis>its</emphasis> representation format. With each layer of wrapping, the integrity of the original data is potentially tainted more and more, much like the result of making a copy of a copy (of a copy …) of a favorite audio or video cassette."
msgstr ""

#: en.xml:16263(title) 
msgid "Using the APIs"
msgstr ""

#: en.xml:16265(para) 
msgid "Developing applications against the Subversion library APIs is fairly straightforward. All of the public header files live in the <filename moreinfo=\"none\">subversion/include</filename> directory of the source tree. These headers are copied into your system locations when you build and install Subversion itself from source. These headers represent the entirety of the functions and types meant to be accessible by users of the Subversion libraries."
msgstr ""

#: en.xml:16274(para) 
msgid "The first thing you might notice is that Subversion's datatypes and functions are namespace protected. Every public Subversion symbol name begins with <literal moreinfo=\"none\">svn_</literal>, followed by a short code for the library in which the symbol is defined (such as <literal moreinfo=\"none\">wc</literal>, <literal moreinfo=\"none\">client</literal>, <literal moreinfo=\"none\">fs</literal>, etc.), followed by a single underscore (<literal moreinfo=\"none\">_</literal>) and then the rest of the symbol name. Semi-public functions (used among source files of a given library but not by code outside that library, and found inside the library directories themselves) differ from this naming scheme in that instead of a single underscore after the library code, they use a double underscore (<literal moreinfo=\"none\">__</literal>). Functions that are private to a given source file have no special prefixing, and are declared <literal moreinfo=\"none\">static</literal>. Of course, a compiler isn't interested in these naming conventions, but they help to clarify the scope of a given function or datatype."
msgstr ""

#: en.xml:16294(title) 
msgid "The Apache Portable Runtime Library"
msgstr ""

#: en.xml:16296(para) 
msgid "Along with Subversion's own datatypes, you will see many references to datatypes that begin with <literal moreinfo=\"none\">apr_</literal>—symbols from the Apache Portable Runtime (APR) library. APR is Apache's portability library, originally carved out of its server code as an attempt to separate the OS-specific bits from the OS-independent portions of the code. The result was a library that provides a generic API for performing operations that differ mildly—or wildly—from OS to OS. While the Apache HTTP Server was obviously the first user of the APR library, the Subversion developers immediately recognized the value of using APR as well. This means that there are practically no OS-specific code portions in Subversion itself. Also, it means that the Subversion client compiles and runs anywhere that the server does. Currently this list includes all flavors of Unix, Win32, BeOS, OS/2, and Mac OS X."
msgstr ""

#: en.xml:16316(para) 
msgid "Subversion uses ANSI system calls and datatypes as much as possible."
msgstr ""

#: en.xml:16329(para) 
msgid "Neon and Berkeley DB are examples of such libraries."
msgstr ""

#: en.xml:16313(para) 
msgid "In addition to providing consistent implementations of system calls that differ across operating systems, <footnote><placeholder-1/></footnote> APR gives Subversion immediate access to many custom datatypes, such as dynamic arrays and hash tables. Subversion uses these types extensively throughout the codebase. But perhaps the most pervasive APR datatype, found in nearly every Subversion API prototype, is the <structname>apr_pool_t</structname>—the APR memory pool. Subversion uses pools internally for all its memory allocation needs (unless an external library requires a different memory management schema for data passed through its API), <footnote><placeholder-2/></footnote> and while a person coding against the Subversion APIs is not required to do the same, they are required to provide pools to the API functions that need them. This means that users of the Subversion API must also link against APR, must call <function moreinfo=\"none\">apr_initialize()</function> to initialize the APR subsystem, and then must acquire a pool for use with Subversion API calls. See <xref linkend=\"svn.developer.pools\"/> for more information."
msgstr ""

#: en.xml:16344(title) 
msgid "URL and Path Requirements"
msgstr ""

#: en.xml:16346(para) 
msgid "With remote version control operation as the whole point of Subversion's existence, it makes sense that some attention has been paid to internationalization (i18n) support. After all, while <quote>remote</quote> might mean <quote>across the office</quote>, it could just as well mean <quote>across the globe.</quote> To facilitate this, all of Subversion's public interfaces that accept path arguments expect those paths to be canonicalized, and encoded in UTF-8. This means, for example, that any new client binary that drives the libsvn_client interface needs to first convert paths from the locale-specific encoding to UTF-8 before passing those paths to the Subversion libraries, and then re-convert any resultant output paths from Subversion back into the locale's encoding before using those paths for non-Subversion purposes. Fortunately, Subversion provides a suite of functions (see <filename moreinfo=\"none\">subversion/include/svn_utf.h</filename>) that can be used by any program to do these conversions."
msgstr ""

#: en.xml:16364(para) 
msgid "Also, Subversion APIs require all URL parameters to be properly URI-encoded. So, instead of passing <systemitem class=\"url\" moreinfo=\"none\">file:///home/username/My File.txt</systemitem> as the URL of a file named <literal moreinfo=\"none\">My File.txt</literal>, you need to pass <systemitem class=\"url\" moreinfo=\"none\">file:///home/username/My%20File.txt</systemitem>. Again, Subversion supplies helper functions that your application can use—<function moreinfo=\"none\">svn_path_uri_encode()</function> and <function moreinfo=\"none\">svn_path_uri_decode()</function>, for URI encoding and decoding, respectively."
msgstr ""

#: en.xml:16377(title) 
msgid "Using Languages Other than C and C++"
msgstr ""

#: en.xml:16379(para) 
msgid "If you are interested in using the Subversion libraries in conjunction with something other than a C program—say a Python or Perl script—Subversion has some support for this via the Simplified Wrapper and Interface Generator (SWIG). The SWIG bindings for Subversion are located in <filename moreinfo=\"none\">subversion/bindings/swig</filename> and whilst still maturing, they are in a usable state. These bindings allow you to call Subversion API functions indirectly, using wrappers that translate the datatypes native to your scripting language into the datatypes needed by Subversion's C libraries."
msgstr ""

#: en.xml:16390(para) 
msgid "There is an obvious benefit to accessing the Subversion APIs via a language binding—simplicity. Generally speaking, languages such as Python and Perl are much more flexible and easy to use than C or C++. The sort of high-level datatypes and context-driven type checking provided by these languages are often better at handling information that comes from users. As you know, humans are proficient at botching up input to a program, and scripting languages tend to handle that misinformation more gracefully. Of course, often that flexibility comes at the cost of performance. That is why using a tightly-optimized, C-based interface and library suite, combined with a powerful, flexible binding language, is so appealing."
msgstr ""

#: en.xml:16404(para) 
msgid "Let's look at a sample program that uses Subversion's Python SWIG bindings to recursively crawl the youngest repository revision, and print the various paths reached during the crawl."
msgstr ""

#: en.xml:16410(title) 
msgid "Using the Repository Layer with Python"
msgstr ""

#: en.xml:16412(programlisting) 
#, no-wrap
msgid "\n#!/usr/bin/python\n\n\"\"\"Crawl a repository, printing versioned object path names.\"\"\"\n\nimport sys\nimport os.path\nimport svn.fs, svn.core, svn.repos\n\ndef crawl_filesystem_dir(root, directory, pool):\n    \"\"\"Recursively crawl DIRECTORY under ROOT in the filesystem, and return\n    a list of all the paths at or below DIRECTORY.  Use POOL for all \n    allocations.\"\"\"\n\n    # Print the name of this path.\n    print directory + \"/\"\n    \n    # Get the directory entries for DIRECTORY.\n    entries = svn.fs.svn_fs_dir_entries(root, directory, pool)\n\n    # Use an iteration subpool.\n    subpool = svn.core.svn_pool_create(pool)\n\n    # Loop over the entries.\n    names = entries.keys()\n    for name in names:\n        # Clear the iteration subpool.\n        svn.core.svn_pool_clear(subpool)\n\n        # Calculate the entry's full path.\n        full_path = directory + '/' + name\n\n        # If the entry is a directory, recurse.  The recursion will return\n        # a list with the entry and all its children, which we will add to\n        # our running list of paths.\n        if svn.fs.svn_fs_is_dir(root, full_path, subpool):\n            crawl_filesystem_dir(root, full_path, subpool)\n        else:\n            # Else it's a file, so print its path here.\n            print full_path\n\n    # Destroy the iteration subpool.\n    svn.core.svn_pool_destroy(subpool)\n\ndef crawl_youngest(pool, repos_path):\n    \"\"\"Open the repository at REPOS_PATH, and recursively crawl its\n    youngest revision.\"\"\"\n    \n    # Open the repository at REPOS_PATH, and get a reference to its\n    # versioning filesystem.\n    repos_obj = svn.repos.svn_repos_open(repos_path, pool)\n    fs_obj = svn.repos.svn_repos_fs(repos_obj)\n\n    # Query the current youngest revision.\n    youngest_rev = svn.fs.svn_fs_youngest_rev(fs_obj, pool)\n    \n    # Open a root object representing the youngest (HEAD) revision.\n    root_obj = svn.fs.svn_fs_revision_root(fs_obj, youngest_rev, pool)\n\n    # Do the recursive crawl.\n    crawl_filesystem_dir(root_obj, \"\", pool)\n    \nif __name__ == \"__main__\":\n    # Check for sane usage.\n    if len(sys.argv) != 2:\n        sys.stderr.write(\"Usage: %s REPOS_PATH\\n\"\n                         % (os.path.basename(sys.argv[0])))\n        sys.exit(1)\n\n    # Canonicalize (enough for Subversion, at least) the repository path.\n    repos_path = os.path.normpath(sys.argv[1])\n    if repos_path == '.': \n        repos_path = ''\n\n    # Call the app-wrapper, which takes care of APR initialization/shutdown\n    # and the creation and cleanup of our top-level memory pool.\n    svn.core.run_app(crawl_youngest, repos_path)\n"
msgstr ""

#: en.xml:16492(para) 
msgid "This same program in C would need to deal with custom datatypes (such as those provided by the APR library) for representing the hash of entries and the list of paths, but Python has hashes (called <quote>dictionaries</quote>) and lists as built-in datatypes, and provides a rich collection of functions for operating on those types. So SWIG (with the help of some customizations in Subversion's language bindings layer) takes care of mapping those custom datatypes into the native datatypes of the target language. This provides a more intuitive interface for users of that language."
msgstr ""

#: en.xml:16503(para) 
msgid "The Subversion Python bindings can be used for working copy operations, too. In the previous section of this chapter, we mentioned the <filename moreinfo=\"none\">libsvn_client</filename> interface, and how it exists for the sole purpose of simplifying the process of writing a Subversion client. The following is a brief example of how that library can be accessed via the SWIG bindings to recreate a scaled-down version of the <command moreinfo=\"none\">svn status</command> command."
msgstr ""

#: en.xml:16513(title) 
msgid "A Python Status Crawler"
msgstr ""

#: en.xml:16515(programlisting) 
#, no-wrap
msgid "\n#!/usr/bin/env python\n\n\"\"\"Crawl a working copy directory, printing status information.\"\"\"\n\nimport sys\nimport os.path\nimport getopt\nimport svn.core, svn.client, svn.wc\n\ndef generate_status_code(status):\n    \"\"\"Translate a status value into a single-character status code,\n    using the same logic as the Subversion command-line client.\"\"\"\n\n    if status == svn.wc.svn_wc_status_none:\n        return ' '\n    if status == svn.wc.svn_wc_status_normal:\n        return ' '\n    if status == svn.wc.svn_wc_status_added:\n        return 'A'\n    if status == svn.wc.svn_wc_status_missing:\n        return '!'\n    if status == svn.wc.svn_wc_status_incomplete:\n        return '!'\n    if status == svn.wc.svn_wc_status_deleted:\n        return 'D'\n    if status == svn.wc.svn_wc_status_replaced:\n        return 'R'\n    if status == svn.wc.svn_wc_status_modified:\n        return 'M'\n    if status == svn.wc.svn_wc_status_merged:\n        return 'G'\n    if status == svn.wc.svn_wc_status_conflicted:\n        return 'C'\n    if status == svn.wc.svn_wc_status_obstructed:\n        return '~'\n    if status == svn.wc.svn_wc_status_ignored:\n        return 'I'\n    if status == svn.wc.svn_wc_status_external:\n        return 'X'\n    if status == svn.wc.svn_wc_status_unversioned:\n        return '?'\n    return '?'\n\ndef do_status(pool, wc_path, verbose):\n    # Calculate the length of the input working copy path.\n    wc_path_len = len(wc_path)\n\n    # Build a client context baton.\n    ctx = svn.client.svn_client_ctx_t()\n\n    def _status_callback(path, status, root_path_len=wc_path_len):\n        \"\"\"A callback function for svn_client_status.\"\"\"\n\n        # Print the path, minus the bit that overlaps with the root of\n        # the status crawl\n        text_status = generate_status_code(status.text_status)\n        prop_status = generate_status_code(status.prop_status)\n        print '%s%s  %s' % (text_status, prop_status, path[wc_path_len + 1:])\n        \n    # Do the status crawl, using _status_callback() as our callback function.\n    svn.client.svn_client_status(wc_path, None, _status_callback,\n                                 1, verbose, 0, 0, ctx, pool)\n\ndef usage_and_exit(errorcode):\n    \"\"\"Print usage message, and exit with ERRORCODE.\"\"\"\n    stream = errorcode and sys.stderr or sys.stdout\n    stream.write(\"\"\"Usage: %s OPTIONS WC-PATH\nOptions:\n  --help, -h    : Show this usage message\n  --verbose, -v : Show all statuses, even uninteresting ones\n\"\"\" % (os.path.basename(sys.argv[0])))\n    sys.exit(errorcode)\n    \nif __name__ == '__main__':\n    # Parse command-line options.\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], \"hv\", [\"help\", \"verbose\"])\n    except getopt.GetoptError:\n        usage_and_exit(1)\n    verbose = 0\n    for opt, arg in opts:\n        if opt in (\"-h\", \"--help\"):\n            usage_and_exit(0)\n        if opt in (\"-v\", \"--verbose\"):\n            verbose = 1\n    if len(args) != 1:\n        usage_and_exit(2)\n            \n    # Canonicalize (enough for Subversion, at least) the working copy path.\n    wc_path = os.path.normpath(args[0])\n    if wc_path == '.': \n        wc_path = ''\n\n    # Call the app-wrapper, which takes care of APR initialization/shutdown\n    # and the creation and cleanup of our top-level memory pool.\n    svn.core.run_app(do_status, wc_path, verbose)\n"
msgstr ""

#: en.xml:16615(para) 
msgid "Subversion's language bindings unfortunately tend to lack the level of attention given to the core Subversion modules. However, there have been significant efforts towards creating functional bindings for Python, Perl, and Ruby. To some extent, the work done preparing the SWIG interface files for these languages is reusable in efforts to generate bindings for other languages supported by SWIG (which includes versions of C#, Guile, Java, MzScheme, OCaml, PHP, Tcl, and others). However, some extra programming is required to compensate for complex APIs that SWIG needs some help interfacing with. For more information on SWIG itself, see the project's website at <ulink url=\"http://www.swig.org/\"/>."
msgstr ""

#: en.xml:16635(title) 
msgid "Inside the Working Copy Administration Area"
msgstr ""

#: en.xml:16637(para) 
msgid "As we mentioned earlier, each directory of a Subversion working copy contains a special subdirectory called <filename moreinfo=\"none\">.svn</filename> which houses administrative data about that working copy directory. Subversion uses the information in <filename moreinfo=\"none\">.svn</filename> to keep track of things like:"
msgstr ""

#: en.xml:16645(para) 
msgid "Which repository location(s) are represented by the files and subdirectories in the working copy directory."
msgstr ""

#: en.xml:16650(para) 
msgid "What revision of each of those files and directories are currently present in the working copy."
msgstr ""

#: en.xml:16654(para) 
msgid "Any user-defined properties that might be attached to those files and directories."
msgstr ""

#: en.xml:16658(para) 
msgid "Pristine (un-edited) copies of the working copy files."
msgstr ""

#: en.xml:16663(para) 
msgid "While there are several other bits of data stored in the <filename moreinfo=\"none\">.svn</filename> directory, we will examine only a couple of the most important items."
msgstr ""

#: en.xml:16669(title) 
msgid "The Entries File"
msgstr ""

#: en.xml:16671(para) 
msgid "Perhaps the single most important file in the <filename moreinfo=\"none\">.svn</filename> directory is the <filename moreinfo=\"none\">entries</filename> file. The entries file is an XML document which contains the bulk of the administrative information about a versioned resource in a working copy directory. It is this one file which tracks the repository URLs, pristine revision, file checksums, pristine text and property timestamps, scheduling and conflict state information, last-known commit information (author, revision, timestamp), local copy history—practically everything that a Subversion client is interested in knowing about a versioned (or to-be-versioned) resource!"
msgstr ""

#: en.xml:16685(title) 
msgid "Comparing the Administrative Areas of Subversion and CVS"
msgstr ""

#: en.xml:16688(para) 
msgid "A glance inside the typical <filename moreinfo=\"none\">.svn</filename> directory turns up a bit more than what CVS maintains in its <filename moreinfo=\"none\">CVS</filename> administrative directories. The <filename moreinfo=\"none\">entries</filename> file contains XML which describes the current state of the working copy directory, and basically serves the purposes of CVS's <filename moreinfo=\"none\">Entries</filename>, <filename moreinfo=\"none\">Root</filename>, and <filename moreinfo=\"none\">Repository</filename> files combined."
msgstr ""

#: en.xml:16699(para) 
msgid "The following is an example of an actual entries file:"
msgstr ""

#: en.xml:16703(title) 
msgid "Contents of a Typical <filename moreinfo=\"none\">.svn/entries</filename> File"
msgstr ""

#: en.xml:16705(programlisting) 
#, no-wrap
msgid "\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;wc-entries\n   xmlns=\"svn:\"&gt;\n&lt;entry\n   committed-rev=\"1\"\n   name=\"\"\n   committed-date=\"2005-04-04T13:32:28.526873Z\"\n   url=\"http://svn.red-bean.com/repos/greek-tree/A/D\"\n   last-author=\"jrandom\"\n   kind=\"dir\"\n   uuid=\"4e820d15-a807-0410-81d5-aa59edf69161\"\n   revision=\"1\"/&gt;\n&lt;entry\n   name=\"lambda\"\n   copied=\"true\"\n   kind=\"file\"\n   copyfrom-rev=\"1\"\n   schedule=\"add\"\n   copyfrom-url=\"http://svn.red-bean.com/repos/greek-tree/A/B/lambda\"/&gt;\n&lt;entry\n   committed-rev=\"1\"\n   name=\"gamma\"\n   text-time=\"2005-12-11T16:32:46.000000Z\"\n   committed-date=\"2005-04-04T13:32:28.526873Z\"\n   checksum=\"ada10d942b1964d359e048dbacff3460\"\n   last-author=\"jrandom\"\n   kind=\"file\"\n   prop-time=\"2005-12-11T16:32:45.000000Z\"/&gt;\n&lt;entry\n   name=\"zeta\"\n   kind=\"file\"\n   schedule=\"add\"\n   revision=\"0\"/&gt;\n&lt;entry\n   name=\"G\"\n   kind=\"dir\"/&gt;\n&lt;entry\n   name=\"H\"\n   kind=\"dir\"\n   schedule=\"delete\"/&gt;\n&lt;/wc-entries&gt;\n"
msgstr ""

#: en.xml:16750(para) 
msgid "As you can see, the entries file is essentially a list of entries. Each <sgmltag>entry</sgmltag> tag represents one of three things: the working copy directory itself (called the <quote>this directory</quote> entry, and noted as having an empty value for its <structfield>name</structfield> attribute), a file in that working copy directory (noted by having its <structfield>kind</structfield> attribute set to <literal moreinfo=\"none\">\"file\"</literal>), or a subdirectory in that working copy (<structfield>kind</structfield> here is set to <literal moreinfo=\"none\">\"dir\"</literal>). The files and subdirectories whose entries are stored in this file are either already under version control, or (as in the case of the file named <filename moreinfo=\"none\">zeta</filename> above) are scheduled to be added to version control when the user next commits this working copy directory's changes. Each entry has a unique name, and each entry has a node kind."
msgstr ""

#: en.xml:16779(para) 
msgid "That is, the URL for the entry is the same as the concatenation of the parent directory's URL and the entry's name."
msgstr ""

#: en.xml:16767(para) 
msgid "Developers should be aware of some special rules that Subversion uses when reading and writing its <filename moreinfo=\"none\">entries</filename> files. While each entry has a revision and URL associated with it, note that not every <sgmltag>entry</sgmltag> tag in the sample file has explicit <structfield>revision</structfield> or <structfield>url</structfield> attributes attached to it. Subversion allows entries to not explicitly store those two attributes when their values are the same as (in the <structfield>revision</structfield> case) or trivially calculable from <footnote><placeholder-1/></footnote> (in the <structfield>url</structfield> case) the data stored in the <quote>this directory</quote> entry. Note also that for subdirectory entries, Subversion stores only the crucial attributes—name, kind, url, revision, and schedule. In an effort to reduce duplicated information, Subversion dictates that the method for determining the full set of information about a subdirectory is to traverse down into that subdirectory, and read the <quote>this directory</quote> entry from its own <filename moreinfo=\"none\">.svn/entries</filename> file. However, a reference to the subdirectory is kept in its parent's <filename moreinfo=\"none\">entries</filename> file, with enough information to permit basic versioning operations in the event that the subdirectory itself is actually missing from disk."
msgstr ""

#: en.xml:16801(title) 
msgid "Pristine Copies and Property Files"
msgstr ""

#: en.xml:16803(para) 
msgid "As mentioned before, the <filename moreinfo=\"none\">.svn</filename> directory also holds the pristine <quote>text-base</quote> versions of files. Those can be found in <filename moreinfo=\"none\">.svn/text-base</filename>. The benefits of these pristine copies are multiple—network-free checks for local modifications and difference reporting, network-free reversion of modified or missing files, smaller transmission of changes to the server—but comes at the cost of having each versioned file stored at least twice on disk. These days, this seems to be a negligible penalty for most files. However, the situation gets uglier as the size of your versioned files grows. Some attention is being given to making the presence of the <quote>text-base</quote> an option. Ironically though, it is as your versioned files' sizes get larger that the existence of the <quote>text-base</quote> becomes more crucial—who wants to transmit a huge file across a network just because they want to commit a tiny change to it?"
msgstr ""

#: en.xml:16822(para) 
msgid "Similar in purpose to the <quote>text-base</quote> files are the property files and their pristine <quote>prop-base</quote> copies, located in <filename moreinfo=\"none\">.svn/props</filename> and <filename moreinfo=\"none\">.svn/prop-base</filename> respectively. Since directories can have properties, too, there are also <filename moreinfo=\"none\">.svn/dir-props</filename> and <filename moreinfo=\"none\">.svn/dir-prop-base</filename> files. Each of these property files (<quote>working</quote> and <quote>base</quote> versions) uses a simple <quote>hash-on-disk</quote> file format for storing the property names and values."
msgstr ""

#: en.xml:16841(title) 
msgid "WebDAV"
msgstr ""

#: en.xml:16843(para) 
msgid "WebDAV (shorthand for <quote>Web-based Distributed Authoring and Versioning</quote>) is an extension of the standard HTTP protocol designed to make the web into a read/write medium, instead of the basically read-only medium that exists today. The theory is that directories and files can be shared—as both readable and writable objects—over the web. RFCs 2518 and 3253 describe the WebDAV/DeltaV extensions to HTTP, and are available (along with a lot of other useful information) at <ulink url=\"http://www.webdav.org/\"/>."
msgstr ""

#: en.xml:16853(para) 
msgid "A number of operating system file browsers are already able to mount networked directories using WebDAV. On Win32, the Windows Explorer can browse what it calls Web Folders (which are just WebDAV-ready network locations) as if they were regular shared folders. Mac OS X also has this capability, as do the Nautilus and Konqueror browsers (under GNOME and KDE, respectively)."
msgstr ""

#: en.xml:16861(para) 
msgid "How does all of this apply to Subversion? The mod_dav_svn Apache module uses HTTP, extended by WebDAV and DeltaV, as one of its network protocols. Subversion uses mod_dav_svn to map between Subversion's versioning concepts and those of RFCs 2518 and 3253."
msgstr ""

#: en.xml:16868(para) 
msgid "For a more thorough discussion of WebDAV, how it works, and how Subversion uses it, see <xref linkend=\"svn.webdav\"/>. Among other things, that appendix discusses the degree to which Subversion adheres to the generic WebDAV specification, and how that affects interoperability with generic WebDAV clients."
msgstr ""

#: en.xml:16880(title) 
msgid "Programming with Memory Pools"
msgstr ""

#: en.xml:16882(para) 
msgid "Almost every developer who has used the C programming language has at some point sighed at the daunting task of managing memory usage. Allocating enough memory to use, keeping track of those allocations, freeing the memory when you no longer need it—these tasks can be quite complex. And of course, failure to do those things properly can result in a program that crashes itself, or worse, crashes the computer. Fortunately, the APR library that Subversion depends on for portability provides the <structname>apr_pool_t</structname> type, which represents a pool from which the application may allocate memory."
msgstr ""

#: en.xml:16894(para) 
msgid "A memory pool is an abstract representation of a chunk of memory allocated for use by a program. Rather than requesting memory directly from the OS using the standard <function moreinfo=\"none\">malloc()</function> and friends, programs that link against APR can simply request that a pool of memory be created (using the <function moreinfo=\"none\">apr_pool_create()</function> function). APR will allocate a moderately sized chunk of memory from the OS, and that memory will be instantly available for use by the program. Any time the program needs some of the pool memory, it uses one of the APR pool API functions, like <function moreinfo=\"none\">apr_palloc()</function>, which returns a generic memory location from the pool. The program can keep requesting bits and pieces of memory from the pool, and APR will keep granting the requests. Pools will automatically grow in size to accommodate programs that request more memory than the original pool contained, until of course there is no more memory available on the system."
msgstr ""

#: en.xml:16912(para) 
msgid "Now, if this were the end of the pool story, it would hardly have merited special attention. Fortunately, that's not the case. Pools can not only be created; they can also be cleared and destroyed, using <function moreinfo=\"none\">apr_pool_clear()</function> and <function moreinfo=\"none\">apr_pool_destroy()</function> respectively. This gives developers the flexibility to allocate several—or several thousand—things from the pool, and then clean up all of that memory with a single function call! Further, pools have hierarchy. You can make <quote>subpools</quote> of any previously created pool. When you clear a pool, all of its subpools are destroyed; if you destroy a pool, it and its subpools are destroyed."
msgstr ""

#: en.xml:16925(para) 
msgid "Before we go further, developers should be aware that they probably will not find many calls to the APR pool functions we just mentioned in the Subversion source code. APR pools offer some extensibility mechanisms, like the ability to have custom <quote>user data</quote> attached to the pool, and mechanisms for registering cleanup functions that get called when the pool is destroyed. Subversion makes use of these extensions in a somewhat non-trivial way. So, Subversion supplies (and most of its code uses) the wrapper functions <function moreinfo=\"none\">svn_pool_create()</function>, <function moreinfo=\"none\">svn_pool_clear()</function>, and <function moreinfo=\"none\">svn_pool_destroy()</function>."
msgstr ""

#: en.xml:16938(para) 
msgid "While pools are helpful for basic memory management, the pool construct really shines in looping and recursive scenarios. Since loops are often unbounded in their iterations, and recursions in their depth, memory consumption in these areas of the code can become unpredictable. Fortunately, using nested memory pools can be a great way to easily manage these potentially hairy situations. The following example demonstrates the basic use of nested pools in a situation that is fairly common—recursively crawling a directory tree, doing some task to each thing in the tree."
msgstr ""

#: en.xml:16950(title) 
msgid "Effective Pool Usage"
msgstr ""

#: en.xml:16951(programlisting) 
#, no-wrap
msgid "\n/* Recursively crawl over DIRECTORY, adding the paths of all its file\n   children to the FILES array, and doing some task to each path\n   encountered.  Use POOL for the all temporary allocations, and store\n   the hash paths in the same pool as the hash itself is allocated in.  */\nstatic apr_status_t \ncrawl_dir (apr_array_header_t *files,\n           const char *directory,\n           apr_pool_t *pool)\n{\n  apr_pool_t *hash_pool = files-&gt;pool;  /* array pool */\n  apr_pool_t *subpool = svn_pool_create (pool);  /* iteration pool */\n  apr_dir_t *dir;\n  apr_finfo_t finfo;\n  apr_status_t apr_err;\n  apr_int32_t flags = APR_FINFO_TYPE | APR_FINFO_NAME;\n\n  apr_err = apr_dir_open (&amp;dir, directory, pool);\n  if (apr_err)\n    return apr_err;\n\n  /* Loop over the directory entries, clearing the subpool at the top of\n     each iteration.  */\n  for (apr_err = apr_dir_read (&amp;finfo, flags, dir);\n       apr_err == APR_SUCCESS;\n       apr_err = apr_dir_read (&amp;finfo, flags, dir))\n    {\n      const char *child_path;\n\n      /* Clear the per-iteration SUBPOOL.  */\n      svn_pool_clear (subpool);\n\n      /* Skip entries for \"this dir\" ('.') and its parent ('..').  */\n      if (finfo.filetype == APR_DIR)\n        {\n          if (finfo.name[0] == '.'\n              &amp;&amp; (finfo.name[1] == '\\0'\n                  || (finfo.name[1] == '.' &amp;&amp; finfo.name[2] == '\\0')))\n            continue;\n        }\n\n      /* Build CHILD_PATH from DIRECTORY and FINFO.name.  */\n      child_path = svn_path_join (directory, finfo.name, subpool);\n\n      /* Do some task to this encountered path. */\n      do_some_task (child_path, subpool);\n\n      /* Handle subdirectories by recursing into them, passing SUBPOOL\n         as the pool for temporary allocations.  */\n      if (finfo.filetype == APR_DIR)\n        {\n          apr_err = crawl_dir (files, child_path, subpool);\n          if (apr_err)\n            return apr_err;\n        }\n\n      /* Handle files by adding their paths to the FILES array.  */\n      else if (finfo.filetype == APR_REG)\n        {\n          /* Copy the file's path into the FILES array's pool.  */\n          child_path = apr_pstrdup (hash_pool, child_path);\n\n          /* Add the path to the array.  */\n          (*((const char **) apr_array_push (files))) = child_path;\n        }\n    }\n\n  /* Destroy SUBPOOL.  */\n  svn_pool_destroy (subpool);\n\n  /* Check that the loop exited cleanly. */\n  if (apr_err)\n    return apr_err;\n\n  /* Yes, it exited cleanly, so close the dir. */\n  apr_err = apr_dir_close (dir);\n  if (apr_err)\n    return apr_err;\n\n  return APR_SUCCESS;\n}\n"
msgstr ""

#: en.xml:17035(para) 
msgid "The previous example demonstrates effective pool usage in <emphasis>both</emphasis> looping and recursive situations. Each recursion begins by making a subpool of the pool passed to the function. This subpool is used for the looping region, and cleared with each iteration. The result is memory usage is roughly proportional to the depth of the recursion, not to total number of file and directories present as children of the top-level directory. When the first call to this recursive function finally finishes, there is actually very little data stored in the pool that was passed to it. Now imagine the extra complexity that would be present if this function had to <function moreinfo=\"none\">alloc()</function> and <function moreinfo=\"none\">free()</function> every single piece of data used!"
msgstr ""

#: en.xml:17049(para) 
msgid "Pools might not be ideal for every application, but they are extremely useful in Subversion. As a Subversion developer, you'll need to grow comfortable with pools and how to wield them correctly. Memory usage bugs and bloating can be difficult to diagnose and fix regardless of the API, but the pool construct provided by APR has proven a tremendously convenient, time-saving bit of functionality."
msgstr ""

#: en.xml:17063(title) 
msgid "Contributing to Subversion"
msgstr ""

#: en.xml:17065(para) 
msgid "The official source of information about the Subversion project is, of course, the project's website at <ulink url=\"http://subversion.tigris.org/\"/>. There you can find information about getting access to the source code and participating on the discussion lists. The Subversion community always welcomes new members. If you are interested in participating in this community by contributing changes to the source code, here are some hints on how to get started."
msgstr ""

#: en.xml:17076(title) 
msgid "Join the Community"
msgstr ""

#: en.xml:17078(para) 
msgid "The first step in community participation is to find a way to stay on top of the latest happenings. To do this most effectively, you will want to subscribe to the main developer discussion list (<email>dev@subversion.tigris.org</email>) and commit mail list (<email>svn@subversion.tigris.org</email>). By following these lists even loosely, you will have access to important design discussions, be able to see actual changes to Subversion source code as they occur, and be able to witness peer reviews of those changes and proposed changes. These email based discussion lists are the primary communication media for Subversion development. See the Mailing Lists section of the website for other Subversion-related lists you might be interested in."
msgstr ""

#: en.xml:17092(para) 
msgid "But how do you know what needs to be done? It is quite common for a programmer to have the greatest intentions of helping out with the development, yet be unable to find a good starting point. After all, not many folks come to the community having already decided on a particular itch they would like to scratch. But by watching the developer discussion lists, you might see mentions of existing bugs or feature requests fly by that particularly interest you. Also, a great place to look for outstanding, unclaimed tasks is the Issue Tracking database on the Subversion website. There you will find the current list of known bugs and feature requests. If you want to start with something small, look for issues marked as <quote>bite-sized</quote>."
msgstr ""

#: en.xml:17110(title) 
msgid "Get the Source Code"
msgstr ""

#: en.xml:17112(para) 
msgid "To edit the code, you need to have the code. This means you need to check out a working copy from the public Subversion source repository. As straightforward as that might sound, the task can be slightly tricky. Because Subversion's source code is versioned using Subversion itself, you actually need to <quote>bootstrap</quote> by getting a working Subversion client via some other method. The most common methods include downloading the latest binary distribution (if such is available for your platform), or downloading the latest source tarball and building your own Subversion client. If you build from source, make sure to read the <filename moreinfo=\"none\">INSTALL</filename> file in the top level of the source tree for instructions."
msgstr ""

#: en.xml:17130(para) 
msgid "Note that the URL checked out in the example above ends not with <literal moreinfo=\"none\">svn</literal>, but with a subdirectory thereof called <literal moreinfo=\"none\">trunk</literal>. See our discussion of Subversion's branching and tagging model for the reasoning behind this."
msgstr ""

#: en.xml:17126(para) 
msgid "After you have a working Subversion client, you are now poised to checkout a working copy of the Subversion source repository from <ulink url=\"http://svn.collab.net/repos/svn/trunk/\"/>: <footnote><placeholder-1/></footnote>"
msgstr ""

#: en.xml:17137(screen) 
#, no-wrap
msgid "\n$ svn checkout http://svn.collab.net/repos/svn/trunk subversion\nA    subversion/HACKING\nA    subversion/INSTALL\nA    subversion/README\nA    subversion/autogen.sh\nA    subversion/build.conf\n…\n"
msgstr ""

#: en.xml:17147(para) 
msgid "The above command will checkout the bleeding-edge, latest version of the Subversion source code into a subdirectory named <filename moreinfo=\"none\">subversion</filename> in your current working directory. Obviously, you can adjust that last argument as you see fit. Regardless of what you call the new working copy directory, though, after this operation completes, you will now have the Subversion source code. Of course, you will still need to fetch a few helper libraries (apr, apr-util, etc.)—see the <filename moreinfo=\"none\">INSTALL</filename> file in the top level of the working copy for details."
msgstr ""

#: en.xml:17162(title) 
msgid "Become Familiar with Community Policies"
msgstr ""

#: en.xml:17178(para) 
msgid "While this may superficially appear as some sort of elitism, this <quote>earn your commit privileges</quote> notion is about efficiency—whether it costs more in time and effort to review and apply someone else's changes that are likely to be safe and useful, versus the potential costs of undoing changes that are dangerous."
msgstr ""

#: en.xml:17164(para) 
msgid "Now that you have a working copy containing the latest Subversion source code, you will most certainly want to take a cruise through the <quote>Hacker's Guide to Subversion</quote>, which is available either as the <filename moreinfo=\"none\">www/hacking.html</filename> file in the working copy, or on the Subversion website at <ulink url=\"http://subversion.tigris.org/hacking.html\"/>. This guide contains general instructions for contributing to Subversion, including how to properly format your source code for consistency with the rest of the codebase, how to describe your proposed changes with an effective change log message, how to test your changes, and so on. Commit privileges on the Subversion source repository are earned—a government by meritocracy. <footnote><placeholder-1/></footnote> The <quote>Hacker's Guide</quote> is an invaluable resource when it comes to making sure that your proposed changes earn the praises they deserve without being rejected on technicalities."
msgstr ""

#: en.xml:17195(title) 
msgid "Make and Test Your Changes"
msgstr ""

#: en.xml:17197(para) 
msgid "With the code and community policy understanding in hand, you are ready to make your changes. It is best to try to make smaller but related sets of changes, even tackling larger tasks in stages, instead of making huge, sweeping modifications. Your proposed changes will be easier to understand (and therefore easier to review) if you disturb the fewest lines of code possible to accomplish your task properly. After making each set of proposed changes, your Subversion tree should be in a state in which the software compiles with no warnings."
msgstr ""

#: en.xml:17210(para) 
msgid "You might want to grab some popcorn. <quote>Thorough</quote>, in this instance, translates to somewhere in the neighborhood of thirty minutes of non-interactive machine churn."
msgstr ""

#: en.xml:17208(para) 
msgid "Subversion has a fairly thorough <footnote><placeholder-1/></footnote> regression test suite, and your proposed changes are expected to not cause any of those tests to fail. By running <command moreinfo=\"none\">make check</command> (in Unix) from the top of the source tree, you can sanity-check your changes. The fastest way to get your code contributions rejected (other than failing to supply a good log message) is to submit changes that cause failure in the test suite."
msgstr ""

#. ### TODO: Describe building and testing on Windows.
#: en.xml:17225(para) 
msgid "In the best-case scenario, you will have actually added appropriate tests to that test suite which verify that your proposed changes work as expected. In fact, sometimes the best contribution a person can make is solely the addition of new tests. You can write regression tests for functionality that currently works in Subversion as a way to protect against future changes that might trigger failure in those areas. Also, you can write new tests that demonstrate known failures. For this purpose, the Subversion test suite allows you to specify that a given test is expected to fail (called an <literal moreinfo=\"none\">XFAIL</literal>), and so long as Subversion fails in the way that was expected, a test result of <literal moreinfo=\"none\">XFAIL</literal> itself is considered a success. Ultimately, the better the test suite, the less time wasted on diagnosing potentially obscure regression bugs."
msgstr ""

#: en.xml:17245(title) 
msgid "Donate Your Changes"
msgstr ""

#: en.xml:17247(para) 
msgid "After making your modifications to the source code, compose a clear and concise log message to describe those changes and the reasons for them. Then, send an email to the developers list containing your log message and the output of <command moreinfo=\"none\">svn diff</command> (from the top of your Subversion working copy). If the community members consider your changes acceptable, someone who has commit privileges (permission to make new revisions in the Subversion source repository) will add your changes to the public source code tree. Recall that permission to directly commit changes to the repository is granted on merit—if you demonstrate comprehension of Subversion, programming competency, and a <quote>team spirit</quote>, you will likely be awarded that permission."
msgstr ""

#: en.xml:17273(title) 
msgid "Subversion Complete Reference"
msgstr ""

#: en.xml:17276(para) 
msgid "This chapter is intended to be a complete reference to using Subversion. This includes the command line client (<command moreinfo=\"none\">svn</command>) and all its subcommands, as well as the repository administration programs (<command moreinfo=\"none\">svnadmin</command> and <command moreinfo=\"none\">svnlook</command>) and their respective subcommands."
msgstr ""

#: en.xml:17288(title) 
msgid "The Subversion Command Line Client: <command moreinfo=\"none\">svn</command>"
msgstr ""

#: en.xml:17293(para) 
msgid "Yes, yes, you don't need a subcommand to use the <option>--version</option> switch, but we'll get to that in just a minute."
msgstr ""

#: en.xml:17291(para) 
msgid "To use the command line client, you type <command moreinfo=\"none\">svn</command>, the subcommand you wish to use <placeholder-1/>, and any switches or targets that you wish to operate on—there is no specific order that the subcommand and the switches must appear in. For example, all of the following are valid ways to use <command moreinfo=\"none\">svn status</command>:"
msgstr ""

#: en.xml:17301(screen) 
#, no-wrap
msgid "\n$ svn -v status\n$ svn status -v \n$ svn status -v myfile\n"
msgstr ""

#: en.xml:17307(para) 
msgid "You can find many more examples of how to use most client commands in <xref linkend=\"svn.tour\"/> and commands for managing properties in <xref linkend=\"svn.advanced.props\"/>."
msgstr ""

#: en.xml:17313(title) 
msgid "<command moreinfo=\"none\">svn</command> Switches"
msgstr ""

#: en.xml:17315(para) 
msgid "While Subversion has different switches for its subcommands, all switches are global—that is, each switch is guaranteed to mean the same thing regardless of the subcommand you use it with. For example, <option>--verbose</option> (<option>-v</option>) always means <quote>verbose output</quote>, regardless of the subcommand you use it with."
msgstr ""

#: en.xml:17326(option) 
msgid "--auto-props"
msgstr ""

#: en.xml:17328(para) 
msgid "Enables auto-props, overriding the <literal moreinfo=\"none\">enable-auto-props</literal> directive in the <filename moreinfo=\"none\">config</filename> file."
msgstr ""

#: en.xml:17335(option) 
msgid "--config-dir"
msgstr ""

#: en.xml:17336(replaceable) en.xml:21494(replaceable) 
msgid "DIR"
msgstr ""

#: en.xml:17338(para) 
msgid "Instructs Subversion to read configuration information from the specified directory instead of the default location (<filename moreinfo=\"none\">.subversion</filename> in the user's home directory)."
msgstr ""

#: en.xml:17346(option) 
msgid "--diff-cmd"
msgstr ""

#: en.xml:17347(replaceable) en.xml:17362(replaceable) en.xml:17379(replaceable) 
msgid "CMD"
msgstr ""

#: en.xml:17349(para) 
msgid "Specifies an external program to use to show differences between files. When <command moreinfo=\"none\">svn diff</command> is invoked, it uses Subversion's internal diff engine, which provides unified diffs by default. If you want to use an external diff program, use <option>--diff-cmd</option>. You can pass switches to the diff program with the <option>--extensions</option> switch (more on that later in this section)."
msgstr ""

#: en.xml:17361(option) 
msgid "--diff3-cmd"
msgstr ""

#: en.xml:17364(para) 
msgid "Specifies an external program to use to merge files."
msgstr ""

#: en.xml:17369(option) 
msgid "--dry-run"
msgstr ""

#: en.xml:17371(para) 
msgid "Goes through all the motions of running a command, but makes no actual changes—either on disk or in the repository."
msgstr ""

#: en.xml:17378(option) 
msgid "--editor-cmd"
msgstr ""

#: en.xml:17381(para) 
msgid "Specifies an external program to use to edit a log message or a property value. See the <literal moreinfo=\"none\">editor-cmd</literal> section in <xref linkend=\"svn.advanced.confarea.opts.config\"/> for ways to specify a default editor."
msgstr ""

#: en.xml:17389(option) 
msgid "--encoding"
msgstr ""

#: en.xml:17389(replaceable) 
msgid "ENC"
msgstr ""

#: en.xml:17391(para) 
msgid "Tells Subversion that your commit message is encoded in the charset provided. The default is your operating system's native locale, and you should specify the encoding if your commit message is in any other encoding."
msgstr ""

#: en.xml:17400(term) 
msgid "<option>--extensions</option> (<option>-x</option>) <replaceable>ARGS</replaceable>"
msgstr ""

#: en.xml:17403(para) 
msgid "Specifies an argument or arguments that Subversion should pass to an external diff command when providing differences between files. If you wish to pass multiple arguments, you must enclose all of them in quotes (for example, <command moreinfo=\"none\">svn diff --diff-cmd /usr/bin/diff -x \"-b -E\"</command>). This switch can <emphasis>only</emphasis> be used if you also pass the <option>--diff-cmd</option> switch."
msgstr ""

#: en.xml:17415(term) 
msgid "<option>--file</option> (<option>-F</option>) <replaceable>FILENAME</replaceable>"
msgstr ""

#: en.xml:17419(para) 
msgid "Uses the contents of the file passed as an argument to this switch for the specified subcommand."
msgstr ""

#: en.xml:17425(option) 
msgid "--force"
msgstr ""

#: en.xml:17427(para) 
msgid "Forces a particular command or operation to run. There are some operations that Subversion will prevent you from doing in normal usage, but you can pass the force switch to tell Subversion <quote>I know what I'm doing as well as the possible repercussions of doing it, so let me at 'em</quote>. This switch is the programmatic equivalent of doing your own electrical work with the power on—if you don't know what you're doing, you're likely to get a nasty shock."
msgstr ""

#: en.xml:17440(option) 
msgid "--force-log"
msgstr ""

#: en.xml:17442(para) 
msgid "Forces a suspicious parameter passed to the <option>--message</option> (<option>-m</option>) or <option>--file</option> (<option>-F</option>) options to be accepted as valid. By default, Subversion will produce an error if parameters to these options look like they might instead be targets of the subcommand. For example, if you pass a versioned file's path to the <option>--file</option> (<option>-F</option>) option, Subversion will assume you've made a mistake, that the path was instead intended as the target of the operation, and that you simply failed to provide some other—unversioned—file as the source of your log message. To assert your intent and override these types of errors, pass the <option>--force-log</option> option to subcommands that accept log messages."
msgstr ""

#: en.xml:17461(term) 
msgid "<option>--help</option> (<option>-h</option> or <option>-?</option>)"
msgstr ""

#: en.xml:17465(para) 
msgid "If used with one or more subcommands, shows the built-in help text for each subcommand. If used alone, it displays the general client help text."
msgstr ""

#: en.xml:17472(option) 
msgid "--ignore-ancestry"
msgstr ""

#: en.xml:17474(para) 
msgid "Tells Subversion to ignore ancestry when calculating differences (rely on path contents alone)."
msgstr ""

#: en.xml:17480(option) 
msgid "--ignore-externals"
msgstr ""

#: en.xml:17482(para) 
msgid "Tells Subversion to ignore external definitions and the external working copies managed by them."
msgstr ""

#: en.xml:17488(option) en.xml:21484(option) 
msgid "--incremental"
msgstr ""

#: en.xml:17490(para) 
msgid "Prints output in a format suitable for concatenation."
msgstr ""

#: en.xml:17496(option) 
msgid "--limit"
msgstr ""

#: en.xml:17497(replaceable) 
msgid "NUM"
msgstr ""

#: en.xml:17499(para) 
msgid "Show only the first <replaceable>NUM</replaceable> log messages."
msgstr ""

#: en.xml:17505(term) 
msgid "<option>--message</option> (<option>-m</option>) <replaceable>MESSAGE</replaceable>"
msgstr ""

#: en.xml:17509(para) 
msgid "Indicates that you will specify a commit message on the command line, following this switch. For example:"
msgstr ""

#: en.xml:17513(screen) 
#, no-wrap
msgid "\n$ svn commit -m \"They don't make Sunday.\"\n"
msgstr ""

#: en.xml:17520(option) 
msgid "--new"
msgstr ""

#: en.xml:17520(replaceable) en.xml:17620(replaceable) 
msgid "ARG"
msgstr ""

#: en.xml:17522(para) 
msgid "Uses <replaceable>ARG</replaceable> as the newer target."
msgstr ""

#: en.xml:17528(option) 
msgid "--no-auth-cache"
msgstr ""

#: en.xml:17530(para) 
msgid "Prevents caching of authentication information (e.g. username and password) in the Subversion administrative directories."
msgstr ""

#: en.xml:17537(option) 
msgid "--no-auto-props"
msgstr ""

#: en.xml:17539(para) 
msgid "Disables auto-props, overriding the <literal moreinfo=\"none\">enable-auto-props</literal> directive in the <filename moreinfo=\"none\">config</filename> file."
msgstr ""

#: en.xml:17546(option) 
msgid "--no-diff-added"
msgstr ""

#: en.xml:17548(para) 
msgid "Prevents Subversion from printing differences for added files. The default behavior when you add a file is for <command moreinfo=\"none\">svn diff</command> to print the same differences that you would see if you had added the entire contents of an existing (empty) file."
msgstr ""

#: en.xml:17557(option) en.xml:22281(option) 
msgid "--no-diff-deleted"
msgstr ""

#: en.xml:17559(para) 
msgid "Prevents Subversion from printing differences for deleted files. The default behavior when you remove a file is for <command moreinfo=\"none\">svn diff</command> to print the same differences that you would see if you had left the file but removed all the content."
msgstr ""

#: en.xml:17568(option) 
msgid "--no-ignore"
msgstr ""

#: en.xml:17570(para) 
msgid "Shows files in the status listing that would normally be omitted since they match a pattern in the <literal moreinfo=\"none\">global-ignores</literal> configuration option or the <literal moreinfo=\"none\">svn:ignore</literal> property. See <xref linkend=\"svn.advanced.confarea.opts.config\"/> and <xref linkend=\"svn.advanced.props.special.ignore\"/> for more information."
msgstr ""

#: en.xml:17579(option) 
msgid "--no-unlock"
msgstr ""

#: en.xml:17581(para) 
msgid "Don't automatically unlock files (the default commit behavior is to unlock all files listed as part of the commit). See <xref linkend=\"svn.advanced.locking\"/> for more information."
msgstr ""

#: en.xml:17589(option) 
msgid "--non-interactive"
msgstr ""

#: en.xml:17591(para) 
msgid "In the case of an authentication failure, or insufficient credentials, prevents prompting for credentials (e.g. username or password). This is useful if you're running Subversion inside of an automated script and it's more appropriate to have Subversion fail than to prompt for more information."
msgstr ""

#: en.xml:17601(term) 
msgid "<option>--non-recursive</option> (<option>-N</option>)"
msgstr ""

#: en.xml:17603(para) 
msgid "Stops a subcommand from recursing into subdirectories. Most subcommands recurse by default, but some subcommands—usually those that have the potential to remove or undo your local modifications—do not."
msgstr ""

#: en.xml:17612(option) 
msgid "--notice-ancestry"
msgstr ""

#: en.xml:17614(para) 
msgid "Pay attention to ancestry when calculating differences."
msgstr ""

#: en.xml:17620(option) 
msgid "--old"
msgstr ""

#: en.xml:17622(para) 
msgid "Uses <replaceable>ARG</replaceable> as the older target."
msgstr ""

#: en.xml:17628(option) 
msgid "--password"
msgstr ""

#: en.xml:17629(replaceable) 
msgid "PASS"
msgstr ""

#: en.xml:17631(para) 
msgid "Indicates that you are providing your password for authentication on the command line—otherwise, if it is needed, Subversion will prompt you for it."
msgstr ""

#: en.xml:17639(term) 
msgid "<option>--quiet</option> (<option>-q</option>)"
msgstr ""

#: en.xml:17641(para) 
msgid "Requests that the client print only essential information while performing an operation."
msgstr ""

#: en.xml:17647(term) 
msgid "<option>--recursive</option> (<option>-R</option>)"
msgstr ""

#: en.xml:17649(para) 
msgid "Makes a subcommand recurse into subdirectories. Most subcommands recurse by default."
msgstr ""

#: en.xml:17655(option) 
msgid "--relocate"
msgstr ""

#: en.xml:17655(replaceable) 
msgid "FROM TO [PATH...]"
msgstr ""

#: en.xml:17658(para) 
msgid "Used with the <command moreinfo=\"none\">svn switch</command> subcommand, changes the location of the repository that your working copy references. This is useful if the location of your repository changes and you have an existing working copy that you'd like to continue to use. See <command moreinfo=\"none\">svn switch</command> for an example."
msgstr ""

#: en.xml:17669(term) 
msgid "<option>--revision</option> (<option>-r</option>) <replaceable>REV</replaceable>"
msgstr ""

#: en.xml:17673(para) 
msgid "Indicates that you're going to supply a revision (or range of revisions) for a particular operation. You can provide revision numbers, revision keywords or dates (in curly braces), as arguments to the revision switch. If you wish to provide a range of revisions, you can provide two revisions separated by a colon. For example:"
msgstr ""

#: en.xml:17681(screen) 
#, no-wrap
msgid "\n$ svn log -r 1729\n$ svn log -r 1729:HEAD\n$ svn log -r 1729:1744\n$ svn log -r {2001-12-04}:{2002-02-17}\n$ svn log -r 1729:{2002-02-17}\n"
msgstr ""

#: en.xml:17689(para) 
msgid "See <xref linkend=\"svn.tour.revs.keywords\"/> for more information."
msgstr ""

#: en.xml:17695(option) en.xml:22301(option) 
msgid "--revprop"
msgstr ""

#: en.xml:17697(para) en.xml:22303(para) 
msgid "Operates on a revision property instead of a Subversion property specific to a file or directory. This switch requires that you also pass a revision with the <option>--revision</option> (<option>-r</option>) switch. See <xref linkend=\"svn.reposadmin.basics.revprops\"/> for more details on unversioned properties."
msgstr ""

#: en.xml:17707(term) 
msgid "<option>--show-updates</option> (<option>-u</option>)"
msgstr ""

#: en.xml:17709(para) 
msgid "Causes the client to display information about which files in your working copy are out-of-date. This doesn't actually update any of your files—it just shows you which files will be updated if you run <command moreinfo=\"none\">svn update</command>."
msgstr ""

#: en.xml:17719(option) 
msgid "--stop-on-copy"
msgstr ""

#: en.xml:17721(para) 
msgid "Causes a Subversion subcommand which is traversing the history of a versioned resource to stop harvesting that historical information when a copy—that is, a location in history where that resource was copied from another location in the repository—is encountered."
msgstr ""

#: en.xml:17731(option) 
msgid "--strict"
msgstr ""

#: en.xml:17733(para) 
msgid "Causes Subversion to use strict semantics, a notion which is rather vague unless talking about specific subcommands."
msgstr ""

#: en.xml:17740(option) 
msgid "--targets"
msgstr ""

#: en.xml:17741(replaceable) 
msgid "FILENAME"
msgstr ""

#: en.xml:17743(para) 
msgid "Tells Subversion to get the list of files that you wish to operate on from the filename you provide instead of listing all the files on the command line."
msgstr ""

#: en.xml:17751(option) 
msgid "--username"
msgstr ""

#: en.xml:17752(replaceable) 
msgid "NAME"
msgstr ""

#: en.xml:17754(para) 
msgid "Indicates that you are providing your username for authentication on the command line—otherwise, if it is needed, Subversion will prompt you for it."
msgstr ""

#: en.xml:17762(term) 
msgid "<option>--verbose</option> (<option>-v</option>)"
msgstr ""

#: en.xml:17764(para) 
msgid "Requests that the client print out as much information as it can while running any subcommand. This may result in Subversion printing out additional fields, detailed information about every file, or additional information regarding its actions."
msgstr ""

#: en.xml:17773(option) en.xml:23177(option) en.xml:23317(option) 
msgid "--version"
msgstr ""

#: en.xml:17775(para) 
msgid "Prints the client version info. This information not only includes the version number of the client, but also a listing of all repository access modules that the client can use to access a Subversion repository. With <option>--quiet</option> (<option>-q</option>) it prints only the version number in a compact form."
msgstr ""

#: en.xml:17786(option) 
msgid "--xml"
msgstr ""

#: en.xml:17788(para) 
msgid "Prints output in XML format."
msgstr ""

#: en.xml:17798(title) 
msgid "<command moreinfo=\"none\">svn</command> Subcommands"
msgstr ""

#: en.xml:17803(refpurpose) 
msgid "Add files, directories, or symbolic links."
msgstr ""

#: en.xml:17807(title) en.xml:17906(title) en.xml:17969(title) en.xml:18046(title) en.xml:18176(title) en.xml:18247(title) en.xml:18380(title) en.xml:18547(title) en.xml:18652(title) en.xml:18897(title) en.xml:19004(title) en.xml:19050(title) en.xml:19145(title) en.xml:19298(title) en.xml:19405(title) en.xml:19496(title) en.xml:19734(title) en.xml:19847(title) en.xml:19926(title) en.xml:20033(title) en.xml:20105(title) en.xml:20173(title) en.xml:20248(title) en.xml:20328(title) en.xml:20457(title) en.xml:20538(title) en.xml:20635(title) en.xml:21033(title) en.xml:21186(title) en.xml:21272(title) en.xml:21551(title) en.xml:21607(title) en.xml:21640(title) en.xml:21742(title) en.xml:21768(title) en.xml:21805(title) en.xml:21830(title) en.xml:21870(title) en.xml:21928(title) en.xml:21969(title) en.xml:22008(title) en.xml:22078(title) en.xml:22116(title) en.xml:22163(title) en.xml:22216(title) en.xml:22343(title) en.xml:22382(title) en.xml:22433(title) en.xml:22525(title) en.xml:22564(title) en.xml:22628(title) en.xml:22667(title) en.xml:22694(title) en.xml:22751(title) en.xml:22795(title) en.xml:22839(title) en.xml:22878(title) en.xml:22926(title) en.xml:22984(title) en.xml:23032(title) en.xml:23063(title) en.xml:23264(title) 
msgid "Synopsis"
msgstr ""

#: en.xml:17808(programlisting) 
#, no-wrap
msgid "svn add PATH..."
msgstr ""

#: en.xml:17813(para) 
msgid "Add files, directories, or symbolic links to your working copy and schedule them for addition to the repository. They will be uploaded and added to the repository on your next commit. If you add something and change your mind before committing, you can unschedule the addition using <command moreinfo=\"none\">svn revert</command>."
msgstr ""

#: en.xml:17822(title) en.xml:17919(title) en.xml:17981(title) en.xml:18063(title) en.xml:18200(title) en.xml:18281(title) en.xml:18435(title) en.xml:18568(title) en.xml:18761(title) en.xml:18922(title) en.xml:19015(title) en.xml:19066(title) en.xml:19190(title) en.xml:19334(title) en.xml:19421(title) en.xml:19533(title) en.xml:19772(title) en.xml:19866(title) en.xml:19969(title) en.xml:20047(title) en.xml:20119(title) en.xml:20189(title) en.xml:20262(title) en.xml:20351(title) en.xml:20473(title) en.xml:20555(title) en.xml:20938(title) en.xml:21052(title) en.xml:21203(title) en.xml:21337(title) en.xml:21756(title) en.xml:22680(title) en.xml:22890(title) en.xml:22938(title) 
msgid "Alternate Names"
msgstr ""

#: en.xml:17823(para) en.xml:17982(para) en.xml:18201(para) en.xml:18923(para) en.xml:19067(para) en.xml:19191(para) en.xml:19422(para) en.xml:19534(para) en.xml:19773(para) en.xml:19867(para) en.xml:20474(para) en.xml:20556(para) en.xml:21204(para) en.xml:21940(para) en.xml:22090(para) en.xml:22810(para) 
msgid "None"
msgstr ""

#: en.xml:17827(title) en.xml:17924(title) en.xml:17986(title) en.xml:18068(title) en.xml:18205(title) en.xml:18288(title) en.xml:18440(title) en.xml:18573(title) en.xml:18766(title) en.xml:18927(title) en.xml:19023(title) en.xml:19071(title) en.xml:19195(title) en.xml:19339(title) en.xml:19426(title) en.xml:19538(title) en.xml:19777(title) en.xml:19871(title) en.xml:19974(title) en.xml:20052(title) en.xml:20124(title) en.xml:20194(title) en.xml:20267(title) en.xml:20356(title) en.xml:20478(title) en.xml:20560(title) en.xml:20943(title) en.xml:21057(title) en.xml:21208(title) en.xml:21342(title) 
msgid "Changes"
msgstr ""

#: en.xml:17828(para) 
msgid "Working Copy"
msgstr ""

#: en.xml:17832(title) en.xml:17929(title) en.xml:17991(title) en.xml:18073(title) en.xml:18210(title) en.xml:18293(title) en.xml:18446(title) en.xml:18579(title) en.xml:18771(title) en.xml:18932(title) en.xml:19028(title) en.xml:19076(title) en.xml:19200(title) en.xml:19344(title) en.xml:19431(title) en.xml:19543(title) en.xml:19782(title) en.xml:19876(title) en.xml:19979(title) en.xml:20057(title) en.xml:20129(title) en.xml:20199(title) en.xml:20272(title) en.xml:20361(title) en.xml:20483(title) en.xml:20565(title) en.xml:20948(title) en.xml:21062(title) en.xml:21213(title) en.xml:21347(title) 
msgid "Accesses Repository"
msgstr ""

#: en.xml:17833(para) en.xml:18211(para) en.xml:19029(para) en.xml:20484(para) en.xml:20566(para) 
msgid "No"
msgstr ""

#: en.xml:17837(title) en.xml:17934(title) en.xml:17996(title) en.xml:18078(title) en.xml:18215(title) en.xml:18298(title) en.xml:18452(title) en.xml:18584(title) en.xml:18777(title) en.xml:18937(title) en.xml:19033(title) en.xml:19081(title) en.xml:19205(title) en.xml:19349(title) en.xml:19436(title) en.xml:19548(title) en.xml:19787(title) en.xml:19881(title) en.xml:19984(title) en.xml:20062(title) en.xml:20134(title) en.xml:20204(title) en.xml:20277(title) en.xml:20366(title) en.xml:20488(title) en.xml:20570(title) en.xml:20953(title) en.xml:21067(title) en.xml:21218(title) en.xml:21352(title) en.xml:21569(title) en.xml:21625(title) en.xml:21696(title) en.xml:21788(title) en.xml:21882(title) en.xml:21938(title) en.xml:22018(title) en.xml:22088(title) en.xml:22127(title) en.xml:22189(title) en.xml:22354(title) en.xml:22393(title) en.xml:22490(title) en.xml:22536(title) en.xml:22575(title) en.xml:22640(title) en.xml:22706(title) en.xml:22762(title) en.xml:22808(title) en.xml:22849(title) en.xml:22895(title) en.xml:22943(title) en.xml:22996(title) en.xml:23286(title) 
msgid "Switches"
msgstr ""

#: en.xml:17839(screen) 
#, no-wrap
msgid "\n--targets FILENAME\n--non-recursive (-N)\n--quiet (-q)\n--config-dir DIR\n--auto-props\n--no-auto-props\n--force\n"
msgstr ""

#: en.xml:17851(title) en.xml:17948(title) en.xml:18009(title) en.xml:18094(title) en.xml:18225(title) en.xml:18318(title) en.xml:18471(title) en.xml:18604(title) en.xml:18797(title) en.xml:18955(title) en.xml:19103(title) en.xml:19222(title) en.xml:19366(title) en.xml:19454(title) en.xml:19568(title) en.xml:19806(title) en.xml:19899(title) en.xml:20004(title) en.xml:20078(title) en.xml:20150(title) en.xml:20220(title) en.xml:20294(title) en.xml:20386(title) en.xml:20499(title) en.xml:20581(title) en.xml:20971(title) en.xml:21084(title) en.xml:21232(title) en.xml:21369(title) en.xml:21580(title) en.xml:21707(title) en.xml:21846(title) en.xml:21982(title) en.xml:22024(title) en.xml:22135(title) en.xml:22198(title) en.xml:22229(title) en.xml:22363(title) en.xml:22402(title) en.xml:22499(title) en.xml:22545(title) en.xml:22586(title) en.xml:22649(title) en.xml:22715(title) en.xml:22771(title) en.xml:22814(title) en.xml:22858(title) en.xml:22905(title) en.xml:22954(title) en.xml:23006(title) en.xml:23047(title) en.xml:23073(title) en.xml:23328(title) 
msgid "Examples"
msgstr ""

#: en.xml:17853(para) 
msgid "To add a file to your working copy:"
msgstr ""

#: en.xml:17855(screen) 
#, no-wrap
msgid "\n$ svn add foo.c \nA         foo.c\n"
msgstr ""

#: en.xml:17860(para) 
msgid "When adding a directory, the default behavior of <command moreinfo=\"none\">svn add</command> is to recurse:"
msgstr ""

#: en.xml:17863(screen) 
#, no-wrap
msgid "\n$ svn add testdir\nA         testdir\nA         testdir/a\nA         testdir/b\nA         testdir/c\nA         testdir/d\n"
msgstr ""

#: en.xml:17872(para) 
msgid "You can add a directory without adding its contents:"
msgstr ""

#: en.xml:17875(screen) 
#, no-wrap
msgid "\n$ svn add --non-recursive otherdir\nA         otherdir\n"
msgstr ""

#: en.xml:17880(para) 
msgid "Normally, the command <command moreinfo=\"none\">svn add *</command> will skip over any directories that are already under version control. Sometimes, however, you may want to add every unversioned object in your working copy, including those hiding deeper down. Passing the <option>--force</option> option makes <command moreinfo=\"none\">svn add</command> recurse into versioned directories:"
msgstr ""

#: en.xml:17888(screen) 
#, no-wrap
msgid "\n$ svn add * --force\nA         foo.c\nA         somedir/bar.c\nA         otherdir/docs/baz.doc\n…\n"
msgstr ""

#: en.xml:17901(refname) 
msgid "svn blame"
msgstr ""

#: en.xml:17902(refpurpose) 
msgid "Show author and revision information in-line for the specified files or URLs."
msgstr ""

#: en.xml:17907(programlisting) 
#, no-wrap
msgid "svn blame TARGET[@REV]..."
msgstr ""

#: en.xml:17912(para) 
msgid "Show author and revision information in-line for the specified files or URLs. Each line of text is annotated at the beginning with the author (username) and the revision number for the last change to that line."
msgstr ""

#: en.xml:17920(para) 
msgid "praise, annotate, ann"
msgstr ""

#: en.xml:17925(para) en.xml:17987(para) en.xml:18767(para) en.xml:19024(para) en.xml:19196(para) en.xml:19340(para) en.xml:19539(para) en.xml:20944(para) 
msgid "Nothing"
msgstr ""

#: en.xml:17930(para) en.xml:17992(para) en.xml:18074(para) en.xml:18294(para) en.xml:19077(para) en.xml:19345(para) en.xml:19432(para) en.xml:19544(para) en.xml:21063(para) en.xml:21214(para) en.xml:21348(para) 
msgid "Yes"
msgstr ""

#: en.xml:17936(screen) 
#, no-wrap
msgid "\n--revision (-r) REV\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--config-dir DIR\n--verbose\n"
msgstr ""

#: en.xml:17950(para) 
msgid "If you want to see blame annotated source for <filename moreinfo=\"none\">readme.txt</filename> in your test repository:"
msgstr ""

#: en.xml:17953(screen) 
#, no-wrap
msgid "\n$ svn blame http://svn.red-bean.com/repos/test/readme.txt\n     3      sally This is a README file.\n     5      harry You should read this.\n"
msgstr ""

#: en.xml:17965(refpurpose) 
msgid "Output the contents of the specified files or URLs."
msgstr ""

#: en.xml:17970(programlisting) 
#, no-wrap
msgid "svn cat TARGET[@REV]..."
msgstr ""

#: en.xml:17975(para) 
msgid "Output the contents of the specified files or URLs. For listing the contents of directories, see <command moreinfo=\"none\">svn list</command>."
msgstr ""

#: en.xml:17998(screen) 
#, no-wrap
msgid "\n--revision (-r) REV\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--config-dir DIR\n"
msgstr ""

#: en.xml:18011(para) 
msgid "If you want to view readme.txt in your repository without checking it out:"
msgstr ""

#: en.xml:18013(screen) 
#, no-wrap
msgid "\n$ svn cat http://svn.red-bean.com/repos/test/readme.txt\nThis is a README file.\nYou should read this.\n"
msgstr ""

#: en.xml:18020(para) 
msgid "If your working copy is out of date (or you have local modifications) and you want to see the <literal moreinfo=\"none\">HEAD</literal> revision of a file in your working copy, <command moreinfo=\"none\">svn cat</command> will automatically fetch the <literal moreinfo=\"none\">HEAD</literal> revision when you give it a path:"
msgstr ""

#: en.xml:18028(screen) 
#, no-wrap
msgid "\n$ cat foo.c\nThis file is in my local working copy \nand has changes that I've made.\n\n$ svn cat foo.c\nLatest revision fresh from the repository!\n"
msgstr ""

#: en.xml:18042(refname) 
msgid "svn checkout"
msgstr ""

#: en.xml:18043(refpurpose) 
msgid "Check out a working copy from a repository."
msgstr ""

#: en.xml:18047(programlisting) 
#, no-wrap
msgid "svn checkout URL[@REV]... [PATH]"
msgstr ""

#: en.xml:18052(para) 
msgid "Check out a working copy from a repository. If <replaceable>PATH</replaceable> is omitted, the basename of the URL will be used as the destination. If multiple URLs are given each will be checked out into a subdirectory of <replaceable>PATH</replaceable>, with the name of the subdirectory being the basename of the URL."
msgstr ""

#: en.xml:18064(para) 
msgid "co"
msgstr ""

#: en.xml:18069(para) 
msgid "Creates a working copy."
msgstr ""

#: en.xml:18080(screen) 
#, no-wrap
msgid "\n--revision (-r) REV\n--quiet (-q)\n--non-recursive (-N)\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--ignore-externals\n--config-dir DIR\n"
msgstr ""

#: en.xml:18096(para) 
msgid "Check out a working copy into a directory called <filename moreinfo=\"none\">mine</filename>:"
msgstr ""

#: en.xml:18099(screen) 
#, no-wrap
msgid "\n$ svn checkout file:///tmp/repos/test mine\nA  mine/a\nA  mine/b\nChecked out revision 2.\n$ ls\nmine\n"
msgstr ""

#: en.xml:18108(para) 
msgid "Check out 2 different directories into two separate working copies:"
msgstr ""

#: en.xml:18111(screen) 
#, no-wrap
msgid "\n$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz\nA  test/a\nA  test/b\nChecked out revision 2.\nA  quiz/l\nA  quiz/m\nChecked out revision 2.\n$ ls\nquiz  test\n"
msgstr ""

#: en.xml:18123(para) 
msgid "Check out 2 different directories into two separate working copies, but place both into a directory called <filename moreinfo=\"none\">working-copies</filename>:"
msgstr ""

#: en.xml:18127(screen) 
#, no-wrap
msgid "\n$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz working-copies\nA  working-copies/test/a\nA  working-copies/test/b\nChecked out revision 2.\nA  working-copies/quiz/l\nA  working-copies/quiz/m\nChecked out revision 2.\n$ ls\nworking-copies\n"
msgstr ""

#: en.xml:18139(para) 
msgid "If you interrupt a checkout (or something else interrupts your checkout like loss of connectivity, etc.), you can restart it either by issuing the identical checkout command again, or by updating the incomplete working copy:"
msgstr ""

#: en.xml:18145(screen) 
#, no-wrap
msgid "\n$ svn checkout file:///tmp/repos/test test\nA  test/a\nA  test/b\n^C\nsvn: The operation was interrupted\nsvn: caught SIGINT\n\n$ svn checkout file:///tmp/repos/test test\nA  test/c\nA  test/d\n^C\nsvn: The operation was interrupted\nsvn: caught SIGINT\n\n$ cd test\n$ svn update\nA  test/e\nA  test/f\nUpdated to revision 3.\n"
msgstr ""

#: en.xml:18173(refpurpose) 
msgid "Recursively clean up the working copy."
msgstr ""

#: en.xml:18177(programlisting) 
#, no-wrap
msgid "svn cleanup [PATH...]"
msgstr ""

#: en.xml:18182(para) 
msgid "Recursively clean up the working copy, removing working copy locks and resuming unfinished operations. If you ever get a <quote>working copy locked</quote> error, run this command to remove stale locks and get your working copy into a usable state again."
msgstr ""

#: en.xml:18188(para) 
msgid "If, for some reason, an <command moreinfo=\"none\">svn update</command> fails due to a problem running an external diff program (e.g. user input or network failure), pass the <option>--diff3-cmd</option> to allow cleanup to complete any merging with your external diff program. You can also specify any configuration directory with the <option>--config-dir</option> switch, but you should need these switches extremely infrequently."
msgstr ""

#: en.xml:18206(para) en.xml:19778(para) en.xml:20479(para) en.xml:20561(para) en.xml:21058(para) en.xml:21343(para) 
msgid "Working copy"
msgstr ""

#: en.xml:18217(screen) 
#, no-wrap
msgid "\n--diff3-cmd CMD\n--config-dir DIR\n"
msgstr ""

#: en.xml:18227(para) 
msgid "Well, there's not much to the examples here as <command moreinfo=\"none\">svn cleanup</command> generates no output. If you pass no <replaceable>PATH</replaceable>, <quote><filename moreinfo=\"none\">.</filename></quote> is used."
msgstr ""

#: en.xml:18232(screen) 
#, no-wrap
msgid "\n$ svn cleanup\n\n$ svn cleanup /path/to/working-copy\n"
msgstr ""

#: en.xml:18244(refpurpose) 
msgid "Send changes from your working copy to the repository."
msgstr ""

#: en.xml:18248(programlisting) 
#, no-wrap
msgid "svn commit [PATH...]"
msgstr ""

#: en.xml:18253(para) 
msgid "Send changes from your working copy to the repository. If you do not supply a log message with your commit by using either the <option>--file</option> or <option>--message</option> switch, <command moreinfo=\"none\">svn</command> will launch your editor for you to compose a commit message. See the <literal moreinfo=\"none\">editor-cmd</literal> section in <xref linkend=\"svn.advanced.confarea.opts.config\"/>."
msgstr ""

#: en.xml:18261(para) 
msgid "<command moreinfo=\"none\">svn commit</command> will send found lock tokens and release locks on all <replaceable>PATHS</replaceable> committed (recursively) unless <option>--no-unlock</option> is passed."
msgstr ""

#: en.xml:18267(para) 
msgid "If you begin a commit and Subversion launches your editor to compose the commit message, you can still abort without committing your changes. If you want to cancel your commit, just quit your editor without saving your commit message and Subversion will prompt you to either abort the commit, continue with no message, or edit the message again."
msgstr ""

#: en.xml:18282(para) 
msgid "ci (short for <quote>check in</quote>; not <quote>co</quote>, which is short for <quote>checkout</quote>)"
msgstr ""

#: en.xml:18289(para) 
msgid "Working copy, repository"
msgstr ""

#: en.xml:18300(screen) 
#, no-wrap
msgid "\n--message (-m) TEXT\n--file (-F) FILE\n--quiet (-q)\n--no-unlock\n--non-recursive (-N)\n--targets FILENAME\n--force-log\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--encoding ENC\n--config-dir DIR\n"
msgstr ""

#: en.xml:18320(para) 
msgid "Commit a simple modification to a file with the commit message on the command line and an implicit target of your current directory (<quote><filename moreinfo=\"none\">.</filename></quote>):"
msgstr ""

#: en.xml:18325(screen) 
#, no-wrap
msgid "\n$ svn commit -m \"added howto section.\"\nSending        a\nTransmitting file data .\nCommitted revision 3.\n"
msgstr ""

#: en.xml:18332(para) 
msgid "Commit a modification to the file <filename moreinfo=\"none\">foo.c</filename> (explicitly specified on the command line) with the commit message in a file named <literal moreinfo=\"none\">msg</literal>:"
msgstr ""

#: en.xml:18337(screen) 
#, no-wrap
msgid "\n$ svn commit -F msg foo.c\nSending        foo.c\nTransmitting file data .\nCommitted revision 5.\n"
msgstr ""

#: en.xml:18344(para) 
msgid "If you want to use a file that's under version control for your commit message with <option>--file</option>, you need to pass the <option>--force-log</option> switch:"
msgstr ""

#: en.xml:18349(screen) 
#, no-wrap
msgid "\n$ svn commit --file file_under_vc.txt foo.c\nsvn: The log message file is under version control\nsvn: Log message file is a versioned file; use '--force-log' to override\n\n$ svn commit --force-log --file file_under_vc.txt foo.c\nSending        foo.c\nTransmitting file data .\nCommitted revision 6.\n"
msgstr ""

#: en.xml:18360(para) 
msgid "To commit a file scheduled for deletion:"
msgstr ""

#: en.xml:18362(screen) 
#, no-wrap
msgid "\n$ svn commit -m \"removed file 'c'.\"\nDeleting       c\n\nCommitted revision 7.\n"
msgstr ""

#: en.xml:18375(refpurpose) 
msgid "Copy a file or directory in a working copy or in the repository."
msgstr ""

#: en.xml:18381(programlisting) 
#, no-wrap
msgid "svn copy SRC DST"
msgstr ""

#: en.xml:18387(para) 
msgid "Copy a file in a working copy or in the repository. <replaceable>SRC</replaceable> and <replaceable>DST</replaceable> can each be either a working copy (WC) path or URL:"
msgstr ""

#: en.xml:18395(term) en.xml:19951(term) 
msgid "WC -&gt; WC"
msgstr ""

#: en.xml:18397(para) 
msgid "Copy and schedule an item for addition (with history)."
msgstr ""

#: en.xml:18403(term) 
msgid "WC -&gt; URL"
msgstr ""

#: en.xml:18405(para) 
msgid "Immediately commit a copy of WC to URL."
msgstr ""

#: en.xml:18410(term) 
msgid "URL -&gt; WC"
msgstr ""

#: en.xml:18412(para) 
msgid "Check out URL into WC, and schedule it for addition."
msgstr ""

#: en.xml:18418(term) en.xml:19959(term) 
msgid "URL -&gt; URL"
msgstr ""

#: en.xml:18420(para) 
msgid "Complete server-side copy. This is usually used to branch and tag."
msgstr ""

#: en.xml:18428(para) 
msgid "You can only copy files within a single repository. Subversion does not support cross-repository copying."
msgstr ""

#: en.xml:18436(para) 
msgid "cp"
msgstr ""

#: en.xml:18441(para) 
msgid "Repository if destination is a URL."
msgstr ""

#: en.xml:18442(para) 
msgid "Working copy if destination is a WC path."
msgstr ""

#: en.xml:18447(para) 
msgid "If source or destination is in the repository, or if needed to look up the source revision number."
msgstr ""

#: en.xml:18454(screen) 
#, no-wrap
msgid "\n--message (-m) TEXT\n--file (-F) FILE\n--revision (-r) REV\n--quiet (-q)\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--force-log\n--editor-cmd EDITOR\n--encoding ENC\n--config-dir DIR\n"
msgstr ""

#: en.xml:18473(para) 
msgid "Copy an item within your working copy (just schedules the copy—nothing goes into the repository until you commit):"
msgstr ""

#: en.xml:18477(screen) 
#, no-wrap
msgid "\n$ svn copy foo.txt bar.txt\nA         bar.txt\n$ svn status\nA  +   bar.txt\n"
msgstr ""

#: en.xml:18484(para) 
msgid "Copy an item in your working copy to a URL in the repository (an immediate commit, so you must supply a commit message):"
msgstr ""

#: en.xml:18488(screen) 
#, no-wrap
msgid "\n$ svn copy near.txt file:///tmp/repos/test/far-away.txt -m \"Remote copy.\"\n\nCommitted revision 8.\n"
msgstr ""

#: en.xml:18494(para) 
msgid "Copy an item from the repository to your working copy (just schedules the copy—nothing goes into the repository until you commit):"
msgstr ""

#: en.xml:18499(para) 
msgid "This is the recommended way to resurrect a dead file in your repository!"
msgstr ""

#: en.xml:18503(screen) 
#, no-wrap
msgid "\n$ svn copy file:///tmp/repos/test/far-away near-here\nA         near-here\n"
msgstr ""

#: en.xml:18508(para) 
msgid "And finally, copying between two URLs:"
msgstr ""

#: en.xml:18510(screen) 
#, no-wrap
msgid "\n$ svn copy file:///tmp/repos/test/far-away file:///tmp/repos/test/over-there -m \"remote copy.\"\n\nCommitted revision 9.\n"
msgstr ""

#: en.xml:18517(para) 
msgid "This is the easiest way to <quote>tag</quote> a revision in your repository—just <command moreinfo=\"none\">svn copy</command> that revision (usually <literal moreinfo=\"none\">HEAD</literal>) into your tags directory."
msgstr ""

#: en.xml:18523(screen) 
#, no-wrap
msgid "\n$ svn copy file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0.6.32-prerelease -m \"tag tree\"\n\nCommitted revision 12.\n"
msgstr ""

#: en.xml:18529(para) 
msgid "And don't worry if you forgot to tag—you can always specify an older revision and tag anytime:"
msgstr ""

#: en.xml:18532(screen) 
#, no-wrap
msgid "\n$ svn copy -r 11 file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0.6.32-prerelease -m \"Forgot to tag at rev 11\"\n\nCommitted revision 13.\n"
msgstr ""

#: en.xml:18543(refpurpose) 
msgid "Delete an item from a working copy or the repository."
msgstr ""

#: en.xml:18548(programlisting) 
#, no-wrap
msgid "svn delete PATH..."
msgstr ""

#: en.xml:18549(programlisting) 
#, no-wrap
msgid "svn delete URL..."
msgstr ""

#: en.xml:18554(para) 
msgid "Items specified by <replaceable>PATH</replaceable> are scheduled for deletion upon the next commit. Files (and directories that have not been committed) are immediately removed from the working copy. The command will not remove any unversioned or modified items; use the <option>--force</option> switch to override this behavior."
msgstr ""

#: en.xml:18562(para) 
msgid "Items specified by URL are deleted from the repository via an immediate commit. Multiple URLs are committed atomically."
msgstr ""

#: en.xml:18569(para) 
msgid "del, remove, rm"
msgstr ""

#: en.xml:18574(para) 
msgid "Working copy if operating on files, Repository if operating on URLs"
msgstr ""

#: en.xml:18580(para) en.xml:19201(para) 
msgid "Only if operating on URLs"
msgstr ""

#: en.xml:18586(screen) 
#, no-wrap
msgid "\n--force\n--force-log\n--message (-m) TEXT\n--file (-F) FILE\n--quiet (-q)\n--targets FILENAME\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--editor-cmd EDITOR\n--encoding ENC\n--config-dir DIR\n"
msgstr ""

#: en.xml:18606(para) 
msgid "Using <command moreinfo=\"none\">svn</command> to delete a file from your working copy merely schedules it to be deleted. When you commit, the file is deleted in the repository."
msgstr ""

#: en.xml:18611(screen) 
#, no-wrap
msgid "\n$ svn delete myfile\nD         myfile\n\n$ svn commit -m \"Deleted file 'myfile'.\"\nDeleting       myfile\nTransmitting file data .\nCommitted revision 14.\n"
msgstr ""

#: en.xml:18621(para) 
msgid "Deleting a URL, however, is immediate, so you have to supply a log message:"
msgstr ""

#: en.xml:18624(screen) 
#, no-wrap
msgid "\n$ svn delete -m \"Deleting file 'yourfile'\" file:///tmp/repos/test/yourfile\n\nCommitted revision 15.\n"
msgstr ""

#: en.xml:18630(para) 
msgid "Here's an example of how to force deletion of a file that has local mods:"
msgstr ""

#: en.xml:18633(screen) 
#, no-wrap
msgid "\n$ svn delete over-there \nsvn: Attempting restricted operation for modified resource\nsvn: Use --force to override this restriction\nsvn: 'over-there' has local modifications\n\n$ svn delete --force over-there \nD         over-there\n"
msgstr ""

#: en.xml:18649(refpurpose) 
msgid "Display the differences between two paths."
msgstr ""

#: en.xml:18653(programlisting) 
#, no-wrap
msgid "diff [-r N[:M]] [TARGET[@REV]...]"
msgstr ""

#: en.xml:18654(programlisting) 
#, no-wrap
msgid "diff [-r N[:M]] --old OLD-TGT[@OLDREV] [--new NEW-TGT[@NEWREV]] [PATH...]"
msgstr ""

#: en.xml:18655(programlisting) 
#, no-wrap
msgid "diff OLD-URL[@OLDREV] NEW-URL[@NEWREV]"
msgstr ""

#: en.xml:18660(para) 
msgid "Display the differences between two paths. The three different ways you can use <command moreinfo=\"none\">svn diff</command> are:"
msgstr ""

#: en.xml:18664(para) 
msgid "<command moreinfo=\"none\">svn diff [-r N[:M]] [--old OLD-TGT] [--new NEW-TGT] [PATH...]</command> displays the differences between <replaceable>OLD-TGT</replaceable> and <replaceable>NEW-TGT</replaceable>. If <replaceable>PATH</replaceable>s are given, they are treated as relative to <replaceable>OLD-TGT</replaceable> and <replaceable>NEW-TGT</replaceable> and the output is restricted to differences in only those paths. <replaceable>OLD-TGT</replaceable> and <replaceable>NEW-TGT</replaceable> may be working copy paths or <replaceable>URL</replaceable><literal moreinfo=\"none\">[@</literal><replaceable>REV</replaceable><literal moreinfo=\"none\">]</literal>. <replaceable>OLD-TGT</replaceable> defaults to the current working directory and <replaceable>NEW-TGT</replaceable> defaults to <replaceable>OLD-TGT</replaceable>. <replaceable>N</replaceable> defaults to <literal moreinfo=\"none\">BASE</literal> or, if <replaceable>OLD-TGT</replaceable> is a URL, to <literal moreinfo=\"none\">HEAD</literal>. <replaceable>M</replaceable> defaults to the current working version or, if <replaceable>NEW-TGT</replaceable> is a URL, to <literal moreinfo=\"none\">HEAD</literal>. <command moreinfo=\"none\">svn diff -r N</command> sets the revision of <replaceable>OLD-TGT</replaceable> to <replaceable>N</replaceable>, <command moreinfo=\"none\">svn diff -r N:M</command> also sets the revision of <replaceable>NEW-TGT</replaceable> to <replaceable>M</replaceable>."
msgstr ""

#: en.xml:18692(para) 
msgid "<command moreinfo=\"none\">svn diff -r N:M URL</command> is shorthand for <command moreinfo=\"none\">svn diff -r N:M --old=URL --new=URL</command>."
msgstr ""

#: en.xml:18696(para) 
msgid "<command moreinfo=\"none\">svn diff [-r N[:M]] URL1[@N] URL2[@M]</command> is shorthand for <command moreinfo=\"none\">svn diff [-r N[:M]] --old=URL1 --new=URL2</command>."
msgstr ""

#: en.xml:18700(para) 
msgid "If <replaceable>TARGET</replaceable> is a URL, then revs N and M can be given either via the <option>--revision</option> or by using <quote>@</quote> notation as described earlier."
msgstr ""

#: en.xml:18705(para) 
msgid "If <replaceable>TARGET</replaceable> is a working copy path, then the <option>--revision</option> switch means:"
msgstr ""

#: en.xml:18712(option) 
msgid "--revision N:M"
msgstr ""

#: en.xml:18714(para) 
msgid "The server compares <replaceable>TARGET</replaceable>@<replaceable>N</replaceable> and <replaceable>TARGET</replaceable>@<replaceable>M</replaceable>."
msgstr ""

#: en.xml:18722(option) 
msgid "--revision N"
msgstr ""

#: en.xml:18724(para) 
msgid "The client compares <replaceable>TARGET</replaceable>@<replaceable>N</replaceable> against working copy."
msgstr ""

#: en.xml:18731(term) 
msgid "(no <option>--revision</option>)"
msgstr ""

#: en.xml:18733(para) 
msgid "The client compares base and working copies of <replaceable>TARGET</replaceable>."
msgstr ""

#: en.xml:18740(para) 
msgid "If the alternate syntax is used, the server compares <replaceable>URL1</replaceable> and <replaceable>URL2</replaceable> at revisions <replaceable>N</replaceable> and <replaceable>M</replaceable> respectively. If either <replaceable>N</replaceable> or <replaceable>M</replaceable> are omitted, a value of <literal moreinfo=\"none\">HEAD</literal> is assumed."
msgstr ""

#: en.xml:18749(para) 
msgid "By default, <command moreinfo=\"none\">svn diff</command> ignores the ancestry of files and merely compares the contents of the two files being compared. If you use <option>--notice-ancestry</option>, the ancestry of the paths in question will be taken into consideration when comparing revisions (that is, if you run <command moreinfo=\"none\">svn diff</command> on two files with identical contents but different ancestry you will see the entire contents of the file as having been removed and added again)."
msgstr ""

#: en.xml:18762(para) 
msgid "di"
msgstr ""

#: en.xml:18772(para) 
msgid "For obtaining differences against anything but <literal moreinfo=\"none\">BASE</literal> revision in your working copy"
msgstr ""

#: en.xml:18779(screen) 
#, no-wrap
msgid "\n--revision (-r) REV\n--old OLD-TARGET\n--new NEW-TARGET\n--extensions (-x) \"ARGS\"\n--non-recursive (-N)\n--diff-cmd CMD\n--notice-ancestry\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--no-diff-deleted\n--config-dir DIR\n"
msgstr ""

#: en.xml:18799(para) 
msgid "Compare <literal moreinfo=\"none\">BASE</literal> and your working copy (one of the most popular uses of <command moreinfo=\"none\">svn diff</command>):"
msgstr ""

#: en.xml:18803(screen) 
#, no-wrap
msgid "\n$ svn diff COMMITTERS \nIndex: COMMITTERS\n===================================================================\n--- COMMITTERS\t(revision 4404)\n+++ COMMITTERS\t(working copy)\n"
msgstr ""

#: en.xml:18811(para) 
msgid "See how your working copy's modifications compare against an older revision:"
msgstr ""

#: en.xml:18814(screen) 
#, no-wrap
msgid "\n$ svn diff -r 3900 COMMITTERS \nIndex: COMMITTERS\n===================================================================\n--- COMMITTERS\t(revision 3900)\n+++ COMMITTERS\t(working copy)\n"
msgstr ""

#: en.xml:18822(para) 
msgid "Compare revision 3000 to revision 3500 using <quote>@</quote> syntax:"
msgstr ""

#: en.xml:18825(screen) 
#, no-wrap
msgid "\n$ svn diff http://svn.collab.net/repos/svn/trunk/COMMITTERS@3000 http://svn.collab.net/repos/svn/trunk/COMMITTERS@3500\nIndex: COMMITTERS\n===================================================================\n--- COMMITTERS\t(revision 3000)\n+++ COMMITTERS\t(revision 3500)\n…\n"
msgstr ""

#: en.xml:18834(para) 
msgid "Compare revision 3000 to revision 3500 using range notation (you only pass the one URL in this case):"
msgstr ""

#: en.xml:18838(screen) 
#, no-wrap
msgid "\n$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk/COMMITTERS\nIndex: COMMITTERS\n===================================================================\n--- COMMITTERS\t(revision 3000)\n+++ COMMITTERS\t(revision 3500)\n"
msgstr ""

#: en.xml:18847(para) 
msgid "Compare revision 3000 to revision 3500 of all files in <filename moreinfo=\"none\">trunk</filename> using range notation:"
msgstr ""

#: en.xml:18850(screen) 
#, no-wrap
msgid "\n$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk\n          "
msgstr ""

#: en.xml:18855(para) 
msgid "Compare revision 3000 to revision 3500 of only three files in <filename moreinfo=\"none\">trunk</filename> using range notation:"
msgstr ""

#: en.xml:18859(screen) 
#, no-wrap
msgid "\n$ svn diff -r 3000:3500 --old http://svn.collab.net/repos/svn/trunk COMMITTERS README HACKING\n          "
msgstr ""

#: en.xml:18863(para) 
msgid "If you have a working copy, you can obtain the differences without typing in the long URLs:"
msgstr ""

#: en.xml:18866(screen) 
#, no-wrap
msgid "\n$ svn diff -r 3000:3500 COMMITTERS \nIndex: COMMITTERS\n===================================================================\n--- COMMITTERS\t(revision 3000)\n+++ COMMITTERS\t(revision 3500)\n"
msgstr ""

#: en.xml:18874(para) 
msgid "Use <option>--diff-cmd</option><replaceable>CMD</replaceable><option>-x</option> to pass arguments directly to the external diff program"
msgstr ""

#: en.xml:18879(screen) 
#, no-wrap
msgid "\n$ svn diff --diff-cmd /usr/bin/diff -x \"-i -b\" COMMITTERS \nIndex: COMMITTERS\n===================================================================\n0a1,2\n&gt; This is a test\n&gt; \n"
msgstr ""

#: en.xml:18893(refname) 
msgid "svn export"
msgstr ""

#: en.xml:18894(refpurpose) 
msgid "Export a clean directory tree."
msgstr ""

#: en.xml:18898(programlisting) 
#, no-wrap
msgid "svn export [-r REV] URL[@PEGREV] [PATH]"
msgstr ""

#: en.xml:18899(programlisting) 
#, no-wrap
msgid "svn export [-r REV] PATH1[@PEGREV] [PATH2]"
msgstr ""

#: en.xml:18904(para) 
msgid "The first form exports a clean directory tree from the repository specified by URL, at revision <replaceable>REV</replaceable> if it is given, otherwise at <literal moreinfo=\"none\">HEAD</literal>, into <replaceable>PATH</replaceable>. If <replaceable>PATH</replaceable> is omitted, the last component of the <replaceable>URL</replaceable> is used for the local directory name."
msgstr ""

#: en.xml:18913(para) 
msgid "The second form exports a clean directory tree from the working copy specified by <replaceable>PATH1</replaceable> into <replaceable>PATH2</replaceable>. All local changes will be preserved, but files not under version control will not be copied."
msgstr ""

#: en.xml:18928(para) 
msgid "Local disk"
msgstr ""

#: en.xml:18933(para) 
msgid "Only if exporting from a URL"
msgstr ""

#: en.xml:18939(screen) 
#, no-wrap
msgid "\n--revision (-r) REV\n--quiet (-q)\n--force\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--non-recursive\n--config-dir DIR\n--native-eol EOL\n--ignore-externals\n"
msgstr ""

#: en.xml:18957(para) 
msgid "Export from your working copy (doesn't print every file and directory):"
msgstr ""

#: en.xml:18960(screen) 
#, no-wrap
msgid "\n$ svn export a-wc my-export\nExport complete.\n"
msgstr ""

#: en.xml:18965(para) 
msgid "Export directly from the repository (prints every file and directory):"
msgstr ""

#: en.xml:18968(screen) 
#, no-wrap
msgid "\n$ svn export file:///tmp/repos my-export\nA  my-export/test\nA  my-export/quiz\n…\nExported revision 15.\n"
msgstr ""

#: en.xml:18976(para) 
msgid "When rolling operating-system-specific release packages, it can be useful to export a tree which uses a specific EOL character for line endings. The <option>--native-eol</option> option will do this, but it only affects files that have <literal moreinfo=\"none\">svn:eol-style = native</literal> properties attached to them. For example, to export a tree with all CRLF line endings (possibly for a Windows .zip file distribution):"
msgstr ""

#: en.xml:18985(screen) 
#, no-wrap
msgid "\n$ svn export file://tmp/repos my-export --native-eol CRLF\nA  my-export/test\nA  my-export/quiz\n…\nExported revision 15.\n"
msgstr ""

#: en.xml:19000(refname) 
msgid "svn help"
msgstr ""

#: en.xml:19005(programlisting) 
#, no-wrap
msgid "svn help [SUBCOMMAND...]"
msgstr ""

#: en.xml:19010(para) 
msgid "This is your best friend when you're using Subversion and this book isn't within reach!"
msgstr ""

#: en.xml:19016(para) en.xml:21757(para) en.xml:22681(para) 
msgid "?, h"
msgstr ""

#: en.xml:19017(para) 
msgid "The options <option>-?</option>, <option>-h</option> and <option>--help</option> have the same effect as using the <command moreinfo=\"none\">help</command> subcommand."
msgstr ""

#: en.xml:19035(screen) 
#, no-wrap
msgid "\n--version\n--quiet (-q)\n--config-dir DIR\n"
msgstr ""

#: en.xml:19046(refpurpose) 
msgid "Commit an unversioned file or tree into the repository."
msgstr ""

#: en.xml:19051(programlisting) 
#, no-wrap
msgid "svn import [PATH] URL"
msgstr ""

#: en.xml:19056(para) 
msgid "Recursively commit a copy of <replaceable>PATH</replaceable> to <replaceable>URL</replaceable>. If <replaceable>PATH</replaceable> is omitted <quote><filename moreinfo=\"none\">.</filename></quote> is assumed. Parent directories are created in the repository as necessary."
msgstr ""

#: en.xml:19072(para) 
msgid "Repository"
msgstr ""

#: en.xml:19083(screen) 
#, no-wrap
msgid "\n--message (-m) TEXT\n--file (-F) FILE\n--quiet (-q)\n--non-recursive (-N)\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--force-log\n--editor-cmd EDITOR\n--encoding ENC\n--config-dir DIR\n--auto-props\n--no-auto-props\n--ignore-externals\n"
msgstr ""

#: en.xml:19105(para) 
msgid "This imports the local directory <filename moreinfo=\"none\">myproj</filename> into the root of your repository:"
msgstr ""

#: en.xml:19108(screen) 
#, no-wrap
msgid "\n$ svn import -m \"New import\" myproj http://svn.red-bean.com/repos/test\nAdding         myproj/sample.txt\n…\nTransmitting file data .........\nCommitted revision 16.\n"
msgstr ""

#: en.xml:19116(para) 
msgid "This imports the local directory <filename moreinfo=\"none\">myproj</filename> into <filename moreinfo=\"none\">trunk/misc</filename> in your repository. The directory <filename moreinfo=\"none\">trunk/misc</filename> need not exist before you import into it—<command moreinfo=\"none\">svn import</command> will recursively create directories for you:"
msgstr ""

#: en.xml:19121(screen) 
#, no-wrap
msgid "\n$ svn import -m \"New import\" myproj \\\n    http://svn.red-bean.com/repos/test/trunk/misc/myproj\nAdding         myproj/sample.txt\n…\nTransmitting file data .........\nCommitted revision 19.\n"
msgstr ""

#: en.xml:19130(para) 
msgid "After importing data, note that the original tree is <emphasis>not</emphasis> under version control. To start working, you still need to <command moreinfo=\"none\">svn checkout</command> a fresh working copy of the tree."
msgstr ""

#: en.xml:19140(refname) 
msgid "svn info"
msgstr ""

#: en.xml:19141(refpurpose) 
msgid "Display information about a local or remote item."
msgstr ""

#: en.xml:19146(programlisting) 
#, no-wrap
msgid "svn info [TARGET...]"
msgstr ""

#: en.xml:19151(para) 
msgid "Print information about the working copy paths or URLs specified. The information shown for both may include:"
msgstr ""

#: en.xml:19156(para) 
msgid "Path"
msgstr ""

#: en.xml:19157(para) 
msgid "Name"
msgstr ""

#: en.xml:19158(para) 
msgid "URL"
msgstr ""

#: en.xml:19159(para) 
msgid "Repository Root"
msgstr ""

#: en.xml:19160(para) 
msgid "Repository UUID"
msgstr ""

#: en.xml:19162(para) 
msgid "Node Kind"
msgstr ""

#: en.xml:19163(para) 
msgid "Last Changed Author"
msgstr ""

#: en.xml:19164(para) 
msgid "Last Changed Revision"
msgstr ""

#: en.xml:19165(para) 
msgid "Last Changed Date"
msgstr ""

#: en.xml:19166(para) 
msgid "Lock Token"
msgstr ""

#: en.xml:19167(para) 
msgid "Lock Owner"
msgstr ""

#: en.xml:19168(para) 
msgid "Lock Created (date)"
msgstr ""

#: en.xml:19169(para) 
msgid "Lock Expires (date)"
msgstr ""

#: en.xml:19172(para) 
msgid "Additional kinds of information available only for working copy paths are:"
msgstr ""

#: en.xml:19176(para) 
msgid "Schedule"
msgstr ""

#: en.xml:19177(para) 
msgid "Copied From URL"
msgstr ""

#: en.xml:19178(para) 
msgid "Copied From Rev"
msgstr ""

#: en.xml:19179(para) 
msgid "Text Last Updated"
msgstr ""

#: en.xml:19180(para) 
msgid "Properties Last Updated"
msgstr ""

#: en.xml:19181(para) 
msgid "Checksum"
msgstr ""

#: en.xml:19182(para) 
msgid "Conflict Previous Base File"
msgstr ""

#: en.xml:19183(para) 
msgid "Conflict Previous Working File"
msgstr ""

#: en.xml:19184(para) 
msgid "Conflict Current Base File"
msgstr ""

#: en.xml:19185(para) 
msgid "Conflict Properties File"
msgstr ""

#: en.xml:19207(screen) 
#, no-wrap
msgid "\n--revision (-r)\n--recursive (-R)\n--targets FILENAME\n--incremental\n--xml\n--username ARG\n--password ARG\n--no-auth-cache\n--non-interactive\n--config-dir DIR\n"
msgstr ""

#: en.xml:19224(para) 
msgid "<command moreinfo=\"none\">svn info</command> will show you all the useful information that it has for items in your working copy. It will show information for files:"
msgstr ""

#: en.xml:19228(screen) 
#, no-wrap
msgid "\n$ svn info foo.c\nPath: foo.c\nName: foo.c\nURL: http://svn.red-bean.com/repos/test/foo.c\nRepository Root: http://svn.red-bean.com/repos/test\nRepository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25\nRevision: 4417\nNode Kind: file\nSchedule: normal\nLast Changed Author: sally\nLast Changed Rev: 20\nLast Changed Date: 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003)\nText Last Updated: 2003-01-16 21:18:16 -0600 (Thu, 16 Jan 2003)\nProperties Last Updated: 2003-01-13 21:50:19 -0600 (Mon, 13 Jan 2003)\nChecksum: d6aeb60b0662ccceb6bce4bac344cb66\n"
msgstr ""

#: en.xml:19246(para) 
msgid "It will also show information for directories:"
msgstr ""

#: en.xml:19248(screen) 
#, no-wrap
msgid "\n$ svn info vendors\nPath: vendors\nURL: http://svn.red-bean.com/repos/test/vendors\nRepository Root: http://svn.red-bean.com/repos/test\nRepository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25\nRevision: 19\nNode Kind: directory\nSchedule: normal\nLast Changed Author: harry\nLast Changed Rev: 19\nLast Changed Date: 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003)\nProperties Last Updated: 2003-01-16 23:39:02 -0600 (Thu, 16 Jan 2003)\n"
msgstr ""

#: en.xml:19263(para) 
msgid "<command moreinfo=\"none\">svn info</command> also acts on URLs (also note that the file readme.doc in this example is locked, so lock information is also provided):"
msgstr ""

#: en.xml:19267(screen) 
#, no-wrap
msgid "\n$ svn info http://svn.red-bean.com/repos/test/readme.doc\nPath: readme.doc\nName: readme.doc\nURL: http://svn.red-bean.com/repos/test/readme.doc\nRepository Root: http://svn.red-bean.com/repos/test\nRepository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25\nRevision: 1\nNode Kind: file\nSchedule: normal\nLast Changed Author: sally\nLast Changed Rev: 42\nLast Changed Date: 2003-01-14 23:21:19 -0600 (Tue, 14 Jan 2003)\nLock Token: opaquelocktoken:14011d4b-54fb-0310-8541-dbd16bd471b2\nLock Owner: harry\nLock Created: 2003-01-15 17:35:12 -0600 (Wed, 15 Jan 2003)\nLock Comment (1 line):\nMy test lock comment\n"
msgstr ""

#: en.xml:19295(refpurpose) 
msgid "List directory entries in the repository."
msgstr ""

#: en.xml:19299(programlisting) 
#, no-wrap
msgid "svn list [TARGET[@REV]...]"
msgstr ""

#: en.xml:19304(para) 
msgid "List each <replaceable>TARGET</replaceable> file and the contents of each <replaceable>TARGET</replaceable> directory as they exist in the repository. If <replaceable>TARGET</replaceable> is a working copy path, the corresponding repository URL will be used."
msgstr ""

#: en.xml:19310(para) 
msgid "The default <replaceable>TARGET</replaceable> is <quote><filename moreinfo=\"none\">.</filename></quote>, meaning the repository URL of the current working copy directory."
msgstr ""

#: en.xml:19315(para) 
msgid "With <option>--verbose</option>, the following fields show the status of the item:"
msgstr ""

#: en.xml:19319(para) 
msgid "Revision number of the last commit"
msgstr ""

#: en.xml:19320(para) 
msgid "Author of the last commit"
msgstr ""

#: en.xml:19321(para) 
msgid "Size (in bytes)"
msgstr ""

#: en.xml:19322(para) 
msgid "Date and time of the last commit"
msgstr ""

#: en.xml:19326(para) 
msgid "With <option>--xml</option>, output is in XML format (with a header and an enclosing document element unless <option>--incremental</option> is also specified). All of the information is present; the <option>--verbose</option> option is not accepted."
msgstr ""

#: en.xml:19335(para) 
msgid "ls"
msgstr ""

#: en.xml:19351(screen) 
#, no-wrap
msgid "\n--revision (-r) REV\n--verbose (-v)\n--recursive (-R)\n--incremental\n--xml\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--config-dir DIR\n"
msgstr ""

#: en.xml:19368(para) 
msgid "<command moreinfo=\"none\">svn list</command> is most useful if you want to see what files a repository has without downloading a working copy:"
msgstr ""

#: en.xml:19372(screen) 
#, no-wrap
msgid "\n$ svn list http://svn.red-bean.com/repos/test/support\nREADME.txt\nINSTALL\nexamples/\n…\n"
msgstr ""

#: en.xml:19380(para) 
msgid "You can pass the <option>--verbose</option> switch for additional information, rather like the UNIX command <command moreinfo=\"none\">ls -l</command>:"
msgstr ""

#: en.xml:19384(screen) 
#, no-wrap
msgid "\n$ svn list --verbose file:///tmp/repos\n     16 sally         28361 Jan 16 23:18 README.txt\n     27 sally             0 Jan 18 15:27 INSTALL\n     24 harry               Jan 18 11:27 examples/\n"
msgstr ""

#: en.xml:19391(para) 
msgid "For further details, see <xref linkend=\"svn.tour.history.list\"/>."
msgstr ""

#: en.xml:19399(refname) 
msgid "svn lock"
msgstr ""

#: en.xml:19400(refpurpose) 
msgid "Lock working copy paths or URLs in the repository, so that no other user can commit changes to them."
msgstr ""

#: en.xml:19406(programlisting) 
#, no-wrap
msgid "svn lock TARGET..."
msgstr ""

#: en.xml:19411(para) 
msgid "Lock each <replaceable>TARGET</replaceable>. If any <replaceable>TARGET</replaceable> is already locked by another user, print a warning and continue locking the rest of the <replaceable>TARGET</replaceable>s. Use <option>--force</option> to steal a lock from another user or working copy."
msgstr ""

#: en.xml:19427(para) en.xml:21209(para) 
msgid "Working Copy, Repository"
msgstr ""

#: en.xml:19438(screen) 
#, no-wrap
msgid "\n--targets ARG\n--message (-m) ARG\n--file (-F) ARG\n--force-log\n--encoding ARG\n--username ARG\n--password ARG\n--no-auth-cache\n--non-interactive\n--config-dir ARG\n--force\n"
msgstr ""

#: en.xml:19456(para) 
msgid "Lock two files in your working copy:"
msgstr ""

#: en.xml:19458(screen) 
#, no-wrap
msgid "\n\n$ svn lock tree.jpg house.jpg\n'tree.jpg' locked by user 'harry'.\n'house.jpg' locked by user 'harry'.\n"
msgstr ""

#: en.xml:19465(para) 
msgid "Lock a file in your working copy that is currently locked by another user:"
msgstr ""

#: en.xml:19468(screen) 
#, no-wrap
msgid "\n$ svn lock tree.jpg\nsvn: warning: Path '/tree.jpg is already locked by user 'harry in \\\n     filesystem '/svn/repos/db'\n\n$ svn lock --force foo\n'tree.jpg' locked by user 'sally'.\n"
msgstr ""

#: en.xml:19477(para) 
msgid "Lock a file without a working copy:"
msgstr ""

#: en.xml:19479(screen) 
#, no-wrap
msgid "\n$ svn lock http://svn.red-bean.com/repos/test/tree.jpg\n'tree.jpg' locked by user 'sally'.\n"
msgstr ""

#: en.xml:19484(para) en.xml:21260(para) 
msgid "For further details, see <xref linkend=\"svn.advanced.locking\"/>."
msgstr ""

#: en.xml:19493(refpurpose) 
msgid "Display commit log messages."
msgstr ""

#: en.xml:19497(programlisting) 
#, no-wrap
msgid "svn log [PATH]"
msgstr ""

#: en.xml:19498(programlisting) 
#, no-wrap
msgid "svn log URL [PATH...]"
msgstr ""

#: en.xml:19503(para) 
msgid "The default target is the path of your current directory. If no arguments are supplied, <command moreinfo=\"none\">svn log</command> shows the log messages for all files and directories inside of (and including) the current working directory of your working copy. You can refine the results by specifying a path, one or more revisions, or any combination of the two. The default revision range for a local path is <literal moreinfo=\"none\">BASE:1</literal>."
msgstr ""

#: en.xml:19512(para) 
msgid "If you specify a URL alone, then it prints log messages for everything that the URL contains. If you add paths past the URL, only messages for those paths under that URL will be printed. The default revision range for a URL is <literal moreinfo=\"none\">HEAD:1</literal>."
msgstr ""

#: en.xml:19518(para) 
msgid "With <option>--verbose</option>, <command moreinfo=\"none\">svn log</command> will also print all affected paths with each log message. With <option>--quiet</option>, <command moreinfo=\"none\">svn log</command> will not print the log message body itself (this is compatible with <option>--verbose</option>)."
msgstr ""

#: en.xml:19524(para) 
msgid "Each log message is printed just once, even if more than one of the affected paths for that revision were explicitly requested. Logs follow copy history by default. Use <option>--stop-on-copy</option> to disable this behavior, which can be useful for determining branch points."
msgstr ""

#: en.xml:19550(screen) 
#, no-wrap
msgid "\n--revision (-r) REV\n--quiet (-q)\n--verbose (-v)\n--targets FILENAME\n--stop-on-copy\n--incremental\n--limit NUM\n--xml\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--config-dir DIR\n"
msgstr ""

#: en.xml:19570(para) 
msgid "You can see the log messages for all the paths that changed in your working copy by running <command moreinfo=\"none\">svn log</command> from the top:"
msgstr ""

#: en.xml:19574(screen) 
#, no-wrap
msgid "\n$ svn log\n------------------------------------------------------------------------\nr20 | harry | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line\n\nTweak.\n------------------------------------------------------------------------\nr17 | sally | 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003) | 2 lines\n…\n"
msgstr ""

#: en.xml:19585(para) 
msgid "Examine all log messages for a particular file in your working copy:"
msgstr ""

#: en.xml:19588(screen) 
#, no-wrap
msgid "\n$ svn log foo.c\n------------------------------------------------------------------------\nr32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line\n\nAdded defines.\n------------------------------------------------------------------------\nr28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines\n…\n"
msgstr ""

#: en.xml:19599(para) 
msgid "If you don't have a working copy handy, you can log a URL:"
msgstr ""

#: en.xml:19602(screen) 
#, no-wrap
msgid "\n$ svn log http://svn.red-bean.com/repos/test/foo.c\n------------------------------------------------------------------------\nr32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line\n\nAdded defines.\n------------------------------------------------------------------------\nr28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines\n…\n"
msgstr ""

#: en.xml:19613(para) 
msgid "If you want several distinct paths underneath the same URL, you can use the <literal moreinfo=\"none\">URL [PATH...]</literal> syntax."
msgstr ""

#: en.xml:19617(screen) 
#, no-wrap
msgid "\n$ svn log http://svn.red-bean.com/repos/test/ foo.c bar.c\n------------------------------------------------------------------------\nr32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line\n\nAdded defines.\n------------------------------------------------------------------------\nr31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line\n\nAdded new file bar.c\n------------------------------------------------------------------------\nr28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines\n…\n"
msgstr ""

#: en.xml:19632(para) 
msgid "When you're concatenating the results of multiple calls to the log command, you may want to use the <option>--incremental</option> switch. <command moreinfo=\"none\">svn log</command> normally prints out a dashed line at the beginning of a log message, after each subsequent log message, and following the final log message. If you ran <command moreinfo=\"none\">svn log</command> on a range of two revisions, you would get this:"
msgstr ""

#: en.xml:19640(screen) 
#, no-wrap
msgid "\n$ svn log -r 14:15\n------------------------------------------------------------------------\nr14 | …\n\n------------------------------------------------------------------------\nr15 | …\n\n------------------------------------------------------------------------\n"
msgstr ""

#: en.xml:19651(para) 
msgid "However, if you wanted to gather 2 non-sequential log messages into a file, you might do something like this:"
msgstr ""

#: en.xml:19655(screen) 
#, no-wrap
msgid "\n$ svn log -r 14 &gt; mylog\n$ svn log -r 19 &gt;&gt; mylog\n$ svn log -r 27 &gt;&gt; mylog\n$ cat mylog\n------------------------------------------------------------------------\nr14 | …\n\n------------------------------------------------------------------------\n------------------------------------------------------------------------\nr19 | …\n\n------------------------------------------------------------------------\n------------------------------------------------------------------------\nr27 | …\n\n------------------------------------------------------------------------\n"
msgstr ""

#: en.xml:19674(para) 
msgid "You can avoid the clutter of the double dashed lines in your output by using the incremental switch:"
msgstr ""

#: en.xml:19678(screen) 
#, no-wrap
msgid "\n$ svn log --incremental -r 14 &gt; mylog\n$ svn log --incremental -r 19 &gt;&gt; mylog\n$ svn log --incremental -r 27 &gt;&gt; mylog\n$ cat mylog\n------------------------------------------------------------------------\nr14 | …\n\n------------------------------------------------------------------------\nr19 | …\n\n------------------------------------------------------------------------\nr27 | …\n"
msgstr ""

#: en.xml:19693(para) 
msgid "The <option>--incremental</option> switch provides similar output control when using the <option>--xml</option> switch."
msgstr ""

#: en.xml:19700(para) 
msgid "If you run <command moreinfo=\"none\">svn log</command> on a specific path and provide a specific revision and get no output at all"
msgstr ""

#: en.xml:19704(screen) 
#, no-wrap
msgid "\n$ svn log -r 20 http://svn.red-bean.com/untouched.txt\n------------------------------------------------------------------------\n"
msgstr ""

#: en.xml:19709(para) 
msgid "That just means that the path was not modified in that revision. If you log from the top of the repository, or know the file that changed in that revision, you can specify it explicitly:"
msgstr ""

#: en.xml:19714(screen) 
#, no-wrap
msgid "\n$ svn log -r 20 touched.txt \n------------------------------------------------------------------------\nr20 | sally | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line\n\nMade a change.\n------------------------------------------------------------------------\n"
msgstr ""

#: en.xml:19729(refname) 
msgid "svn merge"
msgstr ""

#: en.xml:19730(refpurpose) 
msgid "Apply the differences between two sources to a working copy path."
msgstr ""

#: en.xml:19735(programlisting) 
#, no-wrap
msgid "svn merge sourceURL1[@N] sourceURL2[@M] [WCPATH]"
msgstr ""

#: en.xml:19736(programlisting) 
#, no-wrap
msgid "svn merge sourceWCPATH1@N sourceWCPATH2@M [WCPATH]"
msgstr ""

#: en.xml:19737(programlisting) 
#, no-wrap
msgid "svn merge -r N:M SOURCE[@REV] [WCPATH]"
msgstr ""

#: en.xml:19742(para) 
msgid "In the first and second forms, the source paths (URLs in the first form, working copy paths in the second) are specified at revisions <replaceable>N</replaceable> and <replaceable>M</replaceable>. These are the two sources to be compared. The revisions default to <literal moreinfo=\"none\">HEAD</literal> if omitted."
msgstr ""

#: en.xml:19749(para) 
msgid "In the third form, <replaceable>SOURCE</replaceable> can be a URL or working copy item, in which case the corresponding URL is used. This URL, at revisions <replaceable>N</replaceable> and <replaceable>M</replaceable>, defines the two sources to be compared."
msgstr ""

#: en.xml:19756(para) 
msgid "<replaceable>WCPATH</replaceable> is the working copy path that will receive the changes. If <replaceable>WCPATH</replaceable> is omitted, a default value of <quote><filename moreinfo=\"none\">.</filename></quote> is assumed, unless the sources have identical basenames that match a file within <quote><filename moreinfo=\"none\">.</filename></quote>: in which case, the differences will be applied to that file."
msgstr ""

#: en.xml:19764(para) 
msgid "Unlike <command moreinfo=\"none\">svn diff</command>, the merge command takes the ancestry of a file into consideration when performing a merge operation. This is very important when you're merging changes from one branch into another and you've renamed a file on one branch but not the other."
msgstr ""

#: en.xml:19783(para) 
msgid "Only if working with URLs"
msgstr ""

#: en.xml:19789(screen) 
#, no-wrap
msgid "\n--revision (-r) REV\n--non-recursive (-N)\n--quiet (-q)\n--force\n--dry-run\n--diff3-cmd CMD\n--ignore-ancestry\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--config-dir DIR\n"
msgstr ""

#: en.xml:19808(para) 
msgid "Merge a branch back into the trunk (assuming that you have a working copy of the trunk, and that the branch was created in revision 250):"
msgstr ""

#: en.xml:19812(screen) 
#, no-wrap
msgid "\n$ svn merge -r 250:HEAD http://svn.red-bean.com/repos/branches/my-branch\nU  myproj/tiny.txt\nU  myproj/thhgttg.txt\nU  myproj/win.txt\nU  myproj/flo.txt\n"
msgstr ""

#: en.xml:19820(para) 
msgid "If you branched at revision 23, and you want to merge changes on trunk into your branch, you could do this from inside the working copy of your branch:"
msgstr ""

#: en.xml:19824(screen) 
#, no-wrap
msgid "\n$ svn merge -r 23:30 file:///tmp/repos/trunk/vendors\nU  myproj/thhgttg.txt\n…\n"
msgstr ""

#: en.xml:19830(para) 
msgid "To merge changes to a single file:"
msgstr ""

#: en.xml:19832(screen) 
#, no-wrap
msgid "\n$ cd myproj\n$ svn merge -r 30:31 thhgttg.txt \nU  thhgttg.txt\n"
msgstr ""

#: en.xml:19843(refname) 
msgid "svn mkdir"
msgstr ""

#: en.xml:19844(refpurpose) 
msgid "Create a new directory under version control."
msgstr ""

#: en.xml:19848(programlisting) 
#, no-wrap
msgid "svn mkdir PATH..."
msgstr ""

#: en.xml:19849(programlisting) 
#, no-wrap
msgid "svn mkdir URL..."
msgstr ""

#: en.xml:19854(para) 
msgid "Create a directory with a name given by the final component of the <replaceable>PATH</replaceable> or URL. A directory specified by a working copy <replaceable>PATH</replaceable> is scheduled for addition in the working copy. A directory specified by a URL is created in the repository via an immediate commit. Multiple directory URLs are committed atomically. In both cases all the intermediate directories must already exist."
msgstr ""

#: en.xml:19872(para) en.xml:19975(para) 
msgid "Working copy, repository if operating on a URL"
msgstr ""

#: en.xml:19877(para) en.xml:19980(para) en.xml:20058(para) en.xml:20130(para) en.xml:20200(para) en.xml:20273(para) en.xml:20362(para) 
msgid "Only if operating on a URL"
msgstr ""

#: en.xml:19883(screen) 
#, no-wrap
msgid "\n--message (-m) TEXT\n--file (-F) FILE\n--quiet (-q)\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--editor-cmd EDITOR\n--encoding ENC\n--force-log\n--config-dir DIR\n"
msgstr ""

#: en.xml:19901(para) 
msgid "Create a directory in your working copy:"
msgstr ""

#: en.xml:19903(screen) 
#, no-wrap
msgid "\n$ svn mkdir newdir\nA         newdir\n"
msgstr ""

#: en.xml:19908(para) 
msgid "Create one in the repository (instant commit, so a log message is required):"
msgstr ""

#: en.xml:19911(screen) 
#, no-wrap
msgid "\n$ svn mkdir -m \"Making a new dir.\" http://svn.red-bean.com/repos/newdir\n\nCommitted revision 26.\n"
msgstr ""

#: en.xml:19923(refpurpose) 
msgid "Move a file or directory."
msgstr ""

#: en.xml:19927(programlisting) 
#, no-wrap
msgid "svn move SRC DST"
msgstr ""

#: en.xml:19932(para) 
msgid "This command moves a file or directory in your working copy or in the repository."
msgstr ""

#: en.xml:19936(para) 
msgid "This command is equivalent to an <command moreinfo=\"none\">svn copy</command> followed by <command moreinfo=\"none\">svn delete</command>."
msgstr ""

#: en.xml:19942(para) 
msgid "Subversion does not support moving between working copies and URLs. In addition, you can only move files within a single repository—Subversion does not support cross-repository moving."
msgstr ""

#: en.xml:19953(para) 
msgid "Move and schedule a file or directory for addition (with history)."
msgstr ""

#: en.xml:19961(para) 
msgid "Complete server-side rename."
msgstr ""

#: en.xml:19970(para) 
msgid "mv, rename, ren"
msgstr ""

#: en.xml:19986(screen) 
#, no-wrap
msgid "\n--message (-m) TEXT\n--file (-F) FILE\n--revision (-r) REV\n--quiet (-q)\n--force\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--editor-cmd EDITOR\n--encoding ENC\n--force-log\n--config-dir DIR\n"
msgstr ""

#: en.xml:20006(para) 
msgid "Move a file in your working copy:"
msgstr ""

#: en.xml:20008(screen) 
#, no-wrap
msgid "\n$ svn move foo.c bar.c\nA         bar.c\nD         foo.c\n"
msgstr ""

#: en.xml:20014(para) 
msgid "Move a file in the repository (an immediate commit, so it requires a commit message):"
msgstr ""

#: en.xml:20017(screen) 
#, no-wrap
msgid "\n$ svn move -m \"Move a file\" http://svn.red-bean.com/repos/foo.c \\\n                            http://svn.red-bean.com/repos/bar.c\n\nCommitted revision 27.\n"
msgstr ""

#: en.xml:20029(refname) 
msgid "svn propdel"
msgstr ""

#: en.xml:20030(refpurpose) 
msgid "Remove a property from an item."
msgstr ""

#: en.xml:20034(programlisting) 
#, no-wrap
msgid "svn propdel PROPNAME [PATH...]"
msgstr ""

#: en.xml:20035(programlisting) 
#, no-wrap
msgid "svn propdel PROPNAME --revprop -r REV [URL]"
msgstr ""

#: en.xml:20040(para) 
msgid "This removes properties from files, directories, or revisions. The first form removes versioned properties in your working copy, while the second removes unversioned remote properties on a repository revision."
msgstr ""

#: en.xml:20048(para) 
msgid "pdel, pd"
msgstr ""

#: en.xml:20053(para) en.xml:20125(para) en.xml:20195(para) en.xml:20268(para) en.xml:20357(para) 
msgid "Working copy, repository only if operating on a URL"
msgstr ""

#: en.xml:20064(screen) 
#, no-wrap
msgid "\n--quiet (-q)\n--recursive (-R)\n--revision (-r) REV\n--revprop\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--config-dir DIR\n"
msgstr ""

#: en.xml:20080(para) 
msgid "Delete a property from a file in your working copy"
msgstr ""

#: en.xml:20083(screen) 
#, no-wrap
msgid "\n$ svn propdel svn:mime-type  some-script\nproperty 'svn:mime-type' deleted from 'some-script'.\n"
msgstr ""

#: en.xml:20088(para) 
msgid "Delete a revision property:"
msgstr ""

#: en.xml:20090(screen) 
#, no-wrap
msgid "\n$ svn propdel --revprop -r 26 release-date \nproperty 'release-date' deleted from repository revision '26'\n"
msgstr ""

#: en.xml:20100(refname) 
msgid "svn propedit"
msgstr ""

#: en.xml:20101(refpurpose) 
msgid "Edit the property of one or more items under version control."
msgstr ""

#: en.xml:20106(programlisting) 
#, no-wrap
msgid "svn propedit PROPNAME PATH..."
msgstr ""

#: en.xml:20107(programlisting) 
#, no-wrap
msgid "svn propedit PROPNAME --revprop -r REV [URL]"
msgstr ""

#: en.xml:20112(para) 
msgid "Edit one or more properties using your favorite editor. The first form edits versioned properties in your working copy, while the second edits unversioned remote properties on a repository revision."
msgstr ""

#: en.xml:20120(para) 
msgid "pedit, pe"
msgstr ""

#: en.xml:20136(screen) 
#, no-wrap
msgid "\n--revision (-r) REV\n--revprop\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--encoding ENC\n--editor-cmd EDITOR\n--config-dir DIR\n"
msgstr ""

#: en.xml:20152(para) 
msgid "<command moreinfo=\"none\">svn propedit</command> makes it easy to modify properties that have multiple values:"
msgstr ""

#: en.xml:20155(screen) 
#, no-wrap
msgid "\n$ svn propedit svn:keywords  foo.c \n    &lt;svn will launch your favorite editor here, with a buffer open\n    containing the current contents of the svn:keywords property.  You\n    can add multiple values to a property easily here by entering one\n    value per line.&gt;\nSet new value for property 'svn:keywords' on 'foo.c'\n"
msgstr ""

#: en.xml:20169(refname) 
msgid "svn propget"
msgstr ""

#: en.xml:20170(refpurpose) 
msgid "Print the value of a property."
msgstr ""

#: en.xml:20174(programlisting) 
#, no-wrap
msgid "svn propget PROPNAME [TARGET[@REV]...]"
msgstr ""

#: en.xml:20175(programlisting) 
#, no-wrap
msgid "svn propget PROPNAME --revprop -r REV [URL]"
msgstr ""

#: en.xml:20180(para) 
msgid "Print the value of a property on files, directories, or revisions. The first form prints the versioned property of an item or items in your working copy, while the second prints unversioned remote property on a repository revision. See <xref linkend=\"svn.advanced.props\"/> for more information on properties."
msgstr ""

#: en.xml:20190(para) 
msgid "pget, pg"
msgstr ""

#: en.xml:20206(screen) 
#, no-wrap
msgid "\n--recursive (-R)\n--revision (-r) REV\n--revprop\n--strict\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--config-dir DIR\n"
msgstr ""

#: en.xml:20222(para) 
msgid "Examine a property of a file in your working copy:"
msgstr ""

#: en.xml:20225(screen) 
#, no-wrap
msgid "\n$ svn propget svn:keywords foo.c\nAuthor\nDate\nRev\n"
msgstr ""

#: en.xml:20232(para) 
msgid "The same goes for a revision property:"
msgstr ""

#: en.xml:20234(screen) 
#, no-wrap
msgid "\n$ svn propget svn:log --revprop -r 20 \nBegan journal.\n"
msgstr ""

#: en.xml:20244(refname) 
msgid "svn proplist"
msgstr ""

#: en.xml:20245(refpurpose) 
msgid "List all properties."
msgstr ""

#: en.xml:20249(programlisting) 
#, no-wrap
msgid "svn proplist [TARGET[@REV]...]"
msgstr ""

#: en.xml:20250(programlisting) 
#, no-wrap
msgid "svn proplist --revprop -r REV [URL]"
msgstr ""

#: en.xml:20255(para) 
msgid "List all properties on files, directories, or revisions. The first form lists versioned properties in your working copy, while the second lists unversioned remote properties on a repository revision."
msgstr ""

#: en.xml:20263(para) 
msgid "plist, pl"
msgstr ""

#: en.xml:20279(screen) 
#, no-wrap
msgid "\n--verbose (-v)\n--recursive (-R)\n--revision (-r) REV\n--quiet (-q)\n--revprop\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--config-dir DIR\n"
msgstr ""

#: en.xml:20296(para) 
msgid "You can use proplist to see the properties on an item in your working copy:"
msgstr ""

#: en.xml:20299(screen) 
#, no-wrap
msgid "\n$ svn proplist foo.c\nProperties on 'foo.c':\n  svn:mime-type\n  svn:keywords\n  owner\n"
msgstr ""

#: en.xml:20307(para) 
msgid "But with the <option>--verbose</option> flag, svn proplist is extremely handy as it also shows you the values for the properties:"
msgstr ""

#: en.xml:20311(screen) 
#, no-wrap
msgid "\n$ svn proplist --verbose foo.c\nProperties on 'foo.c':\n  svn:mime-type : text/plain\n  svn:keywords : Author Date Rev\n  owner : sally\n"
msgstr ""

#: en.xml:20324(refname) 
msgid "svn propset"
msgstr ""

#: en.xml:20325(refpurpose) 
msgid "Set PROPNAME to PROPVAL on files, directories, or revisions."
msgstr ""

#: en.xml:20329(programlisting) 
#, no-wrap
msgid "svn propset PROPNAME [PROPVAL | -F VALFILE] PATH..."
msgstr ""

#: en.xml:20330(programlisting) 
#, no-wrap
msgid "svn propset PROPNAME --revprop -r REV [PROPVAL | -F VALFILE] [URL]"
msgstr ""

#: en.xml:20336(para) 
msgid "Set <replaceable>PROPNAME</replaceable> to <replaceable>PROPVAL</replaceable> on files, directories, or revisions. The first example creates a versioned, local property change in the working copy, and the second creates an unversioned, remote property change on a repository revision."
msgstr ""

#: en.xml:20344(para) 
msgid "Subversion has a number of <quote>special</quote> properties that affect its behavior. See <xref linkend=\"svn.advanced.props.special\"/> for more on these properties."
msgstr ""

#: en.xml:20352(para) 
msgid "pset, ps"
msgstr ""

#: en.xml:20368(screen) 
#, no-wrap
msgid "\n--file (-F) FILE\n--quiet (-q)\n--revision (-r) REV\n--targets FILENAME\n--recursive (-R)\n--revprop\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--encoding ENC\n--force\n--config-dir DIR\n"
msgstr ""

#: en.xml:20388(para) 
msgid "Set the mimetype on a file:"
msgstr ""

#: en.xml:20390(screen) 
#, no-wrap
msgid "\n$ svn propset svn:mime-type image/jpeg foo.jpg \nproperty 'svn:mime-type' set on 'foo.jpg'\n"
msgstr ""

#: en.xml:20395(para) 
msgid "On a UNIX system, if you want a file to have the executable permission set:"
msgstr ""

#: en.xml:20398(screen) 
#, no-wrap
msgid "\n$ svn propset svn:executable ON somescript\nproperty 'svn:executable' set on 'somescript'\n"
msgstr ""

#: en.xml:20403(para) 
msgid "Perhaps you have an internal policy to set certain properties for the benefit of your coworkers:"
msgstr ""

#: en.xml:20406(screen) 
#, no-wrap
msgid "\n$ svn propset owner sally foo.c\nproperty 'owner' set on 'foo.c'\n"
msgstr ""

#: en.xml:20411(para) 
msgid "If you made a mistake in a log message for a particular revision and want to change it, use <option>--revprop</option> and set <literal moreinfo=\"none\">svn:log</literal> to the new log message:"
msgstr ""

#: en.xml:20416(screen) 
#, no-wrap
msgid "\n$ svn propset --revprop -r 25 svn:log \"Journaled about trip to New York.\"\nproperty 'svn:log' set on repository revision '25'\n"
msgstr ""

#: en.xml:20421(para) 
msgid "Or, if you don't have a working copy, you can provide a URL."
msgstr ""

#: en.xml:20424(screen) 
#, no-wrap
msgid "\n$ svn propset --revprop -r 26 svn:log \"Document nap.\" http://svn.red-bean.com/repos\nproperty 'svn:log' set on repository revision '25'\n"
msgstr ""

#: en.xml:20429(para) 
msgid "Lastly, you can tell propset to take its input from a file. You could even use this to set the contents of a property to something binary:"
msgstr ""

#: en.xml:20433(screen) 
#, no-wrap
msgid "\n$ svn propset owner-pic -F sally.jpg moo.c \nproperty 'owner-pic' set on 'moo.c'\n"
msgstr ""

#: en.xml:20439(para) 
msgid "By default, you cannot modify revision properties in a Subversion repository. Your repository administrator must explicitly enable revision property modifications by creating a hook named <literal moreinfo=\"none\">pre-revprop-change</literal>. See <xref linkend=\"svn.reposadmin.create.hooks\"/> for more information on hook scripts."
msgstr ""

#: en.xml:20453(quote) 
msgid "conflicted"
msgstr ""

#: en.xml:20453(refpurpose) 
msgid "Remove <placeholder-1/> state on working copy files or directories."
msgstr ""

#: en.xml:20458(programlisting) 
#, no-wrap
msgid "svn resolved PATH..."
msgstr ""

#: en.xml:20463(para) 
msgid "Remove <quote>conflicted</quote> state on working copy files or directories. This routine does not semantically resolve conflict markers; it merely removes conflict-related artifact files and allows <replaceable>PATH</replaceable> to be committed again; that is, it tells Subversion that the conflicts have been <quote>resolved</quote>. See <xref linkend=\"svn.tour.cycle.resolve\"/> for an in-depth look at resolving conflicts."
msgstr ""

#: en.xml:20490(screen) en.xml:20572(screen) 
#, no-wrap
msgid "\n--targets FILENAME\n--recursive (-R)\n--quiet (-q)\n--config-dir DIR\n"
msgstr ""

#: en.xml:20501(para) 
msgid "If you get a conflict on an update, your working copy will sprout three new files:"
msgstr ""

#: en.xml:20504(screen) 
#, no-wrap
msgid "\n$ svn update\nC  foo.c\nUpdated to revision 31.\n$ ls\nfoo.c\nfoo.c.mine\nfoo.c.r30\nfoo.c.r31\n"
msgstr ""

#: en.xml:20515(para) 
msgid "Once you've resolved the conflict and <filename moreinfo=\"none\">foo.c</filename> is ready to be committed, run <command moreinfo=\"none\">svn resolved</command> to let your working copy know you've taken care of everything."
msgstr ""

#: en.xml:20521(para) 
msgid "You <emphasis>can</emphasis> just remove the conflict files and commit, but <command moreinfo=\"none\">svn resolved</command> fixes up some bookkeeping data in the working copy administrative area in addition to removing the conflict files, so we recommend that you use this command."
msgstr ""

#: en.xml:20535(refpurpose) 
msgid "Undo all local edits."
msgstr ""

#: en.xml:20539(programlisting) 
#, no-wrap
msgid "svn revert PATH..."
msgstr ""

#: en.xml:20544(para) 
msgid "Reverts any local changes to a file or directory and resolves any conflicted states. <command moreinfo=\"none\">svn revert</command> will not only revert the contents of an item in your working copy, but also any property changes. Finally, you can use it to undo any scheduling operations that you may have done (e.g. files scheduled for addition or deletion can be <quote>unscheduled</quote>)."
msgstr ""

#: en.xml:20583(para) 
msgid "Discard changes to a file:"
msgstr ""

#: en.xml:20585(screen) 
#, no-wrap
msgid "\n$ svn revert foo.c\nReverted foo.c\n"
msgstr ""

#: en.xml:20590(para) 
msgid "If you want to revert a whole directory of files, use the <option>--recursive</option> flag:"
msgstr ""

#: en.xml:20593(screen) 
#, no-wrap
msgid "\n$ svn revert --recursive .\nReverted newdir/afile\nReverted foo.c\nReverted bar.txt\n"
msgstr ""

#: en.xml:20600(para) 
msgid "Lastly, you can undo any scheduling operations:"
msgstr ""

#: en.xml:20603(screen) 
#, no-wrap
msgid "\n$ svn add mistake.txt whoops\nA         mistake.txt\nA         whoops\nA         whoops/oopsie.c\n\n$ svn revert mistake.txt whoops\nReverted mistake.txt\nReverted whoops\n\n$ svn status\n?      mistake.txt\n?      whoops\n"
msgstr ""

#: en.xml:20619(para) 
msgid "If you provide no targets to <command moreinfo=\"none\">svn revert</command>, it will do nothing—to protect you from accidentally losing changes in your working copy, <command moreinfo=\"none\">svn revert</command> requires you to provide at least one target."
msgstr ""

#: en.xml:20632(refpurpose) 
msgid "Print the status of working copy files and directories."
msgstr ""

#: en.xml:20636(programlisting) 
#, no-wrap
msgid "svn status [PATH...]"
msgstr ""

#: en.xml:20641(para) 
msgid "Print the status of working copy files and directories. With no arguments, it prints only locally modified items (no repository access). With <option>--show-updates</option>, add working revision and server out-of-date information. With <option>--verbose</option>, print full revision information on every item."
msgstr ""

#: en.xml:20649(para) 
msgid "The first six columns in the output are each one character wide, and each column gives you information about different aspects of each working copy item."
msgstr ""

#: en.xml:20653(para) 
msgid "The first column indicates that an item was added, deleted, or otherwise changed."
msgstr ""

#: en.xml:20659(term) en.xml:20754(term) en.xml:20786(term) en.xml:20807(term) en.xml:20828(term) en.xml:20848(term) en.xml:20907(term) 
msgid "' '"
msgstr ""

#: en.xml:20661(para) en.xml:20756(para) 
msgid "No modifications."
msgstr ""

#: en.xml:20666(term) 
msgid "'A'"
msgstr ""

#: en.xml:20668(para) 
msgid "Item is scheduled for Addition."
msgstr ""

#: en.xml:20673(term) 
msgid "'D'"
msgstr ""

#: en.xml:20675(para) 
msgid "Item is scheduled for Deletion."
msgstr ""

#: en.xml:20680(term) en.xml:20761(term) 
msgid "'M'"
msgstr ""

#: en.xml:20682(para) 
msgid "Item has been modified."
msgstr ""

#: en.xml:20687(term) 
msgid "'R'"
msgstr ""

#: en.xml:20689(para) 
msgid "Item has been replaced in your working copy. This means the file was scheduled for deletion, and then a new file with the same name was scheduled for addition in its place."
msgstr ""

#: en.xml:20697(term) en.xml:20769(term) 
msgid "'C'"
msgstr ""

#: en.xml:20699(para) 
msgid "The contents (as opposed to the properties) of the item conflict with updates received from the repository."
msgstr ""

#: en.xml:20706(term) 
msgid "'X'"
msgstr ""

#: en.xml:20708(para) 
msgid "Item is related to an externals definition."
msgstr ""

#: en.xml:20713(term) 
msgid "'I'"
msgstr ""

#: en.xml:20715(para) 
msgid "Item is being ignored (e.g. with the <literal moreinfo=\"none\">svn:ignore</literal> property)."
msgstr ""

#: en.xml:20721(term) 
msgid "'?'"
msgstr ""

#: en.xml:20723(para) 
msgid "Item is not under version control."
msgstr ""

#: en.xml:20728(term) 
msgid "'!'"
msgstr ""

#: en.xml:20730(para) 
msgid "Item is missing (e.g. you moved or deleted it without using <command moreinfo=\"none\">svn</command>). This also indicates that a directory is incomplete (a checkout or update was interrupted)."
msgstr ""

#: en.xml:20738(term) 
msgid "'~'"
msgstr ""

#: en.xml:20740(para) 
msgid "Item is versioned as one kind of object (file, directory, link), but has been replaced by different kind of object."
msgstr ""

#: en.xml:20748(para) 
msgid "The second column tells the status of a file's or directory's properties."
msgstr ""

#: en.xml:20763(para) 
msgid "Properties for this item have been modified."
msgstr ""

#: en.xml:20771(para) 
msgid "Properties for this item are in conflict with property updates received from the repository."
msgstr ""

#: en.xml:20779(para) 
msgid "The third column is populated only if the working copy directory is locked. (See <xref linkend=\"svn.tour.other.cleanup\"/>.)"
msgstr ""

#: en.xml:20788(para) 
msgid "Item is not locked."
msgstr ""

#: en.xml:20793(term) 
msgid "'L'"
msgstr ""

#: en.xml:20795(para) 
msgid "Item is locked."
msgstr ""

#: en.xml:20801(para) 
msgid "The fourth column is populated only if the item is scheduled for addition-with-history."
msgstr ""

#: en.xml:20809(para) 
msgid "No history scheduled with commit."
msgstr ""

#: en.xml:20814(term) 
msgid "'+'"
msgstr ""

#: en.xml:20816(para) 
msgid "History scheduled with commit."
msgstr ""

#: en.xml:20822(para) 
msgid "The fifth column is populated only if the item is switched relative to its parent (see <xref linkend=\"svn.branchmerge.switchwc\"/>)."
msgstr ""

#: en.xml:20830(para) 
msgid "Item is a child of its parent directory."
msgstr ""

#: en.xml:20835(term) 
msgid "'S'"
msgstr ""

#: en.xml:20837(para) 
msgid "Item is switched."
msgstr ""

#: en.xml:20843(para) 
msgid "The sixth column is populated with lock information."
msgstr ""

#: en.xml:20850(para) 
msgid "When <option>--show-updates</option> is used, the file is not locked. If <option>--show-updates</option> is <emphasis>not</emphasis> used, this merely means that the file is not locked in this working copy."
msgstr ""

#: en.xml:20859(term) 
msgid "K"
msgstr ""

#: en.xml:20861(para) 
msgid "File is locked in this working copy."
msgstr ""

#: en.xml:20866(term) 
msgid "O"
msgstr ""

#: en.xml:20868(para) 
msgid "File is locked either by another user or in another working copy. This only appears when <option>--show-updates</option> is used."
msgstr ""

#: en.xml:20875(term) 
msgid "T"
msgstr ""

#: en.xml:20877(para) 
msgid "File was locked in this working copy, but the lock has been <quote>stolen</quote>and is invalid. The file is currently locked in the repository. This only appears when <option>--show-updates</option> is used."
msgstr ""

#: en.xml:20886(term) 
msgid "B"
msgstr ""

#: en.xml:20888(para) 
msgid "File was locked in this working copy, but the lock has been <quote>broken</quote>and is invalid. The file is no longer locked This only appears when <option>--show-updates</option> is used."
msgstr ""

#: en.xml:20900(para) 
msgid "The out-of-date information appears in the seventh column (only if you pass the <option>--show-updates</option> switch)."
msgstr ""

#: en.xml:20909(para) 
msgid "The item in your working copy is up-to-date."
msgstr ""

#: en.xml:20914(term) 
msgid "'*'"
msgstr ""

#: en.xml:20916(para) 
msgid "A newer revision of the item exists on the server."
msgstr ""

#: en.xml:20923(para) 
msgid "The remaining fields are variable width and delimited by spaces. The working revision is the next field if the <option>--show-updates</option> or <option>--verbose</option> switches are passed."
msgstr ""

#: en.xml:20928(para) 
msgid "If the <option>--verbose</option> switch is passed, the last committed revision and last committed author are displayed next."
msgstr ""

#: en.xml:20932(para) 
msgid "The working copy path is always the final field, so it can include spaces."
msgstr ""

#: en.xml:20939(para) 
msgid "stat, st"
msgstr ""

#: en.xml:20949(para) 
msgid "Only if using <option>--show-updates</option>"
msgstr ""

#: en.xml:20955(screen) 
#, no-wrap
msgid "\n--show-updates (-u)\n--verbose (-v)\n--non-recursive (-N)\n--quiet (-q)\n--no-ignore\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--config-dir\n--ignore-externals\n"
msgstr ""

#: en.xml:20973(para) 
msgid "This is the easiest way to find out what changes you have made to your working copy:"
msgstr ""

#: en.xml:20976(screen) 
#, no-wrap
msgid "\n$ svn status wc\n M     wc/bar.c\nA  +   wc/qax.c\n"
msgstr ""

#: en.xml:20982(para) 
msgid "If you want to find out what files in your working copy are out-of-date, pass the <option>--show-updates</option> switch (this will <emphasis>not</emphasis> make any changes to your working copy). Here you can see that <filename moreinfo=\"none\">wc/foo.c</filename> has changed in the repository since we last updated our working copy:"
msgstr ""

#: en.xml:20991(screen) 
#, no-wrap
msgid "\n$ svn status --show-updates wc\n M           965    wc/bar.c\n       *     965    wc/foo.c\nA  +         965    wc/qax.c\nStatus against revision:    981\n"
msgstr ""

#: en.xml:21000(para) 
msgid "<option>--show-updates</option><emphasis>only</emphasis> places an asterisk next to items that are out of date (that is, items that will be updated from the repository if you run <command moreinfo=\"none\">svn update</command>). <option>--show-updates</option> does <emphasis>not</emphasis> cause the status listing to reflect the repository's version of the item."
msgstr ""

#: en.xml:21009(para) 
msgid "And finally, the most information you can get out of the status subcommand:"
msgstr ""

#: en.xml:21012(screen) 
#, no-wrap
msgid "\n$ svn status --show-updates --verbose wc\n M           965       938 sally        wc/bar.c\n       *     965       922 harry        wc/foo.c\nA  +         965       687 harry        wc/qax.c\n             965       687 harry        wc/zig.c\nHead revision:   981\n"
msgstr ""

#: en.xml:21021(para) 
msgid "For many more examples of <command moreinfo=\"none\">svn status</command>, see <xref linkend=\"svn.tour.cycle.examine.status\"/>."
msgstr ""

#: en.xml:21029(refname) 
msgid "svn switch"
msgstr ""

#: en.xml:21030(refpurpose) 
msgid "Update working copy to a different URL."
msgstr ""

#: en.xml:21034(programlisting) 
#, no-wrap
msgid "svn switch URL [PATH]"
msgstr ""

#: en.xml:21036(programlisting) 
#, no-wrap
msgid "switch --relocate FROM TO [PATH...]"
msgstr ""

#: en.xml:21043(para) 
msgid "This subcommand updates your working copy to mirror a new URL—usually a URL which shares a common ancestor with your working copy, although not necessarily. This is the Subversion way to move a working copy to a new branch. See <xref linkend=\"svn.branchmerge.switchwc\"/> for an in-depth look at switching."
msgstr ""

#: en.xml:21053(para) 
msgid "sw"
msgstr ""

#: en.xml:21069(screen) 
#, no-wrap
msgid "\n--revision (-r) REV\n--non-recursive (-N)\n--quiet (-q)\n--diff3-cmd CMD\n--relocate\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--config-dir DIR\n"
msgstr ""

#: en.xml:21086(para) 
msgid "If you're currently inside the directory <filename moreinfo=\"none\">vendors</filename> which was branched to <filename moreinfo=\"none\">vendors-with-fix</filename> and you'd like to switch your working copy to that branch:"
msgstr ""

#: en.xml:21091(screen) 
#, no-wrap
msgid "\n$ svn switch http://svn.red-bean.com/repos/branches/vendors-with-fix .\nU  myproj/foo.txt\nU  myproj/bar.txt\nU  myproj/baz.c\nU  myproj/qux.c\nUpdated to revision 31.\n"
msgstr ""

#: en.xml:21100(para) 
msgid "And to switch back, just provide the URL to the location in the repository from which you originally checked out your working copy:"
msgstr ""

#: en.xml:21104(screen) 
#, no-wrap
msgid "\n$ svn switch http://svn.red-bean.com/repos/trunk/vendors .\nU  myproj/foo.txt\nU  myproj/bar.txt\nU  myproj/baz.c\nU  myproj/qux.c\nUpdated to revision 31.\n"
msgstr ""

#: en.xml:21114(para) 
msgid "You can just switch part of your working copy to a branch if you don't want to switch your entire working copy."
msgstr ""

#: en.xml:21119(para) 
msgid "Sometimes an administrator might change the <quote>base location</quote> of your repository—in other words, the contents of the repository doesn't change, but the main URL used to reach the root of the repository does. For example, the hostname may change, the URL scheme, or any part of the URL which leads to the repository itself. Rather than checkout a new working copy, you can have the <command moreinfo=\"none\">svn switch</command> command <quote>rewrite</quote> the beginnings of all the URLs in your working copy. Use the <option>--relocate</option> option to do the substitution. No file contents are changed, nor is the repository contacted. It's similar to running a Perl script over your working copy <filename moreinfo=\"none\">.svn/</filename> directories which runs <command moreinfo=\"none\">s/OldRoot/NewRoot/</command>."
msgstr ""

#: en.xml:21135(screen) 
#, no-wrap
msgid "\n$ svn checkout file:///tmp/repos test\nA  test/a\nA  test/b\n…\n\n$ mv repos newlocation\n$ cd test/\n\n$ svn update\nsvn: Unable to open an ra_local session to URL\nsvn: Unable to open repository 'file:///tmp/repos'\n\n$ svn switch --relocate file:///tmp/repos file:///tmp/newlocation .\n$ svn update\nAt revision 3.\n"
msgstr ""

#: en.xml:21154(para) 
msgid "Be careful when using the <option>--relocate</option> option. If you mistype the argument, you might end up creating nonsensical URLs within your working copy that render the whole workspace unusable and tricky to fix. It's also important to understand exactly when one should or shouldn't use <option>--relocate</option>. Here's the rule of thumb:"
msgstr ""

#: en.xml:21164(para) 
msgid "If the working copy needs to reflect a new directory <emphasis>within</emphasis> the repository, then use just <command moreinfo=\"none\">svn switch</command>."
msgstr ""

#: en.xml:21169(para) 
msgid "If the working copy still reflects the same repository directory, but the location of the repository itself has changed, then use <command moreinfo=\"none\">svn switch --relocate</command>."
msgstr ""

#: en.xml:21182(refname) 
msgid "svn unlock"
msgstr ""

#: en.xml:21183(refpurpose) 
msgid "Unlock working copy paths or URLs."
msgstr ""

#: en.xml:21187(programlisting) 
#, no-wrap
msgid "svn unlock TARGET..."
msgstr ""

#: en.xml:21192(para) 
msgid "Unlock each <replaceable>TARGET</replaceable>. If any <replaceable>TARGET</replaceable> is either locked by another user or no valid lock token exists in the working copy, print a warning and continue unlocking the rest of the <replaceable>TARGET</replaceable>s. Use <option>--force</option> to break a lock belonging to another user or working copy."
msgstr ""

#: en.xml:21220(screen) 
#, no-wrap
msgid "\n--targets ARG\n--username ARG\n--password ARG\n--no-auth-cache\n--non-interactive\n--config-dir ARG\n--force\n"
msgstr ""

#: en.xml:21234(para) 
msgid "Unlock two files in your working copy:"
msgstr ""

#: en.xml:21236(screen) 
#, no-wrap
msgid "\n\n$ svn unlock tree.jpg house.jpg\n'tree.jpg' unlocked.\n'house.jpg' unlocked.\n"
msgstr ""

#: en.xml:21243(para) 
msgid "Unlock a file in your working copy that is currently locked by another user:"
msgstr ""

#: en.xml:21246(screen) 
#, no-wrap
msgid "\n$ svn unlock tree.jpg\nsvn: 'tree.jpg' is not locked in this working copy\n$ svn unlock --force tree.jpg\n'tree.jpg' unlocked.\n"
msgstr ""

#: en.xml:21253(para) 
msgid "Unlock a file without a working copy:"
msgstr ""

#: en.xml:21255(screen) 
#, no-wrap
msgid "\n$ svn unlock http://svn.red-bean.com/repos/test/tree.jpg\n'tree.jpg unlocked.\n"
msgstr ""

#: en.xml:21269(refpurpose) 
msgid "Update your working copy."
msgstr ""

#: en.xml:21273(programlisting) 
#, no-wrap
msgid "svn update [PATH...]"
msgstr ""

#: en.xml:21278(para) 
msgid "<command moreinfo=\"none\">svn update</command> brings changes from the repository into your working copy. If no revision given, it brings your working copy up-to-date with the <literal moreinfo=\"none\">HEAD</literal> revision. Otherwise, it synchronizes the working copy to the revision given by the <option>--revision</option> switch. As part of the synchronization, <command moreinfo=\"none\">svn update</command> also removes any stale locks (see <xref linkend=\"svn.tour.other.cleanup\"/>) found in the working copy."
msgstr ""

#: en.xml:21288(para) 
msgid "For each updated item a line will start with a character reporting the action taken. These characters have the following meaning:"
msgstr ""

#: en.xml:21295(term) 
msgid "A"
msgstr ""

#: en.xml:21297(para) 
msgid "Added"
msgstr ""

#: en.xml:21302(term) 
msgid "D"
msgstr ""

#: en.xml:21304(para) 
msgid "Deleted"
msgstr ""

#: en.xml:21309(term) 
msgid "U"
msgstr ""

#: en.xml:21311(para) 
msgid "Updated"
msgstr ""

#: en.xml:21316(term) 
msgid "C"
msgstr ""

#: en.xml:21318(para) 
msgid "Conflict"
msgstr ""

#: en.xml:21323(term) 
msgid "G"
msgstr ""

#: en.xml:21325(para) 
msgid "Merged"
msgstr ""

#: en.xml:21331(para) 
msgid "A character in the first column signifies an update to the actual file, while updates to the file's properties are shown in the second column."
msgstr ""

#: en.xml:21338(para) 
msgid "up"
msgstr ""

#: en.xml:21354(screen) 
#, no-wrap
msgid "\n--revision (-r) REV\n--non-recursive (-N)\n--quiet (-q)\n--diff3-cmd CMD\n--username USER\n--password PASS\n--no-auth-cache\n--non-interactive\n--config-dir DIR\n--ignore-externals\n"
msgstr ""

#: en.xml:21371(para) 
msgid "Pick up repository changes that have happened since your last update:"
msgstr ""

#: en.xml:21374(screen) 
#, no-wrap
msgid "\n$ svn update\nA  newdir/toggle.c\nA  newdir/disclose.c\nA  newdir/launch.c\nD  newdir/README\nUpdated to revision 32.\n"
msgstr ""

#: en.xml:21383(para) 
msgid "You can also update your working copy to an older revision (Subversion doesn't have the concept of <quote>sticky</quote> files like CVS does; see <xref linkend=\"svn.forcvs\"/>):"
msgstr ""

#: en.xml:21387(screen) 
#, no-wrap
msgid "\n$ svn update -r30\nA  newdir/README\nD  newdir/toggle.c\nD  newdir/disclose.c\nD  newdir/launch.c\nU  foo.c\nUpdated to revision 30.\n"
msgstr ""

#: en.xml:21398(para) 
msgid "If you want to examine an older revision of a single file, you may want to use <command moreinfo=\"none\">svn cat</command>."
msgstr ""

#: en.xml:21415(para) 
msgid "<command moreinfo=\"none\">svnadmin</command> is the administrative tool for monitoring and repairing your Subversion repository. For detailed information, see <xref linkend=\"svn.reposadmin.maint.tk.svnadmin\"/>."
msgstr ""

#: en.xml:21419(para) 
msgid "Since <command moreinfo=\"none\">svnadmin</command> works via direct repository access (and thus can only be used on the machine that holds the repository), it refers to the repository with a path, not a URL."
msgstr ""

#: en.xml:21425(title) 
msgid "<command moreinfo=\"none\">svnadmin</command> Switches"
msgstr ""

#: en.xml:21430(option) 
msgid "--bdb-log-keep"
msgstr ""

#: en.xml:21432(para) 
msgid "(Berkeley DB specific) Disable automatic log removal of database log files."
msgstr ""

#: en.xml:21438(option) 
msgid "--bdb-txn-nosync"
msgstr ""

#: en.xml:21440(para) 
msgid "(Berkeley DB specific) Disables fsync when committing database transactions."
msgstr ""

#: en.xml:21446(option) 
msgid "--bypass-hooks"
msgstr ""

#: en.xml:21448(para) 
msgid "Bypass the repository hook system."
msgstr ""

#: en.xml:21453(option) 
msgid "--clean-logs"
msgstr ""

#: en.xml:21455(para) 
msgid "Removes unused Berkeley DB logs."
msgstr ""

#: en.xml:21462(option) 
msgid "--force-uuid"
msgstr ""

#: en.xml:21464(para) 
msgid "By default, when loading data into repository that already contains revisions, <command moreinfo=\"none\">svnadmin</command> will ignore the <literal moreinfo=\"none\">UUID</literal> from the dump stream. This switch will cause the repository's <literal moreinfo=\"none\">UUID</literal> to be set to the <literal moreinfo=\"none\">UUID</literal> from the stream."
msgstr ""

#: en.xml:21474(option) 
msgid "--ignore-uuid"
msgstr ""

#: en.xml:21476(para) 
msgid "By default, when loading an empty repository, <command moreinfo=\"none\">svnadmin</command> will use the <literal moreinfo=\"none\">UUID</literal> from the dump stream. This switch will cause that UUID to be ignored."
msgstr ""

#: en.xml:21486(para) 
msgid "Dump a revision only as a diff against the previous revision, instead of the usual fulltext."
msgstr ""

#: en.xml:21493(option) 
msgid "--parent-dir <placeholder-1/>"
msgstr ""

#: en.xml:21496(para) 
msgid "When loading a dump file, root paths at <replaceable>DIR</replaceable> instead of <filename moreinfo=\"none\">/</filename>."
msgstr ""

#: en.xml:21503(term) 
msgid "<option>--revision</option> (<option>-r</option>) <replaceable>ARG</replaceable>"
msgstr ""

#: en.xml:21506(para) 
msgid "Specify a particular revision to operate on."
msgstr ""

#: en.xml:21512(option) 
msgid "--quiet"
msgstr ""

#: en.xml:21514(para) 
msgid "Do not show normal progress—show only errors."
msgstr ""

#: en.xml:21520(option) 
msgid "--use-post-commit-hook"
msgstr ""

#: en.xml:21522(para) 
msgid "When loading a dump file, run the repository's post-commit hook after finalizing each newly loaded revision."
msgstr ""

#: en.xml:21529(option) 
msgid "--use-pre-commit-hook"
msgstr ""

#: en.xml:21531(para) 
msgid "When loading a dump file, run the repository's pre-commit hook before finalizing each newly loaded revision. If the hook fails, abort the commit and terminate the load process."
msgstr ""

#: en.xml:21543(title) 
msgid "<command moreinfo=\"none\">svnadmin</command> Subcommands"
msgstr ""

#: en.xml:21547(refname) 
msgid "svnadmin create"
msgstr ""

#: en.xml:21548(refpurpose) 
msgid "Create a new, empty repository."
msgstr ""

#: en.xml:21552(programlisting) 
#, no-wrap
msgid "svnadmin create REPOS_PATH"
msgstr ""

#: en.xml:21559(para) 
msgid "Remember, <command moreinfo=\"none\">svnadmin</command> works only with local <emphasis>paths</emphasis>, not <emphasis>URLs</emphasis>."
msgstr ""

#: en.xml:21557(para) 
msgid "Create a new, empty repository at the path provided. If the provided directory does not exist, it will be created for you.<placeholder-1/> As of Subversion 1.2, <command moreinfo=\"none\">svnadmin</command> creates new repositories with the <literal moreinfo=\"none\">fsfs</literal> filesystem backend by default."
msgstr ""

#: en.xml:21571(screen) 
#, no-wrap
msgid "\n--bdb-txn-nosync\n--bdb-log-keep\n--config-dir DIR\n--fs-type TYPE\n"
msgstr ""

#: en.xml:21582(para) 
msgid "Creating a new repository is just this easy:"
msgstr ""

#: en.xml:21584(screen) 
#, no-wrap
msgid "\n$ svnadmin create /usr/local/svn/repos\n"
msgstr ""

#: en.xml:21588(para) 
msgid "In Subversion 1.0, a Berkeley DB repository is always created. In Subversion 1.1, a Berkeley DB repository is the default repository type, but an FSFS repository can be created using the <option>--fs-type</option> option:"
msgstr ""

#: en.xml:21594(screen) 
#, no-wrap
msgid "\n$ svnadmin create /usr/local/svn/repos --fs-type fsfs\n"
msgstr ""

#: en.xml:21603(refname) 
msgid "svnadmin deltify"
msgstr ""

#: en.xml:21604(refpurpose) 
msgid "Deltify changed paths in a revision range."
msgstr ""

#: en.xml:21608(programlisting) 
#, no-wrap
msgid "svnadmin deltify [-r LOWER[:UPPER]] REPOS_PATH"
msgstr ""

#: en.xml:21613(para) 
msgid "<command moreinfo=\"none\">svnadmin deltify</command> only exists in 1.0.x due to historical reasons. This command is deprecated and no longer needed."
msgstr ""

#: en.xml:21617(para) 
msgid "It dates from a time when Subversion offered administrators greater control over compression strategies in the repository. This turned out to be a lot of complexity for <emphasis>very</emphasis> little gain, and this <quote>feature</quote> was deprecated."
msgstr ""

#: en.xml:21627(screen) 
#, no-wrap
msgid "\n--revision (-r)\n--quiet\n"
msgstr ""

#: en.xml:21636(refname) 
msgid "svnadmin dump"
msgstr ""

#: en.xml:21637(refpurpose) 
msgid "Dump the contents of filesystem to stdout."
msgstr ""

#: en.xml:21641(programlisting) 
#, no-wrap
msgid "svnadmin dump REPOS_PATH [-r LOWER[:UPPER]] [--incremental]"
msgstr ""

#: en.xml:21646(para) 
msgid "Dump the contents of filesystem to stdout in a <quote>dumpfile</quote> portable format, sending feedback to stderr. Dump revisions <replaceable>LOWER</replaceable> rev through <replaceable>UPPER</replaceable> rev. If no revisions are given, dump all revision trees. If only <replaceable>LOWER</replaceable> is given, dump that one revision tree. See <xref linkend=\"svn.reposadmin.maint.migrate\"/> for a practical use."
msgstr ""

#: en.xml:21656(para) 
msgid "By default, the Subversion dumpfile stream contains a single revision (the first revision in the requested revision range) in which every file and directory in the repository in that revision is presented as if that whole tree was added at once, followed by other revisions (the remainder of the revisions in the requested range) which contain only the files and directories which were modified in those revisions. For a modified file, the complete fulltext representation of its contents, as well as all of its properties, are presented in the dumpfile; for a directory, all of its properties are presented."
msgstr ""

#: en.xml:21668(para) 
msgid "There are a pair of useful options which modify the dumpfile generator's behavior. The first is the <option>--incremental</option> option, which simply causes that first revision in the dumpfile stream to contain only the files and directories modified in that revision, instead of being presented as the addition of a new tree, and in exactly the same way that every other revision in the dumpfile is presented. This is useful for generating a dumpfile that is to be loaded into another repository which already has the files and directories that exist in the original repository."
msgstr ""

#: en.xml:21680(para) 
msgid "The second useful option is <option>--deltas</option>. This switch causes <command moreinfo=\"none\">svnadmin dump</command> to, instead of emitting fulltext representations of file contents and property lists, emit only deltas of those items against their previous versions. This reduces (in some cases, drastically) the size of the dumpfile that <command moreinfo=\"none\">svnadmin dump</command> creates. There are, however, disadvantages to using this option—deltified dumpfiles are more CPU intensive to create, cannot be operated on by <command moreinfo=\"none\">svndumpfilter</command>, and tend not to compress as well as their non-deltified counterparts when using third-party tools like <command moreinfo=\"none\">gzip</command> and <command moreinfo=\"none\">bzip2</command>."
msgstr ""

#: en.xml:21698(screen) 
#, no-wrap
msgid "\n--revision (-r)\n--incremental\n--quiet\n--deltas\n"
msgstr ""

#: en.xml:21709(para) 
msgid "Dump your whole repository:"
msgstr ""

#: en.xml:21711(screen) 
#, no-wrap
msgid "\n$ svnadmin dump /usr/local/svn/repos\nSVN-fs-dump-format-version: 1\nRevision-number: 0\n* Dumped revision 0.\nProp-content-length: 56\nContent-length: 56\n…\n"
msgstr ""

#: en.xml:21721(para) 
msgid "Incrementally dump a single transaction from your repository:"
msgstr ""

#: en.xml:21724(screen) 
#, no-wrap
msgid "\n$ svnadmin dump /usr/local/svn/repos -r 21 --incremental \n* Dumped revision 21.\nSVN-fs-dump-format-version: 1\nRevision-number: 21\nProp-content-length: 101\nContent-length: 101\n…\n"
msgstr ""

#: en.xml:21739(refname) 
msgid "svnadmin help"
msgstr ""

#: en.xml:21743(programlisting) 
#, no-wrap
msgid "svnadmin help [SUBCOMMAND...]"
msgstr ""

#: en.xml:21749(para) 
msgid "This subcommand is useful when you're trapped on a desert island with neither a net connection nor a copy of this book."
msgstr ""

#: en.xml:21764(refname) 
msgid "svnadmin hotcopy"
msgstr ""

#: en.xml:21765(refpurpose) 
msgid "Make a hot copy of a repository."
msgstr ""

#: en.xml:21769(programlisting) 
#, no-wrap
msgid "svnadmin hotcopy REPOS_PATH NEW_REPOS_PATH"
msgstr ""

#: en.xml:21775(para) 
msgid "This subcommand makes a full <quote>hot</quote> backup of your repository, including all hooks, configuration files, and, of course, database files. If you pass the <option>--clean-logs</option> switch, <command moreinfo=\"none\">svnadmin</command> will perform a hotcopy of your repository, and then remove unused Berkeley DB logs from the original repository. You can run this command at any time and make a safe copy of the repository, regardless of whether other processes are using the repository."
msgstr ""

#: en.xml:21790(screen) 
#, no-wrap
msgid "\n--clean-logs\n"
msgstr ""

#: en.xml:21799(refname) 
msgid "svnadmin list-dblogs"
msgstr ""

#: en.xml:21802(literal) en.xml:21827(literal) en.xml:22002(literal) 
msgid "bdb"
msgstr ""

#: en.xml:21799(refpurpose) 
msgid "Ask Berkeley DB which log files exist for a given Subversion repository (applies only to repositories using the <placeholder-1/> backend)."
msgstr ""

#: en.xml:21806(programlisting) 
#, no-wrap
msgid "svnadmin list-dblogs REPOS_PATH"
msgstr ""

#: en.xml:21811(para) en.xml:21836(para) 
msgid "Berkeley DB creates logs of all changes to the repository, which allow it to recover in the face of catastrophe. Unless you enable <literal moreinfo=\"none\">DB_LOG_AUTOREMOVE</literal>, the log files accumulate, although most are no longer used and can be deleted to reclaim disk space. See <xref linkend=\"svn.reposadmin.maint.diskspace\"/> for more information."
msgstr ""

#: en.xml:21824(refname) 
msgid "svnadmin list-unused-dblogs"
msgstr ""

#: en.xml:21825(refpurpose) 
msgid "Ask Berkeley DB which log files can be safely deleted (applies only to repositories using the <placeholder-1/> backend)."
msgstr ""

#: en.xml:21831(programlisting) 
#, no-wrap
msgid "svnadmin list-unused-dblogs REPOS_PATH"
msgstr ""

#: en.xml:21848(para) 
msgid "Remove all unused log files from a repository:"
msgstr ""

#: en.xml:21865(refname) 
msgid "svnadmin load"
msgstr ""

#: en.xml:21866(quote) 
msgid "dumpfile"
msgstr ""

#: en.xml:21865(refpurpose) 
msgid "Read a <placeholder-1/>-formatted stream from stdin."
msgstr ""

#: en.xml:21871(programlisting) 
#, no-wrap
msgid "svnadmin load REPOS_PATH"
msgstr ""

#: en.xml:21876(para) 
msgid "Read a <quote>dumpfile</quote>-formatted stream from stdin, committing new revisions into the repository's filesystem. Send progress feedback to stdout."
msgstr ""

#: en.xml:21884(screen) 
#, no-wrap
msgid "\n--quiet (-q)\n--ignore-uuid\n--force-uuid\n--use-pre-commit-hook\n--use-post-commit-hook\n--parent-dir\n"
msgstr ""

#: en.xml:21895(title) en.xml:21944(title) en.xml:22094(title) 
msgid "Example"
msgstr ""

#: en.xml:21897(para) 
msgid "This shows the beginning of loading a repository from a backup file (made, of course, with <command moreinfo=\"none\">svnadmin dump</command>):"
msgstr ""

#: en.xml:21901(screen) 
#, no-wrap
msgid "\n$ svnadmin load /usr/local/svn/restored &lt; repos-backup\n&lt;&lt;&lt; Started new txn, based on original revision 1\n     * adding path : test ... done.\n     * adding path : test/a ... done.\n…\n"
msgstr ""

#: en.xml:21909(para) 
msgid "Or if you want to load into a subdirectory:"
msgstr ""

#: en.xml:21911(screen) 
#, no-wrap
msgid "\n$ svnadmin load --parent-dir new/subdir/for/project /usr/local/svn/restored &lt; repos-backup\n&lt;&lt;&lt; Started new txn, based on original revision 1\n     * adding path : test ... done.\n     * adding path : test/a ... done.\n…\n"
msgstr ""

#: en.xml:21924(refname) 
msgid "svnadmin lslocks"
msgstr ""

#: en.xml:21925(refpurpose) 
msgid "Print descriptions of all locks."
msgstr ""

#: en.xml:21929(programlisting) 
#, no-wrap
msgid "svnadmin lslocks REPOS_PATH"
msgstr ""

#: en.xml:21934(para) 
msgid "Print descriptions of all locks in a repository."
msgstr ""

#: en.xml:21947(para) 
msgid "This lists the one locked file in the repository at <filename moreinfo=\"none\">/svn/repos</filename>"
msgstr ""

#: en.xml:21950(screen) 
#, no-wrap
msgid "\n$ svnadmin lslocks /svn/repos\nPath: /tree.jpg\nUUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753\nOwner: harry\nCreated: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)\nExpires: \nComment (1 line):\nRework the uppermost branches on the bald cypress in the foreground.\n"
msgstr ""

#: en.xml:21965(refname) 
msgid "svnadmin lstxns"
msgstr ""

#: en.xml:21966(refpurpose) 
msgid "Print the names of all uncommitted transactions."
msgstr ""

#: en.xml:21970(programlisting) 
#, no-wrap
msgid "svnadmin lstxns REPOS_PATH"
msgstr ""

#: en.xml:21975(para) 
msgid "Print the names of all uncommitted transactions. See <xref linkend=\"svn.reposadmin.maint.cleanup\"/> for information on how uncommitted transactions are created and what you should do with them."
msgstr ""

#: en.xml:21984(para) 
msgid "List all outstanding transactions in a repository."
msgstr ""

#: en.xml:21987(screen) 
#, no-wrap
msgid "\n$ svnadmin lstxns /usr/local/svn/repos/ \n1w\n1x\n"
msgstr ""

#: en.xml:21998(refname) 
msgid "svnadmin recover"
msgstr ""

#: en.xml:22003(filename) 
msgid "repos/conf/passwd"
msgstr ""

#: en.xml:22000(refpurpose) 
msgid "Bring a repository database back into a consistent state (applies only to repositories using the <placeholder-1/> backend). In addition, if <placeholder-2/> does not exist, it will create a default password file ."
msgstr ""

#: en.xml:22009(programlisting) 
#, no-wrap
msgid "svnadmin recover REPOS_PATH"
msgstr ""

#: en.xml:22014(para) 
msgid "Run this command if you get an error indicating that your repository needs to be recovered."
msgstr ""

#: en.xml:22019(screen) 
#, no-wrap
msgid "\n--wait\n"
msgstr ""

#: en.xml:22026(para) 
msgid "Recover a hung repository:"
msgstr ""

#: en.xml:22028(screen) 
#, no-wrap
msgid "\n$ svnadmin recover /usr/local/svn/repos/ \nRepository lock acquired.\nPlease wait; recovering the repository may take some time...\n\nRecovery completed.\nThe latest repos revision is 34.\n"
msgstr ""

#: en.xml:22037(para) 
msgid "Recovering the database requires an exclusive lock on the repository. (This is a <quote>database lock</quote>; see <xref linkend=\"svn.advanced.locking.meanings\"/>.) If another process is accessing the repository, then <command moreinfo=\"none\">svnadmin recover</command> will error:"
msgstr ""

#: en.xml:22042(screen) 
#, no-wrap
msgid "\n$ svnadmin recover /usr/local/svn/repos\nsvn: Failed to get exclusive repository access; perhaps another process\nsuch as httpd, svnserve or svn has it open?\n\n$\n"
msgstr ""

#: en.xml:22050(para) 
msgid "The <option>--wait</option> option, however, will cause <command moreinfo=\"none\">svnadmin recover</command> to wait indefinitely for other processes to disconnect:"
msgstr ""

#: en.xml:22054(screen) 
#, no-wrap
msgid "\n$ svnadmin recover /usr/local/svn/repos --wait\nWaiting on repository lock; perhaps another process has it open?\n\n### time goes by…\n\nRepository lock acquired.\nPlease wait; recovering the repository may take some time...\n\nRecovery completed.\nThe latest repos revision is 34.\n"
msgstr ""

#: en.xml:22073(refname) 
msgid "svnadmin rmlocks"
msgstr ""

#: en.xml:22074(refpurpose) 
msgid "Unconditionally remove one or more locks from a repository."
msgstr ""

#: en.xml:22079(programlisting) 
#, no-wrap
msgid "svnadmin rmlocks REPOS_PATH LOCKED_PATH..."
msgstr ""

#: en.xml:22084(para) 
msgid "Remove lock from each <replaceable>LOCKED_PATH</replaceable>."
msgstr ""

#: en.xml:22096(para) 
msgid "This deletes the locks on <filename moreinfo=\"none\">tree.jpg</filename> and <filename moreinfo=\"none\">house.jpg</filename> in the repository at <filename moreinfo=\"none\">/svn/repos</filename>"
msgstr ""

#: en.xml:22101(screen) 
#, no-wrap
msgid "\n$ svnadmin rmlocks /svn/repos tree.jpg house.jpg\nRemoved lock on '/tree.jpg.\nRemoved lock on '/house.jpg.\n"
msgstr ""

#: en.xml:22112(refname) 
msgid "svnadmin rmtxns"
msgstr ""

#: en.xml:22113(refpurpose) 
msgid "Delete transactions from a repository."
msgstr ""

#: en.xml:22117(programlisting) 
#, no-wrap
msgid "svnadmin rmtxns REPOS_PATH TXN_NAME..."
msgstr ""

#: en.xml:22122(para) 
msgid "Delete outstanding transactions from a repository. This is covered in detail in <xref linkend=\"svn.reposadmin.maint.cleanup\"/>."
msgstr ""

#: en.xml:22129(screen) 
#, no-wrap
msgid "\n--quiet (-q)\n"
msgstr ""

#: en.xml:22137(para) 
msgid "Remove named transactions:"
msgstr ""

#: en.xml:22139(screen) 
#, no-wrap
msgid "\n$ svnadmin rmtxns /usr/local/svn/repos/ 1w 1x\n"
msgstr ""

#: en.xml:22143(para) 
msgid "Fortunately, the output of <command moreinfo=\"none\">lstxns</command> works great as the input for <command moreinfo=\"none\">rmtxns</command>:"
msgstr ""

#: en.xml:22146(screen) 
#, no-wrap
msgid "\n$ svnadmin rmtxns /usr/local/svn/repos/  `svnadmin lstxns /usr/local/svn/repos/`\n"
msgstr ""

#: en.xml:22150(para) 
msgid "Which will remove all uncommitted transactions from your repository."
msgstr ""

#: en.xml:22159(refname) 
msgid "svnadmin setlog"
msgstr ""

#: en.xml:22160(refpurpose) 
msgid "Set the log-message on a revision."
msgstr ""

#: en.xml:22164(programlisting) 
#, no-wrap
msgid "svnadmin setlog REPOS_PATH -r REVISION FILE"
msgstr ""

#: en.xml:22169(para) 
msgid "Set the log-message on revision REVISION to the contents of FILE."
msgstr ""

#: en.xml:22172(para) 
msgid "This is similar to using <command moreinfo=\"none\">svn propset --revprop</command> to set the <literal moreinfo=\"none\">svn:log</literal> property on a revision, except that you can also use the option <option>--bypass-hooks</option> to avoid running any pre- or post-commit hooks, which is useful if the modification of revision properties has not been enabled in the pre-revprop-change hook."
msgstr ""

#: en.xml:22181(para) 
msgid "Revision properties are not under version control, so this command will permanently overwrite the previous log message."
msgstr ""

#: en.xml:22191(screen) 
#, no-wrap
msgid "\n--revision (-r) ARG\n--bypass-hooks\n"
msgstr ""

#: en.xml:22200(para) 
msgid "Set the log message for revision 19 to the contents of the file <filename moreinfo=\"none\">msg</filename>:"
msgstr ""

#: en.xml:22203(screen) 
#, no-wrap
msgid "\n$ svnadmin setlog /usr/local/svn/repos/ -r 19 msg\n"
msgstr ""

#: en.xml:22212(refname) 
msgid "svnadmin verify"
msgstr ""

#: en.xml:22213(refpurpose) 
msgid "Verify the data stored in the repository."
msgstr ""

#: en.xml:22217(programlisting) 
#, no-wrap
msgid "svnadmin verify REPOS_PATH"
msgstr ""

#: en.xml:22222(para) 
msgid "Run this command if you wish to verify the integrity of your repository. This basically iterates through all revisions in the repository by internally dumping all revisions and discarding the output."
msgstr ""

#: en.xml:22231(para) 
msgid "Verify a hung repository:"
msgstr ""

#: en.xml:22233(screen) 
#, no-wrap
msgid "\n$ svnadmin verify /usr/local/svn/repos/ \n* Verified revision 1729.\n"
msgstr ""

#: en.xml:22251(para) 
msgid "<command moreinfo=\"none\">svnlook</command> is a command-line utility for examining different aspects of a Subversion repository. It does not make any changes to the repository—it's just used for <quote>peeking</quote>. <command moreinfo=\"none\">svnlook</command> is typically used by the repository hooks, but a repository administrator might find it useful for diagnostic purposes."
msgstr ""

#: en.xml:22259(para) 
msgid "Since <command moreinfo=\"none\">svnlook</command> works via direct repository access (and thus can only be used on the machine that holds the repository), it refers to the repository with a path, not a URL."
msgstr ""

#: en.xml:22263(para) 
msgid "If no revision or transaction is specified, <command moreinfo=\"none\">svnlook</command> defaults to the youngest (most recent) revision of the repository."
msgstr ""

#: en.xml:22269(title) 
msgid "<command moreinfo=\"none\">svnlook</command> Switches"
msgstr ""

#: en.xml:22271(para) 
msgid "Switches in <command moreinfo=\"none\">svnlook</command> are global, just like in <command moreinfo=\"none\">svn</command> and <command moreinfo=\"none\">svnadmin</command>; however, most switches only apply to one subcommand since the functionality of <command moreinfo=\"none\">svnlook</command> is (intentionally) limited in scope."
msgstr ""

#: en.xml:22283(para) 
msgid "Prevents <command moreinfo=\"none\">svnlook</command> from printing differences for deleted files. The default behavior when a file is deleted in a transaction/revision is to print the same differences that you would see if you had left the file but removed all the content."
msgstr ""

#: en.xml:22292(term) 
msgid "<option>--revision</option> (<option>-r</option>)"
msgstr ""

#: en.xml:22295(para) 
msgid "Specify a particular revision number that you wish to examine."
msgstr ""

#: en.xml:22313(term) 
msgid "<option>--transaction</option> (<option>-t</option>)"
msgstr ""

#: en.xml:22316(para) 
msgid "Specify a particular transaction ID that you wish to examine."
msgstr ""

#: en.xml:22322(option) 
msgid "--show-ids"
msgstr ""

#: en.xml:22324(para) 
msgid "Show the filesystem node revision IDs for each path in the filesystem tree."
msgstr ""

#: en.xml:22339(refname) 
msgid "svnlook author"
msgstr ""

#: en.xml:22340(refpurpose) 
msgid "Print the author."
msgstr ""

#: en.xml:22344(programlisting) 
#, no-wrap
msgid "svnlook author REPOS_PATH"
msgstr ""

#: en.xml:22349(para) 
msgid "Print the author of a revision or transaction in the repository."
msgstr ""

#: en.xml:22356(screen) en.xml:22395(screen) en.xml:22492(screen) en.xml:22538(screen) en.xml:22642(screen) en.xml:22764(screen) en.xml:22851(screen) 
#, no-wrap
msgid "\n--revision (-r)\n--transaction (-t)\n"
msgstr ""

#: en.xml:22365(para) 
msgid "<command moreinfo=\"none\">svnlook author</command> is handy, but not very exciting:"
msgstr ""

#: en.xml:22368(screen) 
#, no-wrap
msgid "\n$ svnlook author -r 40 /usr/local/svn/repos \nsally\n"
msgstr ""

#: en.xml:22378(refname) 
msgid "svnlook cat"
msgstr ""

#: en.xml:22379(refpurpose) en.xml:22388(para) 
msgid "Print the contents of a file."
msgstr ""

#: en.xml:22383(programlisting) 
#, no-wrap
msgid "svnlook cat REPOS_PATH PATH_IN_REPOS"
msgstr ""

#: en.xml:22404(para) 
msgid "This shows the contents of a file in transaction <literal moreinfo=\"none\">ax8</literal>, located at <filename moreinfo=\"none\">/trunk/README</filename>:"
msgstr ""

#: en.xml:22408(screen) 
#, no-wrap
msgid "\n$ svnlook cat -t ax8 /usr/local/svn/repos /trunk/README\n\n               Subversion, a version control system.\n               =====================================\n\n$LastChangedDate: 2003-07-17 10:45:25 -0500 (Thu, 17 Jul 2003) $\n\nContents:\n\n     I. A FEW POINTERS\n    II. DOCUMENTATION\n   III. PARTICIPATING IN THE SUBVERSION COMMUNITY\n…\n"
msgstr ""

#: en.xml:22429(refname) 
msgid "svnlook changed"
msgstr ""

#: en.xml:22430(refpurpose) 
msgid "Print the paths that were changed."
msgstr ""

#: en.xml:22434(programlisting) 
#, no-wrap
msgid "svnlook changed REPOS_PATH"
msgstr ""

#: en.xml:22439(para) 
msgid "Print the paths that were changed in a particular revision or transaction, as well as <quote>svn update-style</quote> status letters in the first two columns:"
msgstr ""

#: en.xml:22447(term) 
msgid "'<literal moreinfo=\"none\">A </literal>'"
msgstr ""

#: en.xml:22449(para) 
msgid "Item added to repository."
msgstr ""

#: en.xml:22454(term) 
msgid "'<literal moreinfo=\"none\">D </literal>'"
msgstr ""

#: en.xml:22456(para) 
msgid "Item deleted from repository."
msgstr ""

#: en.xml:22461(term) 
msgid "'<literal moreinfo=\"none\">U </literal>'"
msgstr ""

#: en.xml:22463(para) 
msgid "File contents changed."
msgstr ""

#: en.xml:22468(term) 
msgid "'<literal moreinfo=\"none\">_U</literal>'"
msgstr ""

#: en.xml:22470(para) 
msgid "Properties of item changed."
msgstr ""

#: en.xml:22475(term) 
msgid "'<literal moreinfo=\"none\">UU</literal>'"
msgstr ""

#: en.xml:22477(para) 
msgid "File contents and properties changed."
msgstr ""

#: en.xml:22483(para) 
msgid "Files and directories can be distinguished, as directory paths are displayed with a trailing '<literal moreinfo=\"none\">/</literal>' character."
msgstr ""

#: en.xml:22501(para) 
msgid "This shows a list of all the changed files in revision 39 of a test repository:"
msgstr ""

#: en.xml:22504(screen) 
#, no-wrap
msgid "\n$ svnlook changed -r 39 /usr/local/svn/repos\nA   trunk/vendors/deli/\nA   trunk/vendors/deli/chips.txt\nA   trunk/vendors/deli/sandwich.txt\nA   trunk/vendors/deli/pickle.txt\nU   trunk/vendors/baker/bagel.txt\n_U  trunk/vendors/baker/croissant.txt\nUU  trunk/vendors/baker/pretzel.txt\nD   trunk/vendors/baker/baguette.txt\n"
msgstr ""

#: en.xml:22521(refname) 
msgid "svnlook date"
msgstr ""

#: en.xml:22522(refpurpose) 
msgid "Print the datestamp."
msgstr ""

#: en.xml:22526(programlisting) 
#, no-wrap
msgid "svnlook date REPOS_PATH"
msgstr ""

#: en.xml:22531(para) 
msgid "Print the datestamp of a revision or transaction in a repository."
msgstr ""

#: en.xml:22547(para) 
msgid "This shows the date of revision 40 of a test repository:"
msgstr ""

#: en.xml:22550(screen) 
#, no-wrap
msgid "            \n$ svnlook date -r 40 /tmp/repos/\n2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)\n"
msgstr ""

#: en.xml:22560(refname) 
msgid "svnlook diff"
msgstr ""

#: en.xml:22561(refpurpose) 
msgid "Print differences of changed files and properties."
msgstr ""

#: en.xml:22565(programlisting) 
#, no-wrap
msgid "svnlook diff REPOS_PATH"
msgstr ""

#: en.xml:22570(para) 
msgid "Print GNU-style differences of changed files and properties in a repository."
msgstr ""

#: en.xml:22577(screen) 
#, no-wrap
msgid "\n--revision (-r)\n--transaction (-t)\n--no-diff-added\n--no-diff-deleted\n"
msgstr ""

#: en.xml:22588(para) 
msgid "This shows a newly added (empty) file, a deleted file, and a copied file:"
msgstr ""

#: en.xml:22591(screen) 
#, no-wrap
msgid "\n$ svnlook diff -r 40 /usr/local/svn/repos/\nCopied: egg.txt (from rev 39, trunk/vendors/deli/pickle.txt)\n\nAdded: trunk/vendors/deli/soda.txt\n==============================================================================\n\nModified: trunk/vendors/deli/sandwich.txt\n==============================================================================\n--- trunk/vendors/deli/sandwich.txt\t(original)\n+++ trunk/vendors/deli/sandwich.txt\t2003-02-22 17:45:04.000000000 -0600\n@@ -0,0 +1 @@\n+Don't forget the mayo!\n\nModified: trunk/vendors/deli/logo.jpg\n==============================================================================\n(Binary files differ)\n\nDeleted: trunk/vendors/deli/chips.txt\n==============================================================================\n\nDeleted: trunk/vendors/deli/pickle.txt\n==============================================================================\n"
msgstr ""

#: en.xml:22616(para) 
msgid "If a file has a non-textual <literal moreinfo=\"none\">svn:mime-type</literal> property, then the differences are not explicitly shown."
msgstr ""

#: en.xml:22624(refname) 
msgid "svnlook dirs-changed"
msgstr ""

#: en.xml:22625(refpurpose) 
msgid "Print the directories that were themselves changed."
msgstr ""

#: en.xml:22629(programlisting) 
#, no-wrap
msgid "svnlook dirs-changed REPOS_PATH"
msgstr ""

#: en.xml:22634(para) 
msgid "Print the directories that were themselves changed (property edits) or whose file children were changed."
msgstr ""

#: en.xml:22651(para) 
msgid "This shows the directories that changed in revision 40 in our sample repository:"
msgstr ""

#: en.xml:22654(screen) 
#, no-wrap
msgid "\n$ svnlook dirs-changed -r 40 /usr/local/svn/repos\ntrunk/vendors/deli/\n"
msgstr ""

#: en.xml:22664(refname) 
msgid "svnlook help"
msgstr ""

#: en.xml:22668(programlisting) 
#, no-wrap
msgid "Also svnlook -h and svnlook -?."
msgstr ""

#: en.xml:22673(para) 
msgid "Displays the help message for svnlook. This command, like its brother <command moreinfo=\"none\">svn help</command>, is also your friend, even though you never call it anymore and forgot to invite it to your last party."
msgstr ""

#: en.xml:22688(refname) 
msgid "svnlook history"
msgstr ""

#: en.xml:22689(refpurpose) en.xml:22700(para) 
msgid "Print information about the history of a path in the repository (or the root directory if no path is supplied)."
msgstr ""

#: en.xml:22695(programlisting) 
#, no-wrap
msgid "svnlook history REPOS_PATH [PATH_IN_REPOS]"
msgstr ""

#: en.xml:22708(screen) 
#, no-wrap
msgid "\n--revision (-r)\n--show-ids\n"
msgstr ""

#: en.xml:22717(para) 
msgid "This shows the history output for the path <filename moreinfo=\"none\">/tags/1.0</filename> as of revision 20 in our sample repository."
msgstr ""

#: en.xml:22721(screen) 
#, no-wrap
msgid "\n$ svnlook history -r 20 /usr/local/svn/repos /tags/1.0 --show-ids\nREVISION   PATH &lt;ID&gt;\n--------   ---------\n      19   /tags/1.0 &lt;1.2.12&gt;\n      17   /branches/1.0-rc2 &lt;1.1.10&gt;\n      16   /branches/1.0-rc2 &lt;1.1.x&gt;\n      14   /trunk &lt;1.0.q&gt;\n      13   /trunk &lt;1.0.o&gt;\n      11   /trunk &lt;1.0.k&gt;\n       9   /trunk &lt;1.0.g&gt;\n       8   /trunk &lt;1.0.e&gt;\n       7   /trunk &lt;1.0.b&gt;\n       6   /trunk &lt;1.0.9&gt;\n       5   /trunk &lt;1.0.7&gt;\n       4   /trunk &lt;1.0.6&gt;\n       2   /trunk &lt;1.0.3&gt;\n       1   /trunk &lt;1.0.2&gt;\n"
msgstr ""

#: en.xml:22746(refname) 
msgid "svnlook info"
msgstr ""

#: en.xml:22747(refpurpose) en.xml:22757(para) 
msgid "Print the author, datestamp, log message size, and log message."
msgstr ""

#: en.xml:22752(programlisting) 
#, no-wrap
msgid "svnlook info REPOS_PATH"
msgstr ""

#: en.xml:22773(para) 
msgid "This shows the info output for revision 40 in our sample repository."
msgstr ""

#: en.xml:22776(screen) 
#, no-wrap
msgid "\n$ svnlook info -r 40 /usr/local/svn/repos\nsally\n2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)\n15\nRearrange lunch.\n"
msgstr ""

#: en.xml:22790(refname) 
msgid "svnlook lock"
msgstr ""

#: en.xml:22791(refpurpose) 
msgid "If a lock exists on a path in the repository, describe it."
msgstr ""

#: en.xml:22796(programlisting) 
#, no-wrap
msgid "svnlook lock REPOS_PATH PATH_IN_REPOS"
msgstr ""

#: en.xml:22801(para) 
msgid "Print all information available for the lock at <replaceable>PATH_IN_REPOS</replaceable>. If <replaceable>PATH_IN_REPOS</replaceable> is not locked, print nothing."
msgstr ""

#: en.xml:22816(para) 
msgid "This describes the lock on the file <filename moreinfo=\"none\">tree.jpg</filename>."
msgstr ""

#: en.xml:22819(screen) 
#, no-wrap
msgid "\n$ svnlook lock /svn/repos tree.jpg\nUUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753\nOwner: harry\nCreated: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)\nExpires: \nComment (1 line):\nRework the uppermost branches on the bald cypress in the foreground.\n"
msgstr ""

#: en.xml:22835(refname) 
msgid "svnlook log"
msgstr ""

#: en.xml:22836(refpurpose) en.xml:22845(para) 
msgid "Print the log message."
msgstr ""

#: en.xml:22840(programlisting) 
#, no-wrap
msgid "svnlook log REPOS_PATH"
msgstr ""

#: en.xml:22860(para) 
msgid "This shows the log output for revision 40 in our sample repository:"
msgstr ""

#: en.xml:22863(screen) 
#, no-wrap
msgid "\n$ svnlook log /tmp/repos/\nRearrange lunch.\n"
msgstr ""

#: en.xml:22873(refname) 
msgid "svnlook propget"
msgstr ""

#: en.xml:22874(refpurpose) 
msgid "Print the raw value of a property on a path in the repository."
msgstr ""

#: en.xml:22879(programlisting) 
#, no-wrap
msgid "svnlook propget REPOS_PATH PROPNAME [PATH_IN_REPOS]"
msgstr ""

#: en.xml:22884(para) 
msgid "List the value of a property on a path in the repository."
msgstr ""

#: en.xml:22891(para) 
msgid "pg, pget"
msgstr ""

#: en.xml:22897(screen) 
#, no-wrap
msgid "\n--revision (-r)\n--transaction (-t)\n--revprop\n"
msgstr ""

#: en.xml:22907(para) 
msgid "This shows the value of the <quote>seasonings</quote> property on the file <filename moreinfo=\"none\">/trunk/sandwich</filename> in the <literal moreinfo=\"none\">HEAD</literal> revision:"
msgstr ""

#: en.xml:22911(screen) 
#, no-wrap
msgid "\n$ svnlook pg /usr/local/svn/repos seasonings /trunk/sandwich\nmustard\n"
msgstr ""

#: en.xml:22921(refname) 
msgid "svnlook proplist"
msgstr ""

#: en.xml:22922(refpurpose) 
msgid "Print the names and values of versioned file and directory properties."
msgstr ""

#: en.xml:22927(programlisting) 
#, no-wrap
msgid "svnlook proplist REPOS_PATH [PATH_IN_REPOS]"
msgstr ""

#: en.xml:22932(para) 
msgid "List the properties of a path in the repository. With <option>--verbose</option>, show the property values too."
msgstr ""

#: en.xml:22939(para) 
msgid "pl, plist"
msgstr ""

#: en.xml:22945(screen) 
#, no-wrap
msgid "\n--revision (-r)\n--transaction (-t)\n--verbose (-v)\n--revprop\n"
msgstr ""

#: en.xml:22956(para) 
msgid "This shows the names of properties set on the file <filename moreinfo=\"none\">/trunk/README</filename> in the <literal moreinfo=\"none\">HEAD</literal> revision:"
msgstr ""

#: en.xml:22960(screen) 
#, no-wrap
msgid "\n$ svnlook proplist /usr/local/svn/repos /trunk/README\n  original-author\n  svn:mime-type\n"
msgstr ""

#: en.xml:22966(para) 
msgid "This is the same command as in the previous example, but this time showing the property values as well:"
msgstr ""

#: en.xml:22969(screen) 
#, no-wrap
msgid "\n$ svnlook --verbose proplist /usr/local/svn/repos /trunk/README\n  original-author : fitz\n  svn:mime-type : text/plain\n"
msgstr ""

#: en.xml:22980(refname) 
msgid "svnlook tree"
msgstr ""

#: en.xml:22981(refpurpose) 
msgid "Print the tree."
msgstr ""

#: en.xml:22985(programlisting) 
#, no-wrap
msgid "svnlook tree REPOS_PATH [PATH_IN_REPOS]"
msgstr ""

#: en.xml:22989(para) 
msgid "Print the tree, starting at <replaceable>PATH_IN_REPOS</replaceable> (if supplied, at the root of the tree otherwise), optionally showing node revision IDs."
msgstr ""

#: en.xml:22998(screen) 
#, no-wrap
msgid "\n--revision (-r)\n--transaction (-t)\n--show-ids\n"
msgstr ""

#: en.xml:23008(para) 
msgid "This shows the tree output (with node-IDs) for revision 40 in our sample repository:"
msgstr ""

#: en.xml:23011(screen) 
#, no-wrap
msgid "\n$ svnlook tree -r 40 /usr/local/svn/repos --show-ids\n/ &lt;0.0.2j&gt;\n trunk/ &lt;p.0.2j&gt;\n  vendors/ &lt;q.0.2j&gt;\n   deli/ &lt;1g.0.2j&gt;\n    egg.txt &lt;1i.e.2j&gt;\n    soda.txt &lt;1k.0.2j&gt;\n    sandwich.txt &lt;1j.0.2j&gt;\n"
msgstr ""

#: en.xml:23027(refname) 
msgid "svnlook uuid"
msgstr ""

#: en.xml:23029(literal) 
msgid "UUID"
msgstr ""

#: en.xml:23028(refpurpose) 
msgid "Print the repository's <placeholder-1/>."
msgstr ""

#: en.xml:23033(programlisting) 
#, no-wrap
msgid "svnlook uuid REPOS_PATH"
msgstr ""

#: en.xml:23038(para) 
msgid "Print the <literal moreinfo=\"none\">UUID</literal> for the repository. the UUID is the repository's <emphasis>u</emphasis>niversal <emphasis>u</emphasis>nique <emphasis>id</emphasis>entifier. The Subversion client uses this identifier to differentiate between one repository and another."
msgstr ""

#: en.xml:23049(screen) 
#, no-wrap
msgid "          \n$ svnlook uuid /usr/local/svn/repos\ne7fe1b91-8cd5-0310-98dd-2f12e793c5e8\n"
msgstr ""

#: en.xml:23059(refname) 
msgid "svnlook youngest"
msgstr ""

#: en.xml:23064(programlisting) 
#, no-wrap
msgid "svnlook youngest REPOS_PATH"
msgstr ""

#: en.xml:23069(para) 
msgid "Print the youngest revision number of a repository."
msgstr ""

#: en.xml:23075(para) 
msgid "This shows the youngest revision of our sample repository:"
msgstr ""

#: en.xml:23078(screen) 
#, no-wrap
msgid "          \n$ svnlook youngest /tmp/repos/ \n42\n"
msgstr ""

#: en.xml:23096(para) 
msgid "<command moreinfo=\"none\">svnserve</command> allows access to Subversion repositories using the <literal moreinfo=\"none\">svn</literal> network protocol. You can run svnserve either as a standalone server process, or you can have another process, such as <command moreinfo=\"none\">inetd</command>, <command moreinfo=\"none\">xinetd</command> or <command moreinfo=\"none\">sshd</command>, launch it for you."
msgstr ""

#: en.xml:23103(para) 
msgid "Once the client has selected a repository by transmitting its URL, <command moreinfo=\"none\">svnserve</command> reads a file named <filename moreinfo=\"none\">conf/svnserve.conf</filename> in the repository directory to determine repository-specific settings such as what authentication database to use and what authorization policies to apply. See <xref linkend=\"svn.serverconfig.svnserve\"/> for details of the <filename moreinfo=\"none\">svnserve.conf</filename> file."
msgstr ""

#: en.xml:23113(title) 
msgid "<command moreinfo=\"none\">svnserve</command> Switches"
msgstr ""

#: en.xml:23115(para) 
msgid "Unlike the previous commands we've described. <command moreinfo=\"none\">svnserve</command> has no subcommands—<command moreinfo=\"none\">svnserve</command> is controlled exclusively by switches."
msgstr ""

#: en.xml:23123(term) 
msgid "<option>--daemon</option> (<option>-d</option>)"
msgstr ""

#: en.xml:23125(para) 
msgid "Causes <command moreinfo=\"none\">svnserve</command> to run in daemon mode. <command moreinfo=\"none\">svnserve</command> backgrounds itself and accepts and serves TCP/IP connections on the svn port (3690, by default)."
msgstr ""

#: en.xml:23133(term) 
msgid "<option>--listen-port</option>=<replaceable>PORT</replaceable>"
msgstr ""

#: en.xml:23135(para) 
msgid "Causes svnserve to listen on <replaceable>PORT</replaceable> when run in daemon mode."
msgstr ""

#: en.xml:23142(term) 
msgid "<option>--listen-host</option>=<replaceable>HOST</replaceable>"
msgstr ""

#: en.xml:23144(para) 
msgid "Causes <command moreinfo=\"none\">svnserve</command> to listen on the interface specified by <replaceable>HOST</replaceable>, which may be either a hostname or an IP address."
msgstr ""

#: en.xml:23151(option) 
msgid "--foreground"
msgstr ""

#: en.xml:23153(para) 
msgid "When used together with <option>-d</option>, this switch causes <command moreinfo=\"none\">svnserve</command> to stay in the foreground. This switch is mainly useful for debugging."
msgstr ""

#: en.xml:23161(term) 
msgid "<option>--inetd</option> (<option>-i</option>)"
msgstr ""

#: en.xml:23163(para) 
msgid "Causes <command moreinfo=\"none\">svnserve</command> to use the stdin/stdout file descriptors, as is appropriate for a daemon running out of <command moreinfo=\"none\">inetd</command>."
msgstr ""

#: en.xml:23170(term) en.xml:23310(term) 
msgid "<option>--help</option> (<option>-h</option>)"
msgstr ""

#: en.xml:23172(para) 
msgid "Displays a usage summary and exits."
msgstr ""

#: en.xml:23179(para) 
msgid "Displays version information, a list of repository back-end modules available, and exits."
msgstr ""

#: en.xml:23185(term) 
msgid "<option>--root</option>=<replaceable>ROOT</replaceable> (<option>-r</option>=<replaceable>ROOT</replaceable>)"
msgstr ""

#: en.xml:23188(para) 
msgid "Sets the virtual root for repositories served by <command moreinfo=\"none\">svnserve</command>. The pathname in URLs provided by the client will be interpreted relative to this root, and will not be allowed to escape this root."
msgstr ""

#: en.xml:23197(term) 
msgid "<option>--tunnel</option> (<option>-t</option>)"
msgstr ""

#: en.xml:23199(para) 
msgid "Causes <command moreinfo=\"none\">svnserve</command> to run in tunnel mode, which is just like the <command moreinfo=\"none\">inetd</command> mode of operation (serve one connection over stdin/stdout) except that the connection is considered to be pre-authenticated with the username of the current uid. This flag is selected by the client when running over a tunnel agent such as <command moreinfo=\"none\">ssh</command>."
msgstr ""

#: en.xml:23211(option) 
msgid "--tunnel-user NAME"
msgstr ""

#: en.xml:23213(para) 
msgid "Used in conjunction with <option>--tunnel</option> switch; tells svnserve to assume that <replaceable>NAME</replaceable> is the authenticated user, rather than the UID of the svnserve process. Useful for users wishing to share a single system account over SSH, but maintaining separate commit identities."
msgstr ""

#: en.xml:23224(term) 
msgid "<option>--threads</option> (<option>-T</option>)"
msgstr ""

#: en.xml:23226(para) 
msgid "When running in daemon mode, causes <command moreinfo=\"none\">svnserve</command> to spawn a thread instead of a process for each connection. The <command moreinfo=\"none\">svnserve</command> process still backgrounds itself at startup time."
msgstr ""

#: en.xml:23235(term) 
msgid "<option>--listen-once</option> (<option>-X</option>)"
msgstr ""

#: en.xml:23237(para) 
msgid "Causes <command moreinfo=\"none\">svnserve</command> to accept one connection on the svn port, serve it, and exit. This option is mainly useful for debugging."
msgstr ""

#: en.xml:23259(refpurpose) 
msgid "Summarize the local revision(s) of a working copy."
msgstr ""

#: en.xml:23265(programlisting) 
#, no-wrap
msgid "svnversion [OPTIONS] WC_PATH [TRAIL_URL]"
msgstr ""

#: en.xml:23271(para) 
msgid "<command moreinfo=\"none\">svnversion</command> is a program for summarizing the revision mixture of a working copy. The resultant revision number, or revision range, is written to standard output."
msgstr ""

#: en.xml:23276(para) 
msgid "<replaceable>TRAIL_URL</replaceable>, if present, is the trailing portion of the URL used to determine if <replaceable>WC_PATH</replaceable> itself is switched (detection of switches within <replaceable>WC_PATH</replaceable> does not rely on <replaceable>TRAIL_URL</replaceable>)."
msgstr ""

#: en.xml:23288(para) 
msgid "Like <command moreinfo=\"none\">svnserve</command>, <command moreinfo=\"none\">svnversion</command> has no subcommands, it only has switches."
msgstr ""

#: en.xml:23295(term) 
msgid "<option>--no-newline</option> (<option>-n</option>)"
msgstr ""

#: en.xml:23297(para) 
msgid "Omit the usual trailing newline from the output."
msgstr ""

#: en.xml:23302(term) 
msgid "<option>--committed</option> (<option>-c</option>)"
msgstr ""

#: en.xml:23304(para) 
msgid "Use the last-changed revisions rather than the current (i.e., highest locally available) revisions."
msgstr ""

#: en.xml:23312(para) 
msgid "Print a help summary."
msgstr ""

#: en.xml:23319(para) 
msgid "Print the version of <command moreinfo=\"none\">svnversion</command> and exit with no error."
msgstr ""

#: en.xml:23330(para) 
msgid "If the working copy is all at the same revision (for example, immediately after an update), then that revision is printed out:"
msgstr ""

#: en.xml:23334(screen) 
#, no-wrap
msgid "$ svnversion .\n4168"
msgstr ""

#: en.xml:23337(para) 
msgid "You can add TRAIL_URL to show that the working copy is not switched from what you expect:"
msgstr ""

#: en.xml:23340(screen) 
#, no-wrap
msgid "$ svnversion . /repos/svn/trunk\n4168"
msgstr ""

#: en.xml:23343(para) 
msgid "For a mixed-revision working copy, the range of revisions present is printed:"
msgstr ""

#: en.xml:23346(screen) 
#, no-wrap
msgid "$ svnversion .\n4123:4168"
msgstr ""

#: en.xml:23349(para) 
msgid "If the working copy contains modifications, a trailing \"M\" is added:"
msgstr ""

#: en.xml:23352(screen) 
#, no-wrap
msgid "$ svnversion .\n4168M"
msgstr ""

#: en.xml:23355(para) 
msgid "If the working copy is switched, a trailing \"S\" is added:"
msgstr ""

#: en.xml:23358(screen) 
#, no-wrap
msgid "$ svnversion .\n4168S"
msgstr ""

#: en.xml:23361(para) 
msgid "Thus, here is a mixed-revision, switched working copy containing some local modifications:"
msgstr ""

#: en.xml:23364(screen) 
#, no-wrap
msgid "$ svnversion .\n4212:4168MS"
msgstr ""

#: en.xml:23367(para) 
msgid "If invoked on a directory that is not a working copy, <command moreinfo=\"none\">svnversion</command> assumes it is an exported working copy and prints \"exported\":"
msgstr ""

#: en.xml:23371(screen) 
#, no-wrap
msgid "$ svnversion .\nexported"
msgstr ""

#: en.xml:23389(refname) 
msgid "<placeholder-1/> Configuration Directives"
msgstr ""

#: en.xml:23390(refpurpose) 
msgid "Apache configuration directives for serving Subversion repositories through Apache HTTP Server."
msgstr ""

#: en.xml:23399(para) 
msgid "This section briefly describes each of the Subversion Apache configuration directives. For an in-depth description of configuring Apache with Subversion, see <xref linkend=\"svn.serverconfig.httpd\"/>.)"
msgstr ""

#: en.xml:23406(title) 
msgid "Directives"
msgstr ""

#: en.xml:23411(literal) 
msgid "DAV svn"
msgstr ""

#: en.xml:23414(para) 
msgid "This directive must be included in any <literal moreinfo=\"none\">Directory</literal> or <literal moreinfo=\"none\">Location</literal> block for a Subversion repository. It tells httpd to use the Subversion backend for mod_dav to handle all requests."
msgstr ""

#: en.xml:23424(literal) 
msgid "SVNAutoversioning On"
msgstr ""

#: en.xml:23427(para) 
msgid "This directive allows write requests from WebDAV clients to result in automatic commits. A generic log message is auto-generated and attached to each revision. If you enable Autoversioning, you'll likely want to set <literal moreinfo=\"none\">ModMimeUsePathInfo On</literal> so that <literal moreinfo=\"none\">mod_mime</literal> can set <literal moreinfo=\"none\">svn:mime-type</literal> to the correct mime-type automatically (as best as <literal moreinfo=\"none\">mod_mime</literal> is able to, of course). For more information, see <xref linkend=\"svn.webdav\"/>"
msgstr ""

#: en.xml:23442(literal) 
msgid "SVNPath"
msgstr ""

#: en.xml:23445(para) 
msgid "This directive specifies the location in the filesystem for a Subversion repository's files. In a configuration block for a Subversion repository, either this directive or <literal moreinfo=\"none\">SVNParentPath</literal> must be present, but not both."
msgstr ""

#: en.xml:23456(literal) 
msgid "SVNSpecialURI"
msgstr ""

#: en.xml:23459(para) 
msgid "Specifies the URI component (namespace) for special Subversion resources. The default is <quote><literal moreinfo=\"none\">!svn</literal></quote>, and most administrators will never use this directive. Only set this if there is a pressing need to have a file named <filename moreinfo=\"none\">!svn</filename> in your repository. If you change this on a server already in use, it will break all of the outstanding working copies and your users will hunt you down with pitchforks and flaming torches."
msgstr ""

#: en.xml:23474(literal) 
msgid "SVNReposName"
msgstr ""

#: en.xml:23477(para) 
msgid "Specifies the name of a Subversion repository for use in <literal moreinfo=\"none\">HTTP GET</literal> requests. This value will be prepended to the title of all directory listings (which are served when you navigate to a Subversion repository with a web browser). This directive is optional."
msgstr ""

#: en.xml:23488(literal) 
msgid "SVNIndexXSLT"
msgstr ""

#: en.xml:23491(para) 
msgid "Specifies the URI of an XSL transformation for directory indexes. This directive is optional."
msgstr ""

#: en.xml:23498(literal) 
msgid "SVNParentPath"
msgstr ""

#: en.xml:23501(para) 
msgid "Specifies the location in the filesystem of a parent directory whose child directories are Subversion repositories. In a configuration block for a Subversion repository, either this directive or <literal moreinfo=\"none\">SVNPath</literal> must be present, but not both."
msgstr ""

#: en.xml:23512(literal) 
msgid "SVNPathAuthz"
msgstr ""

#: en.xml:23515(para) 
msgid "Control path-based authorization by enabling or disabling subrequests. See <xref linkend=\"svn.serverconfig.httpd.authz.pathauthzoff\"/> for details."
msgstr ""

#: en.xml:23531(title) 
msgid "Subversion properties"
msgstr ""

#: en.xml:23536(refname) 
msgid "Subversion-defined properties"
msgstr ""

#: en.xml:23536(refpurpose) 
msgid "properties defined by Subversion to control behavior."
msgstr ""

#: en.xml:23544(para) 
msgid "Subversion allows users to invent arbitrarily-named versioned properties on files and directories, as well as unversioned properties on revisions. The only restriction is on properties prefixed with <quote>svn:</quote>. Properties in that namespace are reserved for Subversion's own use. While these properties may be set by users to control Subversion's behavior, users may not invent new <quote>svn:</quote> properties."
msgstr ""

#: en.xml:23556(title) 
msgid "Versioned Properties"
msgstr ""

#: en.xml:23564(para) 
msgid "If present on a file, the client will make the file executable in Unix-hosted working copies. See <xref linkend=\"svn.advanced.props.special.executable\"/>."
msgstr ""

#: en.xml:23575(para) 
msgid "If present on a file, the value indicates the file's mime-type. This allows the client to decide whether line-based contextual merging is safe to perform during updates, and can also affect how the file behaves when fetched via web browser. See <xref linkend=\"svn.advanced.props.special.mime-type\"/>."
msgstr ""

#: en.xml:23589(para) 
msgid "If present on a directory, the value is a list of unversioned file patterns to be ignored by <command moreinfo=\"none\">svn status</command> and other subcommands. See <xref linkend=\"svn.advanced.props.special.ignore\"/>"
msgstr ""

#: en.xml:23602(para) 
msgid "If present on a file, the value tells the client how to expand particular keywords within the file. See <xref linkend=\"svn.advanced.props.special.keywords\"/>."
msgstr ""

#: en.xml:23614(para) 
msgid "If present on a file, the value tells the client how to manipulate the file's line-endings in the working copy. See <xref linkend=\"svn.advanced.props.special.eol-style\"/>."
msgstr ""

#: en.xml:23626(para) 
msgid "If present on a directory, the value is a multi-line list of other paths and URLs the client should check out. See <xref linkend=\"svn.advanced.props.special.externals\"/>."
msgstr ""

#: en.xml:23638(para) 
msgid "If present on a file, indicates that the file is not an ordinary file, but a symbolic link or other special object. See <xref linkend=\"svn.advanced.props.special.special\"/>."
msgstr ""

#: en.xml:23650(para) 
msgid "If present on a file, tells the client to make the file read-only in the working copy, as a reminder that the file should be locked before editing begins. See <xref linkend=\"svn.advanced.locking.lock-communication\"/>."
msgstr ""

#: en.xml:23667(literal) 
msgid "svn:author"
msgstr ""

#: en.xml:23670(para) 
msgid "If present, contains the authenticated username of the person who created the revision. (If not present, then the revision was committed anonymously.)"
msgstr ""

#: en.xml:23678(literal) 
msgid "svn:date"
msgstr ""

#: en.xml:23681(para) 
msgid "Contains the UTC time the revision was created, in ISO format. The value comes from the server machine's clock."
msgstr ""

#: en.xml:23689(literal) 
msgid "svn:log"
msgstr ""

#: en.xml:23692(para) 
msgid "Contains the log message describing the revision."
msgstr ""

#: en.xml:23699(literal) 
msgid "svn:autoversioned"
msgstr ""

#: en.xml:23702(para) 
msgid "If present, the revision was created via the autoversioning feature. See <xref linkend=\"svn.webdav.autoversioning\"/>."
msgstr ""

#: en.xml:23726(title) 
msgid "Subversion for CVS Users"
msgstr ""

#: en.xml:23730(para) 
msgid "This appendix is a guide for CVS users new to Subversion. It's essentially a list of differences between the two systems as <quote>viewed from 10,000 feet</quote>. For each section, we provide backreferences to relevant chapters when possible."
msgstr ""

#: en.xml:23736(para) 
msgid "Although the goal of Subversion is to take over the current and future CVS user base, some new features and design changes were required to fix certain <quote>broken</quote> behaviors that CVS had. This means that, as a CVS user, you may need to break habits—ones that you forgot were odd to begin with."
msgstr ""

#: en.xml:23749(title) 
msgid "Revision Numbers Are Different Now"
msgstr ""

#: en.xml:23751(para) 
msgid "In CVS, revision numbers are per-file. This is because CVS stores its data in RCS files; each file has a corresponding RCS file in the repository, and the repository is roughly laid out according to the structure of your project tree."
msgstr ""

#: en.xml:23756(para) 
msgid "In Subversion, the repository looks like a single filesystem. Each commit results in an entirely new filesystem tree; in essence, the repository is an array of trees. Each of these trees is labeled with a single revision number. When someone talks about <quote>revision 54</quote>, they're talking about a particular tree (and indirectly, the way the filesystem looked after the 54th commit)."
msgstr ""

#: en.xml:23764(para) 
msgid "Technically, it's not valid to talk about <quote>revision 5 of <filename moreinfo=\"none\">foo.c</filename></quote>. Instead, one would say <quote><filename moreinfo=\"none\">foo.c</filename> as it appears in revision 5</quote>. Also, be careful when making assumptions about the evolution of a file. In CVS, revisions 5 and 6 of <filename moreinfo=\"none\">foo.c</filename> are always different. In Subversion, it's most likely that <filename moreinfo=\"none\">foo.c</filename> did <emphasis>not</emphasis> change between revisions 5 and 6."
msgstr ""

#: en.xml:23774(para) 
msgid "For more details on this topic, see <xref linkend=\"svn.basic.in-action.revs\"/>."
msgstr ""

#: en.xml:23782(title) 
msgid "Directory Versions"
msgstr ""

#: en.xml:23784(para) 
msgid "Subversion tracks tree structures, not just file contents. It's one of the biggest reasons Subversion was written to replace CVS."
msgstr ""

#: en.xml:23788(para) 
msgid "Here's what this means to you, as a former CVS user:"
msgstr ""

#: en.xml:23792(para) 
msgid "The <command moreinfo=\"none\">svn add</command> and <command moreinfo=\"none\">svn delete</command> commands work on directories now, just as they work on files. So do <command moreinfo=\"none\">svn copy</command> and <command moreinfo=\"none\">svn move</command>. However, these commands do <emphasis>not</emphasis> cause any kind of immediate change in the repository. Instead, the working items are simply <quote>scheduled</quote> for addition or deletion. No repository changes happen until you run <command moreinfo=\"none\">svn commit</command>."
msgstr ""

#: en.xml:23803(para) 
msgid "Directories aren't dumb containers anymore; they have revision numbers like files. (Or more properly, it's correct to talk about <quote>directory <filename moreinfo=\"none\">foo/</filename> in revision 5</quote>.)"
msgstr ""

#: en.xml:23810(para) 
msgid "Let's talk more about that last point. Directory versioning is a hard problem; because we want to allow mixed-revision working copies, there are some limitations on how far we can abuse this model."
msgstr ""

#: en.xml:23815(para) 
msgid "From a theoretical point of view, we define <quote>revision 5 of directory <filename moreinfo=\"none\">foo</filename></quote> to mean a specific collection of directory-entries and properties. Now suppose we start adding and removing files from <filename moreinfo=\"none\">foo</filename>, and then commit. It would be a lie to say that we still have revision 5 of <filename moreinfo=\"none\">foo</filename>. However, if we bumped <filename moreinfo=\"none\">foo</filename>'s revision number after the commit, that would be a lie too; there may be other changes to <filename moreinfo=\"none\">foo</filename> we haven't yet received, because we haven't updated yet."
msgstr ""

#: en.xml:23827(para) 
msgid "Subversion deals with this problem by quietly tracking committed adds and deletes in the <filename moreinfo=\"none\">.svn</filename> area. When you eventually run <command moreinfo=\"none\">svn update</command>, all accounts are settled with the repository, and the directory's new revision number is set correctly. <emphasis>Therefore, only after an update is it truly safe to say that you have a <quote>perfect</quote> revision of a directory.</emphasis> Most of the time, your working copy will contain <quote>imperfect</quote> directory revisions."
msgstr ""

#: en.xml:23837(para) 
msgid "Similarly, a problem arises if you attempt to commit property changes on a directory. Normally, the commit would bump the working directory's local revision number. But again, that would be a lie, because there may be adds or deletes that the directory doesn't yet have, because no update has happened. <emphasis>Therefore, you are not allowed to commit property-changes on a directory unless the directory is up-to-date.</emphasis>"
msgstr ""

#: en.xml:23846(para) 
msgid "For more discussion about the limitations of directory versioning, see <xref linkend=\"svn.basic.in-action.mixedrevs\"/>."
msgstr ""

#: en.xml:23856(title) 
msgid "More Disconnected Operations"
msgstr ""

#: en.xml:23858(para) 
msgid "In recent years, disk space has become outrageously cheap and abundant, but network bandwidth has not. Therefore, the Subversion working copy has been optimized around the scarcer resource."
msgstr ""

#: en.xml:23863(para) 
msgid "The <filename moreinfo=\"none\">.svn</filename> administrative directory serves the same purpose as the <filename moreinfo=\"none\">CVS</filename> directory, except that it also stores read-only, <quote>pristine</quote> copies of your files. This allows you to do many things off-line:"
msgstr ""

#: en.xml:23874(para) 
msgid "Shows you any local changes you've made (see <xref linkend=\"svn.tour.cycle.examine.status\"/>)"
msgstr ""

#: en.xml:23881(para) 
msgid "Shows you the details of your changes (see <xref linkend=\"svn.tour.cycle.examine.diff\"/>)"
msgstr ""

#: en.xml:23888(para) 
msgid "Removes your local changes (see <xref linkend=\"svn.tour.cycle.examine.revert\"/>)"
msgstr ""

#: en.xml:23894(para) 
msgid "Also, the cached pristine files allow the Subversion client to send differences when committing, which CVS cannot do."
msgstr ""

#: en.xml:23897(para) 
msgid "The last subcommand in the list is new; it will not only remove local changes, but it will un-schedule operations such as adds and deletes. It's the preferred way to revert a file; running <command moreinfo=\"none\">rm file; svn update</command> will still work, but it blurs the purpose of updating. And, while we're on this subject…"
msgstr ""

#: en.xml:23912(title) 
msgid "Distinction Between Status and Update"
msgstr ""

#: en.xml:23914(para) 
msgid "In Subversion, we've tried to erase a lot of the confusion between the <command moreinfo=\"none\">cvs status</command> and <command moreinfo=\"none\">cvs update</command> commands."
msgstr ""

#: en.xml:23918(para) 
msgid "The <command moreinfo=\"none\">cvs status</command> command has two purposes: first, to show the user any local modifications in the working copy, and second, to show the user which files are out-of-date. Unfortunately, because of CVS's hard-to-read status output, many CVS users don't take advantage of this command at all. Instead, they've developed a habit of running <command moreinfo=\"none\">cvs update</command> or <command moreinfo=\"none\">cvs -n update</command> to quickly see their changes. If users forget to use the <option>-n</option> option, this has the side effect of merging repository changes they may not be ready to deal with."
msgstr ""

#: en.xml:23930(para) 
msgid "With Subversion, we've tried to remove this muddle by making the output of <command moreinfo=\"none\">svn status</command> easy to read for both humans and parsers. Also, <command moreinfo=\"none\">svn update</command> only prints information about files that are updated, <emphasis>not</emphasis> local modifications."
msgstr ""

#: en.xml:23937(title) 
msgid "Status"
msgstr ""

#: en.xml:23939(para) 
msgid "<command moreinfo=\"none\">svn status</command> prints all files that have local modifications. By default, the repository is not contacted. While this subcommand accepts a fair number of options, the following are the most commonly used ones:"
msgstr ""

#: en.xml:23946(option) 
msgid "-u"
msgstr ""

#: en.xml:23948(para) 
msgid "Contact the repository to determine, and then display, out-of-dateness information."
msgstr ""

#: en.xml:23954(option) 
msgid "-v"
msgstr ""

#: en.xml:23956(para) 
msgid "Show <emphasis>all</emphasis> entries under version control."
msgstr ""

#: en.xml:23962(option) 
msgid "-N"
msgstr ""

#: en.xml:23964(para) 
msgid "Run non-recursively (do not descend into subdirectories)."
msgstr ""

#: en.xml:23970(para) 
msgid "The <command moreinfo=\"none\">status</command> command has two output formats. In the default <quote>short</quote> format, local modifications look like this:"
msgstr ""

#: en.xml:23974(screen) 
#, no-wrap
msgid "\n$ svn status\nM      foo.c\nM      bar/baz.c\n"
msgstr ""

#: en.xml:23980(para) 
msgid "If you specify the <option>--show-updates</option> (<option>-u</option>) switch, a longer output format is used:"
msgstr ""

#: en.xml:23984(screen) 
#, no-wrap
msgid "\n$ svn status -u\nM            1047   foo.c\n       *     1045   faces.html\n       *            bloo.png\nM            1050   bar/baz.c\nStatus against revision:   1066\n"
msgstr ""

#: en.xml:23993(para) 
msgid "In this case, two new columns appear. The second column contains an asterisk if the file or directory is out-of-date. The third column shows the working-copy's revision number of the item. In the example above, the asterisk indicates that <filename moreinfo=\"none\">faces.html</filename> would be patched if we updated, and that <filename moreinfo=\"none\">bloo.png</filename> is a newly added file in the repository. (The absence of any revision number next to <filename moreinfo=\"none\">bloo.png</filename> means that it doesn't yet exist in the working copy.)"
msgstr ""

#. ###TODO describe -v here as well as -uv. -u and -v use
#.            different <quote>long</quote> formats and need to be
#.            documented separately.  Moreover, as you can combine -u and
#.            -v, it needs to be explained what each of them does.  As -u is
#.            much more important than -v, and the example following that
#.            paragraph *is* about -u, not -v, my patch concentrated on
#.            that.
#: en.xml:24011(para) 
msgid "Lastly, here's a quick summary of the most common status codes that you may see:"
msgstr ""

#: en.xml:24014(screen) 
#, no-wrap
msgid "\nA    Resource is scheduled for Addition\nD    Resource is scheduled for Deletion\nM    Resource has local Modifications\nC    Resource has Conflicts (changes have not been completely merged\n       between the repository and working copy version)\nX    Resource is eXternal to this working copy (may come from another\n       repository).  See <xref linkend=\"svn.advanced.props.special.externals\"></xref>\n?    Resource is not under version control\n!    Resource is missing or incomplete (removed by another tool than\n       Subversion)\n"
msgstr ""

#: en.xml:24027(para) 
msgid "For a more detailed discussion of <command moreinfo=\"none\">svn status</command>, see <xref linkend=\"svn.tour.cycle.examine.status\"/>."
msgstr ""

#: en.xml:24033(title) 
msgid "Update"
msgstr ""

#: en.xml:24035(para) 
msgid "<command moreinfo=\"none\">svn update</command> updates your working copy, and only prints information about files that it updates."
msgstr ""

#: en.xml:24038(para) 
msgid "Subversion has combined the CVS <literal moreinfo=\"none\">P</literal> and <literal moreinfo=\"none\">U</literal> codes into just <literal moreinfo=\"none\">U</literal>. When a merge or conflict occurs, Subversion simply prints <literal moreinfo=\"none\">G</literal> or <literal moreinfo=\"none\">C</literal>, rather than a whole sentence about it."
msgstr ""

#: en.xml:24044(para) 
msgid "For a more detailed discussion of <command moreinfo=\"none\">svn update</command>, see <xref linkend=\"svn.tour.cycle.update\"/>."
msgstr ""

#: en.xml:24055(title) 
msgid "Branches and Tags"
msgstr ""

#: en.xml:24057(para) 
msgid "Subversion doesn't distinguish between filesystem space and <quote>branch</quote> space; branches and tags are ordinary directories within the filesystem. This is probably the single biggest mental hurdle a CVS user will need to climb. Read all about it in <xref linkend=\"svn.branchmerge\"/>."
msgstr ""

#: en.xml:24074(para) 
msgid "That is, providing you don't run out of disk space before your checkout finishes."
msgstr ""

#: en.xml:24065(para) 
msgid "Since Subversion treats branches and tags as ordinary directories, always remember to check out the <literal moreinfo=\"none\">trunk</literal> (<literal moreinfo=\"none\">http://svn.example.com/repos/calc/trunk/</literal>) of your project, and not the project itself (<literal moreinfo=\"none\">http://svn.example.com/repos/calc/</literal>). If you make the mistake of checking out the project itself, you'll wind up with a working copy that contains a copy of your project for every branch and tag you have.<placeholder-1/>"
msgstr ""

#: en.xml:24086(title) 
msgid "Metadata Properties"
msgstr ""

#: en.xml:24088(para) 
msgid "A new feature of Subversion is that you can attach arbitrary metadata (or <quote>properties</quote>) to files and directories. Properties are arbitrary name/value pairs associated with files and directories in your working copy."
msgstr ""

#: en.xml:24094(para) 
msgid "To set or get a property name, use the <command moreinfo=\"none\">svn propset</command> and <command moreinfo=\"none\">svn propget</command> subcommands. To list all properties on an object, use <command moreinfo=\"none\">svn proplist</command>."
msgstr ""

#: en.xml:24099(para) 
msgid "For more information, see <xref linkend=\"svn.advanced.props\"/>."
msgstr ""

#: en.xml:24107(title) 
msgid "Conflict Resolution"
msgstr ""

#: en.xml:24109(para) 
msgid "CVS marks conflicts with in-line <quote>conflict markers</quote>, and prints a <literal moreinfo=\"none\">C</literal> during an update. Historically, this has caused problems, because CVS isn't doing enough. Many users forget about (or don't see) the <literal moreinfo=\"none\">C</literal> after it whizzes by on their terminal. They often forget that the conflict-markers are even present, and then accidentally commit files containing conflict-markers."
msgstr ""

#: en.xml:24118(para) 
msgid "Subversion solves this problem by making conflicts more tangible. It remembers that a file is in a state of conflict, and won't allow you to commit your changes until you run <command moreinfo=\"none\">svn resolved</command>. See <xref linkend=\"svn.tour.cycle.resolve\"/> for more details."
msgstr ""

#: en.xml:24128(title) 
msgid "Binary Files and Translation"
msgstr ""

#: en.xml:24130(para) 
msgid "In the most general sense, Subversion handles binary files more gracefully than CVS does. Because CVS uses RCS, it can only store successive full copies of a changing binary file. Subversion, however, expresses differences between files using a binary-differencing algorithm, regardless of whether they contain textual or binary data. That means that all files are stored differentially (compressed) in the repository."
msgstr ""

#: en.xml:24138(para) 
msgid "CVS users have to mark binary files with <option>-kb</option> flags, to prevent data from being garbled (due to keyword expansion and line-ending translations). They sometimes forget to do this."
msgstr ""

#: en.xml:24143(para) 
msgid "Subversion takes the more paranoid route—first, it never performs any kind of keyword or line-ending translation unless you explicitly ask it do so (see <xref linkend=\"svn.advanced.props.special.keywords\"/> and <xref linkend=\"svn.advanced.props.special.eol-style\"/> for more details). By default, Subversion treats all file data as literal byte strings, and files are always stored in the repository in an untranslated state."
msgstr ""

#: en.xml:24150(para) 
msgid "Second, Subversion maintains an internal notion of whether a file is <quote>text</quote> or <quote>binary</quote> data, but this notion is <emphasis>only</emphasis> extant in the working copy. During an <command moreinfo=\"none\">svn update</command>, Subversion will perform contextual merges on locally modified text files, but will not attempt to do so for binary files."
msgstr ""

#: en.xml:24157(para) 
msgid "To determine whether a contextual merge is possible, Subversion examines the <literal moreinfo=\"none\">svn:mime-type</literal> property. If the file has no <literal moreinfo=\"none\">svn:mime-type</literal> property, or has a mime-type that is textual (e.g. <literal moreinfo=\"none\">text/*</literal>), Subversion assumes it is text. Otherwise, Subversion assumes the file is binary. Subversion also helps users by running a binary-detection algorithm in the <command moreinfo=\"none\">svn import</command> and <command moreinfo=\"none\">svn add</command> commands. These commands will make a good guess and then (possibly) set a binary <literal moreinfo=\"none\">svn:mime-type</literal> property on the file being added. (If Subversion guesses wrong, the user can always remove or hand-edit the property.)"
msgstr ""

#: en.xml:24178(title) 
msgid "Versioned Modules"
msgstr ""

#: en.xml:24180(para) 
msgid "Unlike CVS, a Subversion working copy is aware that it has checked out a module. That means that if somebody changes the definition of a module (e.g. adds or removes components), then a call to <command moreinfo=\"none\">svn update</command> will update the working copy appropriately, adding and removing components."
msgstr ""

#: en.xml:24186(para) 
msgid "Subversion defines modules as a list of directories within a directory property: see <xref linkend=\"svn.advanced.externals\"/>."
msgstr ""

#: en.xml:24196(title) 
msgid "Authentication"
msgstr ""

#: en.xml:24198(para) 
msgid "With CVS's pserver, you are required to <quote>login</quote> to the server before any read or write operation—you even have to login for anonymous operations. With a Subversion repository using Apache <command moreinfo=\"none\">httpd</command> or <command moreinfo=\"none\">svnserve</command> as the server, you don't provide any authentication credentials at the outset—if an operation that you perform requires authentication, the server will challenge you for your credentials (whether those credentials are username and password, a client certificate, or even both). So if your repository is world-readable, you will not be required to authenticate at all for read operations."
msgstr ""

#: en.xml:24211(para) 
msgid "As with CVS, Subversion still caches your credentials on disk (in your <filename moreinfo=\"none\">~/.subversion/auth/</filename> directory) unless you tell it not to by using the <option>--no-auth-cache</option> switch."
msgstr ""

#: en.xml:24216(para) 
msgid "The exception to this behavior, however, is in the case of accessing an <command moreinfo=\"none\">svnserve</command> server over an SSH tunnel, using the <literal moreinfo=\"none\">svn+ssh://</literal> URL schema. In that case, the <command moreinfo=\"none\">ssh</command> program unconditionally demands authentication just to start the tunnel."
msgstr ""

#: en.xml:24229(title) 
msgid "Converting a Repository from CVS to Subversion"
msgstr ""

#: en.xml:24231(para) 
msgid "Perhaps the most important way to familiarize CVS users with Subversion is to let them continue to work on their projects using the new system. And while that can be somewhat accomplished using a flat import into a Subversion repository of an exported CVS repository, the more thorough solution involves transferring not just the latest snapshot of their data, but all the history behind it as well, from one system to another. This is an extremely difficult problem to solve that involves deducing changesets in the absence of atomicity, and translating between the systems' completely orthogonal branching policies, among other complications. Still, there are a handful of tools claiming to at least partially support the ability to convert existing CVS repositories into Subversion ones."
msgstr ""

#: en.xml:24245(para) 
msgid "One such tool is cvs2svn (<ulink url=\"http://cvs2svn.tigris.org/\"/>), a Python script originally created by members of Subversion's own development community. Others include Lev Serebryakov's RefineCVS (<ulink url=\"http://lev.serebryakov.spb.ru/refinecvs/\"/>). These tools have various levels of completeness, and may make entirely different decisions about how to handle your CVS repository history. Whichever tool you decide to use, be sure to perform as much verification as you can stand on the conversion results—after all, you've worked hard to build that history!"
msgstr ""

#: en.xml:24257(para) 
msgid "For an updated collection of links to known converter tools, visit the Links page of the Subversion website (<ulink url=\"http://subversion.tigris.org/project_links.html\"/>)."
msgstr ""

#: en.xml:24272(title) 
msgid "WebDAV and Autoversioning"
msgstr ""

#: en.xml:24276(para) 
msgid "WebDAV is an extension to HTTP, and is growing more and more popular as a standard for file-sharing. Today's operating systems are becoming extremely Web-aware, and many now have built-in support for mounting <quote>shares</quote> exported by WebDAV servers."
msgstr ""

#: en.xml:24282(para) 
msgid "If you use Apache/mod_dav_svn as your Subversion network server, then to some extent, you are also running a WebDAV server. This appendix gives some background on the nature of this protocol, how Subversion uses it, and how well Subversion interoperates with other software that is WebDAV-aware."
msgstr ""

#: en.xml:24294(title) 
msgid "Basic WebDAV Concepts"
msgstr ""

#: en.xml:24296(para) 
msgid "This section provides a very brief, very general overview to the ideas behind WebDAV. It should lay the foundation for understanding WebDAV compatibility issues between clients and servers."
msgstr ""

#: en.xml:24303(title) 
msgid "Original WebDAV"
msgstr ""

#: en.xml:24305(para) 
msgid "RFC 2518 defines a set of concepts and accompanying extension methods to HTTP 1.1 that make the web into a more universal read/write medium. The basic idea is that a WebDAV-compliant web server can act like a generic file server; clients can mount shared folders that behave much like NFS or SMB filesystems."
msgstr ""

#: en.xml:24312(para) 
msgid "The tragedy, though, is that the RFC 2518 WebDAV specification does not provide any sort of model for version control, despite the <quote>V</quote> in DAV. Basic WebDAV clients and servers assume only one version of each file or directory exists, and can be repeatedly overwritten."
msgstr ""

#: en.xml:24318(para) 
msgid "Here are the concepts and terms introduced in basic WebDAV:"
msgstr ""

#: en.xml:24324(term) 
msgid "Resources"
msgstr ""

#: en.xml:24326(para) 
msgid "WebDAV lingo refers to any server-side object (that can be described with a URI) as a <firstterm>resource</firstterm>."
msgstr ""

#: en.xml:24333(term) 
msgid "New write methods"
msgstr ""

#: en.xml:24335(para) 
msgid "Beyond the standard HTTP <literal moreinfo=\"none\">PUT</literal> method (which creates or overwrites a web resource), WebDAV defines new <literal moreinfo=\"none\">COPY</literal> and <literal moreinfo=\"none\">MOVE</literal> methods for duplicating or rearranging resources."
msgstr ""

#: en.xml:24344(term) 
msgid "Collections"
msgstr ""

#: en.xml:24346(para) 
msgid "A <firstterm>collection</firstterm> is the WebDAV term for a grouping of resources. In most cases, it is analogous to a directory. Whereas file resources can be written or created with a <literal moreinfo=\"none\">PUT</literal> method, collection resources are created with the new <literal moreinfo=\"none\">MKCOL</literal> method."
msgstr ""

#: en.xml:24359(para) 
msgid "This is the same idea present in Subversion—metadata attached to files and collections. A client can list or retrieve properties attached to a resource with the new <literal moreinfo=\"none\">PROPFIND</literal> method, and can change them with the <literal moreinfo=\"none\">PROPPATCH</literal> method. Some properties are wholly created and controlled by users (e.g. a property called <quote>color</quote>), and others are wholly created and controlled by the WebDAV server (e.g. a property that contains the last modification time of a file). The former kind are called <firstterm>dead properties</firstterm>, and the latter kind are called <firstterm>live properties</firstterm>."
msgstr ""

#: en.xml:24379(para) 
msgid "A WebDAV server may decide to offer a locking feature to clients—this part of the specification is optional, although most WebDAV servers do offer the feature. If present, then clients can use the new <literal moreinfo=\"none\">LOCK</literal> and <literal moreinfo=\"none\">UNLOCK</literal> methods to mediate access to a resource. In most cases these methods are used to create exclusive write locks (as discussed in <xref linkend=\"svn.basic.vsn-models.lock-unlock\"/>), although shared write locks are also possible in some server implementations."
msgstr ""

#: en.xml:24393(term) 
msgid "Access control"
msgstr ""

#: en.xml:24395(para) 
msgid "A more recent specification (RFC 3744) defines a system for defining access control lists (ACLs) on WebDAV resources. Some clients and servers have begun to implement this feature."
msgstr ""

#: en.xml:24408(title) 
msgid "DeltaV Extensions"
msgstr ""

#: en.xml:24410(para) 
msgid "Because RFC 2518 left out versioning concepts, another committee was left with the responsibility of writing RFC 3253, which adds versioning to WebDAV, a.k.a. <quote>DeltaV</quote>. WebDAV/DeltaV clients and servers are often called just <quote>DeltaV</quote> programs, since DeltaV implies the existence of basic WebDAV."
msgstr ""

#: en.xml:24417(para) 
msgid "DeltaV introduces a whole slew of new acronyms, but don't be intimidated. The ideas are fairly straightforward:"
msgstr ""

#: en.xml:24423(term) 
msgid "Per-resource versioning"
msgstr ""

#: en.xml:24425(para) 
msgid "Like CVS and other version-control systems, DeltaV assumes that each resource has a potentially infinite number of states. A client begins by placing a resource under version control using the new <literal moreinfo=\"none\">VERSION-CONTROL</literal> method."
msgstr ""

#: en.xml:24434(term) 
msgid "Server-side working-copy model"
msgstr ""

#: en.xml:24436(para) 
msgid "Some DeltaV servers support the ability to create a virtual workspace on the server, where all of your work is performed. Clients use the <literal moreinfo=\"none\">MKWORKSPACE</literal> method to create a private area, then indicate they want to change specific resources by <quote>checking them out</quote> into the workspace, editing them, and <quote>checking them in</quote> again. In HTTP terms, the sequence of methods would be <literal moreinfo=\"none\">CHECKOUT</literal>, <literal moreinfo=\"none\">PUT</literal>, <literal moreinfo=\"none\">CHECKIN</literal>."
msgstr ""

#: en.xml:24451(term) 
msgid "Client-side working-copy model"
msgstr ""

#: en.xml:24453(para) 
msgid "Some DeltaV servers also support the idea that the client may have a private working copy on local disk. When the client wants to commit changes to the server, it begins by creating a temporary server transaction (called an <firstterm>activity</firstterm>) with the <literal moreinfo=\"none\">MKACTIVITY</literal> method. The client then performs a <literal moreinfo=\"none\">CHECKOUT</literal> on each resource it wishes to change and sends <literal moreinfo=\"none\">PUT</literal> requests. Finally, the client performs a <literal moreinfo=\"none\">CHECKIN</literal> resource, or sends a <literal moreinfo=\"none\">MERGE</literal> request to check in all resources at once."
msgstr ""

#: en.xml:24469(term) 
msgid "Configurations"
msgstr ""

#: en.xml:24471(para) 
msgid "DeltaV allows you define flexible collections of resources called <quote>configurations</quote>, which don't necessarily correspond to particular directories. A configuration can be made to point to specific versions of files, and then a <quote>baseline</quote> snapshot can be made, much like a tag."
msgstr ""

#: en.xml:24482(term) 
msgid "Extensibility"
msgstr ""

#: en.xml:24484(para) 
msgid "DeltaV defines a new method, <literal moreinfo=\"none\">REPORT</literal>, which allows the client and server to perform customized data exchanges. While DeltaV defines a number of standardized history reports that a client can request, the server is also free to define custom reports. The client sends a <literal moreinfo=\"none\">REPORT</literal> request with a properly-labeled XML body full of custom data; assuming the server understands the specific report-type, it responds with an equally custom XML body. This technique is very similar to XML-RPC."
msgstr ""

#: en.xml:24508(title) 
msgid "Subversion and DeltaV"
msgstr ""

#: en.xml:24510(para) 
msgid "The original WebDAV standard has been widely successful. Every modern computer operating system has a general WebDAV client built-in (details to follow), and a number of popular standalone applications are also able to speak WebDAV — Microsoft Office, Dreamweaver, and Photoshop to name a few. On the server end, the Apache webserver has been able to provide WebDAV services since 1998 and is considered the de-facto open-source standard. There are several other commercial WebDAV servers available, including Microsoft's own IIS."
msgstr ""

#: en.xml:24520(para) 
msgid "DeltaV, unfortunately, has not been so successful. It's very difficult to find any DeltaV clients or servers. The few that do exist are relatively unknown commercial products, and thus it's very difficult to test interoperability. It's not entirely clear as to why DeltaV has remained stagnant. Some argue that the specification is just too complex, others argue that while WebDAV's features have mass appeal (even the least technical users appreciate network file-sharing), version control features aren't interesting or necessary for most users. Finally, some have argued that DeltaV remains unpopular because there's still no open-source server product which implements it."
msgstr ""

#: en.xml:24533(para) 
msgid "When Subversion was still in its design phase, it seemed like a great idea to use Apache httpd as the main network server. It already had a module to provide WebDAV services. DeltaV was a relatively new specification. The hope was that the Subversion server module (mod_dav_svn) would eventually evolve into an open-source DeltaV reference implementation. Unfortunately, DeltaV has a very specific versioning model that doesn't quite line up with Subversion's model. Some concepts were mappable, others were not."
msgstr ""

#: en.xml:24543(para) 
msgid "The upshot is that"
msgstr ""

#: en.xml:24548(para) 
msgid "The Subversion client is not a fully-implemented DeltaV client."
msgstr ""

#: en.xml:24551(para) 
msgid "The client needs certain things from the server that DeltaV cannot provide, and thus is largely dependent on a number of Subversion-specific <literal moreinfo=\"none\">REPORT</literal> requests that only mod_dav_svn understands."
msgstr ""

#: en.xml:24558(para) 
msgid "mod_dav_svn is not a fully-implemented DeltaV server."
msgstr ""

#: en.xml:24560(para) 
msgid "Many portions of the DeltaV specification were irrelevant to Subversion, and thus left unimplemented."
msgstr ""

#: en.xml:24566(para) 
msgid "There is still some debate in the developer community as to whether or not it's worthwhile to remedy either of these situations. It's fairly unrealistic to change Subversion's design to match DeltaV, so there's probably no way the client can ever learn to get everything it needs from a general DeltaV server. On the other hand, mod_dav_svn <emphasis>could</emphasis> be further developed to implement all of DeltaV, but it's hard to find motivation to do so—there are almost no DeltaV clients to interoperate with."
msgstr ""

#: en.xml:24583(title) 
msgid "Autoversioning"
msgstr ""

#: en.xml:24585(para) 
msgid "While the Subversion client is not a full DeltaV client, nor the Subversion server a full DeltaV server, there's still a glimmer of WebDAV interoperability to be happy about: it's called autoversioning."
msgstr ""

#: en.xml:24590(para) 
msgid "Autoversioning is an optional feature defined in the DeltaV standard. A typical DeltaV server will reject an ignorant WebDAV client attempting to do a <literal moreinfo=\"none\">PUT</literal> to a file that's under version control. To change a version-controlled file, the server expects a series proper versioning requests: something like <literal moreinfo=\"none\">MKACTIVITY</literal>, <literal moreinfo=\"none\">CHECKOUT</literal>, <literal moreinfo=\"none\">PUT</literal>, <literal moreinfo=\"none\">CHECKIN</literal>. But if the DeltaV server supports autoversioning, then write-requests from basic WebDAV clients are accepted. The server behaves as if the client had issued the proper series of versioning requests, performing a commit under the hood. In other words, it allows a DeltaV server to interoperate with ordinary WebDAV clients that don't understand versioning."
msgstr ""

#: en.xml:24605(para) 
msgid "Because so many operating systems already have integrated WebDAV clients, the use case for this feature borders on fantastical: imagine an office of ordinary users running Microsoft Windows or Mac OS. Each user <quote>mounts</quote> the Subversion repository, which appears to be an ordinary network folder. They use the shared folder as they always do: open files, edit them, save them. Meanwhile, the server is automatically versioning everything. Any administrator (or knowledgeable user) can still use a Subversion client to search history and retrieve older versions of data."
msgstr ""

#: en.xml:24616(para) 
msgid "This scenario isn't fiction: it's real and it works, as of Subversion 1.2 and later. To activate autoversioning in mod_dav_svn, use the <literal moreinfo=\"none\">SVNAutoversioning</literal> directive within the <filename moreinfo=\"none\">httpd.conf</filename> Location block, like so:"
msgstr ""

#: en.xml:24622(screen) 
#, no-wrap
msgid "\n&lt;Location /repos&gt;\n  DAV svn\n  SVNPath /path/to/repository\n  SVNAutoversioning on\n&lt;/Location&gt;\n"
msgstr ""

#: en.xml:24630(para) 
msgid "When SVNAutoversioning is active, write requests from WebDAV clients result in automatic commits. A generic log message is auto-generated and attached to each revision."
msgstr ""

#: en.xml:24634(para) 
msgid "Before activating this feature, however, understand what you're getting into. WebDAV clients tend to do <emphasis>many</emphasis> write requests, resulting in a huge number of automatically committed revisions. For example, when saving data, many clients will do a <literal moreinfo=\"none\">PUT</literal> of a 0-byte file (as a way of reserving a name) followed by another <literal moreinfo=\"none\">PUT</literal> with the real filedata. The single file-write results in two separate commits. Also consider that many applications auto-save every few minutes, resulting in even more commits."
msgstr ""

#: en.xml:24645(para) 
msgid "If you have a post-commit hook program that sends email, you may want to disable email generation either altogether, or on certain sections of the repository; it depends on whether you think the influx of emails will still prove to be valuable notifications or not. Also, a smart post-commit hook program can distinguish between a transaction created via autoversioning and one created through a normal <command moreinfo=\"none\">svn commit</command>. The trick is to look for a revision property named <literal moreinfo=\"none\">svn:autoversioned</literal>. If present, the commit was made by a generic WebDAV client."
msgstr ""

#: en.xml:24656(para) 
msgid "Another feature that may be a useful complement for <literal moreinfo=\"none\">SVNAutoversioning</literal> comes from Apache's <literal moreinfo=\"none\">mod_mime</literal> module. If a generic WebDAV client adds a new file to the repository, there's no opportunity for the user to set the the <literal moreinfo=\"none\">svn:mime-type</literal> property. This might cause the file to appear as <quote>generic</quote> icon when viewed within a WebDAV shared folder, not having an association with any application. One remedy is to have a sysadmin (or other Subversion-knowledgable person) check out a working copy and manually set the <literal moreinfo=\"none\">svn:mime-type</literal> property on necessary files. But there's potentially no end to such cleanup tasks. Instead, you can use the <literal moreinfo=\"none\">ModMimeUsePathInfo</literal> directive in your Subversion <literal moreinfo=\"none\">&lt;Location&gt;</literal> block:"
msgstr ""

#: en.xml:24673(screen) 
#, no-wrap
msgid "\n&lt;Location /repos&gt;\n  DAV svn\n  SVNPath /path/to/repository\n  SVNAutoversioning on\n\n  ModMimeUsePathInfo on\n\n&lt;/Location&gt;\n"
msgstr ""

#: en.xml:24684(para) 
msgid "This directive allows <literal moreinfo=\"none\">mod_mime</literal> to attempt automatic deduction of the mime-type on new files that enter the repository via autoversioning. The module looks at the file's named extension and possibly the contents as well; if the file matches some common patterns, then the the file's <literal moreinfo=\"none\">svn;mime-type</literal> property will be set automatically."
msgstr ""

#: en.xml:24698(title) 
msgid "Client Interoperability"
msgstr ""

#: en.xml:24700(para) 
msgid "All WebDAV clients fall into one of three categories—standalone applications, file-explorer extensions, or filesystem implementations. These categories broadly define the types of WebDAV functionality available to users. <xref linkend=\"svn.webdav.clients.tbl-1\"/> gives our categorization and a quick description of some common pieces of WebDAV-enabled software. More details about these software offerings, as well as their general category, can be found in the sections that follow."
msgstr ""

#: en.xml:24711(title) 
msgid "Common WebDAV Clients"
msgstr ""

#: en.xml:24715(entry) 
msgid "Software"
msgstr ""

#: en.xml:24716(entry) 
msgid "Category"
msgstr ""

#: en.xml:24722(entry) 
msgid "Adobe Photoshop"
msgstr ""

#: en.xml:24723(entry) en.xml:24729(entry) en.xml:24735(entry) en.xml:24764(entry) en.xml:24770(entry) en.xml:24801(title) 
msgid "Standalone WebDAV applications"
msgstr ""

#: en.xml:24724(entry) 
msgid "Image editing software, allowing direct opening from, and writing to, WebDAV URLs"
msgstr ""

#: en.xml:24728(entry) 
msgid "Cadaver"
msgstr ""

#: en.xml:24730(entry) 
msgid "Command-line WebDAV client supporting file transfer, tree, and locking operations"
msgstr ""

#: en.xml:24734(entry) 
msgid "DAV Explorer"
msgstr ""

#: en.xml:24736(entry) 
msgid "GUI tool for exploring WebDAV shares"
msgstr ""

#: en.xml:24739(entry) 
msgid "davfs2"
msgstr ""

#: en.xml:24740(entry) en.xml:24758(entry) en.xml:24783(entry) en.xml:24789(entry) en.xml:25014(title) 
msgid "WebDAV filesystem implementation"
msgstr ""

#: en.xml:24741(entry) 
msgid "Linux file system driver that allows you to mount a WebDAV share"
msgstr ""

#: en.xml:24745(entry) 
msgid "GNOME Nautilus"
msgstr ""

#: en.xml:24746(entry) en.xml:24752(entry) en.xml:24777(entry) en.xml:24888(title) 
msgid "File-explorer WebDAV extensions"
msgstr ""

#: en.xml:24747(entry) en.xml:24753(entry) 
msgid "GUI file explorer able to perform tree operations on a WebDAV share"
msgstr ""

#: en.xml:24751(entry) 
msgid "KDE Konqueror"
msgstr ""

#: en.xml:24757(entry) en.xml:25044(title) 
msgid "Mac OS X"
msgstr ""

#: en.xml:24759(entry) 
msgid "Operating system with built-in support for mounting WebDAV shares locally"
msgstr ""

#: en.xml:24763(entry) 
msgid "Macromedia Dreamweaver"
msgstr ""

#: en.xml:24765(entry) 
msgid "Web production software able to directly read from and write to WebDAV URLs"
msgstr ""

#: en.xml:24769(entry) 
msgid "Microsoft Office"
msgstr ""

#: en.xml:24771(entry) 
msgid "Office productivity suite with several components able to directly read from and write to WebDAV URLs"
msgstr ""

#: en.xml:24776(entry) en.xml:24903(title) 
msgid "Microsoft Web Folders"
msgstr ""

#: en.xml:24778(entry) 
msgid "GUI file explorer program able to perform tree operations on a WebDAV share"
msgstr ""

#: en.xml:24782(entry) 
msgid "Novell NetDrive"
msgstr ""

#: en.xml:24784(entry) 
msgid "Drive-mapping program for assigning Windows drive letters to a mounted remote WebDAV share"
msgstr ""

#: en.xml:24788(entry) 
msgid "SRT WebDrive"
msgstr ""

#: en.xml:24790(entry) 
msgid "File transfer software which, among other things, allows the assignment of Windows drive letters to a mounted remote WebDAV share"
msgstr ""

#: en.xml:24803(para) 
msgid "A WebDAV application is a program which contains built-in functionality for speaking WebDAV protocols with a WebDAV server. We'll cover some of the most popular programs with this kind of WebDAV support."
msgstr ""

#: en.xml:24809(title) 
msgid "Microsoft Office, Dreamweaver, Photoshop"
msgstr ""

#: en.xml:24815(para) 
msgid "WebDAV support was removed from Microsoft Access for some reason, but exists in the rest of the Office suite."
msgstr ""

#: en.xml:24811(para) 
msgid "On Windows, there are several well-known applications that contain integrated WebDAV client functionality, such as Microsoft's Office, <footnote><placeholder-1/></footnote> Adobe's Photoshop, and Macromedia's Dreamweaver programs. They're able to directly open and save to URLs, and tend to make heavy use of WebDAV locks when editing a file."
msgstr ""

#: en.xml:24823(para) 
msgid "Note that while many of these programs also exist for the Mac OS X, they do not appear to support WebDAV directly on that platform. In fact, on Mac OS X, the <guimenu moreinfo=\"none\">File-&gt;Open</guimenu> dialog box doesn't allow one to type a path or URL at all. It's likely that the WebDAV features were deliberately left out of Macintosh versions of these programs, since OS X already provides such excellent low-level filesystem support for WebDAV."
msgstr ""

#: en.xml:24835(title) 
msgid "Cadaver, DAV Explorer"
msgstr ""

#: en.xml:24837(para) 
msgid "Cadaver is a bare-bones Unix commandline program for browsing and changing WebDAV shares. Like the Subversion client, it uses the neon HTTP library—not surprisingly, both neon and cadaver are written by the same author. Cadaver is free software (GPL license) and is available at <ulink url=\"http://www.webdav.org/cadaver/\"/>."
msgstr ""

#: en.xml:24843(para) 
msgid "Using cadaver is similar to using a commandline FTP program, and thus it's extremely useful for basic WebDAV debugging. It can be used to upload or download files in a pinch, and also to examine properties, copy, move, lock or unlock files:"
msgstr ""

#: en.xml:24849(screen) 
#, no-wrap
msgid "\n$ cadaver http://host/repos\ndav:/repos/&gt; ls\nListing collection `/repos/': succeeded.\nColl: &gt; foobar                                 0  May 10 16:19\n      &gt; playwright.el                       2864  May  4 16:18\n      &gt; proofbypoem.txt                     1461  May  5 15:09\n      &gt; westcoast.jpg                      66737  May  5 15:09\n\ndav:/repos/&gt; put README\nUploading README to `/repos/README':\nProgress: [=============================&gt;] 100.0% of 357 bytes succeeded.\n\ndav:/repos/&gt; get proofbypoem.txt\nDownloading `/repos/proofbypoem.txt' to proofbypoem.txt:\nProgress: [=============================&gt;] 100.0% of 1461 bytes succeeded.\n"
msgstr ""

#: en.xml:24867(para) 
msgid "DAV Explorer is another standalone WebDAV client, written in Java. It's under a free Apache-like license and is available at <ulink url=\"http://www.ics.uci.edu/~webdav/\"/>. DAV Explorer does everything cadaver does, but has the advantages of being portable and being more user-friendly GUI application. It's also one of the first clients to support the new WebDAV Access Control Protocol (RFC 3744)."
msgstr ""

#: en.xml:24875(para) 
msgid "Of course, DAV Explorer's ACL support is useless in this case, since mod_dav_svn doesn't support it. The fact that both Cadaver and DAV Explorer support some limited DeltaV commands isn't particularly useful either, since they don't allow <literal moreinfo=\"none\">MKACTIVITY</literal> requests. But it's not relevant anyway; we're assuming all of these clients are operating against an autoversioning repository."
msgstr ""

#: en.xml:24890(para) 
msgid "Some popular file explorer GUI programs support WebDAV extensions which allow a user to browse a DAV share as if it was just another directory on the local computer, and allowing basic tree editing operations on the items in that share. For example, Windows Explorer is able to browse a WebDAV server as a <quote>network place</quote>. Users can drag files to and from the desktop, or can rename, copy, or delete files in the usual way. But because it's only a feature of the file-explorer, the DAV share isn't visible to ordinary applications. All DAV interaction must happen through the explorer interface."
msgstr ""

#: en.xml:24905(para) 
msgid "Microsoft was one of the original backers of the WebDAV specification, and first started shipping a client in Windows 98, known as <quote>Web Folders</quote>. This client was also shipped in Windows NT4 and 2000."
msgstr ""

#: en.xml:24910(para) 
msgid "The original Web Folders client was an extension to Explorer, the main GUI program used to browse filesystems. It works well enough. In Windows 98, the feature might need to be explicitly installed if Web Folders aren't already visible inside <quote>My Computer</quote>. In Windows 2000, simply add a new <quote>network place</quote>, enter the URL, and the WebDAV share will pop up for browsing."
msgstr ""

#: en.xml:24918(para) 
msgid "With the release of Windows XP, Microsoft started shipping a new implementation of Web Folders, known as the <quote>WebDAV mini-redirector</quote>. The new implementation is a filesystem-level client, allowing WebDAV shares to be mounted as drive letters. Unfortunately, this implementation is incredibly buggy. The client usually tries to convert http URLs (<literal moreinfo=\"none\">http://host/repos</literal>) into UNC share notation (<literal moreinfo=\"none\">\\\\host\\repos</literal>); it also often tries to use Windows Domain authentication to respond to basic-auth HTTP challenges, sending usernames as <literal moreinfo=\"none\">HOST\\username</literal>. These interoperability problems are severe and documented in numerous places around the web, to the frustration of many users. Even Greg Stein, the original author of Apache's WebDAV module, recommends against trying to use XP Web Folders against an Apache server."
msgstr ""

#: en.xml:24935(para) 
msgid "It turns out that the original <quote>Explorer-only</quote> Web Folders implementation isn't dead in XP, it's just buried. It's still possible to find it by using this technique:"
msgstr ""

#: en.xml:24943(para) 
msgid "Go to 'Network Places'."
msgstr ""

#: en.xml:24947(para) 
msgid "Add a new network place."
msgstr ""

#: en.xml:24951(para) 
msgid "When prompted, enter the URL of the repository, but <emphasis>include a port number</emphasis> in the URL. For example, <literal moreinfo=\"none\">http://host/repos</literal> would be entered as <literal moreinfo=\"none\">http://host:80/repos</literal> instead."
msgstr ""

#: en.xml:24959(para) 
msgid "Respond to any authentication prompts."
msgstr ""

#: en.xml:24964(para) 
msgid "There are a number of other rumored workarounds to the problems, but none of them seem to work on all versions and patchlevels of Windows XP. In our tests, only the previous algorithm seems to work consistently on every system. The general consensus of the WebDAV community is that you should avoid the new Web Folders implementation and use the old one instead, and that if you need real a real filesystem-level client for Windows XP, then use a third-party program like WebDrive or NetDrive."
msgstr ""

#: en.xml:24974(para) 
msgid "A final tip: if you're attempting to use XP Web Folders, make sure you have the absolute latest version from Microsoft. For example, Microsoft released a bug-fixed version in January 2005, available at <ulink url=\"http://support.microsoft.com/?kbid=892211\"/>. In particular, this release is known to fix a bug whereby browsing a DAV share shows an unexpected infinite recursion."
msgstr ""

#: en.xml:24986(title) 
msgid "Nautilus, Konqueror"
msgstr ""

#: en.xml:24988(para) 
msgid "Nautilus is the official file manager/browser for the GNOME desktop (<ulink url=\"http://www.gnome.org\"/>), and Konqueror is the manager/browser for KDE desktop (<ulink url=\"http://www.kde.org\"/>). Both of these applications have an explorer-level WebDAV client built-in, and operate just fine against an autoversioning repository."
msgstr ""

#: en.xml:24994(para) 
msgid "In GNOME's Nautilus, from the <guimenu moreinfo=\"none\">File menu</guimenu>, select <guimenuitem moreinfo=\"none\">Open location</guimenuitem> and enter the URL. The repository should then be displayed like any other filesystem."
msgstr ""

#: en.xml:24999(para) 
msgid "In KDE's Konqueror, you need to use the <literal moreinfo=\"none\">webdav://</literal> scheme when entering the URL in the location bar. If you enter an <literal moreinfo=\"none\">http://</literal> URL, Konqueror will behave like an ordinary web browser. You'll likely see the generic HTML directory listing produced by mod_dav_svn. By entering <literal moreinfo=\"none\">webdav://host/repos</literal> instead of <literal moreinfo=\"none\">http://host/repos</literal>, Konqueror becomes a WebDAV client and displays the repository as a filesystem."
msgstr ""

#: en.xml:25016(para) 
msgid "The WebDAV filesystem implementation is arguably the best sort of WebDAV client. It's implemented as a low-level filesystem module, typically within the operating system's kernel. This means that the DAV share is mounted like any other network filesystem, similar to mounting an NFS share on Unix, or attaching an SMB share as drive-letter in Windows. As a result, this sort of client provides completely transparent read/write WebDAV access to all programs. Applications aren't even aware that WebDAV requests are happening."
msgstr ""

#: en.xml:25028(title) 
msgid "WebDrive, NetDrive"
msgstr ""

#: en.xml:25030(para) 
msgid "Both WebDrive and NetDrive are excellent commercial products which allows a WebDAV share to be attached as drive letters in Windows. We've had nothing but success with these products. At the time of writing, WebDrive can be purchased from South River Technologies (<ulink url=\"http://www.southrivertech.com\"/>). NetDrive ships with Netware, is free of charge, and can be found by searching the web for <quote>netdrive.exe</quote>. Though it is freely available online, users are required to have a Netware license. (If any of that sounds odd to you, you're not alone. See this page on Novell's website: <ulink url=\"http://www.novell.com/coolsolutions/qna/999.html\"/>)"
msgstr ""

#: en.xml:25051(para) 
msgid "From the Darwin terminal, one can also run <literal moreinfo=\"none\">mount -t webdav URL /mountpoint</literal>"
msgstr ""

#: en.xml:25046(para) 
msgid "Apple's OS X operating system has an integrated filesystem-level WebDAV client. From the Finder, select the <guimenuitem moreinfo=\"none\">Connect to Server</guimenuitem> item from the <guimenu moreinfo=\"none\">Go menu</guimenu>. Enter a WebDAV URL, and it appears as a disk on the desktop, just like any other mounted volume.<placeholder-1/>."
msgstr ""

#: en.xml:25055(para) 
msgid "Note that if your mod_dav_svn is older than version 1.2, OS X will refuse to mount the share as read-write; it will appear as read-only. This is because the OS X insists on locking support for read-write shares, and the ability to lock files first appeared in Subversion 1.2."
msgstr ""

#: en.xml:25061(para) 
msgid "One more word of warning: OS X's WebDAV client can sometimes be overly sensitive to HTTP redirects. If OS X is unable to mount the repository at all, you may need to enable the BrowserMatch directive in the Apache server's <filename moreinfo=\"none\">httpd.conf</filename>:"
msgstr ""

#: en.xml:25067(screen) 
#, no-wrap
msgid "\nBrowserMatch \"^WebDAVFS/1.[012]\" redirect-carefully\n"
msgstr ""

#: en.xml:25074(title) 
msgid "Linux davfs2"
msgstr ""

#: en.xml:25076(para) 
msgid "Linux davfs2 is a filesystem module for the Linux kernel, whose development is located at <ulink url=\"http://dav.sourceforge.net/\"/>. Once installed, a WebDAV network share can be mounted with the usual Linux mount command:"
msgstr ""

#: en.xml:25081(screen) 
#, no-wrap
msgid "\n$ mount.davfs http://host/repos /mnt/dav\n"
msgstr ""

#: en.xml:25098(title) 
msgid "Third Party Tools"
msgstr ""

#: en.xml:25102(para) 
msgid "Subversion's modular design (covered in <xref linkend=\"svn.developer.layerlib\"/>) and the availability of language bindings (as described in <xref linkend=\"svn.developer.usingapi.otherlangs\"/>) make it a likely candidate for use as an extension or backend to other pieces of software. For a listing of many third-party tools that are using Subversion functionality under-the-hood, check out the Links page on the Subversion website (<ulink url=\"http://subversion.tigris.org/project_links.html\"/>)."
msgstr ""

#: en.xml:25120(title) 
msgid "Copyright"
msgstr ""

#: en.xml:25123(programlisting) 
#, no-wrap
msgid "\n\nCopyright (c) 2002-2006\nBen Collins-Sussman, Brian W. Fitzpatrick, C. Michael Pilato.  \n\nThis work is licensed under the Creative Commons Attribution License.\nTo view a copy of this license, visit\nhttp://creativecommons.org/licenses/by/2.0/ or send a letter to\nCreative Commons, 559 Nathan Abbott Way, Stanford, California 94305,\nUSA.\n\nA summary of the license is given below, followed by the full legal\ntext.\n\n--------------------------------------------------------------------\n\nYou are free:\n\n    * to copy, distribute, display, and perform the work\n    * to make derivative works\n    * to make commercial use of the work\n\nUnder the following conditions:\n\t\nAttribution. You must give the original author credit.\n\n    * For any reuse or distribution, you must make clear to others the\n      license terms of this work.\n\n    * Any of these conditions can be waived if you get permission from\n      the author.\n\nYour fair use and other rights are in no way affected by the above.\n\nThe above is a summary of the full license below.\n\n====================================================================\n\nCreative Commons Legal Code\nAttribution 2.0\n\nCREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE\nLEGAL SERVICES. DISTRIBUTION OF THIS LICENSE DOES NOT CREATE AN\nATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS\nINFORMATION ON AN \"AS-IS\" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES\nREGARDING THE INFORMATION PROVIDED, AND DISCLAIMS LIABILITY FOR\nDAMAGES RESULTING FROM ITS USE.\n\nLicense\n\nTHE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS\nCREATIVE COMMONS PUBLIC LICENSE (\"CCPL\" OR \"LICENSE\"). THE WORK IS\nPROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE\nWORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS\nPROHIBITED.\n\nBY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND\nAGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. THE LICENSOR GRANTS\nYOU THE RIGHTS CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF\nSUCH TERMS AND CONDITIONS.\n\n1. Definitions\n\n   a. \"Collective Work\" means a work, such as a periodical issue,\n      anthology or encyclopedia, in which the Work in its entirety in\n      unmodified form, along with a number of other contributions,\n      constituting separate and independent works in themselves, are\n      assembled into a collective whole. A work that constitutes a\n      Collective Work will not be considered a Derivative Work (as\n      defined below) for the purposes of this License.\n\n   b. \"Derivative Work\" means a work based upon the Work or upon the\n      Work and other pre-existing works, such as a translation,\n      musical arrangement, dramatization, fictionalization, motion\n      picture version, sound recording, art reproduction, abridgment,\n      condensation, or any other form in which the Work may be recast,\n      transformed, or adapted, except that a work that constitutes a\n      Collective Work will not be considered a Derivative Work for the\n      purpose of this License. For the avoidance of doubt, where the\n      Work is a musical composition or sound recording, the\n      synchronization of the Work in timed-relation with a moving\n      image (\"synching\") will be considered a Derivative Work for the\n      purpose of this License.\n\n   c. \"Licensor\" means the individual or entity that offers the Work\n      under the terms of this License.\n\n   d. \"Original Author\" means the individual or entity who created the Work.\n\n   e. \"Work\" means the copyrightable work of authorship offered under\n      the terms of this License.\n\n   f. \"You\" means an individual or entity exercising rights under this\n      License who has not previously violated the terms of this\n      License with respect to the Work, or who has received express\n      permission from the Licensor to exercise rights under this\n      License despite a previous violation.\n\n2. Fair Use Rights. Nothing in this license is intended to reduce,\n   limit, or restrict any rights arising from fair use, first sale or\n   other limitations on the exclusive rights of the copyright owner\n   under copyright law or other applicable laws.\n\n3. License Grant. Subject to the terms and conditions of this License,\n   Licensor hereby grants You a worldwide, royalty-free,\n   non-exclusive, perpetual (for the duration of the applicable\n   copyright) license to exercise the rights in the Work as stated\n   below:\n\n   a. to reproduce the Work, to incorporate the Work into one or more\n      Collective Works, and to reproduce the Work as incorporated in\n      the Collective Works;\n\n   b. to create and reproduce Derivative Works;\n\n   c. to distribute copies or phonorecords of, display publicly,\n      perform publicly, and perform publicly by means of a digital\n      audio transmission the Work including as incorporated in\n      Collective Works;\n\n   d. to distribute copies or phonorecords of, display publicly,\n      perform publicly, and perform publicly by means of a digital\n      audio transmission Derivative Works.\n\n   e.\n\n      For the avoidance of doubt, where the work is a musical composition:\n\n         i. Performance Royalties Under Blanket Licenses. Licensor\n            waives the exclusive right to collect, whether\n            individually or via a performance rights society\n            (e.g. ASCAP, BMI, SESAC), royalties for the public\n            performance or public digital performance (e.g. webcast)\n            of the Work.\n\n        ii. Mechanical Rights and Statutory Royalties. Licensor waives\n            the exclusive right to collect, whether individually or\n            via a music rights agency or designated agent (e.g. Harry\n            Fox Agency), royalties for any phonorecord You create from\n            the Work (\"cover version\") and distribute, subject to the\n            compulsory license created by 17 USC Section 115 of the US\n            Copyright Act (or the equivalent in other jurisdictions).\n\n   f. Webcasting Rights and Statutory Royalties. For the avoidance of\n      doubt, where the Work is a sound recording, Licensor waives the\n      exclusive right to collect, whether individually or via a\n      performance-rights society (e.g. SoundExchange), royalties for\n      the public digital performance (e.g. webcast) of the Work,\n      subject to the compulsory license created by 17 USC Section 114\n      of the US Copyright Act (or the equivalent in other\n      jurisdictions).\n\nThe above rights may be exercised in all media and formats whether now\nknown or hereafter devised. The above rights include the right to make\nsuch modifications as are technically necessary to exercise the rights\nin other media and formats. All rights not expressly granted by\nLicensor are hereby reserved.\n\n4. Restrictions.The license granted in Section 3 above is expressly\n   made subject to and limited by the following restrictions:\n\n   a. You may distribute, publicly display, publicly perform, or\n      publicly digitally perform the Work only under the terms of this\n      License, and You must include a copy of, or the Uniform Resource\n      Identifier for, this License with every copy or phonorecord of\n      the Work You distribute, publicly display, publicly perform, or\n      publicly digitally perform. You may not offer or impose any\n      terms on the Work that alter or restrict the terms of this\n      License or the recipients' exercise of the rights granted\n      hereunder. You may not sublicense the Work. You must keep intact\n      all notices that refer to this License and to the disclaimer of\n      warranties. You may not distribute, publicly display, publicly\n      perform, or publicly digitally perform the Work with any\n      technological measures that control access or use of the Work in\n      a manner inconsistent with the terms of this License\n      Agreement. The above applies to the Work as incorporated in a\n      Collective Work, but this does not require the Collective Work\n      apart from the Work itself to be made subject to the terms of\n      this License. If You create a Collective Work, upon notice from\n      any Licensor You must, to the extent practicable, remove from\n      the Collective Work any reference to such Licensor or the\n      Original Author, as requested. If You create a Derivative Work,\n      upon notice from any Licensor You must, to the extent\n      practicable, remove from the Derivative Work any reference to\n      such Licensor or the Original Author, as requested.\n\n   b. If you distribute, publicly display, publicly perform, or\n      publicly digitally perform the Work or any Derivative Works or\n      Collective Works, You must keep intact all copyright notices for\n      the Work and give the Original Author credit reasonable to the\n      medium or means You are utilizing by conveying the name (or\n      pseudonym if applicable) of the Original Author if supplied; the\n      title of the Work if supplied; to the extent reasonably\n      practicable, the Uniform Resource Identifier, if any, that\n      Licensor specifies to be associated with the Work, unless such\n      URI does not refer to the copyright notice or licensing\n      information for the Work; and in the case of a Derivative Work,\n      a credit identifying the use of the Work in the Derivative Work\n      (e.g., \"French translation of the Work by Original Author,\" or\n      \"Screenplay based on original Work by Original Author\"). Such\n      credit may be implemented in any reasonable manner; provided,\n      however, that in the case of a Derivative Work or Collective\n      Work, at a minimum such credit will appear where any other\n      comparable authorship credit appears and in a manner at least as\n      prominent as such other comparable authorship credit.\n\n5. Representations, Warranties and Disclaimer\n\nUNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING,\nLICENSOR OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR\nWARRANTIES OF ANY KIND CONCERNING THE WORK, EXPRESS, IMPLIED,\nSTATUTORY OR OTHERWISE, INCLUDING, WITHOUT LIMITATION, WARRANTIES OF\nTITLE, MERCHANTIBILITY, FITNESS FOR A PARTICULAR PURPOSE,\nNONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY,\nOR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT\nDISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED\nWARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.\n\n6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY\n   APPLICABLE LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY\n   LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE\n   OR EXEMPLARY DAMAGES ARISING OUT OF THIS LICENSE OR THE USE OF THE\n   WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n   DAMAGES.\n\n7. Termination\n\n   a. This License and the rights granted hereunder will terminate\n      automatically upon any breach by You of the terms of this\n      License. Individuals or entities who have received Derivative\n      Works or Collective Works from You under this License, however,\n      will not have their licenses terminated provided such\n      individuals or entities remain in full compliance with those\n      licenses. Sections 1, 2, 5, 6, 7, and 8 will survive any\n      termination of this License.\n\n   b. Subject to the above terms and conditions, the license granted\n      here is perpetual (for the duration of the applicable copyright\n      in the Work). Notwithstanding the above, Licensor reserves the\n      right to release the Work under different license terms or to\n      stop distributing the Work at any time; provided, however that\n      any such election will not serve to withdraw this License (or\n      any other license that has been, or is required to be, granted\n      under the terms of this License), and this License will continue\n      in full force and effect unless terminated as stated above.\n\n8. Miscellaneous\n\n   a. Each time You distribute or publicly digitally perform the Work\n      or a Collective Work, the Licensor offers to the recipient a\n      license to the Work on the same terms and conditions as the\n      license granted to You under this License.\n\n   b. Each time You distribute or publicly digitally perform a\n      Derivative Work, Licensor offers to the recipient a license to\n      the original Work on the same terms and conditions as the\n      license granted to You under this License.\n\n   c. If any provision of this License is invalid or unenforceable\n      under applicable law, it shall not affect the validity or\n      enforceability of the remainder of the terms of this License,\n      and without further action by the parties to this agreement,\n      such provision shall be reformed to the minimum extent necessary\n      to make such provision valid and enforceable.\n\n   d. No term or provision of this License shall be deemed waived and\n      no breach consented to unless such waiver or consent shall be in\n      writing and signed by the party to be charged with such waiver\n      or consent.\n\n   e. This License constitutes the entire agreement between the\n      parties with respect to the Work licensed here. There are no\n      understandings, agreements or representations with respect to\n      the Work not specified here. Licensor shall not be bound by any\n      additional provisions that may appear in any communication from\n      You. This License may not be modified without the mutual written\n      agreement of the Licensor and You.\n\nCreative Commons is not a party to this License, and makes no warranty\nwhatsoever in connection with the Work. Creative Commons will not be\nliable to You or any party on any legal theory for any damages\nwhatsoever, including without limitation any general, special,\nincidental or consequential damages arising in connection to this\nlicense. Notwithstanding the foregoing two (2) sentences, if Creative\nCommons has expressly identified itself as the Licensor hereunder, it\nshall have all rights and obligations of Licensor.\n\nExcept for the limited purpose of indicating to the public that the\nWork is licensed under the CCPL, neither party will use the trademark\n\"Creative Commons\" or any related trademark or logo of Creative\nCommons without the prior written consent of Creative Commons. Any\npermitted use will be in compliance with Creative Commons'\nthen-current trademark usage guidelines, as may be published on its\nwebsite or otherwise made available upon request from time to time.\n\nCreative Commons may be contacted at http://creativecommons.org/.\n\n====================================================================\n"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>.
#: en.xml:0(None) 
msgid "translator-credits"
msgstr ""

#. Place the translation of 'translation' here.
#: en.xml:0(None) 
msgid "translator-translation"
msgstr ""

