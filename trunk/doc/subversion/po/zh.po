# Copyright (C) 2007 the Subversion Book team
# 
# Authors:
# Dongsheng Song <dongsheng.song@gmail.com>, 2007
# Xun Leasun <leasun@gmail.com>
# Daijun Sun <daijun@gmail.com>
msgid ""
msgstr ""
"Project-Id-Version: Subversion Book\n"
"POT-Creation-Date: 2007-05-06 12:52+0800\n"
"PO-Revision-Date: 2007-04-30 10:07+0800\n"
"Last-Translator: Dongsheng Song <dongsheng.song@gmail.com>\n"
"Language-Team: Subversion Book team <svnbook-dev@red-bean.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: build/en/book.xml:0(None)
msgid "translator-credits"
msgstr ""
"Dongsheng Song <dongsheng.song@gmail.com>\n"
"Xun Leasun <leasun@gmail.com>\n"
"Daijun Sun <daijun@gmail.com>\n"

#: build/en/book.xml:10017(para)
msgid "There's nothing particularly incorrect about such a layout, but it may or may not seem as intuitive for your users. Especially in large, multi-project situations with many users, those users may tend to be familiar with only one or two of the projects in the repository. But the projects-as-branch-siblings tends to de-emphasize project individuality and focus on the entire set of projects as a single entity. That's a social issue though. We like our originally suggested arrangement for purely practical reasons—it's easier to ask about (or modify, or migrate elsewhere) the entire history of a single project when there's a single repository path that holds the entire history—past, present, tagged, and branched—for that project and that project alone."
msgstr ""

#: build/en/book.xml:10036(title)
msgid "Deciding Where and How to Host Your Repository"
msgstr ""

#: build/en/book.xml:10038(para)
msgid "Before creating your Subversion repository, an obvious question you'll need to answer is where the thing is going to live. This is strongly connected to a myriad of other questions involving how the repository will be accessed (via a Subversion server or directly), by whom (users behind your corporate firewall or the whole world out on the open Internet), what other services you'll be providing around Subversion (repository browsing interfaces, e-mail based commit notification, etc.), your data backup strategy, and so on."
msgstr ""

#: build/en/book.xml:10049(para)
msgid "We cover server choice and configuration in <xref linkend=\"svn.serverconfig\"/>, but the point we'd like to briefly make here is simply that the answers to some of these other questions might have implications that force your hand when deciding where your repository will live. For example, certain deployment scenarios might require accessing the repository via a remote filesystem from multiple computers, in which case (as you'll read in the next section) your choice of a repository back-end data store turns out not to be a choice at all because only one of the available back-ends will work in this scenario."
msgstr ""

#: build/en/book.xml:10060(para)
msgid "To try to address each and every possible way to deploy Subversion is both not possible and outside the scope of this book. We simply encourage you to evaluate your options using these pages and other sources as your reference material, and plan ahead."
msgstr ""

#: build/en/book.xml:1007(title) build/en/book.xml:1014(title)
msgid "Subversion's Architecture"
msgstr "Subversion的架构"

#: build/en/book.xml:10070(title)
msgid "Choosing a Data Store"
msgstr "选择数据存储格式"

#: build/en/book.xml:10072(para)
#, fuzzy
msgid "As of version 1.1, Subversion provides two options for the type of underlying data store—often referred to as <quote>the back-end</quote> or, somewhat confusingly, <quote>the (versioned) filesystem</quote>—that each repository uses. One type of data store keeps everything in a Berkeley DB (or BDB) database environment; repositories that use this type are often referred to as being <quote>BDB-backed</quote>. The other type stores data in ordinary flat files, using a custom format. Subversion developers have adopted the habit of referring to this latter data storage mechanism as <firstterm>FSFS</firstterm><placeholder-1/> —a versioned filesystem implementation that uses the native OS filesystem to store data."
msgstr "在Subversion1.2中，版本库中存储数据有两种方式。一种是在Berkeley DB数据库中存储数据；另一种是使用普通的文件，使用自定义格式。因为Subversion的开发者称版本库为（版本化的）文件系统，他们接受了称后一种存储方式为FSFS<footnote><placeholder-1/></footnote>的习惯，也就是说，使用本地操作系统文件系统来存储数据的版本化文件的系统。"

#: build/en/book.xml:10084(para)
#, fuzzy
msgid "Often pronounced <quote>fuzz-fuzz</quote>, if Jack Repenning has anything to say about it. (This book, however, assumes that the reader is thinking <quote>eff-ess-eff-ess</quote>.)"
msgstr "读作<quote>fuzz-fuzz</quote>, 如果Jack Repenning说起这个问题。"

#: build/en/book.xml:1009(para)
#, fuzzy
msgid "<xref linkend=\"svn.intro.architecture.dia-1\"/> illustrates a <quote>mile-high</quote> view of Subversion's design."
msgstr "<xref linkend=\"svn.intro.architecture.dia-1\"/>给出了Subversion设计总体上的<quote>俯视图</quote>。"

#: build/en/book.xml:10092(para)
#, fuzzy
msgid "<xref linkend=\"svn.reposadmin.basics.backends.tbl-1\"/> gives a comparative overview of Berkeley DB and FSFS repositories."
msgstr "<xref linkend=\"svn.reposadmin.basics.backends.tbl-1\"/>从总体上比较了Berkeley DB和FSFS版本库，下一部分将会详细讲述细节。"

#: build/en/book.xml:10097(title)
msgid "Repository Data Store Comparison"
msgstr "版本库数据存储对照表"

#: build/en/book.xml:101(para)
msgid "The problem with such FAQs is that they are not, in a literal sense, FAQs at all. No one ever called the tech support line and asked, <quote>How can we maximize productivity?</quote>. Rather, people asked highly specific questions, like, <quote>How can we change the calendaring system to send reminders two days in advance instead of one?</quote> and so on. But it's a lot easier to make up imaginary Frequently Asked Questions than it is to discover the real ones. Compiling a true FAQ sheet requires a sustained, organized effort: over the lifetime of the software, incoming questions must be tracked, responses monitored, and all gathered into a coherent, searchable whole that reflects the collective experience of users in the wild. It calls for the patient, observant attitude of a field naturalist. No grand hypothesizing, no visionary pronouncements here—open eyes and accurate note-taking are what's needed most."
msgstr "类似的问题完全不符合FAQ的精神。没人会打电话给技术支援中心，询问<quote>怎样提高生产率？</quote>相反，人们经常询问一些非常具体的问题，像<quote>怎样让日程系统提前两天而不是一天提醒相关用户？</quote>等等。但是想象比发现真正的问题更容易。构建一个真实的问题列表需要持之以恒的、有组织的辛勤工作：跨越整个软件生命周期，追踪新提出的问题，监控反馈信息，所有的问题要整理成一个统一的、可查询的整体，并且能够真实的反映所有用户的感受。这需要耐心，如自然学家一样严谨的态度，没有浮华的假设，没有虚幻的断言—相反的，需要开放的视野和精确的记录。"

#: build/en/book.xml:10101(entry)
msgid "Category"
msgstr "分类"

#: build/en/book.xml:10102(entry) build/en/book.xml:12670(entry)
msgid "Feature"
msgstr "特性"

#: build/en/book.xml:10103(entry) build/en/book.xml:10207(title)
msgid "Berkeley DB"
msgstr "Berkeley DB"

#: build/en/book.xml:10104(entry) build/en/book.xml:10335(title)
msgid "FSFS"
msgstr "FSFS"

#: build/en/book.xml:10109(entry)
msgid "Reliability"
msgstr "可靠性"

#: build/en/book.xml:10110(entry)
msgid "Data integrity"
msgstr ""

#: build/en/book.xml:10111(entry)
msgid "when properly deployed, extremely reliable; Berkeley DB 4.4 brings auto-recovery"
msgstr ""

#: build/en/book.xml:10113(entry)
msgid "older versions had some rarely demonstrated, but data-destroying bugs"
msgstr ""

#: build/en/book.xml:10117(entry)
msgid "Sensitivity to interruptions"
msgstr "对操作中断的敏感"

#: build/en/book.xml:10118(entry)
#, fuzzy
msgid "very; crashes and permission problems can leave the database <placeholder-1/>, requiring journaled recovery procedures"
msgstr "很敏感；系统崩溃或者权限问题会导致数据库<placeholder-1/>，需要定期进行恢复。"

#: build/en/book.xml:10119(quote)
msgid "wedged"
msgstr "塞住"

#: build/en/book.xml:10121(entry)
msgid "quite insensitive"
msgstr "十分敏感"

#: build/en/book.xml:10124(entry)
msgid "Accessibility"
msgstr "可用性"

#: build/en/book.xml:10125(entry)
msgid "Usable from a read-only mount"
msgstr "可只读加载"

#: build/en/book.xml:10126(entry) build/en/book.xml:10131(entry)
msgid "no"
msgstr "不能"

#: build/en/book.xml:10127(entry) build/en/book.xml:10132(entry)
#: build/en/book.xml:10137(entry)
msgid "yes"
msgstr "可以"

#: build/en/book.xml:10130(entry)
msgid "Platform-independent storage"
msgstr "存储平台无关"

#: build/en/book.xml:10135(entry)
msgid "Usable over network filesystems"
msgstr "可从网络文件系统访问"

#: build/en/book.xml:10136(entry)
msgid "generally, no"
msgstr ""

#: build/en/book.xml:10140(entry)
msgid "Group permissions handling"
msgstr "组访问权处理"

#: build/en/book.xml:10141(entry)
#, fuzzy
msgid "sensitive to user umask problems; best if accessed by only one user"
msgstr "对于用户的umask设置十分敏感，最好只由一个用户访问。"

#: build/en/book.xml:10143(entry)
msgid "works around umask problems"
msgstr "对umask设置不敏感"

#: build/en/book.xml:10146(entry)
msgid "Scalability"
msgstr "伸缩性"

#: build/en/book.xml:10147(entry)
#, fuzzy
msgid "Repository disk usage"
msgstr "版本库大小"

#: build/en/book.xml:10148(entry)
msgid "larger (especially if logfiles aren't purged)"
msgstr ""

#: build/en/book.xml:10149(entry)
msgid "smaller"
msgstr "较小"

#: build/en/book.xml:10152(entry)
#, fuzzy
msgid "Number of revision trees"
msgstr "可扩展性：修订版本树的数量"

#: build/en/book.xml:10153(entry)
msgid "database; no problems"
msgstr "数据库，没有限制"

#: build/en/book.xml:10154(entry)
#, fuzzy
msgid "some older native filesystems don't scale well with thousands of entries in a single directory"
msgstr "许多古老的本地文件系统在处理单一目录包含上千个条目时出现问题。"

#: build/en/book.xml:10158(entry)
#, fuzzy
msgid "Directories with many files"
msgstr "可扩展性：文件较多的目录"

#: build/en/book.xml:10159(entry)
msgid "slower"
msgstr "较慢"

#: build/en/book.xml:10160(entry)
msgid "faster"
msgstr "较快"

#: build/en/book.xml:10163(entry)
msgid "Performance"
msgstr "性能"

#: build/en/book.xml:10164(entry)
msgid "Checking out latest revision"
msgstr "检出最新的代码"

#: build/en/book.xml:10165(entry) build/en/book.xml:10166(entry)
msgid "no meaningful difference"
msgstr ""

#: build/en/book.xml:10169(entry)
msgid "Large commits"
msgstr "大的提交"

#: build/en/book.xml:10170(entry)
msgid "slower overall, but cost is amortized across the lifetime of the commit"
msgstr ""

#: build/en/book.xml:10172(entry)
#, fuzzy
msgid "faster overall, but finalization delay may cause client timeouts"
msgstr "较快，但是最后较长的延时可能会导致客户端操作超时"

#: build/en/book.xml:10179(para)
msgid "There are advantages and disadvantages to each of these two back-end types. Neither of them is more <quote>official</quote> than the other, though the newer FSFS is the default data store as of Subversion 1.2. Both are reliable enough to trust with your versioned data. But as you can see in <xref linkend=\"svn.reposadmin.basics.backends.tbl-1\"/>, the FSFS backend provides quite a bit more flexibility in terms of its supported deployment scenarios. More flexibility means you have to work a little harder to find ways to deploy it incorrectly. Those reasons—plus the fact that not using Berkeley DB means there's one fewer component in the system—largely explain why today almost everyone uses the FSFS backend when creating new repositories."
msgstr ""

#: build/en/book.xml:1018(para)
msgid "On one end is a Subversion repository that holds all of your versioned data. On the other end is your Subversion client program, which manages local reflections of portions of that versioned data (called <quote>working copies</quote>). Between these extremes are multiple routes through various Repository Access (RA) layers. Some of these routes go across computer networks and through network servers which then access the repository. Others bypass the network altogether and access the repository directly."
msgstr "图中的一端是保存所有在版本控制下数据的Subversion版本库，另一端是Subvesion的客户端程序，管理着所有在版本控制下数据的本地影射（称为<quote>工作拷贝</quote>），在这两极之间是各种各样的版本库访问（RA）层，某些使用电脑网络通过网络服务器访问版本库，某些则绕过网络服务器直接访问版本库。"

#: build/en/book.xml:10193(para)
msgid "Fortunately, most programs which access Subversion repositories are blissfully ignorant of which back-end data store is in use. And you aren't even necessarily stuck with your first choice of a data store—in the event that you change your mind later, Subversion provides ways of migrating your repository's data into another repository that uses a different back-end data store. We talk more about that later in this chapter."
msgstr ""

#: build/en/book.xml:10202(para)
msgid "The following subsections provide a more detailed look at the available data store types."
msgstr ""

#: build/en/book.xml:10209(para)
msgid "When the initial design phase of Subversion was in progress, the developers decided to use Berkeley DB for a variety of reasons, including its open-source license, transaction support, reliability, performance, API simplicity, thread-safety, support for cursors, and so on."
msgstr "在Subversion的初始设计阶段，开发者因为多种原因而决定采用Berkeley DB，比如它的开源协议、事务支持、可靠性、性能、简单的API、线程安全、支持游标等。"

#: build/en/book.xml:10216(para)
msgid "Berkeley DB provides real transaction support—perhaps its most powerful feature. Multiple processes accessing your Subversion repositories don't have to worry about accidentally clobbering each other's data. The isolation provided by the transaction system is such that for any given operation, the Subversion repository code sees a static view of the database—not a database that is constantly changing at the hand of some other process—and can make decisions based on that view. If the decision made happens to conflict with what another process is doing, the entire operation is rolled back as if it never happened, and Subversion gracefully retries the operation against a new, updated (and yet still static) view of the database."
msgstr "Berkeley DB提供了真正的事务支持－这或许是它最强大的特性，访问你的Subversion版本库的多个进程不必担心偶尔会破坏其他进程的数据。事务系统提供的隔离对于任何给定的操作，Subversion版本库代码看到的只是数据库的静态视图－而不是一个在其他进程影响不断变化的数据库－并能够根据该视图作出决定。如果该决定正好同其他进程所做操作冲突，整个操作会回滚，就像什么都没有发生一样，并且Subversion会优雅的再次对更新的静态视图进行操作。"

#: build/en/book.xml:10231(para)
msgid "Another great feature of Berkeley DB is <firstterm>hot backups</firstterm>—the ability to backup the database environment without taking it <quote>offline</quote>. We'll discuss how to backup your repository in <xref linkend=\"svn.reposadmin.maint.backup\"/>, but the benefits of being able to make fully functional copies of your repositories without any downtime should be obvious."
msgstr "Berkeley DB另一个强大的特性是热备份－不必<quote>脱机</quote>就可以备份数据库环境的能力。我们将会在<xref linkend=\"svn.reposadmin.maint.backup\"/>讨论如何备份你的版本库，能够不停止系统对版本库做全面备份的好处是显而易见的。"

#: build/en/book.xml:10238(para)
#, fuzzy
msgid "Berkeley DB is also a very reliable database system when properly used. Subversion uses Berkeley DB's logging facilities, which means that the database first writes to on-disk log files a description of any modifications it is about to make, and then makes the modification itself. This is to ensure that if anything goes wrong, the database system can back up to a previous <firstterm>checkpoint</firstterm>—a location in the log files known not to be corrupt—and replay transactions until the data is restored to a usable state. See <xref linkend=\"svn.reposadmin.maint.diskspace\"/> for more about Berkeley DB log files."
msgstr "Berkeley DB同时是一个可信赖的数据库系统。Subversion利用了Berkeley DB可以记日志的便利，这意味着数据库先在磁盘上写一个日志文件，描述它将要做的修改，然后再做这些修改。这是为了确保如果如果任何地方出了差错，数据库系统能恢复到先前的检查点—一个日志文件认为没有错误的位置，重新开始事务直到数据恢复为一个可用的状态。关于Berkeley DB日志文件的更多信息请查看<xref linkend=\"svn.reposadmin.maint.diskspace\"/>。"

#: build/en/book.xml:10251(para)
#, fuzzy
msgid "But every rose has its thorn, and so we must note some known limitations of Berkeley DB. First, Berkeley DB environments are not portable. You cannot simply copy a Subversion repository that was created on a Unix system onto a Windows system and expect it to work. While much of the Berkeley DB database format is architecture independent, there are other aspects of the environment that are not. Secondly, Subversion uses Berkeley DB in a way that will not operate on Windows 95/98 systems—if you need to house a BDB-backed repository on a Windows machine, stick with Windows 2000 or newer."
msgstr "但是每朵玫瑰都有刺，我们也必须记录一些Berkeley DB已知的缺陷。首先，Berkeley DB环境不是跨平台的。你不能简单的拷贝一个在Unix上创建的Subversion版本库到一个Windows系统并期望它能够正常工作。尽管Berkeley DB数据库的大部分格式是不受架构约束的，但环境还是有一些方面没有独立出来。其次，使用Berkeley DB的Subversion不能在95/98系统上运行—如果你需要将版本库建在一个Windows机器上，请装到Windows2000或WindowsXP上。另外，Berkeley DB版本库不能放在网络共享文件夹中，尽管Berkeley DB承诺如果按照一套特定规范的话，可以在网络共享上正常运行，但实际上已知的共享类型几乎都不满足这套规范。"

#: build/en/book.xml:10263(para)
msgid "While Berkeley DB promises to behave correctly on network shares that meet a particular set of specifications, <placeholder-1/> most networked filesystem types and appliances do <emphasis>not</emphasis> actually meet those requirements. And in no case can you allow a BDB-backed repository that resides on a network share to be accessed by multiple clients of that share at once (which quite often is the whole point of having the repository live on a network share in the first place)."
msgstr ""

#: build/en/book.xml:10266(para)
msgid "Berkeley DB requires that the underlying filesystem implement strict POSIX locking semantics, and more importantly, the ability to map files directly into process memory."
msgstr ""

#: build/en/book.xml:10280(para)
msgid "If you attempt to use Berkeley DB on a non-compliant remote filesystem, the results are unpredictable—you may see mysterious errors right away, or it may be months before you discover that your repository database is subtly corrupted. You should strongly consider using the FSFS data store for repositories that need to live on a network share."
msgstr ""

#: build/en/book.xml:10289(para)
#, fuzzy
msgid "Finally, because Berkeley DB is a library linked directly into Subversion, it's more sensitive to interruptions than a typical relational database system. Most SQL systems, for example, have a dedicated server process that mediates all access to tables. If a program accessing the database crashes for some reason, the database daemon notices the lost connection and cleans up any mess left behind. And because the database daemon is the only process accessing the tables, applications don't need to worry about permission conflicts. These things are not the case with Berkeley DB, however. Subversion (and programs using Subversion libraries) access the database tables directly, which means that a program crash can leave the database in a temporarily inconsistent, inaccessible state. When this happens, an administrator needs to ask Berkeley DB to restore to a checkpoint, which is a bit of an annoyance. Other things can cause a repository to <quote>wedge</quote> besides crashed processes, such as programs conflicting over ownership and permissions on the database files."
msgstr "最后，因为Berkeley DB的库直接链接到了Subversion中，它对于中断比典型的关系型数据库系统更为敏感。大多数SQL系统，举例来说，有一个主服务进程来协调对数据库表的访问。如果一个访问数据库的程序因为某种原因出现问题，数据库守护进程察觉到连接中断会做一些清理。因为数据库守护进程是唯一访问数据库表的进程，应用程序不需要担心访问许可的冲突。但是，这些情况与Berkeley DB不同。Subversion（和使用Subversion库的程序）直接访问数据库的表，这意味着如果有一个程序崩溃，就会使数据库处于一个暂时的不一致、不可访问的状态。当这种情况发生时，管理员需要让Berkeley DB恢复到一个检查点，这的确有点讨厌。除了崩溃的进程，还有一些情况能让版本库出现异常，比如程序在数据库文件的所有权或访问权限上发生冲突。因为Berkeley DB版本库非常快，并且可以扩展，非常适合使用一个单独的服务进程，通过一个用户来访问—比如Apache的<command moreinfo=\"none\">httpd</command>或<command moreinfo=\"none\">svnserve</command>（参见<xref linkend=\"svn.serverconfig\"/>）—而不是多用户通过<literal moreinfo=\"none\">file:///</literal>或<literal moreinfo=\"none\">svn+ssh://</literal>URL的方式多用户访问。如果将Berkeley DB版本库直接用作多用户访问，请先阅读<xref linkend=\"svn.serverconfig.multimethod\"/>。"

#: build/en/book.xml:10310(para)
msgid "Berkeley DB 4.4 brings (to Subversion 1.4 and better) the ability for Subversion to automatically and transparently recover Berkeley DB environments in need of such recovery. When a Subversion process attaches to a repository's Berkeley DB environment, it uses some process accounting mechanisms to detect any unclean disconnections by previous processes, performs any necessary recovery, and then continues on as if nothing happened. This doesn't completely eliminate instances of repository wedging, but it does drastically reduce the amount of human interaction required to recover from them."
msgstr ""

#: build/en/book.xml:10323(para)
msgid "So while a Berkeley DB repository is quite fast and scalable, it's best used by a single server process running as one user—such as Apache's <command moreinfo=\"none\">httpd</command> or <command moreinfo=\"none\">svnserve</command> (see <xref linkend=\"svn.serverconfig\"/>)—rather than accessing it as many different users via <literal moreinfo=\"none\">file://</literal> or <literal moreinfo=\"none\">svn+ssh://</literal> URLs. If using a Berkeley DB repository directly as multiple users, be sure to read <xref linkend=\"svn.serverconfig.multimethod\"/>."
msgstr ""

#: build/en/book.xml:1033(title)
msgid "Subversion's Components"
msgstr "Subversion的组件"

#: build/en/book.xml:10337(para)
#, fuzzy
msgid "In mid-2004, a second type of repository storage system—one which doesn't use a database at all—came into being. An FSFS repository stores the changes associated with a revision in a single file, and so all of a repository's revisions can be found in a single subdirectory full of numbered files. Transactions are created in separate subdirectories as individual files. When complete, the transaction file is renamed and moved into the revisions directory, thus guaranteeing that commits are atomic. And because a revision file is permanent and unchanging, the repository also can be backed up while <quote>hot</quote>, just like a BDB-backed repository."
msgstr "在2004年中期，另一种版本库存储系统慢慢形成了：一种不需要数据库的存储系统。FSFS版本库在单一文件中存储修订版本树，所以版本库中所有的修订版本都在一个子文件夹中有限的几个文件里。事务在单独的子目录中被创建，创建完成后，一个单独的事务文件被创建并移动到修订版本目录，这保证提交是原子性的。因为一个修订版本文件是持久不可改变的，版本库也可以做到热备份，就象Berkeley DB版本库一样。"

#: build/en/book.xml:1035(para)
msgid "Subversion, once installed, has a number of different pieces. The following is a quick overview of what you get. Don't be alarmed if the brief descriptions leave you scratching your head—there are <emphasis>plenty</emphasis> more pages in this book devoted to alleviating that confusion."
msgstr "安装好的Subversion有几个几个部分组成，本节将简单的介绍一下这些组件。下文的描述或许过于简略，不易理解，不过不用担心，本书后面章节中会用<emphasis>更多的</emphasis>内容来详细阐述这些组件。"

#: build/en/book.xml:10351(para)
#, fuzzy
msgid "The FSFS revision files describe a revision's directory structure, file contents, and deltas against files in other revision trees. Unlike a Berkeley DB database, this storage format is portable across different operating systems and isn't sensitive to CPU architecture. Because there's no journaling or shared-memory files being used, the repository can be safely accessed over a network filesystem and examined in a read-only environment. The lack of database overhead also means that the overall repository size is a bit smaller."
msgstr "修订版本文件格式代表了一个修订版本的目录结构，文件内容，和其它修订版本树中相关信息。不像Berkeley DB数据库，这种存储格式可跨平台并且与CPU架构无关。因为没有日志或用到共享内存的文件，数据库能被网络文件系统安全的访问和在只读环境下检查。缺少数据库花消同时也意味着版本库的总体体积可以稍小一点。"

#: build/en/book.xml:10362(para)
#, fuzzy
msgid "FSFS has different performance characteristics too. When committing a directory with a huge number of files, FSFS is able to more quickly append directory entries. On the other hand, FSFS writes the latest version of a file as a delta against an earlier version, which means that checking out the latest tree is a bit slower than fetching the fulltexts stored in a Berkeley DB HEAD revision. FSFS also has a longer delay when finalizing a commit, which could in extreme cases cause clients to time out while waiting for a response."
msgstr "FSFS也有一种不同的性能特性。当提交大量文件时，FSFS使用O(N)算法来追加条目，而Berkeley DB则用(N^2)算法来重写整个目录。另一方面，FSFS通过写入与上一个版本比较的变化来记录新版本，这也意味着获取最新修订版本时会比Berkeley DB慢一点，提交时FSFS也会有一个更长的延迟，在某些极端情况下会导致客护端在等待回应时超时。"

#: build/en/book.xml:10373(para)
#, fuzzy
msgid "The most important distinction, however, is FSFS's inability to be <quote>wedged</quote> when something goes wrong. If a process using a Berkeley DB database runs into a permissions problem or suddenly crashes, the database can be left in an unusable state until an administrator recovers it. If the same scenarios happen to a process using an FSFS repository, the repository isn't affected at all. At worst, some transaction data is left behind."
msgstr "最重要的区别是当出现错误时FSFS不会楔住的能力。如果使用Berkeley DB的进程发生许可错误或突然崩溃，数据库会一直无法使用，直到管理员恢复。假如在应用FSFS版本库时发生同样的情况，版本库不会受到任何干扰，最坏情况下也就是会留下一些事务数据。"

#: build/en/book.xml:10382(para)
msgid "The only real argument against FSFS is its relative immaturity compared to Berkeley DB. Unlike Berkeley DB, which has years of history, its own dedicated development team and, now, Oracle's mighty name attached to it, <placeholder-1/> FSFS is a much newer bit of engineering. Prior to Subversion 1.4, it was still shaking out some pretty serious data integrity bugs which, while only triggered in very rare cases, nonetheless did occur. That said, FSFS has quickly become the back-end of choice for some of the largest public and private Subversion repositories, and promises a lower barrier to entry for Subversion across the board."
msgstr ""

#: build/en/book.xml:10387(para)
msgid "Oracle bought Sleepycat and its flagship software, Berkeley DB, on Valentine's Day in 2006."
msgstr ""

#: build/en/book.xml:10407(title)
#, fuzzy
msgid "Creating and Configuring Your Repository"
msgstr "创建一个新的Subversion版本库。"

#: build/en/book.xml:10409(para)
msgid "In <xref linkend=\"svn.reposadmin.planning\"/>, we looked at some of the important decisions that should be made before creating and configuring your Subversion repository. Now, we finally get to get our hands dirty! In this section, we'll see how to actually create a Subversion repository and configure it to perform custom actions when special repository events occur."
msgstr ""

#: build/en/book.xml:10419(title)
msgid "Creating the Repository"
msgstr "创建版本库"

#: build/en/book.xml:10421(para)
#, fuzzy
msgid "Subversion repository creation is an incredibly simple task. The <command moreinfo=\"none\">svnadmin</command> utility that comes with Subversion provides a subcommand (<literal moreinfo=\"none\">create</literal>) for doing just that."
msgstr "创建一个 Subversion 版本库出乎寻常的简单。 Subversion 提供的<command moreinfo=\"none\">svnadmin</command> 工具，有一个执行这个功能的子命令。要建立一个新的版本库，只需要运行："

#: build/en/book.xml:10426(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create /path/to/repos\n"
msgstr ""
"\n"
"$ svnadmin create /path/to/repos\n"

#: build/en/book.xml:1043(term) build/en/book.xml:18147(primary)
#: build/en/book.xml:18253(primary) build/en/book.xml:18323(primary)
#: build/en/book.xml:18408(primary) build/en/book.xml:18545(primary)
#: build/en/book.xml:18623(primary) build/en/book.xml:18761(primary)
#: build/en/book.xml:18936(primary) build/en/book.xml:19049(primary)
#: build/en/book.xml:19301(primary) build/en/book.xml:19415(primary)
#: build/en/book.xml:19467(primary) build/en/book.xml:19569(primary)
#: build/en/book.xml:19730(primary) build/en/book.xml:19842(primary)
#: build/en/book.xml:19942(primary) build/en/book.xml:20186(primary)
#: build/en/book.xml:20307(primary) build/en/book.xml:20393(primary)
#: build/en/book.xml:20507(primary) build/en/book.xml:20585(primary)
#: build/en/book.xml:20661(primary) build/en/book.xml:20743(primary)
#: build/en/book.xml:20830(primary) build/en/book.xml:20965(primary)
#: build/en/book.xml:21054(primary) build/en/book.xml:21158(primary)
#: build/en/book.xml:21563(primary) build/en/book.xml:21723(primary)
#: build/en/book.xml:21816(primary)
msgid "svn"
msgstr "svn"

#: build/en/book.xml:10430(para)
msgid "This creates a new repository in the directory <filename moreinfo=\"none\">/path/to/repos</filename>, and with the default filesystem data store. Prior to Subversion 1.2, the default was to use Berkeley DB; the default is now FSFS. You can explicitly choose the filesystem type using the <option>--fs-type</option> argument, which accepts as a parameter either <literal moreinfo=\"none\">fsfs</literal> or <literal moreinfo=\"none\">bdb</literal>."
msgstr ""

#: build/en/book.xml:10439(screen)
#, no-wrap
msgid ""
"\n"
"$ # Create an FSFS-backed repository\n"
"$ svnadmin create --fs-type fsfs /path/to/repos\n"
"$\n"
msgstr ""
"\n"
"$ # Create an FSFS-backed repository\n"
"$ svnadmin create --fs-type fsfs /path/to/repos\n"
"$\n"

#: build/en/book.xml:10445(screen)
#, no-wrap
msgid ""
"\n"
"# Create a Berkeley-DB-backed repository\n"
"$ svnadmin create --fs-type bdb /path/to/repos\n"
"$\n"
msgstr ""
"\n"
"# Create a Berkeley-DB-backed repository\n"
"$ svnadmin create --fs-type bdb /path/to/repos\n"
"$\n"

#: build/en/book.xml:1045(para)
msgid "The command-line client program."
msgstr "命令行客户端程序。"

#: build/en/book.xml:10451(para)
#, fuzzy
msgid "After running this simple command, you have a Subversion repository."
msgstr "目前Subversion有已实现了九种钩子："

#: build/en/book.xml:10455(para)
#, fuzzy
msgid "The path argument to <command moreinfo=\"none\">svnadmin</command> is just a regular filesystem path and not a URL like the <command moreinfo=\"none\">svn</command> client program uses when referring to repositories. Both <command moreinfo=\"none\">svnadmin</command> and <command moreinfo=\"none\">svnlook</command> are considered server-side utilities—they are used on the machine where the repository resides to examine or modify aspects of the repository, and are in fact unable to perform tasks across a network. A common mistake made by Subversion newcomers is trying to pass URLs (even <quote>local</quote><literal moreinfo=\"none\">file://</literal> ones) to these two programs."
msgstr "你可能已经注意到了，<command moreinfo=\"none\">svnadmin</command>命令的路径参数只是一个普通的文件系统路径，而不是一个<command moreinfo=\"none\">svn</command>客户端程序访问版本库时使用的URL。<command moreinfo=\"none\">svnadmin</command>和<command moreinfo=\"none\">svnlook</command>都被认为是服务器端工具—它们在版本库所在的机器上使用，用来检查或修改版本库，不能通过网络来执行任务。一个Subversion的新手通常会犯的错误，就是试图将URL（甚至<quote>本地</quote><literal moreinfo=\"none\">file:</literal>路径）传给这两个程序。"

#: build/en/book.xml:10468(para)
#, fuzzy
msgid "Present in the <filename moreinfo=\"none\">db/</filename> subdirectory of your repository is the implementation of the versioned filesystem. Your new repository's versioned filesystem begins life at revision 0, which is defined to consist of nothing but the top-level root (<filename moreinfo=\"none\">/</filename>) directory. Initially, revision 0 also has a single revision property, <literal moreinfo=\"none\">svn:date</literal>, set to the time at which the repository was created."
msgstr "这个命令在目录<filename moreinfo=\"none\">/path/to/repos</filename>创建了一个新的版本库。这个新的版本库会以修订版本版本0开始其生命周期，里面除了最上层的根目录(<filename moreinfo=\"none\">/</filename>)，什么都没有。刚开始，修订版本0有一个修订版本属性<literal moreinfo=\"none\">svn:date</literal>，设置为版本库创建的时间。"

#: build/en/book.xml:10477(para)
msgid "Now that you have a repository, it's time to customize it."
msgstr ""

#: build/en/book.xml:10481(para)
#, fuzzy
msgid "While some parts of a Subversion repository—such as the configuration files and hook scripts—are meant to be examined and modified manually, you shouldn't (and shouldn't need to) tamper with the other parts of the repository <quote>by hand</quote>. The <command moreinfo=\"none\">svnadmin</command> tool should be sufficient for any changes necessary to your repository, or you can look to third-party tools (such as Berkeley DB's tool suite) for tweaking relevant subsections of the repository. Do <emphasis>not</emphasis> attempt manual manipulation of your version control history by poking and prodding around in your repository's data store files!"
msgstr "一般来说，你不需要手动干预版本库。<command moreinfo=\"none\">svnadmin</command>工具应该足以用来处理对版本库的任何修改，或者你也可以使用第三方工具（比如Berkeley DB的工具包）来调整部分版本库。不过还是会有些例外情况，我们会在这里提到。"

#: build/en/book.xml:10499(title)
msgid "Implementing Repository Hooks"
msgstr "实现版本库钩子"

#: build/en/book.xml:1050(term) build/en/book.xml:24024(command)
#: build/en/book.xml:24029(primary) build/en/book.xml:24033(refname)
msgid "svnversion"
msgstr "svnversion"

#: build/en/book.xml:10501(para)
msgid "A <firstterm>hook</firstterm> is a program triggered by some repository event, such as the creation of a new revision or the modification of an unversioned property. Some hooks (the so-called <quote>pre hooks</quote>) run in advance of a repository operation and provide a means by which to both report what is about to happen and to prevent it from happening at all. Other hooks (the <quote>post hooks</quote>) run after the completion of a repository event, and are useful for reporting purposes only. Each hook is handed enough information to tell what that event is (or was), the specific repository changes proposed (or completed), and the username of the person who triggered the event."
msgstr ""

#: build/en/book.xml:10514(para)
msgid "The <filename moreinfo=\"none\">hooks</filename> subdirectory is, by default, filled with templates for various repository hooks."
msgstr "默认情况下，钩子的子目录中包含各种版本库钩子模板。"

#: build/en/book.xml:10518(screen)
#, no-wrap
msgid ""
"\n"
"$ ls repos/hooks/\n"
"post-commit.tmpl\t  post-unlock.tmpl  pre-revprop-change.tmpl\n"
"post-lock.tmpl\t\t  pre-commit.tmpl   pre-unlock.tmpl\n"
"post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl\n"
msgstr ""
"\n"
"$ ls repos/hooks/\n"
"post-commit.tmpl\t  post-unlock.tmpl  pre-revprop-change.tmpl\n"
"post-lock.tmpl\t\t  pre-commit.tmpl   pre-unlock.tmpl\n"
"post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl\n"

#: build/en/book.xml:1052(para)
msgid "A program for reporting the state (in terms of revisions of the items present) of a working copy."
msgstr "此工具用来显示工作副本的状态（用术语来说，就是当前项目的修订版本）。"

#: build/en/book.xml:10525(para)
#, fuzzy
msgid "There is one template for each hook that the Subversion repository supports, and by examining the contents of those template scripts, you can see what triggers each script to run and what data is passed to that script. Also present in many of these templates are examples of how one might use that script, in conjunction with other Subversion-supplied programs, to perform common useful tasks. To actually install a working hook, you need only place some executable program or script into the <filename moreinfo=\"none\">repos/hooks</filename> directory which can be executed as the name (like <command moreinfo=\"none\">start-commit</command> or <command moreinfo=\"none\">post-commit</command>) of the hook."
msgstr "对每种Subversion版本库支持的钩子的都有一个模板，通过查看这些脚本的内容，你能看到是什么事件触发了脚本及如何给传脚本传递数据。同时，这些模版也是如何使用这些脚本，结合Subversion支持的工具来完成有用任务的例子。要实际安装一个可用的钩子，你需要在<filename moreinfo=\"none\">repos/hooks</filename>目录下安装一些与钩子同名（如 <command moreinfo=\"none\">start-commit</command>或者<command moreinfo=\"none\">post-commit</command>）的可执行程序或脚本。"

#: build/en/book.xml:10538(para)
msgid "On Unix platforms, this means supplying a script or program (which could be a shell script, a Python program, a compiled C binary, or any number of other things) named exactly like the name of the hook. Of course, the template files are present for more than just informational purposes—the easiest way to install a hook on Unix platforms is to simply copy the appropriate template file to a new file that lacks the <literal moreinfo=\"none\">.tmpl</literal> extension, customize the hook's contents, and ensure that the script is executable. Windows, however, uses file extensions to determine whether or not a program is executable, so you would need to supply a program whose basename is the name of the hook, and whose extension is one of the special extensions recognized by Windows for executable programs, such as <filename moreinfo=\"none\">.exe</filename> or <filename moreinfo=\"none\">.com</filename> for programs, and <filename moreinfo=\"none\">.bat</filename> for batch files."
msgstr "在Unix平台上，这意味着要提供一个与钩子同名的脚本或程序（可能是shell 脚本，Python 程序，编译过的c语言二进制文件或其他东西）。当然，脚本模板文件不仅仅是展示了一些信息—在Unix下安装钩子最简单的办法就是拷贝这些模板，并且去掉.tmpl扩展名，然后自定义钩子的内容，确定脚本是可运行的。Windows用文件的扩展名来决定一个程序是否可运行，所以你要使程序的基本名与钩子同名，同时，它的扩展名是Windows系统所能辨认的，例如<filename moreinfo=\"none\">exe</filename>、<filename moreinfo=\"none\">com</filename>和批处理的<filename moreinfo=\"none\">bat</filename>。"

#: build/en/book.xml:10557(para)
#, fuzzy
msgid "For security reasons, the Subversion repository executes hook programs with an empty environment—that is, no environment variables are set at all, not even <literal moreinfo=\"none\">$PATH</literal> (or <literal moreinfo=\"none\">%PATH%</literal>, under Windows). Because of this, many administrators are baffled when their hook program runs fine by hand, but doesn't work when run by Subversion. Be sure to explicitly set any necessary environment variables in your hook program and/or use absolute paths to programs."
msgstr "由于安全原因，Subversion版本库在一个空环境中执行钩子脚本—就是没有任何环境变量，甚至没有<literal moreinfo=\"none\">$PATH</literal>或<literal moreinfo=\"none\">%PATH%</literal>。由于这个原因，许多管理员会感到很困惑，它们的钩子脚本手工运行时正常，可在Subversion中却不能运行。要注意，必须在你的钩子中设置好环境变量或为你的程序指定好绝对路径。"

#: build/en/book.xml:10568(para)
#, fuzzy
msgid "Subversion will attempt to execute hooks as the same user who owns the process which is accessing the Subversion repository. In most cases, the repository is being accessed via a Subversion server, so this user is the same user as which that server runs on the system. The hooks themselves will need to be configured with OS-level permissions that allow that user to execute them. Also, this means that any file or programs (including the Subversion repository itself) accessed directly or indirectly by the hook will be accessed as the same user. In other words, be alert to potential permission-related problems that could prevent the hook from performing the tasks it is designed to perform."
msgstr "Subversion会试图以当前访问版本库的用户身份执行钩子。通常，对版本库的访问总是通过Apache HTTP服务器和mod_dav_svn进行，因此，执行钩子的用户就是运行Apache的用户。钩子本身需要具有操作系统级的访问许可，用户可以运行它。另外，其它被钩子直接或间接使用的文件或程序（包括Subversion版本库本身）也要被同一个用户访问。换句话说，要注意潜在的访问控制问题，它可能会让你的钩子无法按照你的目的顺利执行。"

#: build/en/book.xml:1058(term) build/en/book.xml:10734(title)
#: build/en/book.xml:22908(command) build/en/book.xml:22998(primary)
#: build/en/book.xml:23044(primary) build/en/book.xml:23102(primary)
#: build/en/book.xml:23201(primary) build/en/book.xml:23247(primary)
#: build/en/book.xml:23318(primary) build/en/book.xml:23365(primary)
#: build/en/book.xml:23396(primary) build/en/book.xml:23461(primary)
#: build/en/book.xml:23512(primary) build/en/book.xml:23564(primary)
#: build/en/book.xml:23609(primary) build/en/book.xml:23664(primary)
#: build/en/book.xml:23730(primary) build/en/book.xml:23784(primary)
#: build/en/book.xml:23823(primary)
msgid "svnlook"
msgstr "svnlook"

#: build/en/book.xml:10581(para)
msgid "There are nine hooks implemented by the Subversion repository, and you can get details about each of them in <xref linkend=\"svn.ref.reposhooks\"/>. As a repository administrator, you'll need to decide which of hooks you wish to implement (by way of providing an appropriately named and permissioned hook program), and how. This decision needs to be made with the bigger picture of how repository is deployed in mind. For example, if you are using server configuration stuffs to determine which usernames are permitted to commit changes to your repository, then you don't need to do this sort of access control via the hook system."
msgstr ""

#: build/en/book.xml:10593(para)
msgid "There is no shortage of Subversion hook programs and scripts freely available either from the Subversion community itself or elsewhere. These scripts cover a wide range of utility—basic access control, policy adherence checking, issue tracker integration, email- or syndication-based commit notification, and beyond. See <xref linkend=\"svn.3rdparty\"/> for discussion of some of the most commonly used hook programs. Or, if you wish to write your own, see <xref linkend=\"svn.developer\"/>."
msgstr ""

#: build/en/book.xml:1060(para)
#, fuzzy
msgid "A tool for directly inspecting a Subversion repository."
msgstr "查看Subversion版本库的工具。"

#: build/en/book.xml:10603(para)
msgid "While hook scripts can be leveraged to do almost anything, there is one dimension in which hook script authors should show restraint: do <emphasis>not</emphasis> modify a commit transaction using hook scripts. While it might be tempting to use hook scripts to automatically correct errors or shortcomings or policy violations present in the files being committed, doing so can cause problems. Subversion keeps client-side caches of certain bits of repository data, and if you change a commit transaction in this way, those caches become indetectably stale. This inconsistency can lead to surprising and unexpected behavior. Instead of modifying the transaction, you should simply <emphasis>validate</emphasis> the transaction in the <filename moreinfo=\"none\">pre-commit</filename> hook and reject the commit if it does not meet the desired requirements. As an added bonus, your users will learn the value of careful, compliance-minded work habits."
msgstr ""

#: build/en/book.xml:10626(title)
msgid "Berkeley DB Configuration"
msgstr "Berkeley DB配置"

#: build/en/book.xml:10628(para)
#, fuzzy
msgid "A Berkeley DB environment is an encapsulation of one or more databases, log files, region files and configuration files. The Berkeley DB environment has its own set of default configuration values for things like the number of database locks allowed to be taken out at any given time, or the maximum size of the journaling log files, etc. Subversion's filesystem logic additionally chooses default values for some of the Berkeley DB configuration options. However, sometimes your particular repository, with its unique collection of data and access patterns, might require a different set of configuration option values."
msgstr "Berkeley DB环境是对一个或多个数据库、日志文件、区域文件和配置文件的封装。Berkeley DB环境对许多参数有自己的缺省值，例如任何时间里可用的数据库锁定数目、日志文件的最大值等。Subversion文件系统会使用Berkeley DB的默认值。 不过，有时候你的特定版本库与它独特的数据集合和访问类型，可能需要不同的配置选项。"

#: build/en/book.xml:10640(para)
#, fuzzy
msgid "The producers of Berkeley DB understand that different applications and database environments have different requirements, and so they have provided a mechanism for overriding at runtime many of the configuration values for the Berkeley DB environment. Berkeley checks for the presence of a file named <filename moreinfo=\"none\">DB_CONFIG</filename> in the environment directory, and parses the options found in that file for use with that particular Berkeley DB environment."
msgstr "Sleepycat（Berkeley DB的制造厂商）的人们清楚不同的数据库有不同的需求，所以他们提供了在运行中覆盖Berkeley DB环境配置参数的机制。Berkeley在每一个环境目录中检查是否存在一个名叫<filename moreinfo=\"none\">DB_CONFIG</filename>的文件，然后解析其中的参数成为Berkeley环境所用的选项。"

#: build/en/book.xml:10649(para)
#, fuzzy
msgid "The Berkeley DB configuration file for a BDB-backed repository is located in the repository's <filename moreinfo=\"none\">db</filename> subdirectory, at <filename moreinfo=\"none\">db/DB_CONFIG</filename>. Subversion itself creates this file when it creates the rest of the repository. The file initially contains some default options, as well as pointers to the Berkeley DB online documentation so you can read about what those options do. Of course, you are free to add any of the supported Berkeley DB options to your <filename moreinfo=\"none\">DB_CONFIG</filename> file. Just be aware that while Subversion never attempts to read or interpret the contents of the file, and makes no direct use of the option settings in it, you'll want to avoid any configuration changes that may cause Berkeley DB to behave in a fashion that is at odds with what Subversion might expect. Also, changes made to <filename moreinfo=\"none\">DB_CONFIG</filename> won't take effect until you recover the database environment (using <command moreinfo=\"none\">svnadmin recover</command>)."
msgstr "你的版本库的Berkeley配置文件位于<filename moreinfo=\"none\">db</filename>目录的<filename moreinfo=\"none\">repos/db/DB_CONFIG</filename>， Subversion在创建版本库时自己创建了这个文件。这个文件初始时包含了一些默认选项，也包含了Berkeley DB在线文档，使你能够了解这些选项是做什么的。当然，你也可以为你的<filename moreinfo=\"none\">DB_CONFIG</filename> 文件添加任何Berkeley DB支持的选项。需要注意到，虽然Subversion不会尝试读取并解析这个文件，或使用其中的设置，你一定要避免会导致Berkeley DB按照Subversion代码不习惯的方式工作的修改。另外，<filename moreinfo=\"none\">DB_CONFIG</filename>的修改在复原数据库环境（用<command moreinfo=\"none\">svnadmin recover</command>）之前不会产生任何效果。"

#: build/en/book.xml:1065(term) build/en/book.xml:10701(title)
#: build/en/book.xml:21967(command) build/en/book.xml:22102(primary)
#: build/en/book.xml:22165(primary) build/en/book.xml:22205(primary)
#: build/en/book.xml:22315(primary) build/en/book.xml:22347(primary)
#: build/en/book.xml:22389(primary) build/en/book.xml:22421(primary)
#: build/en/book.xml:22469(primary) build/en/book.xml:22535(primary)
#: build/en/book.xml:22583(primary) build/en/book.xml:22623(primary)
#: build/en/book.xml:22705(primary) build/en/book.xml:22751(primary)
#: build/en/book.xml:22805(primary) build/en/book.xml:22865(primary)
msgid "svnadmin"
msgstr "svnadmin"

#: build/en/book.xml:1067(para)
msgid "A tool for creating, tweaking or repairing a Subversion repository."
msgstr "建立、调整和修复Subversion版本库的工具。"

#: build/en/book.xml:10676(title)
msgid "Repository Maintenance"
msgstr "版本库维护"

#: build/en/book.xml:10678(para)
#, fuzzy
msgid "Maintaining a Subversion repository can be a daunting task, mostly due to the complexities inherent in systems which have a database backend. Doing the task well is all about knowing the tools—what they are, when to use them, and how to use them. This section will introduce you to the repository administration tools provided by Subversion, and how to wield them to accomplish tasks such as repository data migration, upgrades, backups and cleanups."
msgstr "维护一个Subversion版本库是一项令人沮丧的工作，主要因为有数据库后端与生俱来的复杂性。做好这项工作需要知道一些工具——它们是什么，什么时候用以及如何使用。这一节将会向你介绍Subversion自带的版本库管理工具，以及如何使用它们来完成诸如版本库移植、升级、备份和整理之类的任务。"

#: build/en/book.xml:10689(title)
msgid "An Administrator's Toolkit"
msgstr "管理员的工具箱"

#: build/en/book.xml:10691(para)
msgid "Subversion provides a handful of utilities useful for creating, inspecting, modifying and repairing your repository. Let's look more closely at each of those tools. Afterward, we'll briefly examine some of the utilities included in the Berkeley DB distribution that provide functionality specific to your repository's database backend not otherwise provided by Subversion's own tools."
msgstr "Subversion提供了一些用来创建、查看、修改和修复版本库的工具。让我们首先详细了解一下每个工具，然后，我们再看一下仅在Berkeley DB后端分发版本中提供的版本数据库工具。"

#: build/en/book.xml:10703(para)
#, fuzzy
msgid "The <command moreinfo=\"none\">svnadmin</command> program is the repository administrator's best friend. Besides providing the ability to create Subversion repositories, this program allows you to perform several maintenance operations on those repositories. The syntax of <command moreinfo=\"none\">svnadmin</command> is similar to that of other Subversion command-line programs:"
msgstr "<command moreinfo=\"none\">svnadmin</command>程序是版本库管理员最好的朋友。除了提供创建Subversion版本库的功能，这个程序使你可以维护这些版本库。<command moreinfo=\"none\">svnadmin</command>的语法跟<command moreinfo=\"none\">svnlook</command>类似："

#: build/en/book.xml:10711(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin help\n"
"general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnadmin --version' to see the program version and FS modules.\n"
"\n"
"Available subcommands:\n"
"   crashtest\n"
"   create\n"
"   deltify\n"
"…\n"
msgstr ""
"\n"
"$ svnadmin help\n"
"general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnadmin --version' to see the program version and FS modules.\n"
"\n"
"Available subcommands:\n"
"   crashtest\n"
"   create\n"
"   deltify\n"
"…\n"

#: build/en/book.xml:10724(para)
#, fuzzy
msgid "We've already mentioned <command moreinfo=\"none\">svnadmin</command>'s <literal moreinfo=\"none\">create</literal> subcommand (see <xref linkend=\"svn.reposadmin.basics.creating\"/>). Most of the others we will cover as they become topically relevant later in this chapter. And you can consult <xref linkend=\"svn.ref.svnadmin\"/> for a full rundown of subcommands and what each of them offers."
msgstr "我们已经提过<command moreinfo=\"none\">svnadmin</command>的<literal moreinfo=\"none\">create</literal>子命令（参照<xref linkend=\"svn.reposadmin.create\"/>）。本章中我们会详细讲解大多数其他的命令。现在，我们来简单的看一下每个可用的子命令提供了什么功能。"

#: build/en/book.xml:1073(term) build/en/book.xml:10859(title)
msgid "svndumpfilter"
msgstr "svndumpfilter"

#: build/en/book.xml:10736(para)
#, fuzzy
msgid "<command moreinfo=\"none\">svnlook</command> is a tool provided by Subversion for examining the various revisions and transactions in a repository. No part of this program attempts to change the repository. <command moreinfo=\"none\">svnlook</command> is typically used by the repository hooks for reporting the changes that are about to be committed (in the case of the <command moreinfo=\"none\">pre-commit</command> hook) or that were just committed (in the case of the <command moreinfo=\"none\">post-commit</command> hook) to the repository. A repository administrator may use this tool for diagnostic purposes."
msgstr "<command moreinfo=\"none\">svnlook</command>是Subversion提供的用来查看版本库中不同的修订版本和事务。这个程序不会修改版本库内容－这是个<quote>只读</quote>的工具。<command moreinfo=\"none\">svnlook</command>通常用在版本库钩子程序中，用来记录版本库即将提交（<command moreinfo=\"none\">用在pre-commit钩子时）</command>或者已经提交的（用在<command moreinfo=\"none\">post-commit</command>钩子时）修改。版本库管理员可以将这个工具用于诊断。"

#: build/en/book.xml:10747(para)
msgid "<command moreinfo=\"none\">svnlook</command> has a straightforward syntax:"
msgstr "<command moreinfo=\"none\">svnlook</command> 的语法很直接："

#: build/en/book.xml:1075(para)
msgid "A program for filtering Subversion repository dump streams."
msgstr "过滤Subversion版本库转储数据流的工具。"

#: build/en/book.xml:10750(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook help\n"
"general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]\n"
"Note: any subcommand which takes the '--revision' and '--transaction'\n"
"      options will, if invoked without one of those options, act on\n"
"      the repository's youngest revision.\n"
"Type 'svnlook help &lt;subcommand$gt;' for help on a specific subcommand.\n"
"Type 'svnlook --version' to see the program version and FS modules.\n"
"…\n"
msgstr ""
"\n"
"$ svnlook help\n"
"general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]\n"
"Note: any subcommand which takes the '--revision' and '--transaction'\n"
"      options will, if invoked without one of those options, act on\n"
"      the repository's youngest revision.\n"
"Type 'svnlook help &lt;subcommand$gt;' for help on a specific subcommand.\n"
"Type 'svnlook --version' to see the program version and FS modules.\n"
"…\n"

#: build/en/book.xml:10761(para)
#, fuzzy
msgid "Nearly every one of <command moreinfo=\"none\">svnlook</command>'s subcommands can operate on either a revision or a transaction tree, printing information about the tree itself, or how it differs from the previous revision of the repository. You use the <option>--revision (-r)</option> and <option>--transaction (-t)</option> options to specify which revision or transaction, respectively, to examine. In the absence of both the <option>--revision (-r)</option> and <option>--transaction (-t)</option> options, <command moreinfo=\"none\">svnlook</command> will examine the youngest (or <quote>HEAD</quote>) revision in the repository. So the following two commands do exactly the same thing when 19 is the youngest revision in the repository located at <filename moreinfo=\"none\">/path/to/repos</filename>:"
msgstr "几乎<command moreinfo=\"none\">svnlook</command>的每一个子命令都能操作修订版本或事务树，显示树本身的信息，或是它与版本库中上一个修订版本的不同。你可以用<option>--revision</option> 和 <option>--transaction</option>选项指定要查看的修订版本或事务。注意，虽然修订版本号看起来像自然数，但是事务名称是包含英文字母与数字的字符串。请记住文件系统只允许浏览未提交的事务（还没有形成一个新的修订版本的事务）。多数版本库没有这种事务，因为事务通常或者被提交了（这样便不能被查看），或者被中止并删除了。"

#: build/en/book.xml:10776(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook info /path/to/repos\n"
"$ svnlook info /path/to/repos -r 19\n"
msgstr ""
"\n"
"$ svnlook info /path/to/repos\n"
"$ svnlook info /path/to/repos -r 19\n"

#: build/en/book.xml:10781(para)
#, fuzzy
msgid "The only exception to these rules about subcommands is the <command moreinfo=\"none\">svnlook youngest</command> subcommand, which takes no options, and simply prints out the repository's youngest revision number."
msgstr "这些子命令的唯一例外，是<command moreinfo=\"none\">svnlook youngest</command>命令，它不需要选项，只会显示出<literal moreinfo=\"none\">HEAD</literal>的修订版本号。"

#: build/en/book.xml:10786(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook youngest /path/to/repos\n"
"19\n"
msgstr ""
"\n"
"$ svnlook youngest /path/to/repos\n"
"19\n"

#: build/en/book.xml:10792(para)
msgid "Keep in mind that the only transactions you can browse are uncommitted ones. Most repositories will have no such transactions, because transactions are usually either committed (in which case, you should access them as revision with the <option>--revision (-r)</option> option) or aborted and removed."
msgstr ""

#: build/en/book.xml:10800(para)
msgid "Output from <command moreinfo=\"none\">svnlook</command> is designed to be both human- and machine-parsable. Take as an example the output of the <literal moreinfo=\"none\">info</literal> subcommand:"
msgstr "<command moreinfo=\"none\">svnlook</command>的输出被设计为人和机器都易理解，拿<literal moreinfo=\"none\">info</literal>子命令举例来说："

#: build/en/book.xml:10804(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook info /path/to/repos\n"
"sally\n"
"2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)\n"
"27\n"
"Added the usual\n"
"Greek tree.\n"
msgstr ""
"\n"
"$ svnlook info /path/to/repos\n"
"sally\n"
"2002-11-04 09:29:13 -0600 (Mon， 04 Nov 2002)\n"
"27\n"
"Added the usual\n"
"Greek tree.\n"

#: build/en/book.xml:1081(term) build/en/book.xml:16483(term)
#: build/en/book.xml:24178(command) build/en/book.xml:24183(literal)
msgid "mod_dav_svn"
msgstr "mod_dav_svn"

#: build/en/book.xml:10813(para)
msgid "The output of the <literal moreinfo=\"none\">info</literal> subcommand is defined as:"
msgstr "<literal moreinfo=\"none\">info</literal>子命令的输出定义如下："

#: build/en/book.xml:10818(para)
msgid "The author, followed by a newline."
msgstr "作者，后接换行。"

#: build/en/book.xml:10821(para)
msgid "The date, followed by a newline."
msgstr "日期，后接换行。"

#: build/en/book.xml:10824(para)
msgid "The number of characters in the log message, followed by a newline."
msgstr "日志消息的字数，后接换行。"

#: build/en/book.xml:10828(para)
msgid "The log message itself, followed by a newline."
msgstr "日志信息本身， 后接换行。"

#: build/en/book.xml:1083(para)
msgid "A plug-in module for the Apache HTTP Server, used to make your repository available to others over a network."
msgstr "Apache HTTP服务器的一个插件，使版本库可以通过网络访问。"

#: build/en/book.xml:10832(para)
#, fuzzy
msgid "This output is human-readable, meaning items like the datestamp are displayed using a textual representation instead of something more obscure (such as the number of nanoseconds since the Tasty Freeze guy drove by). But the output is also machine-parsable—because the log message can contain multiple lines and be unbounded in length, <command moreinfo=\"none\">svnlook</command> provides the length of that message before the message itself. This allows scripts and other wrappers around this command to make intelligent decisions about the log message, such as how much memory to allocate for the message, or at least how many bytes to skip in the event that this output is not the last bit of data in the stream."
msgstr "这种输出是人可阅读的，像是时间戳这种有意义的条目，使用文本表示，而不是其他比较晦涩的方式（例如许多无聊的人推荐的十亿分之一秒的数量）。这种输出也是机器可读的—因为日志信息可以有多行，没有长度的限制，<command moreinfo=\"none\">svnlook</command>在日志消息之前提供了消息的长度，这使得脚本或者其他对这个命令进行的封装提供了更强的功能，比如日志消息使用了多少内存，或在这个输出成为最后一个字节之前应该略过多少字节。"

#: build/en/book.xml:10846(para)
#, fuzzy
msgid "<command moreinfo=\"none\">svnlook</command> can perform a variety of other queries: displaying subsets of bits of information we've mentioned previously, recursively listing versioned directory trees, reporting which paths were modified in a given revision or transaction, showing textual and property differences made to files and directories, and so on. See <xref linkend=\"svn.ref.svnlook\"/> for a full reference of <command moreinfo=\"none\">svnlook</command>'s features."
msgstr "<command moreinfo=\"none\">svnlook</command>还可以做很多别的查询，显示我们先前提到的信息的一些子集，报告指定的修订版本或事务中哪些路径曾经被修改过，显示对文件和目录做过的文本和属性的修改，等等。下面是<command moreinfo=\"none\">svnlook</command>命令能接受的子命令的介绍，以及这些子命令的输出："

#: build/en/book.xml:10861(para)
#, fuzzy
msgid "While it won't be the most commonly used tool at the administrator's disposal, <command moreinfo=\"none\">svndumpfilter</command> provides a very particular brand of useful functionality—the ability to quickly and easily modify streams of Subversion repository history data by acting as a path-based filter."
msgstr "虽然在管理员的日常工作中并不会经常使用，不过<command moreinfo=\"none\">svndumpfilter</command>可以对特定的路径进行过滤。这是一个独特而很有意义的用法，可以帮助你快速方便的修改转储的数据。使用时，只需提供一个你想要保留的（或者不想保留的）路径列表，然后把你的版本库转储文件送进这个过滤器。最后你就可以得到一个仅包含你想保留的路径的转储数据流。"

#: build/en/book.xml:10868(para)
msgid "The syntax of <command moreinfo=\"none\">svndumpfilter</command> is as follows:"
msgstr "<command moreinfo=\"none\">svndumpfilter</command>的语法如下："

#: build/en/book.xml:10871(screen)
#, no-wrap
msgid ""
"\n"
"$ svndumpfilter help\n"
"general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]\n"
"Type \"svndumpfilter help &lt;subcommand&gt;\" for help on a specific subcommand.\n"
"Type 'svndumpfilter --version' to see the program version.\n"
"  \n"
"Available subcommands:\n"
"   exclude\n"
"   include\n"
"   help (?, h)\n"
msgstr ""
"\n"
"$ svndumpfilter help\n"
"general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]\n"
"Type \"svndumpfilter help &lt;subcommand&gt;\" for help on a specific subcommand.\n"
"Type 'svndumpfilter --version' to see the program version.\n"
"  \n"
"Available subcommands:\n"
"   exclude\n"
"   include\n"
"   help (?, h)\n"

#: build/en/book.xml:10883(para)
msgid "There are only two interesting subcommands. They allow you to make the choice between explicit or implicit inclusion of paths in the stream:"
msgstr "有意义的子命令只有两个。你可以使用这两个子命令说明你希望保留和不希望保留的路径："

#: build/en/book.xml:10889(literal)
msgid "exclude"
msgstr "exclude"

#: build/en/book.xml:10891(para)
msgid "Filter out a set of paths from the dump data stream."
msgstr "将指定路径的数据从转储数据流中排除。"

#: build/en/book.xml:10897(literal)
msgid "include"
msgstr "include"

#: build/en/book.xml:10899(para)
msgid "Allow only the requested set of paths to pass through the dump data stream."
msgstr "将指定路径的数据添加到转储数据流中。"

#: build/en/book.xml:1090(term) build/en/book.xml:12672(entry)
#: build/en/book.xml:1624(literal) build/en/book.xml:23864(command)
msgid "svnserve"
msgstr "svnserve"

#: build/en/book.xml:10905(para)
#, fuzzy
msgid "You can learn more about these subcommands and <command moreinfo=\"none\">svndumpfilter</command>'s unique purpose in <xref linkend=\"svn.reposadmin.maint.filtering\"/>."
msgstr "关于<command moreinfo=\"none\">svn update</command>的详细讨论，见<xref linkend=\"svn.tour.cycle.update\"/>。"

#: build/en/book.xml:10912(title) build/en/book.xml:1099(term)
msgid "svnsync"
msgstr "svnsync"

#: build/en/book.xml:10914(para)
msgid "The <command moreinfo=\"none\">svnsync</command> program, which is new to the 1.4 release of Subversion, provides all the functionality required for maintaining a read-only mirror of a Subversion repository. The program really has one job—to transfer one repository's versioned history into another repository. And while there are few ways to do that, its primary strength is that it can operate remotely—the <quote>source</quote> and <quote>sink</quote><placeholder-1/> repositories may be on different computers from each other and from <command moreinfo=\"none\">svnsync</command> itself."
msgstr ""

#: build/en/book.xml:1092(para)
msgid "A custom standalone server program, runnable as a daemon process or invokable by SSH; another way to make your repository available to others over a network."
msgstr "一个单独运行的服务器程序，可以作为守护进程或由SSH调用。这是另一种使版本库可以通过网络访问的方式。"

#: build/en/book.xml:10924(para)
#, fuzzy
msgid "Or is that, the <quote>sync</quote>?"
msgstr "<quote>锁定</quote>的三种含义"

#: build/en/book.xml:10929(para)
msgid "As you might expect, <command moreinfo=\"none\">svnsync</command> has a syntax that looks very much like every other program we've mentioned in this chapter:"
msgstr ""

#: build/en/book.xml:10933(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help\n"
"general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnsync --version' to see the program version and RA modules.\n"
"\n"
"Available subcommands:\n"
"   initialize (init)\n"
"   synchronize (sync)\n"
"   copy-revprops\n"
"   help (?, h)\n"
"$\n"
msgstr ""
"\n"
"$ svnsync help\n"
"general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnsync --version' to see the program version and RA modules.\n"
"\n"
"Available subcommands:\n"
"   initialize (init)\n"
"   synchronize (sync)\n"
"   copy-revprops\n"
"   help (?, h)\n"
"$\n"

#: build/en/book.xml:10947(para)
#, fuzzy
msgid "We talk more about replication repositories with <command moreinfo=\"none\">svnsync</command> in <xref linkend=\"svn.reposadmin.maint.replication\"/>."
msgstr "关于<command moreinfo=\"none\">svn status</command>的详细讨论，见<xref linkend=\"svn.tour.cycle.examine.status\"/>。"

#: build/en/book.xml:10954(title)
msgid "Berkeley DB Utilities"
msgstr "Berkeley DB工具"

#: build/en/book.xml:10956(para)
#, fuzzy
msgid "If you're using a Berkeley DB repository, then all of your versioned filesystem's structure and data live in a set of database tables within the <filename moreinfo=\"none\">db/</filename> subdirectory of your repository. This subdirectory is a regular Berkeley DB environment directory, and can therefore be used in conjunction with any of the Berkeley database tools, typically provided as part of the Berkeley DB distribution."
msgstr "如果你使用Berkeley DB版本库，那么所有纳入版本控制的文件系统结构和数据都储存在一系列数据库的表中，而这个位于版本库的<filename moreinfo=\"none\">db</filename>子目录下。这个子目录是一个标准的Berkeley DB环境目录，可以应用任何Berkeley数据库工具进行操作（参考SleepyCat网站<ulink url=\"http://www.sleepycat.com/\"/>上关于这些工具的介绍）。"

#: build/en/book.xml:10965(para)
msgid "For day-to-day Subversion use, these tools are unnecessary. Most of the functionality typically needed for Subversion repositories has been duplicated in the <command moreinfo=\"none\">svnadmin</command> tool. For example, <command moreinfo=\"none\">svnadmin list-unused-dblogs</command> and <command moreinfo=\"none\">svnadmin list-dblogs</command> perform a subset of what is provided by the Berkeley <command moreinfo=\"none\">db_archive</command> command, and <command moreinfo=\"none\">svnadmin recover</command> reflects the common use cases of the <command moreinfo=\"none\">db_recover</command> utility."
msgstr "对于Subversion的日常使用来说，这些工具并没有什么用处。大多数Subversion版本库必须的数据库操作都集成到<command moreinfo=\"none\">svnadmin</command>工具中。比如，<command moreinfo=\"none\">svnadmin list-unused-dblogs</command>和<command moreinfo=\"none\">svnadmin list-dblogs</command>实现了Berkeley <command moreinfo=\"none\">db_archive</command>命令功能的一个子集，而<command moreinfo=\"none\">svnadmin recover</command>则起到了 <command moreinfo=\"none\">db_recover</command>工具的作用。"

#: build/en/book.xml:10976(para)
msgid "There are still a few Berkeley DB utilities that you might find useful. The <command moreinfo=\"none\">db_dump</command> and <command moreinfo=\"none\">db_load</command> programs write and read, respectively, a custom file format which describes the keys and values in a Berkeley DB database. Since Berkeley databases are not portable across machine architectures, this format is a useful way to transfer those databases from machine to machine, irrespective of architecture or operating system. Also, the <command moreinfo=\"none\">db_stat</command> utility can provide useful information about the status of your Berkeley DB environment, including detailed statistics about the locking and storage subsystems."
msgstr "当然，还有一些Berkeley DB工具有时是有用的。<command moreinfo=\"none\">db_dump</command>将Berkeley DB数据库中的键值对以特定的格式写入文件中，而<command moreinfo=\"none\">db_load</command>则可以将这些键值对注入到数据库中。Berkeley数据库本身不支持跨平台转移，这两个工具在这样的情况下就可以实现在平台间转移数据库的功能，而无需关心操作系统或机器架构。此外，<command moreinfo=\"none\">db_stat</command>工具能够提供关于Berkeley DB环境的许多有用信息，包括详细的锁定和存储子系统的统计信息。"

#: build/en/book.xml:10989(para)
msgid "For more information on the Berkeley DB tool chain, visit the documentation section of the Berkeley DB section of Oracle's website, located at <ulink url=\"http://www.oracle.com/technology/documentation/berkeley-db/db/\"/>."
msgstr ""

#: build/en/book.xml:10998(title)
#, fuzzy
msgid "Commit Log Message Correction"
msgstr "提交事务。"

#: build/en/book.xml:11000(para)
msgid "Sometimes a user will have an error in her log message (a misspelling or some misinformation, perhaps). If the repository is configured (using the <literal moreinfo=\"none\">pre-revprop-change</literal> and <literal moreinfo=\"none\">post-revprop-change</literal> hooks; see <xref linkend=\"svn.reposadmin.create.hooks\"/>) to accept changes to this log message after the commit is finished, then the user can <quote>fix</quote> her log message remotely using the <command moreinfo=\"none\">svn</command> program's <literal moreinfo=\"none\">propset</literal> command (see <xref linkend=\"svn.ref\"/>). However, because of the potential to lose information forever, Subversion repositories are not, by default, configured to allow changes to unversioned properties—except by an administrator."
msgstr "有时用户输入的日志信息有错误（比如拼写错误或者内容错误）。如果配置版本库时设置了（使用<literal moreinfo=\"none\">pre-revprop-change</literal>和 <literal moreinfo=\"none\">post-revprop-change</literal>钩子；参见<xref linkend=\"svn.reposadmin.create.hooks\"/>）允许用户在提交后修改日志信息的选项，那么用户可以使用<command moreinfo=\"none\">svn</command>程序的<literal moreinfo=\"none\">propset</literal>命令（参见<xref linkend=\"svn.ref\"/>）<quote>修正</quote>日志信息中的错误。不过为了避免永远丢失信息，Subversion版本库通常设置为仅能由管理员修改非版本化属性（这也是默认的选项）。"

#: build/en/book.xml:1101(para)
msgid "A program for incrementally mirroring one repository to another over a network."
msgstr ""

#: build/en/book.xml:11013(para)
msgid "If a log message needs to be changed by an administrator, this can be done using <command moreinfo=\"none\">svnadmin setlog</command>. This command changes the log message (the <literal moreinfo=\"none\">svn:log</literal> property) on a given revision of a repository, reading the new value from a provided file."
msgstr "如果管理员想要修改日志信息，那么可以使用<command moreinfo=\"none\">svnadmin setlog</command>命令。这个命令从指定的文件中读取信息，取代版本库中某个修订版本的日志信息（<literal moreinfo=\"none\">svn:log</literal>属性）。"

#: build/en/book.xml:11019(screen)
#, no-wrap
msgid ""
"\n"
"$ echo \"Here is the new, correct log message\" &gt; newlog.txt\n"
"$ svnadmin setlog myrepos newlog.txt -r 388\n"
msgstr ""
"\n"
"$ echo \"Here is the new， correct log message\" &gt; newlog.txt\n"
"$ svnadmin setlog myrepos newlog.txt -r 388\n"

#: build/en/book.xml:11024(para)
msgid "The <command moreinfo=\"none\">svnadmin setlog</command> command alone is still bound by the same protections against modifying unversioned properties as a remote client is—the <literal moreinfo=\"none\">pre-</literal> and <literal moreinfo=\"none\">post-revprop-change</literal> hooks are still triggered, and therefore must be setup to accept changes of this nature. But an administrator can get around these protections by passing the <option>--bypass-hooks</option> option to the <command moreinfo=\"none\">svnadmin setlog</command> command."
msgstr "即使是<command moreinfo=\"none\">svnadmin setlog</command>命令也受到限制。<literal moreinfo=\"none\">pre-</literal>和 <literal moreinfo=\"none\">post-revprop-change</literal>钩子同样会被触发，因此必须进行相应的设置才能允许修改非版本化属性。不过管理员可以使用<command moreinfo=\"none\">svnadmin setlog</command>命令的<option>--bypass-hooks</option>选项跳过钩子。"

#: build/en/book.xml:11035(para)
msgid "Remember, though, that by bypassing the hooks, you are likely avoiding such things as email notifications of property changes, backup systems which track unversioned property changes, and so on. In other words, be very careful about what you are changing, and how you change it."
msgstr "不过需要注意的是，一旦跳过钩子也就跳过了钩子所提供的所有功能，比如邮件通知（通知属性有改动）、系统备份（可以用来跟踪非版本化的属性变更）等等。换句话说，要留心你所作出的修改，以及你作出修改的方式。"

#: build/en/book.xml:11048(title)
msgid "Managing Disk Space"
msgstr "管理磁盘空间"

#: build/en/book.xml:11050(para)
#, fuzzy
msgid "While the cost of storage has dropped incredibly in the past few years, disk usage is still a valid concern for administrators seeking to version large amounts of data. Every bit of version history information stored in the live repository is information that needs to be backed up elsewhere, perhaps multiple times as part of rotating backup schedules. It is useful to know what pieces of Subversion's repository data need to remain on the live site, which need to be backed up, and which can be safely removed."
msgstr "虽然存储器的价格在过去的几年里以让人难以致信的速度滑落，但是对于那些需要对大量数据进行版本管理的管理员们来说，磁盘空间的消耗依然是一个重要的因素。版本库每增加一个字节都意味着需要多一个字节的磁盘空间进行备份，对于多重备份来说，就需要消耗更多的磁盘空间。Berkeley DB版本库的主要存储机制是基于一个复杂的数据库系统建立的，因此了解一些数据性质是有意义的，比如哪些数据必须保留。哪些数据需要备份、哪些数据可以安全的删除等等。本节的内容专注于Berkeley DB类型的版本库。FSFS类型的版本库不需要进行数据清理和回收。"

#: build/en/book.xml:11062(title)
msgid "How Subversion saves disk space"
msgstr ""

#: build/en/book.xml:11064(para)
#, fuzzy
msgid "To keep the size of the repository as small as possible, Subversion uses <firstterm>deltification</firstterm> (or, <quote>deltified storage</quote>) within the repository itself. Deltification involves encoding the representation of a chunk of data as a collection of differences against some other chunk of data. If the two pieces of data are very similar, this deltification results in storage savings for the deltified chunk—rather than taking up space equal to the size of the original data, it takes up only enough space to say, <quote>I look just like this other piece of data over here, except for the following couple of changes</quote>. The result is that most of the repository data that tends to be sizable—namely, the contents of versioned files—is stored at a much smaller size than the original <quote>fulltext</quote> representation of that data. And for repositories created with Subversion 1.4 or later, the space saving get even better—now those fulltext representations of file contents are themselves compressed."
msgstr "为了尽可能减小版本库的体积，Subversion在版本库中采用了<firstterm>增量化技术</firstterm>（或称为<quote>增量存储技术</quote>）。增量化技术可以将一组数据表示为相对于另一组数据的不同。如果这两组数据十分相似，增量化技术就可以仅保存其中一组数据以及两组数据的差别，而不需要同时保存两组数据，从而节省了磁盘空间。每次一个文件的新版本提交到版本库，版本库就会将之前的版本（之前的多个版本）相对于新版本做增量化处理。采用了这项技术，版本库的数据量大小基本上是可以估算出来的—主要是版本化的文件的大小—并且远小于<quote>全文</quote>保存所需的数据量。"

#: build/en/book.xml:1108(para)
msgid "Assuming you have Subversion installed correctly, you should be ready to start. The next two chapters will walk you through the use of <command moreinfo=\"none\">svn</command>, Subversion's command-line client program."
msgstr "如果已经正确完成了Subversion的安装，我们就可以开始我们的学习之旅了。在后面的两章中，我们将讲解如何使用Subversion的客户端程序<command moreinfo=\"none\">svn</command>。"

#: build/en/book.xml:11085(para)
#, fuzzy
msgid "Because all of the data that is subject to deltification in a BDB-backed repository is stored in a single Berkeley DB database file, reducing the size of the stored values will not immediately reduce the size of the database file itself. Berkeley DB will, however, keep internal records of unused areas of the database file, and consume those areas first before growing the size of the database file. So while deltification doesn't produce immediate space savings, it can drastically slow future growth of the database."
msgstr "由于Subversion版本库的增量化数据保存在单一Berkeley DB数据库文件中，减少数据的体积并不一定能够减小数据库文件的大小。但是，Berkeley DB会在内部记录未使用的数据库文件区域，并且在增加数据库文件大小之前会首先使用这些未使用的区域。因此，即使增量化技术不能立杆见影的节省磁盘空间，也可以极大的减慢数据库的膨胀速度。"

#: build/en/book.xml:11101(title)
#, fuzzy
msgid "Removing dead transactions"
msgstr "移除中止的事务，"

#: build/en/book.xml:11103(para)
#, fuzzy
msgid "Though they are uncommon, there are circumstances in which a Subversion commit process might fail, leaving behind in the repository the remnants of the revision-to-be that wasn't—an uncommitted transaction and all the file and directory changes associated with it. This could happen for several reasons: perhaps the client operation was inelegantly terminated by the user, or a network failure might have occurred in the middle of an operation, etc. Regardless of the reason, dead transactions can happen. They don't do any real harm, other than consuming disk space. A fastidious administrator may nonetheless wish to remove them."
msgstr "<command moreinfo=\"none\">svnadmin</command>的另一个常见用途是查询异常的—可能是已经死亡的—Subversion事务。通常提交操作失败时，与之相关的事务就会被清除。也就是说，事务本身及所有与该事务相关（且仅与该事务相关）的数据会从版本库中删除。不过偶尔也会出现操作失败而事务没有被清除的情况。出现这种情况可能有以下原因：客户端的用户粗暴的结束了操作，操作过程中出现网络故障，等等。不管是什么原因，死亡的事务总是有可能会出现。这类事务不会产生什么负面影响，仅仅是消耗了一点点磁盘空间。不过，严厉的管理员总是希望能够将它们清除出去。"

#: build/en/book.xml:11116(para)
msgid "You can use <command moreinfo=\"none\">svnadmin</command>'s <literal moreinfo=\"none\">lstxns</literal> command to list the names of the currently outstanding transactions."
msgstr "可以使用<command moreinfo=\"none\">svnadmin</command>的<literal moreinfo=\"none\">lstxns</literal> 命令列出当前的异常事务名。"

#: build/en/book.xml:11120(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin lstxns myrepos\n"
"19\n"
"3a1\n"
"a45\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin lstxns myrepos\n"
"19\n"
"3a1\n"
"a45\n"
"$\n"

#: build/en/book.xml:11128(para)
#, fuzzy
msgid "Each item in the resultant output can then be used with <command moreinfo=\"none\">svnlook</command> (and its <option>--transaction (-t)</option> option) to determine who created the transaction, when it was created, what types of changes were made in the transaction—information that is helpful in determining whether or not the transaction is a safe candidate for removal! If so, the transaction's name can be passed to <command moreinfo=\"none\">svnadmin rmtxns</command>, which will perform the cleanup of the transaction. In fact, the <literal moreinfo=\"none\">rmtxns</literal> subcommand can take its input directly from the output of <literal moreinfo=\"none\">lstxns</literal>!"
msgstr "将输出的结果条目作为<command moreinfo=\"none\">svnlook</command>（设置<option>--transaction</option>选项）的参数，就可以获得事务的详细信息，如事务的创建者、创建时间，事务已作出的更改类型，由这些信息可以判断出是否可以将这个事务安全的删除。如果可以安全删除，那么只需将事务名作为参数输入到<command moreinfo=\"none\">svnadmin rmtxns</command>，就可以将事务清除掉了。其实<literal moreinfo=\"none\">rmtxns</literal>子命令可以直接以<literal moreinfo=\"none\">lstxns</literal>的输出作为输入进行清理。"

#: build/en/book.xml:11141(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`\n"
"$\n"

#: build/en/book.xml:11146(para)
#, fuzzy
msgid "If you use these two subcommands like this, you should consider making your repository temporarily inaccessible to clients. That way, no one can begin a legitimate transaction before you start your cleanup. <xref linkend=\"svn.reposadmin.maint.diskspace.deadtxns.ex-1\"/> contains a bit of shell-scripting that can quickly generate information about each outstanding transaction in your repository."
msgstr "在按照上面例子中的方法清理版本库之前，你或许应该暂时关闭版本库和客户端的连接。这样在你开始清理之前，不会有正常的事务进入版本库。下面例子中的shell脚本可以用来迅速获得版本库中异常事务的信息："

#: build/en/book.xml:11155(title)
msgid "txn-info.sh (Reporting Outstanding Transactions)"
msgstr "txn-info.sh（异常事务报告）"

#: build/en/book.xml:11157(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh\n"
"\n"
"### Generate informational output for all outstanding transactions in\n"
"### a Subversion repository.\n"
"\n"
"REPOS=\"${1}\"\n"
"if [ \"x$REPOS\" = x ] ; then\n"
"  echo \"usage: $0 REPOS_PATH\"\n"
"  exit\n"
"fi\n"
"\n"
"for TXN in `svnadmin lstxns ${REPOS}`; do \n"
"  echo \"---[ Transaction ${TXN} ]-------------------------------------------\"\n"
"  svnlook info \"${REPOS}\" -t \"${TXN}\"\n"
"done\n"
msgstr ""
"\n"
"#!/bin/sh\n"
"\n"
"### Generate informational output for all outstanding transactions in\n"
"### a Subversion repository.\n"
"\n"
"REPOS=\"${1}\"\n"
"if [ \"x$REPOS\" = x ] ; then\n"
"  echo \"usage: $0 REPOS_PATH\"\n"
"  exit\n"
"fi\n"
"\n"
"for TXN in `svnadmin lstxns ${REPOS}`; do \n"
"  echo \"---[ Transaction ${TXN} ]-------------------------------------------\"\n"
"  svnlook info \"${REPOS}\" -t \"${TXN}\"\n"
"done\n"

#: build/en/book.xml:11176(para)
#, fuzzy
msgid "The output of the script is basically a concatenation of several chunks of <command moreinfo=\"none\">svnlook info</command> output (see <xref linkend=\"svn.reposadmin.maint.tk.svnlook\"/>), and will look something like:"
msgstr "可以用下面的命令使用上例中脚本： <command moreinfo=\"none\">/path/to/txn-info.sh /path/to/repos</command>。该命令的输出主要由多个<command moreinfo=\"none\">svnlook info</command>参见<xref linkend=\"svn.reposadmin.maint.tk.svnlook\"/>）的输出组成，类似于下面的例子："

#: build/en/book.xml:11181(screen)
#, no-wrap
msgid ""
"\n"
"$ txn-info.sh myrepos\n"
"---[ Transaction 19 ]-------------------------------------------\n"
"sally\n"
"2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)\n"
"0\n"
"---[ Transaction 3a1 ]-------------------------------------------\n"
"harry\n"
"2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)\n"
"39\n"
"Trying to commit over a faulty network.\n"
"---[ Transaction a45 ]-------------------------------------------\n"
"sally\n"
"2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)\n"
"0\n"
"$\n"
msgstr ""
"\n"
"$ txn-info.sh myrepos\n"
"---[ Transaction 19 ]-------------------------------------------\n"
"sally\n"
"2001-09-04 11:57:19 -0500 (Tue， 04 Sep 2001)\n"
"0\n"
"---[ Transaction 3a1 ]-------------------------------------------\n"
"harry\n"
"2001-09-10 16:50:30 -0500 (Mon， 10 Sep 2001)\n"
"39\n"
"Trying to commit over a faulty network.\n"
"---[ Transaction a45 ]-------------------------------------------\n"
"sally\n"
"2001-09-12 11:09:28 -0500 (Wed， 12 Sep 2001)\n"
"0\n"
"$\n"

#: build/en/book.xml:11199(para)
msgid "A long-abandoned transaction usually represents some sort of failed or interrupted commit. A transaction's datestamp can provide interesting information—for example, how likely is it that an operation begun nine months ago is still active?"
msgstr "一个废弃了很长时间的事务通常是提交错误或异常中断的结果。事务的时间戳可以提供给我们一些有趣的信息，比如一个进行了9个月的操作居然还是活动的等等。"

#: build/en/book.xml:11205(para)
#, fuzzy
msgid "In short, transaction cleanup decisions need not be made unwisely. Various sources of information—including Apache's error and access logs, Subversion's operational logs, Subversion revision history, and so on—can be employed in the decision-making process. And of course, an administrator can often simply communicate with a seemingly dead transaction's owner (via email, for example) to verify that the transaction is, in fact, in a zombie state."
msgstr "简言之，作出事务清理的决定前应该仔细考虑一下。许多信息源—比如Apache的错误和访问日志，已成功完成的Subversion提交日志等等—都可以作为决策的参考。管理员还可以直接和那些似乎已经死亡事务的提交者直接交流（比如通过邮件），来确认该事务确实已经死亡了。"

#: build/en/book.xml:11218(title)
#, fuzzy
msgid "Purging unused Berkeley DB logfiles"
msgstr "删除不使用的Berkeley DB日志。"

#: build/en/book.xml:11220(para)
#, fuzzy
msgid "Until recently, the largest offender of disk space usage with respect to BDB-backed Subversion repositories was the log files in which Berkeley DB performs its pre-writes before modifying the actual database files. These files capture all the actions taken along the route of changing the database from one state to another—while the database files reflect at any given time some state, the log files contain all the many changes along the way between states. As such, they can grow and accumulate quite rapidly."
msgstr "目前为止，Subversion版本库中耗费磁盘空间的最大凶手是日志文件，每次Berkeley DB在修改真正的数据文件之前都会进行预写入（pre-writes）操作。这些文件记录了数据库从一个状态变化到另一个状态的所有动作——数据库文件反应了特定时刻数据库的状态，而日志文件则记录了所有状态变化的信息。因此，日志文件会以很快的速度膨胀起来。"

#: build/en/book.xml:11231(para)
msgid "Fortunately, beginning with the 4.2 release of Berkeley DB, the database environment has the ability to remove its own unused log files without any external procedures. Any repositories created using an <command moreinfo=\"none\">svnadmin</command> which is compiled against Berkeley DB version 4.2 or greater will be configured for this automatic log file removal. If you don't want this feature enabled, simply pass the <option>--bdb-log-keep</option> option to the <command moreinfo=\"none\">svnadmin create</command> command. If you forget to do this, or change your mind at a later time, simple edit the <filename moreinfo=\"none\">DB_CONFIG</filename> file found in your repository's <filename moreinfo=\"none\">db</filename> directory, comment out the line which contains the <literal moreinfo=\"none\">set_flags DB_LOG_AUTOREMOVE</literal> directive, and then run <command moreinfo=\"none\">svnadmin recover</command> on your repository to force the configuration changes to take effect. See <xref linkend=\"svn.reposadmin.create.bdb\"/> for more information about database configuration."
msgstr "幸运的是，从版本4.2开始，Berkeley DB的数据库环境无需额外的操作即可删除无用的日志文件。如果编译<command moreinfo=\"none\">svnadmin</command>时使用了高于4.2版本的Berkeley DB，那么由此<command moreinfo=\"none\">svnadmin</command>程序创建的版本库就具备了自动清除日志文件的功能。如果想屏蔽这个功能，只需设置<command moreinfo=\"none\">svnadmin create</command>命令的<option>--bdb-log-keep</option>选项即可。如果创建版本库以后想要修改关于此功能的设置，只需编辑版本库中<filename moreinfo=\"none\">db</filename>目录下的<filename moreinfo=\"none\">DB_CONFIG</filename>文件，注释掉包含<literal moreinfo=\"none\">set_flags DB_LOG_AUTOREMOVE</literal>内容的这一行，然后运行<command moreinfo=\"none\">svnadmin recover</command>强制设置生效就行了。查阅<xref linkend=\"svn.reposadmin.create.bdb\"/>获得更多关于数据库配置的帮助信息。"

#: build/en/book.xml:11249(para)
msgid "Without some sort of automatic log file removal in place, log files will accumulate as you use your repository. This is actually somewhat of a feature of the database system—you should be able to recreate your entire database using nothing but the log files, so these files can be useful for catastrophic database recovery. But typically, you'll want to archive the log files that are no longer in use by Berkeley DB, and then remove them from disk to conserve space. Use the <command moreinfo=\"none\">svnadmin list-unused-dblogs</command> command to list the unused log files:"
msgstr "如果不自动删除日志文件，那么日志文件会随着版本库的使用逐渐增加。这多少应该算是数据库系统的特性，通过这些日志文件可以在数据库严重损坏时恢复整个数据库的内容。但是一般情况下，最好是能够将无用的日志文件收集起来并删除，这样就可以节省磁盘空间。使用<command moreinfo=\"none\">svnadmin list-unused-dblogs</command>命令可以列出无用的日志文件："

#: build/en/book.xml:1126(title)
msgid "Fundamental Concepts"
msgstr "基本概念"

#: build/en/book.xml:11261(screen) build/en/book.xml:22453(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos\n"
"/path/to/repos/log.0000000031\n"
"/path/to/repos/log.0000000032\n"
"/path/to/repos/log.0000000033\n"
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos | xargs rm\n"
"## disk space reclaimed!\n"
msgstr ""
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos\n"
"/path/to/repos/log.0000000031\n"
"/path/to/repos/log.0000000032\n"
"/path/to/repos/log.0000000033\n"
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos | xargs rm\n"
"## disk space reclaimed!\n"

#: build/en/book.xml:11272(para)
msgid "BDB-backed repositories whose log files are used as part of a backup or disaster recovery plan should <emphasis>not</emphasis> make use of the log file autoremoval feature. Reconstruction of a repository's data from log files can only be accomplished when the log files are all available. If some of the log files are removed from disk before the backup system has a chance to copy them elsewhere, the incomplete set of backed-up log files is essentially useless."
msgstr ""

#: build/en/book.xml:1128(para)
msgid "This chapter is a short, casual introduction to Subversion. If you're new to version control, this chapter is definitely for you. We begin with a discussion of general version control concepts, work our way into the specific ideas behind Subversion, and show some simple examples of Subversion in use."
msgstr "本章主要为那些不熟悉版本控制技术的入门者提供一个简单扼要的、非系统的介绍。我们将从版本控制的基本概念开始，随后阐述Subversion的独特理念，并演示一些使用Subversion的例子。"

#: build/en/book.xml:11289(title)
#, fuzzy
msgid "Berkeley DB Recovery"
msgstr "Berkeley DB"

#: build/en/book.xml:11291(para)
msgid "As mentioned in <xref linkend=\"svn.reposadmin.basics.backends.bdb\"/>, a Berkeley DB repository can sometimes be left in frozen state if not closed properly. When this happens, an administrator needs to rewind the database back into a consistent state. This is unique to BDB-backed repositories, though—if you are using FSFS-backed ones instead, this won't apply to you. And for those of you using Subversion 1.4 with Berkeley DB 4.4 or better, you should find that Subversion has become much more resilient in these types of situations. Still, wedged Berkeley DB repositories do occur, and an administrator needs to know how to safely deal with this circumstance."
msgstr ""

#: build/en/book.xml:11303(para)
#, fuzzy
msgid "In order to protect the data in your repository, Berkeley DB uses a locking mechanism. This mechanism ensures that portions of the database are not simultaneously modified by multiple database accessors, and that each process sees the data in the correct state when that data is being read from the database. When a process needs to change something in the database, it first checks for the existence of a lock on the target data. If the data is not locked, the process locks the data, makes the change it wants to make, and then unlocks the data. Other processes are forced to wait until that lock is removed before they are permitted to continue accessing that section of the database. (This has nothing to do with the locks that you, as a user, can apply to versioned files within the repository; we try to clear up the confusion caused by this terminology collision in <xref linkend=\"svn.advanced.locking.meanings\"/>.)"
msgstr "Berkeley DB使用一种锁机制保护版本库中的数据。锁机制确保数据库不会同时被多个访问进程修改，也就保证了从数据库中读取到的数据始终是稳定而且正确的。当一个进程需要修改数据库中的数据时，首先必须检查目标数据是否已经上锁。如果目标数据没有上锁，进程就将它锁上，然后作出修改，最后再将锁解除。而其它进程则必须等待锁解除后才能继续访问数据库中的相关内容。"

#: build/en/book.xml:11319(para)
#, fuzzy
msgid "In the course of using your Subversion repository, fatal errors or interruptions can prevent a process from having the chance to remove the locks it has placed in the database. The result is that the back-end database system gets <quote>wedged</quote>. When this happens, any attempts to access the repository hang indefinitely (since each new accessor is waiting for a lock to go away—which isn't going to happen)."
msgstr "在操作Subversion版本库的过程中，致命错误（如内存或硬盘空间不足）或异常中断可能会导致某个进程没能及时将锁解除。结果就是后端的数据库系统被<quote>塞住</quote>了。一旦发生这种情况，任何访问版本库的进程都会挂起（每个访问进程都在等待锁被解除，但是锁已经无法解除了）。"

#: build/en/book.xml:11328(para)
#, fuzzy
msgid "If this happens to your repository, don't panic. The Berkeley DB filesystem takes advantage of database transactions and checkpoints and pre-write journaling to ensure that only the most catastrophic of events <placeholder-1/> can permanently destroy a database environment. A sufficiently paranoid repository administrator will have made off-site backups of the repository data in some fashion, but head off to the tape backup storage closet just yet."
msgstr "首先，如果你的版本库出现这种情况，没什么好惊慌的。Berkeley DB的文件系统采用了数据库事务、检查点以及预写入日志等技术来取保只有灾难性的事件<footnote><placeholder-1/></footnote>才能永久性的破坏数据库环境。所以虽然一个过于稳重的版本库管理员通常都会按照某种方案进行大量的版本库离线备份，不过不要急着通知你的管理员进行恢复。"

#: build/en/book.xml:11333(para)
msgid "E.g.: hard drive + huge electromagnet = disaster."
msgstr "比如：硬盘 + 大号电磁铁 = 毁灭。"

#: build/en/book.xml:11340(para)
#, fuzzy
msgid "Instead, use the following recipe to attempt to <quote>unwedge</quote> your repository:"
msgstr "然后，使用下面的方法试着<quote>恢复</quote>你的版本库："

#: build/en/book.xml:11345(para)
#, fuzzy
msgid "Make sure that there are no processes accessing (or attempting to access) the repository. For networked repositories, this means shutting down the Apache HTTP Server or svnserve daemon, too."
msgstr "确保没有其它进程访问（或者试图访问）版本库。对于网络版本库，关闭Apache HTTP服务器是个好办法。"

#: build/en/book.xml:1135(para)
msgid "Even though the examples in this chapter show people sharing collections of program source code, keep in mind that Subversion can manage any sort of file collection—it's not limited to helping computer programmers."
msgstr "虽然我们在本章中以分享程序源代码作为例子，但是记住Subversion可以管理任何类型的文件集—它并非是程序员专用的。"

#: build/en/book.xml:11351(para)
msgid "Become the user who owns and manages the repository. This is important, as recovering a repository while running as the wrong user can tweak the permissions of the repository's files in such a way that your repository will still be inaccessible even after it is <quote>unwedged</quote>."
msgstr "成为版本库的拥有者和管理员。这一点很重要，如果以其它用户的身份恢复版本库，可能会改变版本库文件的访问权限，导致在版本库<quote>恢复</quote>后依旧无法访问。"

#: build/en/book.xml:11359(para)
msgid "Run the command <command moreinfo=\"none\">svnadmin recover /path/to/repos</command>. You should see output like this:"
msgstr "运行命令<command moreinfo=\"none\">svnadmin recover /path/to/repos</command>。 输出如下："

#: build/en/book.xml:11363(screen)
#, no-wrap
msgid ""
"\n"
"Repository lock acquired.\n"
"Please wait; recovering the repository may take some time...\n"
"\n"
"Recovery completed.\n"
"The latest repos revision is 19.\n"
msgstr ""
"\n"
"Repository lock acquired。\n"
"Please wait; recovering the repository may take some time...\n"
"\n"
"Recovery completed.\n"
"The latest repos revision is 19.\n"

#: build/en/book.xml:11370(para)
msgid "This command may take many minutes to complete."
msgstr "此命令可能需要数分钟才能完成。"

#: build/en/book.xml:11373(para)
#, fuzzy
msgid "Restart the server process."
msgstr "重新启动Subversion服务器。"

#: build/en/book.xml:11377(para)
msgid "This procedure fixes almost every case of repository lock-up. Make sure that you run this command as the user that owns and manages the database, not just as <literal moreinfo=\"none\">root</literal>. Part of the recovery process might involve recreating from scratch various database files (shared memory regions, for example). Recovering as <literal moreinfo=\"none\">root</literal> will create those files such that they are owned by <literal moreinfo=\"none\">root</literal>, which means that even after you restore connectivity to your repository, regular users will be unable to access it."
msgstr "这个方法能修复几乎所有版本库锁住的问题。记住，要以数据库的拥有者和管理员的身份运行这个命令，而不一定是<literal moreinfo=\"none\">root</literal>用户。恢复过程中可能会使用其它数据存储区（例如共享内存区）重建一些数据库文件。如果以<literal moreinfo=\"none\">root</literal>用户身份恢复版本库，这些重建的文件拥有者将变成<literal moreinfo=\"none\">root</literal>用户，也就是说，即使恢复了到版本库的连接，一般的用户也无权访问这些文件。"

#: build/en/book.xml:11388(para)
msgid "If the previous procedure, for some reason, does not successfully unwedge your repository, you should do two things. First, move your broken repository out of the way and restore your latest backup of it. Then, send an email to the Subversion user list (at <email>users@subversion.tigris.org</email>) describing your problem in detail. Data integrity is an extremely high priority to the Subversion developers."
msgstr "如果因为某些原因，上面的方法没能成功的恢复版本库，那么你可以做两件事。首先，将破损的版本库保存到其它地方，然后从最新的备份中恢复版本库。然后，发送一封邮件到Subversion用户列表（地址是：<email>users@subversion.tigris.org</email>），写清你所遇到的问题。对于Subversion的开发者来说，数据安全是最重要的问题。"

#: build/en/book.xml:11401(title)
#, fuzzy
msgid "Migrating Repository Data Elsewhere"
msgstr "版本库的移植"

#: build/en/book.xml:11403(para)
#, fuzzy
msgid "A Subversion filesystem has its data spread throughout various back-end data store files in a fashion generally understood by (and of interest to) only the Subversion developers themselves. However, circumstances may arise that call for all, or some subset, of that data to be copied or moved into another repository."
msgstr "Subversion文件系统将数据保存在许多数据库表中，而这些表的结构只有Subversion开发者们才了解（也只有他们才感兴趣）不过，有些时候我们会想到把所有的数据（或者一部分数据）保存在一个独立的、可移植的、普通格式的文件中。Subversion通过<command moreinfo=\"none\">svnadmin</command>的两个子命令<literal moreinfo=\"none\">dump</literal>和<literal moreinfo=\"none\">load</literal>提供了类似的功能。"

#: build/en/book.xml:11410(para)
msgid "Subversion provides such functionality by way of repository dump streams. A repository dump stream (often referred to as a <quote>dumpfile</quote> when stored as a file on disk) is a portable, flat file format that describes the various revisions in your repository—what was changed, by whom, when, and so on. This dump stream is the primary mechanism used to marshal versioned history—in whole or in part, with or without modification—between repositories. And Subversion provides the tools necessary for creating and loading these dump streams—the <command moreinfo=\"none\">svnadmin dump</command> and <command moreinfo=\"none\">svnadmin load</command> subcommands, respectively."
msgstr ""

#: build/en/book.xml:11424(para)
msgid "While the Subversion repository dump format contains human-readable portions and a familiar structure (it resembles an RFC-822 format, the same type of format used for most email), it is <emphasis>not</emphasis> a plaintext file format. The format should be treated as a binary file format, highly sensitive to meddling. Many text editor tools will corrupt the file's contents, often due to automatic line ending character conversion."
msgstr ""

#: build/en/book.xml:11434(para)
msgid "There are many reasons for dumping and loading Subversion repository data. Early in Subversion's life, the most common reason was due to the evolution of Subversion itself. As Subversion matured, there were times when changes made to the back-end database schema caused compatibility issues with previous versions of the repository, so users had to dump their repository data using the previous version of Subversion, and load it into a freshly created repository with the new version of Subversion. Now, these types of schema changes haven't occured since Subversion's 1.0 release, and the Subversion developers promise not to force users to dump and load their repositories when upgrading between minor versions (such as from 1.3 to 1.4) of Subversion. But there are still other reasons for dumping and loading, including re-deploying a Berkeley DB repository on a new OS or CPU architecture, switching between the Berkeley DB and FSFS back-ends, or (as we'll cover in <xref linkend=\"svn.reposadmin.maint.filtering\"/> purging versioned data from repository history."
msgstr ""

#: build/en/book.xml:1145(title)
msgid "The Repository"
msgstr "版本库"

#: build/en/book.xml:11453(para)
#, fuzzy
msgid "Whatever your reason for migration repository history, using the <command moreinfo=\"none\">svnadmin dump</command> and <command moreinfo=\"none\">svnadmin load</command> subcommands is straightforward. <command moreinfo=\"none\">svnadmin dump</command> will output a range of repository revisions that are formatted using Subversion's custom filesystem dump format. The dump format is printed to the standard output stream, while informative messages are printed to the standard error stream. This allows you to redirect the output stream to a file while watching the status output in your terminal window. For example:"
msgstr "<command moreinfo=\"none\">svnadmin dump</command>命令会将版本库中的修订版本数据按照特定的格式输出到转储流中。转储数据会输出到标准输出流，而提示信息会输出到标准错误流。这就是说，可以将转储数据存储到文件中，而同时在终端窗口中监视运行状态。例如："

#: build/en/book.xml:11465(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook youngest myrepos\n"
"26\n"
"$ svnadmin dump myrepos &gt; dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"…\n"
"* Dumped revision 25.\n"
"* Dumped revision 26.\n"
msgstr ""
"\n"
"$ svnlook youngest myrepos\n"
"26\n"
"$ svnadmin dump myrepos &gt; dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"…\n"
"* Dumped revision 25.\n"
"* Dumped revision 26.\n"

#: build/en/book.xml:1147(para)
msgid "Subversion is a centralized system for sharing information. At its core is a repository, which is a central store of data. The repository stores information in the form of a <firstterm>filesystem tree</firstterm>—a typical hierarchy of files and directories. Any number of <firstterm>clients</firstterm> connect to the repository, and then read or write to these files. By writing data, a client makes the information available to others; by reading data, the client receives information from others. <xref linkend=\"svn.basic.repository.dia-1\"/> illustrates this."
msgstr "Subversion是一个“中央集权式”的信息共享系统。版本库是Subversion的核心部分，是数据的中央仓库。版本库以文件和目录的典型结构形式—<firstterm>文件系统树</firstterm>来保存信息。此外，数个<firstterm>客户端</firstterm>（数量不限）连接到Subversion版本库，读取、修改这些文件。客户端之间通过修改数据实现与别人共享信息，通过读取数据实现获取别人共享的信息。<xref linkend=\"svn.basic.repository.dia-1\"/>展示了这种系统的概貌："

#: build/en/book.xml:11477(para)
msgid "At the end of the process, you will have a single file (<filename moreinfo=\"none\">dumpfile</filename> in the previous example) that contains all the data stored in your repository in the requested range of revisions. Note that <command moreinfo=\"none\">svnadmin dump</command> is reading revision trees from the repository just like any other <quote>reader</quote> process would (<command moreinfo=\"none\">svn checkout</command>, for example). So it's safe to run this command at any time."
msgstr "最后，版本库中的指定的修订版本数据被转储到一个独立的文件中（在上面的例子中是<filename moreinfo=\"none\">dumpfile</filename>）。注意，<command moreinfo=\"none\">svnadmin dump</command>从版本库中读取修订版本树与其它<quote>读者</quote>（比如<command moreinfo=\"none\">svn checkout</command>）的过程相同，所以可以在任何时候安全的运行这个命令。"

#: build/en/book.xml:11486(para)
msgid "The other subcommand in the pair, <command moreinfo=\"none\">svnadmin load</command>, parses the standard input stream as a Subversion repository dump file, and effectively replays those dumped revisions into the target repository for that operation. It also gives informative feedback, this time using the standard output stream:"
msgstr "另一个命令，<command moreinfo=\"none\">svnadmin load</command>，从标准输入流中读取Subversion转储数据，并且高效的将数据转载到目标版本库中。这个命令的提示信息输出到标准输出流中："

#: build/en/book.xml:11493(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile\n"
"&lt;&lt;&lt; Started new txn, based on original revision 1\n"
"     * adding path : A ... done.\n"
"     * adding path : A/B ... done.\n"
"     …\n"
"------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 2\n"
"     * editing path : A/mu ... done.\n"
"     * editing path : A/D/G/rho ... done.\n"
"\n"
"------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;\n"
"\n"
"…\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 25\n"
"     * editing path : A/D/gamma ... done.\n"
"\n"
"------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 26\n"
"     * adding path : A/Z/zeta ... done.\n"
"     * editing path : A/mu ... done.\n"
"\n"
"------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;\n"
"\n"
msgstr ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile\n"
"&lt;&lt;&lt; Started new txn, based on original revision 1\n"
"     * adding path : A ... done.\n"
"     * adding path : A/B ... done.\n"
"     …\n"
"------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 2\n"
"     * editing path : A/mu ... done.\n"
"     * editing path : A/D/G/rho ... done.\n"
"\n"
"------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;\n"
"\n"
"…\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 25\n"
"     * editing path : A/D/gamma ... done.\n"
"\n"
"------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 26\n"
"     * adding path : A/Z/zeta ... done.\n"
"     * editing path : A/mu ... done.\n"
"\n"
"------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;\n"
"\n"

#: build/en/book.xml:11522(para)
#, fuzzy
msgid "The result of a load is new revisions added to a repository—the same thing you get by making commits against that repository from a regular Subversion client. And just as in a commit, you can use hook programs to perform actions before and after each of the commits made during a load process. By passing the <option>--use-pre-commit-hook</option> and <option>--use-post-commit-hook</option> options to <command moreinfo=\"none\">svnadmin load</command>, you can instruct Subversion to execute the pre-commit and post-commit hook programs, respectively, for each loaded revision. You might use these, for example, to ensure that loaded revisions pass through the same validation steps that regular commits pass through. Of course, you should use these options with care—if your post-commit hook sends emails to a mailing list for each new commit, you might not want to spew hundreds or thousands of commit emails in rapid succession at that list for each of the loaded revisions! You can read more about the use of hook scripts in <xref linkend=\"svn.reposadmin.create.hooks\"/>."
msgstr "load命令的结果就是添加一些新的修订版本—与使用普通Subversion客户端直接提交到版本库相同。正像一次简单的提交，你也可以使用钩子脚本在每次load的开始和结束执行一些操作。通过传递<option>--use-pre-commit-hook</option>和<option>--use-post-commit-hook</option>选项给<command moreinfo=\"none\">svnadmin load</command>，你可以告诉Subversion的对每一个加载修订版本执行pre-commit和post-commit钩子脚本，可以利用这个选项确保这种提交也能通过一般提交的检验。当然，你要小心使用这个选项，你一定不像接受一大堆提交邮件。你可以查看<xref linkend=\"svn.reposadmin.create.hooks\"/>来得到更多相关信息。"

#: build/en/book.xml:11542(para)
msgid "Note that because <command moreinfo=\"none\">svnadmin</command> uses standard input and output streams for the repository dump and load process, people who are feeling especially saucy can try things like this (perhaps even using different versions of <command moreinfo=\"none\">svnadmin</command> on each side of the pipe):"
msgstr "既然<command moreinfo=\"none\">svnadmin</command>使用标准输入流和标准输出流作为转储和装载的输入和输出，那么更漂亮的用法是（管道两端可以是不同版本的<command moreinfo=\"none\">svnadmin</command>："

#: build/en/book.xml:11548(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create newrepos\n"
"$ svnadmin dump myrepos | svnadmin load newrepos\n"
msgstr ""
"\n"
"$ svnadmin create newrepos\n"
"$ svnadmin dump myrepos | svnadmin load newrepos\n"

#: build/en/book.xml:11553(para)
#, fuzzy
msgid "By default, the dump file will be quite large—much larger than the repository itself. That's because by default every version of every file is expressed as a full text in the dump file. This is the fastest and simplest behavior, and nice if you're piping the dump data directly into some other process (such as a compression program, filtering program, or into a loading process). But if you're creating a dump file for longer-term storage, you'll likely want to save disk space by using the <option>--deltas</option> switch. With this option, successive revisions of files will be output as compressed, binary differences—just as file revisions are stored in a repository. This option is slower, but results in a dump file much closer in size to the original repository."
msgstr "默认情况下，转储文件的体积可能会相当庞大——比版本库自身大很多。这是因为在转储文件中，每个文件的每个版本都以完整的文本形式保存下来。这种方法速度很快，而且很简单，尤其是直接将转储数据通过管道输入到其它进程中时（比如一个压缩程序，过滤程序，或者一个装载进程）。不过如果要长期保存转储文件，那么可以使用<option>--deltas</option>选项来节省磁盘空间。设置这个选项，同一个文件的数个连续修订版本会以增量式的方式保存—就像储存在版本库中一样。这个方法较慢，但是转储文件的体积则基本上与版本库的体积相当。"

#: build/en/book.xml:11568(para)
#, fuzzy
msgid "We mentioned previously that <command moreinfo=\"none\">svnadmin dump</command> outputs a range of revisions. Use the <option>--revision (-r)</option> option to specify a single revision to dump, or a range of revisions. If you omit this option, all the existing repository revisions will be dumped."
msgstr "之前我们提到<command moreinfo=\"none\">svnadmin dump</command>输出指定的修订版本。使用<option>--revision</option>选项可以指定一个单独的修订版本，或者一个修订版本的范围。如果忽略这个选项，所有版本库中的修订版本都会被转储。"

#: build/en/book.xml:11575(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile\n"
"$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile\n"
msgstr ""
"\n"
"$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile\n"
"$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile\n"

#: build/en/book.xml:1158(title)
msgid "A typical client/server system"
msgstr "一个典型的客户/服务器系统"

#: build/en/book.xml:11580(para)
msgid "As Subversion dumps each new revision, it outputs only enough information to allow a future loader to re-create that revision based on the previous one. In other words, for any given revision in the dump file, only the items that were changed in that revision will appear in the dump. The only exception to this rule is the first revision that is dumped with the current <command moreinfo=\"none\">svnadmin dump</command> command."
msgstr "Subversion在转储修订版本时，仅会输出与前一个修订版本之间的差异，通过这些差异足以从前一个修订版本中重建当前的修订版本。换句话说，在转储文件中的每一个修订版本仅包含这个修订版本作出的修改。这个规则的唯一一个例外是当前<command moreinfo=\"none\">svnadmin dump</command>转储的第一个修订版本。"

#: build/en/book.xml:11589(para)
msgid "By default, Subversion will not express the first dumped revision as merely differences to be applied to the previous revision. For one thing, there is no previous revision in the dump file! And secondly, Subversion cannot know the state of the repository into which the dump data will be loaded (if it ever, in fact, occurs). To ensure that the output of each execution of <command moreinfo=\"none\">svnadmin dump</command> is self-sufficient, the first dumped revision is by default a full representation of every directory, file, and property in that revision of the repository."
msgstr "默认情况下，Subversion不会把转储的第一个修订版本看作对前一个修订版本的更改。 首先，转储文件中没有比第一个修订版本更靠前的修订版本了！其次，Subversion不知道装载转储数据时（如果真的需要装载的话）的版本库是什么样的情况。为了保证每次运行<command moreinfo=\"none\">svnadmin dump</command>都能得到一个独立的结果，第一个转储的修订版本默认情况下会完整的保存目录、文件以及属性等数据。"

#: build/en/book.xml:11600(para)
msgid "However, you can change this default behavior. If you add the <option>--incremental</option> option when you dump your repository, <command moreinfo=\"none\">svnadmin</command> will compare the first dumped revision against the previous revision in the repository, the same way it treats every other revision that gets dumped. It will then output the first revision exactly as it does the rest of the revisions in the dump range—mentioning only the changes that occurred in that revision. The benefit of this is that you can create several small dump files that can be loaded in succession, instead of one large one, like so:"
msgstr "不过，这些都是可以改变的。如果转储时设置了<option>--incremental</option>选项，<command moreinfo=\"none\">svnadmin</command>会比较第一个转储的修订版本和版本库中前一个修订版本，就像对待其它转储的修订版本一样。转储时也是一样，转储文件中将仅包含第一个转储的修订版本的增量信息。这样的好处是，可以创建几个连续的小体积的转储文件代替一个大文件，比如："

#: build/en/book.xml:11612(screen)
#, fuzzy, no-wrap
msgid ""
"\n"
"$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1\n"
"$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2\n"
"$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3\n"
msgstr ""
"\n"
"$ svnadmin dump myrepos --revision 0:1000 &gt; dumpfile1\n"
"$ svnadmin dump myrepos --revision 1001:2000 --incremental &gt; dumpfile2\n"
"$ svnadmin dump myrepos --revision 2001:3000 --incremental &gt; dumpfile3\n"

#: build/en/book.xml:11618(para)
msgid "These dump files could be loaded into a new repository with the following command sequence:"
msgstr "这些转储文件可以使用下列命令装载到一个新的版本库中："

#: build/en/book.xml:1162(para)
msgid "So why is this interesting? So far, this sounds like the definition of a typical file server. And indeed, the repository <emphasis>is</emphasis> a kind of file server, but it's not your usual breed. What makes the Subversion repository special is that <emphasis>it remembers every change</emphasis> ever written to it: every change to every file, and even changes to the directory tree itself, such as the addition, deletion, and rearrangement of files and directories."
msgstr "这有什么意义吗？说了这么多，Subversion听起来和一般的文件服务器没什么不同。事实上，Subversion的版本库的确<emphasis>是</emphasis>一种文件服务器，但不是“一般”的文件服务器。Subversion版本库的特别之处在于，<emphasis>它会记录每一次改变</emphasis>，每一次文件和目录结构的改变，（比如增加、删除和重新布置文件和目录）它都不会放过。"

#: build/en/book.xml:11621(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile1\n"
"$ svnadmin load newrepos &lt; dumpfile2\n"
"$ svnadmin load newrepos &lt; dumpfile3\n"
msgstr ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile1\n"
"$ svnadmin load newrepos &lt; dumpfile2\n"
"$ svnadmin load newrepos &lt; dumpfile3\n"

#: build/en/book.xml:11627(para)
#, fuzzy
msgid "Another neat trick you can perform with this <option>--incremental</option> option involves appending to an existing dump file a new range of dumped revisions. For example, you might have a <literal moreinfo=\"none\">post-commit</literal> hook that simply appends the repository dump of the single revision that triggered the hook. Or you might have a script that runs nightly to append dump file data for all the revisions that were added to the repository since the last time the script ran. Used like this, <command moreinfo=\"none\">svnadmin dump</command> can be one way to backup changes to your repository over time in case of a system crash or some other catastrophic event."
msgstr "另一个有关的技巧是，可以使用<option>--incremental</option>选项在一个转储文件中增加新的转储修订版本。举个例子，可以使用<literal moreinfo=\"none\">post-commit</literal>钩子在每次新的修订版本提交后将其转储到文件中。或者，可以编写一个脚本，在每天夜里将所有新增的修订版本转储到文件中。这样，<command moreinfo=\"none\">svnadmin</command>的<literal moreinfo=\"none\">dump</literal>和<literal moreinfo=\"none\">load</literal>命令就变成了很好的版本库备份工具，万一出现系统崩溃或其它灾难性事件，它的价值就体现出来了。"

#: build/en/book.xml:11639(para)
msgid "The dump format can also be used to merge the contents of several different repositories into a single repository. By using the <option>--parent-dir</option> option of <command moreinfo=\"none\">svnadmin load</command>, you can specify a new virtual root directory for the load process. That means if you have dump files for three repositories, say <filename moreinfo=\"none\">calc-dumpfile</filename>, <filename moreinfo=\"none\">cal-dumpfile</filename>, and <filename moreinfo=\"none\">ss-dumpfile</filename>, you can first create a new repository to hold them all:"
msgstr "转储还可以用来将几个独立的版本库合并为一个版本库。使用<command moreinfo=\"none\">svnadmin load</command>的<option>--parent-dir</option>选项，可以在装载的时候指定根目录。也就是说，如果有三个不同版本库的转储文件，比如<filename moreinfo=\"none\">calc-dumpfile</filename>，<filename moreinfo=\"none\">cal-dumpfile</filename>，和<filename moreinfo=\"none\">ss-dumpfile</filename>，可以在一个新的版本库中保存所有三个转储文件中的数据："

#: build/en/book.xml:11650(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create /path/to/projects\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin create /path/to/projects\n"
"$\n"

#: build/en/book.xml:11655(para)
msgid "Then, make new directories in the repository which will encapsulate the contents of each of the three previous repositories:"
msgstr "然后在版本库中创建三个目录分别保存来自三个不同版本库的数据："

#: build/en/book.xml:11659(screen)
#, no-wrap
msgid ""
"\n"
"$ svn mkdir -m \"Initial project roots\" \\\n"
"      file:///path/to/projects/calc \\\n"
"      file:///path/to/projects/calendar \\\n"
"      file:///path/to/projects/spreadsheet\n"
"Committed revision 1.\n"
"$ \n"
msgstr ""
"\n"
"$ svn mkdir -m \"Initial project roots\" \\\n"
"      file:///path/to/projects/calc \\\n"
"      file:///path/to/projects/calendar \\\n"
"      file:///path/to/projects/spreadsheet\n"
"Committed revision 1.\n"
"$ \n"

#: build/en/book.xml:11668(para)
msgid "Lastly, load the individual dump files into their respective locations in the new repository:"
msgstr "最后，将转储文件分别装载到各自的目录中："

#: build/en/book.xml:11671(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile\n"
"…\n"
"$\n"

#: build/en/book.xml:11681(para)
#, fuzzy
msgid "We'll mention one final way to use the Subversion repository dump format—conversion from a different storage mechanism or version control system altogether. Because the dump file format is, for the most part, human-readable, it should be relatively easy to describe generic sets of changes—each of which should be treated as a new revision—using this file format. In fact, the <command moreinfo=\"none\">cvs2svn</command> utility (see <xref linkend=\"svn.forcvs.convert\"/>) uses the dump format to represent the contents of a CVS repository so that those contents can be copied into a Subversion repository."
msgstr "我们再介绍一下Subversion版本库转储数据的最后一种用途——在不同的存储机制或版本控制系统之间转换。因为转储数据的格式的大部分是可以阅读的，<footnote><placeholder-1/></footnote>所以使用这种格式描述变更集（每个变更集对应一个新的修订版本）会相对容易一些。事实上，<command moreinfo=\"none\">cvs2svn</command>工具（参见 <xref linkend=\"svn.forcvs.convert\"/>）正是将CVS版本库的内容转换为转储数据格式，如此才能将CVS版本库的数据导入Subversion版本库之中。"

#: build/en/book.xml:11696(title)
#, fuzzy
msgid "Filtering Repository History"
msgstr "比较版本库与版本库"

#: build/en/book.xml:11698(para)
#, fuzzy
msgid "Since Subversion stores your versioned history using, at the very least, binary differencing algorithms and data compression (optionally in a completely opaque database system), attempting manual tweaks is unwise, if not quite difficult, and at any rate strongly discouraged. And once data has been stored in your repository, Subversion generally doesn't provide an easy way to remove that data. <placeholder-1/> But inevitably, there will be times when you would like to manipulate the history of your repository. You might need to strip out all instances of a file that was accidentally added to the repository (and shouldn't be there for whatever reason). <placeholder-2/> Or, perhaps you have multiple projects sharing a single repository, and you decide to split them up into their own repositories. To accomplish tasks like this, administrators need a more manageable and malleable representation of the data in their repositories—the Subversion repository dump format."
msgstr "因为Subversion使用底层的数据库储存各类数据，手工调整是不明智的，即使这样做并不困难。何况，一旦你的数据存进了版本库，通常很难再将它们从版本库中删除。<footnote><placeholder-1/></footnote>但是不可避免的，总会有些时候你需要处理版本库的历史数据。你也许想把一个不应该出现的文件从版本库中彻底清除。或者，你曾经用一个版本库管理多个工程，现在又想把它们分开。要完成这样的工作，管理员们需要更易于管理和扩展的方法表示版本库中的数据，Subversion版本库转储文件格式就是一个很好的选择。"

#: build/en/book.xml:11706(para)
msgid "That's rather the reason you use version control at all, right?"
msgstr ""

#: build/en/book.xml:1171(para)
msgid "When a client reads data from the repository, it normally sees only the latest version of the filesystem tree. But the client also has the ability to view <emphasis>previous</emphasis> states of the filesystem. For example, a client can ask historical questions like, <quote>What did this directory contain last Wednesday?</quote> or <quote>Who was the last person to change this file, and what changes did he make?</quote> These are the sorts of questions that are at the heart of any <firstterm>version control system</firstterm>: systems that are designed to record and track changes to data over time."
msgstr "一般情况下，客户端从版本库中获取的数据是文件系统树中的最新数据。但是客户端也具备查看文件系统树<emphasis>以前</emphasis>任何一个状态的能力。举个例子，客户端有时会对一些历史性问题感兴趣，比如<quote>上星期三时的目录结构是什么样的？</quote>或者<quote>谁最后一个修改了这个文件，都修改了什么？</quote>为了回答类似的问题，<firstterm>版本控制系统</firstterm>产生了。它的主要设计目的即是记录和跟踪数据的变化。"

#: build/en/book.xml:11715(para)
msgid "Conscious, cautious removal of certain bits of versioned data is actually supported by real use-cases. That's why an <quote>obliterate</quote> feature has been one of the most highly requested Subversion features, and one which the Subversion developers hope to soon provide."
msgstr ""

#: build/en/book.xml:11729(para)
#, fuzzy
msgid "As we described in <xref linkend=\"svn.reposadmin.maint.migrate\"/>, the Subversion repository dump format is a human-readable representation of the changes that you've made to your versioned data over time. You use the <command moreinfo=\"none\">svnadmin dump</command> command to generate the dump data, and <command moreinfo=\"none\">svnadmin load</command> to populate a new repository with it (see <xref linkend=\"svn.reposadmin.maint.migrate\"/>). The great thing about the human-readability aspect of the dump format is that, if you aren't careless about it, you can manually inspect and modify it. Of course, the downside is that if you have three years' worth of repository activity encapsulated in what is likely to be a very large dump file, it could take you a long, long time to manually inspect and modify it."
msgstr "Subversion版本库转储文件记录了所有版本数据的变更信息，而且以易于阅读的格式保存。可以使用<command moreinfo=\"none\">svnadmin dump</command>命令生成转储文件，然后用<command moreinfo=\"none\">svnadmin load</command>命令生成一个新的版本库。（参见 <xref linkend=\"svn.reposadmin.maint.migrate\"/>）。转储文件易于阅读意味着你可以小心翼翼的查看和修改它。当然，问题是如果你有一个运行了两年的版本库，那么生成的转储文件会很庞大，阅读和手工修改起来都会花费很多时间。"

#: build/en/book.xml:11744(para)
#, fuzzy
msgid "That's where <command moreinfo=\"none\">svndumpfilter</command> becomes useful. This program acts as path-based filter for repository dump streams. Simply give it either a list of paths you wish to keep, or a list of paths you wish to not keep, then pipe your repository dump data through this filter. The result will be a modified stream of dump data that contains only the versioned paths you (explicitly or implicitly) requested."
msgstr "虽然在管理员的日常工作中并不会经常使用，不过<command moreinfo=\"none\">svndumpfilter</command>可以对特定的路径进行过滤。这是一个独特而很有意义的用法，可以帮助你快速方便的修改转储的数据。使用时，只需提供一个你想要保留的（或者不想保留的）路径列表，然后把你的版本库转储文件送进这个过滤器。最后你就可以得到一个仅包含你想保留的路径的转储数据流。"

#: build/en/book.xml:11753(para)
msgid "Let's look a realistic example of how you might use this program. We discuss elsewhere (see <xref linkend=\"svn.reposadmin.projects.chooselayout\"/>) the process of deciding how to choose a layout for the data in your repositories—using one repository per project or combining them, arranging stuff within your repository, and so on. But sometimes after new revisions start flying in, you rethink your layout and would like to make some changes. A common change is the decision to move multiple projects which are sharing a single repository into separate repositories for each project."
msgstr "现在我来演示如何使用这个命令。我们会在其它章节（参见 <xref linkend=\"svn.reposadmin.projects.chooselayout\"/>）讨论关于如何选择设定版本库布局的问题，比如应该使用一个版本库管理多个项目还是使用一个版本库管理一个项目，或者如何在版本库中安排数据等等。不过，有些时候，即使在项目已经展开以后，你还是希望对版本库的布局做一些调整。最常见的情况是，把原来存放在同一个版本库中的几个项目分开，各自成家。"

#: build/en/book.xml:11764(para)
msgid "Our imaginary repository contains three projects: <literal moreinfo=\"none\">calc</literal>, <literal moreinfo=\"none\">calendar</literal>, and <literal moreinfo=\"none\">spreadsheet</literal>. They have been living side-by-side in a layout like this:"
msgstr "假设有一个包含三个项目的版本库： <literal moreinfo=\"none\">calc</literal>，<literal moreinfo=\"none\">calendar</literal>，和 <literal moreinfo=\"none\">spreadsheet</literal>。它们在版本库中的布局如下："

#: build/en/book.xml:11769(screen)
#, no-wrap
msgid ""
"\n"
"/\n"
"   calc/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   calendar/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   spreadsheet/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
msgstr ""
"\n"
"/\n"
"   calc/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   calendar/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   spreadsheet/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"

#: build/en/book.xml:11785(para)
msgid "To get these three projects into their own repositories, we first dump the whole repository:"
msgstr "现在要把这三个项目转移到三个独立的版本库中。首先，转储整个版本库："

#: build/en/book.xml:11788(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin dump /path/to/repos &gt; repos-dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"* Dumped revision 3.\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin dump /path/to/repos &gt; repos-dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"* Dumped revision 3.\n"
"…\n"
"$\n"

#: build/en/book.xml:11798(para)
msgid "Next, run that dump file through the filter, each time including only one of our top-level directories, and resulting in three new dump files:"
msgstr "然后，将转储文件三次送入过滤器，每次仅保留一个顶级目录，就可以得到三个转储文件："

#: build/en/book.xml:118(para)
msgid "What I love about this book is that it grew out of just such a process, and shows it on every page. It is the direct result of the authors' encounters with users. It began with Ben Collins-Sussman's observation that people were asking the same basic questions over and over on the Subversion mailing lists: What are the standard workflows to use with Subversion? Do branches and tags work the same way as in other version control systems? How can I find out who made a particular change?"
msgstr "我很喜欢这本书，因为它正是按照这种精神建立起来的，这种精神体现在本书的每一页中。这是作者与用户直接交流的结果。而这一切是源于Ben Collins-Sussman's对于Subversion常见问题邮件列表的研究。他发现人们总是在邮件列表中重复询问一些基本问题：使用subversion的一般程序是怎样的？分支与标签同其它版本控制系统的工作方式一样吗？我怎样知道某一处修改是谁做的？"

#: build/en/book.xml:11802(screen)
#, fuzzy, no-wrap
msgid ""
"\n"
"$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile\n"
"…\n"
"$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile\n"
"…\n"
"$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile\n"
"…\n"
"$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile\n"
"…\n"
"$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile\n"
"…\n"
"$\n"

#: build/en/book.xml:11812(para)
msgid "At this point, you have to make a decision. Each of your dump files will create a valid repository, but will preserve the paths exactly as they were in the original repository. This means that even though you would have a repository solely for your <literal moreinfo=\"none\">calc</literal> project, that repository would still have a top-level directory named <filename moreinfo=\"none\">calc</filename>. If you want your <filename moreinfo=\"none\">trunk</filename>, <filename moreinfo=\"none\">tags</filename>, and <filename moreinfo=\"none\">branches</filename> directories to live in the root of your repository, you might wish to edit your dump files, tweaking the <literal moreinfo=\"none\">Node-path</literal> and <literal moreinfo=\"none\">Node-copyfrom-path</literal> headers to no longer have that first <filename moreinfo=\"none\">calc/</filename> path component. Also, you'll want to remove the section of dump data that creates the <filename moreinfo=\"none\">calc</filename> directory. It will look something like:"
msgstr "现在你必须要作出一个决定了。这三个转储文件中，每个都可以用来创建一个可用的版本库，不过它们保留了原版本库的精确路径结构。也就是说，虽然项目<literal moreinfo=\"none\">calc</literal>现在独占了一个版本库，但版本库中还保留着名为<filename moreinfo=\"none\">calc</filename>的顶级目录。如果希望<filename moreinfo=\"none\">trunk</filename>、<filename moreinfo=\"none\">tags</filename>和<filename moreinfo=\"none\">branches</filename>这三个目录直接位于版本库的根路径下，你可能需要编辑转储文件，调整<literal moreinfo=\"none\">Node-path</literal>和<literal moreinfo=\"none\">Copyfrom-path</literal>头参数，将路径<filename moreinfo=\"none\">calc/</filename>删除。同时，你还要删除转储数据中创建<filename moreinfo=\"none\">calc</filename>目录的部分。一般来说，就是如下的一些内容："

#: build/en/book.xml:11829(screen)
#, fuzzy, no-wrap
msgid ""
"\n"
"Node-path: calc\n"
"Node-action: add\n"
"Node-kind: dir\n"
"Content-length: 0\n"
"  \n"
msgstr ""
"\n"
"Node-path: calc\n"
"Node-action: add\n"
"Node-kind: dir\n"
"Content-length: 0\n"
"\n"

#: build/en/book.xml:11838(para)
#, fuzzy
msgid "If you do plan on manually editing the dump file to remove a top-level directory, make sure that your editor is not set to automatically convert end-lines to the native format (e.g. \\r\\n to \\n) as the content will then not agree with the metadata. This will render the dump file useless."
msgstr "如果你打算通过手工编辑转储文件来移除一个顶级目录，注意不要让你的编辑器将换行符转换为本地格式（比如将\\r\\n转换为\\n）。否则文件的内容就与所需的格式不相符，这个转储文件也就失效了。"

#: build/en/book.xml:11846(para)
msgid "All that remains now is to create your three new repositories, and load each dump file into the right repository:"
msgstr "剩下的工作就是创建三个新的版本库，然后将三个转储文件分别导入："

#: build/en/book.xml:11850(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile\n"
"&lt;&lt;&lt; Started new transaction, based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : button.c ... done.\n"
"…\n"
"$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile\n"
"&lt;&lt;&lt; Started new transaction, based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : cal.c ... done.\n"
"…\n"
"$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile\n"
"&lt;&lt;&lt; Started new transaction, based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : ss.c ... done.\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile\n"
"&lt;&lt;&lt; Started new transaction， based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : button.c ... done.\n"
"…\n"
"$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile\n"
"&lt;&lt;&lt; Started new transaction， based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : cal.c ... done.\n"
"…\n"
"$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile\n"
"&lt;&lt;&lt; Started new transaction， based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : ss.c ... done.\n"
"…\n"
"$\n"

#: build/en/book.xml:11869(para)
msgid "Both of <command moreinfo=\"none\">svndumpfilter</command>'s subcommands accept options for deciding how to deal with <quote>empty</quote> revisions. If a given revision contained only changes to paths that were filtered out, that now-empty revision could be considered uninteresting or even unwanted. So to give the user control over what to do with those revisions, <command moreinfo=\"none\">svndumpfilter</command> provides the following command-line options:"
msgstr "<command moreinfo=\"none\">svndumpfilter</command>的两个子命令都可以通过选项设定如何处理<quote>空</quote>修订版本。如果某个指定的修订版本仅包含路径的更改，过滤器就会将它删除，因为当前为空的修订版本通常是无用的甚至是让人讨厌的。为了让用户有选择的处理这些修订版本，<command moreinfo=\"none\">svndumpfilter</command>提供了以下命令行选项："

#: build/en/book.xml:11880(option)
msgid "--drop-empty-revs"
msgstr "--drop-empty-revs"

#: build/en/book.xml:11882(para)
msgid "Do not generate empty revisions at all—just omit them."
msgstr "不生成任何空修订版本，忽略它们。"

#: build/en/book.xml:11887(option)
msgid "--renumber-revs"
msgstr "--renumber-revs"

#: build/en/book.xml:11889(para)
msgid "If empty revisions are dropped (using the <option>--drop-empty-revs</option> option), change the revision numbers of the remaining revisions so that there are no gaps in the numeric sequence."
msgstr "如果空修订版本被剔除（通过使用<option>--drop-empty-revs</option>选项），依次修改其它修订版本的编号，确保编号序列是连续的。"

#: build/en/book.xml:1189(title)
msgid "Versioning Models"
msgstr "版本模型"

#: build/en/book.xml:11896(option)
msgid "--preserve-revprops"
msgstr "--preserve-revprops"

#: build/en/book.xml:11898(para)
msgid "If empty revisions are not dropped, preserve the revision properties (log message, author, date, custom properties, etc.) for those empty revisions. Otherwise, empty revisions will only contain the original datestamp, and a generated log message that indicates that this revision was emptied by <command moreinfo=\"none\">svndumpfilter</command>."
msgstr "如果空修订版本被保留，保持这些空修订版本的属性（日志信息，作者，日期，自定义属性，等等）。如果不设定这个选项，空修订版本将仅保留初始时间戳，以及一个自动生成的日志信息，表明此修订版本由<command moreinfo=\"none\">svndumpfilter</command>处理过。"

#: build/en/book.xml:11909(para)
msgid "While <command moreinfo=\"none\">svndumpfilter</command> can be very useful, and a huge timesaver, there are unfortunately a couple of gotchas. First, this utility is overly sensitive to path semantics. Pay attention to whether paths in your dump file are specified with or without leading slashes. You'll want to look at the <literal moreinfo=\"none\">Node-path</literal> and <literal moreinfo=\"none\">Node-copyfrom-path</literal> headers."
msgstr "尽管<command moreinfo=\"none\">svndumpfilter</command>十分有用，能节省大量的时间，但它却是把不折不扣的双刃剑。首先，这个工具对路径语义极为敏感。仔细检查转储文件中的路径是不是以斜线开头。也许<literal moreinfo=\"none\">Node-path</literal>和<literal moreinfo=\"none\">Copyfrom-path</literal>这两个头参数对你有些帮助。"

#: build/en/book.xml:1191(para)
msgid "The core mission of a version control system is to enable collaborative editing and sharing of data. But different systems use different strategies to achieve this. It's important to understand these different strategies for a couple of reasons. First, it will help you compare and contrast existing version control systems, in case you encounter other systems similar to Subversion. Beyond that, it will also help you make more effective use of Subversion, since Subversion itself supports a couple of different ways of working."
msgstr ""

#: build/en/book.xml:11917(screen)
#, no-wrap
msgid ""
"\n"
"…\n"
"Node-path: spreadsheet/Makefile\n"
"…\n"
msgstr ""
"\n"
"…\n"
"Node-path: spreadsheet/Makefile\n"
"…\n"

#: build/en/book.xml:11923(para)
#, fuzzy
msgid "If the paths have leading slashes, you should include leading slashes in the paths you pass to <command moreinfo=\"none\">svndumpfilter include</command> and <command moreinfo=\"none\">svndumpfilter exclude</command> (and if they don't, you shouldn't). Further, if your dump file has an inconsistent usage of leading slashes for some reason, <placeholder-1/> you should probably normalize those paths so they all have, or lack, leading slashes."
msgstr "如果这些路径以斜线开头，那么你传递给<command moreinfo=\"none\">svndumpfilter include</command>和<command moreinfo=\"none\">svndumpfilter exclude</command>的路径也必须以斜线开头（反之亦然）。如果因为某些原因转储文件中的路径没有统一使用或不使用斜线开头，<footnote><placeholder-1/></footnote>也许需要修正这些路径，统一使用斜线开头或不使用斜线开头。"

#: build/en/book.xml:11930(para)
msgid "While <command moreinfo=\"none\">svnadmin dump</command> has a consistent leading slash policy—to not include them—other programs which generate dump data might not be so consistent."
msgstr "尽管<command moreinfo=\"none\">svnadmin dump</command>对是否以斜线作为路径的开头有统一的规定——这个规定就是不以斜线作为路径的开头——其它生成转储文件的程序不一定会遵守这个规定。"

#: build/en/book.xml:11938(para)
msgid "Also, copied paths can give you some trouble. Subversion supports copy operations in the repository, where a new path is created by copying some already existing path. It is possible that at some point in the lifetime of your repository, you might have copied a file or directory from some location that <command moreinfo=\"none\">svndumpfilter</command> is excluding, to a location that it is including. In order to make the dump data self-sufficient, <command moreinfo=\"none\">svndumpfilter</command> needs to still show the addition of the new path—including the contents of any files created by the copy—and not represent that addition as a copy from a source that won't exist in your filtered dump data stream. But because the Subversion repository dump format only shows what was changed in each revision, the contents of the copy source might not be readily available. If you suspect that you have any copies of this sort in your repository, you might want to rethink your set of included/excluded paths."
msgstr "此外，复制操作生成的路径也会带来麻烦。Subversion支持在版本库中进行复制操作，也就是复制一个存在的路径，生成一个新的路径。问题是，<command moreinfo=\"none\">svndumpfilter</command>保留的某个文件或目录可能是由某个<command moreinfo=\"none\">svndumpfilter</command>排除的文件或目录复制而来的。也就是说，为了确保转储数据的完整性，<command moreinfo=\"none\">svndumpfilter</command>需要切断这些复制自被排除路径的文件与源文件的关系，还要将这些文件的内容以新建的方式添加到转储数据中。但是由于Subversion版本库转储文件格式中仅包含了修订版本的更改信息，因此源文件的内容基本上无法获得。如果你不能确定版本库中是否存在类似的情况，最好重新考虑一下到底保留/排除哪些路径。"

#: build/en/book.xml:11957(para)
msgid "Finally, <command moreinfo=\"none\">svndumpfilter</command> takes path filtering quite literally. If you are trying to copy the history of a project rooted at <filename moreinfo=\"none\">trunk/my-project</filename> and move it into a repository of its own, you would, of course, use the <command moreinfo=\"none\">svndumpfilter include</command> command to keep all the changes in and under <filename moreinfo=\"none\">trunk/my-project</filename>. But the resulting dump file makes no assumptions about the repository into which you plan to load this data. Specifically, the dump data might begin with the revision which added the <filename moreinfo=\"none\">trunk/my-project</filename> directory, but it will <emphasis>not</emphasis> contain directives which would create the <filename moreinfo=\"none\">trunk</filename> directory itself (because <filename moreinfo=\"none\">trunk</filename> doesn't match the include filter). You'll need to make sure that any directories which the new dump stream expect to exist actually do exist in the target repository before trying to load the stream into that repository."
msgstr ""

#: build/en/book.xml:11981(title)
#, fuzzy
msgid "Repository Replication"
msgstr "版本库的恢复"

#: build/en/book.xml:11983(para)
msgid "There are several scenarios in which it is quite handy to have a Subversion repository whose version history is exactly the same as some other repository's. Perhaps the most obvious one is the maintenance of a simple backup repository, used when the primary repository has become inaccessible due to a hardware failure, network outage, or other such annoyance. Other scenarios include deploying mirror repositories to distribute heavy Subversion load across multiple servers, use as a soft-upgrade mechanism, and so on."
msgstr ""

#: build/en/book.xml:11993(para)
msgid "As of version 1.4, Subversion provides a program for managing scenarios like these—<command moreinfo=\"none\">svnsync</command>. <command moreinfo=\"none\">svnsync</command> works by essentially asking the Subversion server to <quote>replay</quote> revisions, one at a time. It then uses that revision information to mimic a commit of the same to another repository. Neither repository needs to be locally accessible to machine on which <command moreinfo=\"none\">svnsync</command> is running—its parameters are repository URLs, and it does all its work through Subversion's repository access (RA) interfaces. All it requires is read access to the source repository and read/write access to the destination repository."
msgstr ""

#. don't seem to render it.
#: build/en/book.xml:12(subtitle)
#, fuzzy
msgid "(Compiled from r2789)"
msgstr "(本书由 r2788 版本构建)"

#: build/en/book.xml:12008(para)
msgid "When using <command moreinfo=\"none\">svnsync</command> against a remote source repository, the Subversion server for that repository must be running Subversion version 1.4 or better."
msgstr ""

#: build/en/book.xml:12013(para)
msgid "Assuming you already have a source repository that you'd like to mirror, the next thing you need is an empty target repository which will actually serve as that mirror. This target repository can use either of the available filesystem data-store back-ends (see <xref linkend=\"svn.reposadmin.basics.backends\"/>), but it must not yet have any version history in it. The protocol via which <command moreinfo=\"none\">svnsync</command> communicates revision information is highly sensitive to mismatches between the versioned histories contained in the source and target repositories. For this reason, while <command moreinfo=\"none\">svnsync</command> cannot <emphasis>demand</emphasis> that the target repository be read-only, <placeholder-1/> allowing the revision history in the target repository to change by any mechanism other than the mirroring process is a recipe for disaster."
msgstr ""

#: build/en/book.xml:12026(para)
msgid "In fact, it can't truly be read-only, or <command moreinfo=\"none\">svnsync</command> itself would have a tough time copying revision history into it."
msgstr ""

#: build/en/book.xml:1203(title)
msgid "The Problem of File-Sharing"
msgstr "文件共享的问题"

#: build/en/book.xml:12035(para)
msgid "Do <emphasis>not</emphasis> modify a mirror repository in such a way as to cause its version history to deviate from that of the repository it mirrors. The only commits and revision property modifications that ever occur on that mirror repository should be those performed by the <command moreinfo=\"none\">svnsync</command> tool."
msgstr ""

#: build/en/book.xml:12043(para)
msgid "Another requirement of the target repository is that the <command moreinfo=\"none\">svnsync</command> process be allowed to modify certain revision properties. <command moreinfo=\"none\">svnsync</command> stores its bookkeeping information in special revision properties on revision 0 of the destination repository. Because <command moreinfo=\"none\">svnsync</command> works within the framework of that repository's hook system, the default state of the repository (which is to disallow revision property changes; see <xref linkend=\"svn.ref.reposhooks.pre-revprop-change\"/>) is insufficient. You'll need to explicitly implement the pre-revprop-change hook, and your script must allow <command moreinfo=\"none\">svnsync</command> to set and change its special properties. With those provisions in place, you are ready to start mirroring repository revisions."
msgstr ""

#: build/en/book.xml:1205(para)
msgid "All version control systems have to solve the same fundamental problem: how will the system allow users to share information, but prevent them from accidentally stepping on each other's feet? It's all too easy for users to accidentally overwrite each other's changes in the repository."
msgstr "所有的版本控制系统都需要解决这样一个基础问题：怎样让系统允许用户共享信息，而不会让他们因意外而互相干扰？版本库里意外覆盖别人的更改非常的容易。"

#: build/en/book.xml:12059(para)
msgid "It's a good idea to implement authorization measures which allow your repository replication process to perform its tasks while preventing other users from modifying the contents of your mirror repository at all."
msgstr ""

#: build/en/book.xml:12065(para)
msgid "Let's walk through the use of <command moreinfo=\"none\">svnsync</command> in a somewhat typical mirroring scenario. We'll pepper this discourse with practical recommendations which you are free to disregard if they aren't required by or suitable for your environment."
msgstr ""

#: build/en/book.xml:12071(para)
msgid "As a service to the fine developers of our favorite version control system, we will be mirroring the public Subversion source code repository and exposing that mirror publicly on the Internet, hosted on a different machine than the one on which the original Subversion source code repository lives. This remote host has a global configuration which permits anonymous users to read the contents of repositories on the host, but requires users to authenticate in order to modify those repositories. (Please forgive us for glossing over the details of Subversion server configuration for the moment—those are covered thoroughly in <xref linkend=\"svn.serverconfig\"/>.) And for no other reason than that it makes for a more interesting example, we'll be driving the replication process from a third machine, the one which we currently find ourselves using."
msgstr ""

#: build/en/book.xml:12086(para)
msgid "First, we'll create the repository which will be our mirror. This and the next couple of steps do require shell access to the machine on which the mirror repository will live. Once the repository is all configured, though, we shouldn't need to touch it directly again."
msgstr ""

#: build/en/book.xml:12092(screen)
#, no-wrap
msgid ""
"\n"
"$ ssh admin@svn.example.com \\\n"
"      \"svnadmin create /path/to/repositories/svn-mirror\"\n"
"admin@svn.example.com's password: ********\n"
"$\n"
msgstr ""

#: build/en/book.xml:12099(para)
msgid "At this point, we have our repository, and due to our server's configuration, that repository is now <quote>live</quote> on the Internet. Now, because we don't want anything modifying the repository except our replication process, we need a way to distinguish that process from other would-be committers. To do so, we use a dedicated username for our process. Only commits and revision property modifications performed by the special username <literal moreinfo=\"none\">syncuser</literal> will be allowed."
msgstr ""

#: build/en/book.xml:12109(para)
msgid "We'll use the repository's hook system both to allow the replication process to do what it needs to do, and to enforce that only it is doing those things. We accomplish this by implementing two of the repository event hooks—pre-revprop-change and start-commit. Our <filename moreinfo=\"none\">pre-revprop-change</filename> hook script is found in <xref linkend=\"svn.reposadmin.maint.replication.pre-revprop-change\"/>, and basically verifies that the user attempting the property changes is our <literal moreinfo=\"none\">syncuser</literal> user. If so, the change is allowed; otherwise, it is denied."
msgstr ""

#: build/en/book.xml:1212(para)
msgid "Consider the scenario shown in <xref linkend=\"svn.basic.vsn-models.problem-sharing.dia-1\"/>. Suppose we have two co-workers, Harry and Sally. They each decide to edit the same repository file at the same time. If Harry saves his changes to the repository first, then it's possible that (a few moments later) Sally could accidentally overwrite them with her own new version of the file. While Harry's version of the file won't be lost forever (because the system remembers every change), any changes Harry made <emphasis>won't</emphasis> be present in Sally's newer version of the file, because she never saw Harry's changes to begin with. Harry's work is still effectively lost—or at least missing from the latest version of the file—and probably by accident. This is definitely a situation we want to avoid!"
msgstr "考虑<xref linkend=\"svn.basic.vsn-models.problem-sharing.dia-1\"/>的情景，我们有两个共同工作者，Harry和Sally，他们想同时编辑版本库里的同一个文件，如果首先Harry保存它的修改，过了一会，Sally可能凑巧用自己的版本覆盖了这些文件，Harry的更改不会永远消失（因为系统记录了每次修改），Harry所有的修改<emphasis>不会</emphasis>出现在Sally的文件中，所以Harry的工作还是丢失了—至少是从最新的版本中丢失了—而且是意外的，这就是我们要明确避免的情况！"

#: build/en/book.xml:12120(title)
msgid "Mirror repository's pre-revprop-change hook script"
msgstr ""

#: build/en/book.xml:12122(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh \n"
"\n"
"USER=\"$3\"\n"
"\n"
"if [ \"$USER\" = \"syncuser\" ]; then exit 0; fi\n"
"\n"
"echo \"Only the syncuser user may change revision properties\" &gt;&amp;2\n"
"exit 1\n"
msgstr ""

#: build/en/book.xml:12134(para)
msgid "That covers revision property changes. Now we need to ensure that only the <literal moreinfo=\"none\">syncuser</literal> user is permitted to commit new revisions to the repository. We do this using a <filename moreinfo=\"none\">start-commit</filename> hook scripts like the one in <xref linkend=\"svn.reposadmin.maint.replication.start-commit\"/>."
msgstr ""

#: build/en/book.xml:12141(title)
msgid "Mirror repository's start-commit hook script"
msgstr ""

#: build/en/book.xml:12143(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh \n"
"\n"
"USER=\"$2\"\n"
"\n"
"if [ \"$USER\" = \"syncuser\" ]; then exit 0; fi\n"
"\n"
"echo \"Only the syncuser user may commit new revisions\" &gt;&amp;2\n"
"exit 1\n"
msgstr ""

#: build/en/book.xml:12155(para)
msgid "After installing our hook scripts and ensuring that they are executable by the Subversion server, we're finished with the setup of the mirror repository. Now, we get to actually do the mirroring."
msgstr ""

#: build/en/book.xml:12160(para)
msgid "The first thing we need to do with <command moreinfo=\"none\">svnsync</command> is to register in our target repository the fact that it will be a mirror of the source repository. We do this using the <command moreinfo=\"none\">svnsync initialize</command> subcommand. Note that the various <command moreinfo=\"none\">svnsync</command> subcommands provide several of the same authentication-related options that <command moreinfo=\"none\">svn</command> does: <option>--username</option>, <option>--password</option>, <option>--non-interactive</option>, <option>--config-dir</option>, and <option>--no-auth-cache</option>."
msgstr ""

#: build/en/book.xml:12173(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help init\n"
"initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL\n"
"\n"
"Initialize a destination repository for synchronization from\n"
"another repository.\n"
"\n"
"The destination URL must point to the root of a repository with\n"
"no committed revisions.  The destination repository must allow\n"
"revision property changes.\n"
"\n"
"You should not commit to, or make revision property changes in,\n"
"the destination repository by any method other than 'svnsync'.\n"
"In other words, the destination repository should be a read-only\n"
"mirror of the source repository.\n"
"\n"
"Valid options:\n"
"  --non-interactive        : do no interactive prompting\n"
"  --no-auth-cache          : do not cache authentication tokens\n"
"  --username arg           : specify a username ARG\n"
"  --password arg           : specify a password ARG\n"
"  --config-dir arg         : read user configuration files from directory ARG\n"
"\n"
"$ svnsync initialize http://svn.example.com/svn-mirror \\\n"
"                     http://svn.collab.net/repos/svn \\\n"
"                     --username syncuser --password syncpass\n"
"Copied properties for revision 0.\n"
"$\n"
msgstr ""

#: build/en/book.xml:12203(para)
msgid "Our target repository will now remember that it is a mirror of the public Subversion source code repository. Notice that we provided a username and password as arguments to <command moreinfo=\"none\">svnsync</command>—that was required by the pre-revprop-change hook on our mirror repository."
msgstr ""

#: build/en/book.xml:12210(para)
msgid "The URLs provided to <command moreinfo=\"none\">svnsync</command> must point to the root directories of the target and source repositories, respectively. The tool does not handle mirroring of repository subtrees."
msgstr ""

#: build/en/book.xml:12217(para)
msgid "The initial release of <command moreinfo=\"none\">svnsync</command> (in Subversion 1.4) has a small shortcoming—the values given to the <option>--username</option> and <option>--password</option> command-line options get used for authentication against both the source and destination repositories. Obviously, there's no guarantee that the synchronizing user's credentials are the same in both places. In the event that they are not the same, users trying to run <command moreinfo=\"none\">svnsync</command> in non-interactive mode (with the <option>--non-interactive</option> option) might experience problems."
msgstr ""

#: build/en/book.xml:12230(para)
msgid "And now comes the fun part. With a single subcommand, we can tell <command moreinfo=\"none\">svnsync</command> to copy all the as-yet-unmirrored revisions from the source repository to the target. <placeholder-1/> The <command moreinfo=\"none\">svnsync synchronize</command> subcommand will peek into the special revision properties previously stored on the target repository, and determine what repository it is mirroring and that the most recently mirrored revision was revision 0. Then it will query the source repository and determine what the latest revision in that repository is. Finally, it asks the source repository's server to start replaying all the revisions between 0 and that latest revision. As <command moreinfo=\"none\">svnsync</command> get the resulting response from the source repository's server, it begins forwarding those revisions to the target repository's server as new commits."
msgstr ""

#: build/en/book.xml:12235(para)
msgid "Be forewarned that while it will take only a few seconds for the average reader to parse this paragraph and the sample output which follows it, the actual time required to complete such a mirroring operation is, shall we say, quite a bit longer."
msgstr ""

#: build/en/book.xml:12254(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help synchronize\n"
"synchronize (sync): usage: svnsync synchronize DEST_URL\n"
"\n"
"Transfer all pending revisions from source to destination.\n"
"…\n"
"$ svnsync synchronize http://svn.example.com/svn-mirror \\\n"
"                      --username syncuser --password syncpass\n"
"Committed revision 1.\n"
"Copied properties for revision 1.\n"
"Committed revision 2.\n"
"Copied properties for revision 2.\n"
"Committed revision 3.\n"
"Copied properties for revision 3.\n"
"…\n"
"Committed revision 23406.\n"
"Copied properties for revision 23406.\n"
"Committed revision 23407.\n"
"Copied properties for revision 23407.\n"
"Committed revision 23408.\n"
"Copied properties for revision 23408.\n"
msgstr ""

#: build/en/book.xml:12277(para)
msgid "Of particular interest here is that for each mirrored revision, there is first a commit of that revision to the target repository, and then property changes follow. This is because the initial commit is performed by (and attributed to) the user <literal moreinfo=\"none\">syncuser</literal>, and datestamped with the time as of that revision's creation. Also, Subversion's underlying repository access interfaces don't provide a mechanism for setting arbitary revision properties as part of a commit. So <command moreinfo=\"none\">svnsync</command> follows up with an immediate series of property modifications which copy all the revision properties found for that revision in the source repository into the target repository. This also has the effect of fixing the author and datestamp of the revision to match that of the source repository."
msgstr ""

#: build/en/book.xml:1228(title)
msgid "The problem to avoid"
msgstr "需要避免的问题"

#: build/en/book.xml:12292(para)
msgid "Also noteworthy is that <command moreinfo=\"none\">svnsync</command> performs careful bookkeeping that allows it to be safely interrupted and restarted without ruining the integrity of the mirrored data. If a network glitch occurs while mirroring a repository, simply repeat the <command moreinfo=\"none\">svnsync synchronize</command> command and it will happily pick up right where it left off. In fact, as new revisions appear in the source repository, this is exactly what you to do in order to keep your mirror up-to-date."
msgstr ""

#: build/en/book.xml:12302(para)
msgid "There is, however, one bit of inelegance in the process. Because Subversion revision properties can be changed at any time throughout the lifetime of the repository, and don't leave an audit trail that indicates when they were changed, replication processes have to pay special attention to them. If you've already mirror the first 15 revisions of a repository and someone then changes a revision property on revision 12, <command moreinfo=\"none\">svnsync</command> won't know to go back and patch up its copy of revision 12. You'll need to tell it to do so manually by using (or with some additionally tooling around) the <command moreinfo=\"none\">svnsync copy-revprops</command> subcommand, which simply re-replicates all the revision properties for a particular revision."
msgstr ""

#: build/en/book.xml:12316(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help copy-revprops\n"
"copy-revprops: usage: svnsync copy-revprops DEST_URL REV\n"
"\n"
"Copy all revision properties for revision REV from source to\n"
"destination.\n"
"…\n"
"$ svnsync copy-revprops http://svn.example.com/svn-mirror 12 \\\n"
"                        --username syncuser --password syncpass\n"
"Copied properties for revision 12.\n"
"$\n"
msgstr ""

#: build/en/book.xml:12329(para)
msgid "That's repository replication in a nutshell. You'll likely want some automation around such a process. For example, while our example was a pull-and-push setup, you might wish to have your primary repository push changes to one or more blessed mirrors as part of its post-commit and post-revprop-change hook implementations. This would enable the mirror to be up-to-date in as near to realtime as is likely possible."
msgstr ""

#: build/en/book.xml:12338(para)
msgid "Also, while it isn't very commonplace to do so, <command moreinfo=\"none\">svnsync</command> does gracefully mirror repositories in which the user as whom it authenticates only has partial read access. It simply copies only the bits of the repository that it is permitted to see. Obviously such a mirror is not useful as a backup solution."
msgstr ""

#: build/en/book.xml:12345(para)
msgid "As far as user interaction with repositories and mirrors goes, it <emphasis>is</emphasis> possible to have a single working copy that interacts with both, but you'll have to jump through some hoops to make it happen. First, you need to ensure that both the primary and mirror repositories have the same repository UUID (which is not the case by default). You can set the mirror repository's UUID by loading a dump file stub into it which contains the UUID of the primary repository, like so:"
msgstr ""

#: build/en/book.xml:12355(screen)
#, no-wrap
msgid ""
"\n"
"$ cat - &lt;&lt;EOF | svnadmin load --force-uuid dest\n"
"SVN-fs-dump-format-version: 2\n"
"\n"
"UUID: 65390229-12b7-0310-b90b-f21a5aa7ec8e\n"
"EOF\n"
"$\n"
msgstr ""

#: build/en/book.xml:1236(title)
msgid "The Lock-Modify-Unlock Solution"
msgstr "锁定-修改-解锁 方案"

#: build/en/book.xml:12364(para)
msgid "Now that the two repositories have the same UUID, you can use <command moreinfo=\"none\">svn switch --relocate</command> to point your working copy to whichever of the repositories you wish to operate against, a process which is described in <xref linkend=\"svn.ref.svn.c.switch\"/>. There is a possible danger here, though, in that if the primary and mirror repositories aren't in close synchronization, a working copy up-to-date with and pointing to the primary repository will, if relocated to point to an out-of-date mirror, become confused about the apparent sudden loss of revisions it fully expects to be present."
msgstr ""

#: build/en/book.xml:12375(para)
msgid "Finally, be aware that the revision-based replication provided by <command moreinfo=\"none\">svnsync</command> is only that—replication of revisions. It does not include such things as the hook implementations, repository or server configuration data, uncommitted transactions, or information about user locks on repository paths. Only information carried by the Subversion repository dump file format is available for replication."
msgstr ""

#: build/en/book.xml:1238(para)
msgid "Many version control systems use a <firstterm>lock-modify-unlock</firstterm> model to address the problem of many authors clobbering each other's work. In this model, the repository allows only one person to change a file at a time. This exclusivity policy is managed using locks. Harry must <quote>lock</quote> a file before he can begin making changes to it. If Harry has locked a file, then Sally cannot also lock it, and therefore cannot make any changes to that file. All she can do is read the file, and wait for Harry to finish his changes and release his lock. After Harry unlocks the file, Sally can take her turn by locking and editing the file. <xref linkend=\"svn.basic.vsn-models.lock-unlock.dia-1\"/> demonstrates this simple solution."
msgstr "许多版本控制系统使用<firstterm>锁定-修改-解锁</firstterm>这种机制解决这种问题，在这样的模型里，在一个时间段里版本库的一个文件只允许被一个人修改。首先在修改之前，Harry要<quote>锁定</quote>住这个文件，锁定很像是从图书馆借一本书，如果Harry锁住这个文件，Sally不能做任何修改，如果Sally想请求得到一个锁，版本库会拒绝这个请求。在Harry结束编辑并且放开这个锁之前，她只可以阅读文件。Harry解锁后，就要换班了，Sally得到自己的轮换位置，锁定并且开始编辑这个文件。<xref linkend=\"svn.basic.vsn-models.lock-unlock.dia-1\"/>描述了这样的解决方案。"

#: build/en/book.xml:12388(title)
msgid "Repository Backup"
msgstr "版本库备份"

#: build/en/book.xml:12390(para)
msgid "Despite numerous advances in technology since the birth of the modern computer, one thing unfortunately rings true with crystalline clarity—sometimes, things go very, very awry. Power outages, network connectivity dropouts, corrupt RAM and crashed hard drives are but a taste of the evil that Fate is poised to unleash on even the most conscientious administrator. And so we arrive at a very important topic—how to make backup copies of your repository data."
msgstr "尽管现代计算机的诞生带来了许多便利，但有一件事听起来是完全正确的—有时候，事情变的糟糕，很糟糕，动力损耗、网络中断、坏掉的内存和损坏的硬盘都是对魔鬼的一种体验，即使对于最尽职的管理员，命运也早已注定。所以我们来到了这个最重要的主题—怎样备份你的版本库数据。"

#: build/en/book.xml:12400(para)
msgid "There are two types of backup methods available for Subversion repository administrators—full and incremental. A full backup of the repository involves squirreling away in one sweeping action all the information required to fully reconstruct that repository in the event of a catastrophe. Usually, it means quite literally the duplication of the entire repository directory (which includes either a Berkeley DB or FSFS environment). Incremental backups are lesser things, backups of only the portion of the repository data that has changed since the previous backup."
msgstr ""

#: build/en/book.xml:12412(para)
msgid "As far as full backups go, the naive approach might seem like a sane one, but unless you temporarily disable all other access to your repository, simply doing a recursive directory copy runs the risk of generating a faulty backup. In the case of Berkeley DB, the documentation describes a certain order in which database files can be copied that will guarantee a valid backup copy. A similar ordering exists for FSFS data. But you don't have to implement these algorithms yourself, because the Subversion development team has already done so. The <command moreinfo=\"none\">svnadmin hotcopy</command> command takes care of the minutia involved in making a hot backup of your repository. And its invocation is as trivial as Unix's <command moreinfo=\"none\">cp</command> or Windows' <command moreinfo=\"none\">copy</command> operations:"
msgstr ""

#: build/en/book.xml:12427(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin hotcopy /path/to/repos /path/to/repos-backup\n"
msgstr ""
"\n"
"$ svnadmin hotcopy /path/to/repos /path/to/repos-backup\n"

#: build/en/book.xml:12431(para)
msgid "The resulting backup is a fully functional Subversion repository, able to be dropped in as a replacement for your live repository should something go horribly wrong."
msgstr "作为结果的备份是一个完全功能的版本库，当发生严重错误时可以作为你的活动版本库的替换。"

#: build/en/book.xml:12435(para)
msgid "When making copies of a Berkeley DB repository, you can even instruct <command moreinfo=\"none\">svnadmin hotcopy</command> to purge any unused Berkeley DB logfiles (see <xref linkend=\"svn.reposadmin.maint.diskspace.bdblogs\"/>) from the original repository upon completion of the copy. Simply provide the <option>--clean-logs</option> option on the command-line."
msgstr ""

#: build/en/book.xml:12442(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin hotcopy --clean-logs /path/to/bdb-repos /path/to/bdb-repos-backup\n"
msgstr ""

#: build/en/book.xml:12446(para)
msgid "Additional tooling around this command is available, too. The <filename moreinfo=\"none\">tools/backup/</filename> directory of the Subversion source distribution holds the <command moreinfo=\"none\">hot-backup.py</command> script. This script adds a bit of backup management atop <command moreinfo=\"none\">svnadmin hotcopy</command>, allowing you to keep only the most recent configured number of backups of each repository. It will automatically manage the names of the backed-up repository directories to avoid collisions with previous backups, and will <quote>rotate off</quote> older backups, deleting them so only the most recent ones remain. Even if you also have an incremental backup, you might want to run this program on a regular basis. For example, you might consider using <command moreinfo=\"none\">hot-backup.py</command> from a program scheduler (such as <command moreinfo=\"none\">cron</command> on Unix systems) which will cause it to run nightly (or at whatever granularity of Time you deem safe enough for you)."
msgstr ""

#: build/en/book.xml:12464(para)
msgid "Some administrators use a different backup mechanism built around generating and storing repository dump data. We described in <xref linkend=\"svn.reposadmin.maint.migrate\"/> how to use <command moreinfo=\"none\">svnadmin dump --incremental</command> to perform an incremental backup of a given revision or range of revisions. And of course, there is a full backup variation of this achieved by omitting the <option>--incremental</option> option to that command. There is some value in these methods in that the format of your backed-up information is flexible—it's not tied to a particular platform, versioned filesystem type, or release of Subversion or Berkeley DB. But that flexibility comes at a cost, namely that restoring that data can take a long time—longer with each new revision committed to your repository. Also, as is the case with so many of the various backup methods, revision property changes made to already-backed-up revisions won't get picked up by a non-overlapping, incremental dump generation. For these reasons, we recommend against relying solely on dump-based backup approaches."
msgstr ""

#: build/en/book.xml:12484(para)
#, fuzzy
msgid "As you can see, each of the various backup types and methods has its advantages and disadvantages. The easiest is by far the full hot backup, which will always result in a perfect working replica of your repository. Should something bad happen to your live repository, you can restore from the backup with a simple recursive directory copy. Unfortunately, if you are maintaining multiple backups of your repository, these full copies will each eat up just as much disk space as your live repository. Incremental backups, by contrast, tend to be quicker to generate and smaller to store. But the restoration process can be a pain, often involving applying multiple incremental backups. And other methods have their own peculiarities. Administators need to find the balance between the cost of making the backup and the cost of restoring it."
msgstr "两种备份方式都有各自的优点，最简单的方式是完全备份，将会每次建立版本库的完美复制品，这意味着如果当你的活动版本库发生了什么事情，你可以用备份恢复。但不幸的是，如果你维护多个备份，每个完全的备份会吞噬掉和你的活动版本库同样的空间。"

#: build/en/book.xml:12500(para)
msgid "The <command moreinfo=\"none\">svnsync</command> program (see <xref linkend=\"svn.reposadmin.maint.replication\"/>) actually provides a rather handy middle-ground approach. If you are regularly synchronizing a read-only mirror with your main repository, then in a pinch, your read-only mirror is probably a good candidate for replacing that main repository if it falls over. The primary disadvantage of this method is that only the versioned repository data gets synchronized—repository configuration files, user-specified repository path locks, and other items which might live in the physical repository directory but not <emphasis>inside</emphasis> the repository's virtual versioned filesystem are not handled by svnsync."
msgstr ""

#: build/en/book.xml:12513(para)
#, fuzzy
msgid "In any backup scenario, repository administrators need to be aware of how modifications to unversioned revision properties affect their backups. Since these changes do not themselves generate new revisions, they will not trigger post-commit hooks, and may not even trigger the pre-revprop-change and post-revprop-change hooks. <placeholder-1/> And since you can change revision properties without respect to chronological order—you can change any revision's properties at any time—an incremental backup of the latest few revisions might not catch a property modification to a revision that was included as part of a previous backup."
msgstr "在每一种备份情境下，版本库管理员需要意识到对未版本化的修订版本属性的修改对备份的影响，因为这些修改本身不会产生新的修订版本，所以不会触发post-commit的钩子程序，也不会触发pre-revprop-change和post-revprop-change的钩子。 <footnote><placeholder-1/></footnote> 而且因为你可以改变修订版本的属性，而不需要遵照时间顺序—你可在任何时刻修改任何修订版本的属性—因此最新版本的增量备份不会捕捉到以前特定修订版本的属性修改。"

#: build/en/book.xml:12520(para)
msgid "<command moreinfo=\"none\">svnadmin setlog</command> can be called in a way that bypasses the hook interface altogether."
msgstr "<command moreinfo=\"none\">svnadmin setlog</command>可以被绕过钩子程序被调用。"

#: build/en/book.xml:1253(title)
msgid "The lock-modify-unlock solution"
msgstr "锁定-修改-解锁 方案2"

#: build/en/book.xml:12530(para)
#, fuzzy
msgid "Generally speaking, only the truly paranoid would need to backup their entire repository, say, every time a commit occurred. However, assuming that a given repository has some other redundancy mechanism in place with relatively fine granularity (like per-commit emails or incremental dumps), a hot backup of the database might be something that a repository administrator would want to include as part of a system-wide nightly backup. It's your data—protect it as much as you'd like."
msgstr "通常说来，在每次提交时，只有妄想狂才会备份整个版本库，然而，假设一个给定的版本库拥有一些恰当粒度的冗余机制（如每次提交的邮件）。版本库管理员也许会希望将版本库的热备份引入到系统级的每夜备份，对大多数版本库，归档的提交邮件为保存资源提供了足够的冗余措施，至少对于最近的提交。但是它是你的数据—你喜欢怎样保护都可以。"

#: build/en/book.xml:12540(para)
#, fuzzy
msgid "Often, the best approach to repository backups is a diversified one which leverages combinations of the methods described here. The Subversion developers, for example, back up the Subversion source code repository nightly using <command moreinfo=\"none\">hot-backup.py</command> and an offsite <command moreinfo=\"none\">rsync</command> of those full backups; keep multiple archives of all the commit and property change notification emails; and have repository mirrors maintained by various volunteers using <command moreinfo=\"none\">svnsync</command>. Your solution might be similar, but should be catered to your needs and that delicate balance of convenience with paranoia. And whatever you do, validate your backups from time to time—what good is a spare tire that has a hole in it? While all of this might not save your hardware from the iron fist of Fate, <placeholder-1/> it should certainly help you recover from those trying times."
msgstr "通常情况下，最好的版本库备份方式是混合的，你可以平衡完全和增量备份，另外配合提交邮件的归档，Subversion开发者，举个例子，在每个新的修订版本建立时备份Subversion的源代码版本库，并且保留所有的提交和属性修改通知文件。你的解决方案类似，必须迎合你的需要，平衡便利和你的偏执。然而这些不会改变你的硬件来自钢铁的命运。<footnote><placeholder-1/></footnote> 这一定会帮助你减少尝试的时间。"

#: build/en/book.xml:12555(para)
msgid "You know—the collective term for all of her <quote>fickle fingers</quote>."
msgstr "你知道的—只是对各种变化莫测的问题的统称。"

#: build/en/book.xml:12569(title) build/en/book.xml:2047(title)
#: build/en/book.xml:3978(title) build/en/book.xml:9639(title)
msgid "Summary"
msgstr "概要"

#: build/en/book.xml:1257(para)
msgid "The problem with the lock-modify-unlock model is that it's a bit restrictive, and often becomes a roadblock for users:"
msgstr "锁定-修改-解锁模型有一点问题就是限制太多，经常会成为用户的障碍："

#: build/en/book.xml:12571(para)
msgid "By now you should have a basic understanding of how to create, configure, and maintain Subversion repositories. We've introduced you to the various tools that will assist you with this task. Throughout the chapter, we've noted common administration pitfalls, and suggestions for avoiding them."
msgstr "现在，你应该已经对如何创建、配置以及维护Subversion版本库有了个基本的认识。我们向您介绍了几个可以帮助您工作的工具。通过这一章，我们说明了一些常见的管理误区，并提出了避免陷入误区的建议。"

#: build/en/book.xml:12578(para)
msgid "All that remains is for you to decide what exciting data to store in your repository, and finally, how to make it available over a network. The next chapter is all about networking."
msgstr "剩下的，就是由你决定在你的版本库中存放一些什么有趣的资料，并最终通过网络获得这些资料。下一章是关于网络的内容。"

#: build/en/book.xml:12592(title)
msgid "Server Configuration"
msgstr "配置服务器"

#: build/en/book.xml:12594(para)
#, fuzzy
msgid "A Subversion repository can be accessed simultaneously by clients running on the same machine on which the repository resides using the <literal moreinfo=\"none\">file://</literal> method. But the typical Subversion setup involves a single server machine being accessed from clients on computers all over the office—or, perhaps, all over the world."
msgstr "一个Subversion的版本库可以和客户端同时运行在同一个机器上，使用<literal moreinfo=\"none\">file:///</literal>访问，但是一个典型的Subversion设置应该包括一个单独的服务器，可以被办公室的所有客户端访问—或者有可能是整个世界。"

#: build/en/book.xml:12601(para)
#, fuzzy
msgid "This chapter describes how to get your Subversion repository exposed outside its host machine for use by remote clients. We will cover Subversion's currently available server mechanisms, discussing the configuration and use of each. After reading this section, you should be able to decide which networking setup is right for your needs, and understand how to enable such a setup on your host computer."
msgstr "本小节描述了怎样将一个Subversion的版本库暴露给远程客户端，我们会覆盖Subversion已存在的服务器机制，讨论各种方式的配置和使用。经过阅读本小节，你可以决定你需要哪种网络设置，并且明白怎样在你的主机上进行配置。"

#: build/en/book.xml:12615(title)
msgid "Overview"
msgstr "概述"

#: build/en/book.xml:12617(para)
#, fuzzy
msgid "Subversion was designed with an abstract network layer. This means that a repository can be programmatically accessed by any sort of server process, and the client <quote>repository access</quote> API allows programmers to write plugins that speak relevant network protocols. In theory, Subversion can use an infinite number of network implementations. In practice, there are only two servers at the time of this writing."
msgstr "Subversion的设计包括一个抽象的网络层，这意味着版本库可以通过各种服务器进程访问，而且客户端<quote>版本库访问</quote>的API允许程序员写出相关协议的插件，理论上讲，Subversion可以使用无限数量的网络协议实现，目前实践中存在着两种服务器。"

#: build/en/book.xml:12625(para)
#, fuzzy
msgid "Apache is an extremely popular webserver; using the <command moreinfo=\"none\">mod_dav_svn</command> module, Apache can access a repository and make it available to clients via the WebDAV/DeltaV protocol, which is an extension of HTTP. Because Apache is an extremely extensible web server, it provides a number of features <quote>for free</quote>, such as encrypted SSL communication, logging, integration with a number of third-party authentication systems, and limited built-in web browsing of repositories."
msgstr "Apache是最流行的web服务器，通过使用<command moreinfo=\"none\">mod_dav_svn</command>模块，Apache可以访问版本库，并且可以使客户端使用HTTP的扩展协议WebDAV/DeltaV进行访问，另一个是<command moreinfo=\"none\">svnserve</command>：一个小的，独立服务器，使用自己定义的协议和客户端，表格6-1比较了这两种服务器。"

#: build/en/book.xml:1263(para)
#, fuzzy
msgid "<emphasis>Locking may cause administrative problems.</emphasis> Sometimes Harry will lock a file and then forget about it. Meanwhile, because Sally is still waiting to edit the file, her hands are tied. And then Harry goes on vacation. Now Sally has to get an administrator to release Harry's lock. The situation ends up causing a lot of unnecessary delay and wasted time."
msgstr "<emphasis>锁定可能导致管理问题。</emphasis>有时候Harry会锁住文件然后忘了此事，这就是说Sally一直等待解锁来编辑这些文件，她在这里僵住了。然后Harry去旅行了，现在Sally只好去找管理员放开锁，这种情况会导致不必要的耽搁和时间浪费。"

#: build/en/book.xml:12635(para)
msgid "In the other corner is <command moreinfo=\"none\">svnserve</command>: a small, lightweight server program that speaks a custom protocol with clients. Because its protocol is explicitly designed for Subversion and is stateful (unlike HTTP), it provides significantly faster network operations—but at the cost of some features as well. It only understands CRAM-MD5 authentication, has no logging, no web-browsing, and no option to encrypt network traffic. It is, however, extremely easy to set up and is often the best option for small teams just starting out with Subversion."
msgstr ""

#: build/en/book.xml:12646(para)
msgid "A third option is to use <command moreinfo=\"none\">svnserve</command> tunneled over an SSH connection. Even though this scenario still uses <command moreinfo=\"none\">svnserve</command>, it differs quite a bit in features from a traditional <command moreinfo=\"none\">svnserve</command> deployment. SSH is used to encrypt all communication. SSH is also used exclusively to authenticate, so real system accounts are required on the server host (unlike vanilla <command moreinfo=\"none\">svnserve</command>, which has its own private user accounts.) Finally, because this setup requires that each user spawn a private, temporary <command moreinfo=\"none\">svnserve</command> process, it's equivalent (from a permissions point of view) to allowing a group of local users to all access the repository via <literal moreinfo=\"none\">file://</literal> URLs. Path-based access control has no meaning, since each user is accessing the repository database files directly."
msgstr ""

#: build/en/book.xml:12662(para)
msgid "Here's a quick summary of the three typical server deployments."
msgstr ""

#: build/en/book.xml:12666(title)
msgid "Comparison of Subversion Server Options"
msgstr ""

#: build/en/book.xml:12671(entry)
msgid "Apache + mod_dav_svn"
msgstr "Apache + mod_dav_svn"

#: build/en/book.xml:12673(entry)
#, fuzzy
msgid "svnserve over SSH"
msgstr "svnserve"

#: build/en/book.xml:12678(entry)
msgid "Authentication options"
msgstr "认证选项"

#: build/en/book.xml:12679(entry)
msgid "HTTP(S) basic auth, X.509 certificates, LDAP, NTLM, or any other mechanism available to Apache httpd"
msgstr "HTTP(S) basic auth、X.509 certificates、LDAP、NTLM或任何Apache httpd已经具备的方式"

#: build/en/book.xml:12681(entry)
msgid "CRAM-MD5"
msgstr "CRAM-MD5"

#: build/en/book.xml:12682(entry)
msgid "SSH"
msgstr "SSH"

#: build/en/book.xml:12686(entry)
msgid "User account options"
msgstr "用户帐号选项"

#: build/en/book.xml:12687(entry) build/en/book.xml:12688(entry)
msgid "private 'users' file"
msgstr "私有的'users'文件"

#: build/en/book.xml:12689(entry)
msgid "system accounts"
msgstr "系统帐号"

#: build/en/book.xml:12693(entry)
msgid "Authorization options"
msgstr "授权选项"

#: build/en/book.xml:12694(entry) build/en/book.xml:12696(entry)
msgid "read/write access can be granted over whole repository, or specified per-path."
msgstr ""

#: build/en/book.xml:12698(entry)
msgid "read/write access only grantable over whole repository"
msgstr ""

#: build/en/book.xml:127(para)
msgid "Frustrated at seeing the same questions day after day, Ben worked intensely over a month in the summer of 2002 to write <citetitle>The Subversion Handbook</citetitle>, a sixty page manual that covered all the basics of using Subversion. The manual made no pretense of being complete, but it was distributed with Subversion and got users over that initial hump in the learning curve. When O'Reilly and Associates decided to publish a full-length Subversion book, the path of least resistance was obvious: just expand the Subversion handbook."
msgstr "日复一日看到相同问题的烦闷，促使Ben在2002年的夏天努力工作了一个月，撰写了一本<citetitle>Subversion手册</citetitle>，一本六十页厚的、涵盖了所有Subversion使用基础知识的手册。这本手册没有说明最终定稿的时间，但它随着Subversion的每个版本一起发布，帮助许多用户跨过学习之初的艰难。当O'Reilly和Associates决定出版一本完备的Subversion图书的时候，一条捷径浮出水面：扩充Subversion手册。"

#: build/en/book.xml:12703(entry)
msgid "Encryption"
msgstr "加密"

#: build/en/book.xml:12704(entry)
msgid "via optional SSL"
msgstr "通过选择SSL"

#: build/en/book.xml:12705(entry)
msgid "none"
msgstr "无"

#: build/en/book.xml:12706(entry)
msgid "SSH tunneled"
msgstr ""

#: build/en/book.xml:12710(entry)
msgid "Logging"
msgstr "日志"

#: build/en/book.xml:12711(entry)
msgid "full Apache logs of each HTTP request, with optional <placeholder-1/> logging of general client operations"
msgstr ""

#: build/en/book.xml:12712(quote)
msgid "high-level"
msgstr ""

#: build/en/book.xml:12714(entry) build/en/book.xml:12715(entry)
msgid "no logging"
msgstr ""

#: build/en/book.xml:12719(entry)
msgid "Interoperability"
msgstr "交互性"

#: build/en/book.xml:12720(entry)
msgid "partially usable by other WebDAV clients"
msgstr "可以部分的被其他WebDAV客户端使用"

#: build/en/book.xml:12721(entry) build/en/book.xml:12722(entry)
msgid "only talks to svn clients"
msgstr ""

#: build/en/book.xml:12726(entry)
msgid "Web viewing"
msgstr "Web浏览能力"

#: build/en/book.xml:12727(entry)
msgid "limited built-in support, or via 3rd-party tools such as ViewVC"
msgstr "有限的内置支持，或者通过第三方工具，如ViewVC"

#: build/en/book.xml:12729(entry) build/en/book.xml:12730(entry)
#, fuzzy
msgid "only via 3rd-party tools such as ViewVC"
msgstr "通过第三方工具，如ViewVC"

#: build/en/book.xml:12734(entry)
msgid "Speed"
msgstr "速度"

#: build/en/book.xml:12735(entry)
msgid "somewhat slower"
msgstr "有些慢"

#: build/en/book.xml:12736(entry) build/en/book.xml:12737(entry)
msgid "somewhat faster"
msgstr "快一点"

#: build/en/book.xml:12741(entry) build/en/book.xml:13603(title)
msgid "Initial setup"
msgstr "初始设置"

#: build/en/book.xml:12742(entry)
msgid "somewhat complex"
msgstr "有些复杂"

#: build/en/book.xml:12743(entry)
msgid "extremely simple"
msgstr "极为简单"

#: build/en/book.xml:12744(entry)
#, fuzzy
msgid "moderately simple"
msgstr "相当简单"

#: build/en/book.xml:1275(para)
#, fuzzy
msgid "<emphasis>Locking may cause unnecessary serialization.</emphasis> What if Harry is editing the beginning of a text file, and Sally simply wants to edit the end of the same file? These changes don't overlap at all. They could easily edit the file simultaneously, and no great harm would come, assuming the changes were properly merged together. There's no need for them to take turns in this situation."
msgstr "<emphasis>锁定可能导致不必要的线性化开发。</emphasis>如果Harry编辑一个文件的开始，Sally想编辑同一个文件的结尾，这种修改不会冲突，设想修改可以正确的合并到一起，他们可以轻松的并行工作而没有太多的坏处，没有必要让他们轮流工作。"

#: build/en/book.xml:12755(title)
#, fuzzy
msgid "Choosing a Server Configuration"
msgstr "配置服务器"

#: build/en/book.xml:12757(para)
msgid "So, which server should you use? Which is best?"
msgstr ""

#: build/en/book.xml:12759(para)
msgid "Obviously, there's no right answer to that question. Every team has different needs, and the different servers all represent different sets of tradeoffs. The Subversion project itself doesn't endorse one server or another, or consider either server more <quote>official</quote> than another."
msgstr ""

#: build/en/book.xml:12765(para)
msgid "Here are some reasons why you might choose one deployment over another, as well as reasons you might <emphasis>not</emphasis> choose one."
msgstr ""

#: build/en/book.xml:12771(title)
#, fuzzy
msgid "The <command moreinfo=\"none\">svnserve</command> Server"
msgstr "<command moreinfo=\"none\">svnserve</command>选项"

#: build/en/book.xml:12775(term) build/en/book.xml:12826(term)
#: build/en/book.xml:12874(term)
msgid "Why you might want to use it:"
msgstr ""

#: build/en/book.xml:12779(para)
msgid "Quick and easy to set up."
msgstr ""

#: build/en/book.xml:12782(para) build/en/book.xml:12830(para)
msgid "Network protocol is stateful and noticeably faster than WebDAV."
msgstr ""

#: build/en/book.xml:12785(para) build/en/book.xml:12882(para)
msgid "No need to create system accounts on server."
msgstr ""

#: build/en/book.xml:12788(para)
msgid "Password is not passed over the network."
msgstr ""

#: build/en/book.xml:12796(term) build/en/book.xml:12844(term)
#: build/en/book.xml:12905(term)
msgid "Why you might want to avoid it:"
msgstr ""

#: build/en/book.xml:12800(para)
msgid "Network protocol is not encrypted."
msgstr ""

#: build/en/book.xml:12803(para) build/en/book.xml:12848(para)
#, fuzzy
msgid "Only one choice of authentication method."
msgstr "回应所有的认证请求。"

#: build/en/book.xml:12806(para)
#, fuzzy
msgid "Password is stored in the clear on the server."
msgstr "在服务器这个项目有了新的修订版本。"

#: build/en/book.xml:12809(para) build/en/book.xml:12851(para)
msgid "No logging of any kind, not even errors."
msgstr ""

#: build/en/book.xml:12822(title)
#, fuzzy
msgid "<command moreinfo=\"none\">svnserve</command> over SSH"
msgstr "<command moreinfo=\"none\">svnserve</command>选项"

#: build/en/book.xml:12833(para)
msgid "You can take advantage of existing ssh accounts and user infrastructure."
msgstr ""

#: build/en/book.xml:12836(para)
msgid "All network traffic is encrypted."
msgstr ""

#: build/en/book.xml:12854(para)
msgid "Requires users to be in same system group, or use a shared ssh key."
msgstr ""

#: build/en/book.xml:12857(para)
msgid "Can lead to file permissions problems."
msgstr ""

#: build/en/book.xml:12870(title)
#, fuzzy
msgid "The Apache HTTP Server"
msgstr "httpd，Apache的HTTP服务器"

#: build/en/book.xml:12878(para)
msgid "Allows Subversion to use any of the numerous authentication systems already integrated with Apache."
msgstr ""

#: build/en/book.xml:1288(para)
#, fuzzy
msgid "<emphasis>Locking may create a false sense of security.</emphasis> Suppose Harry locks and edits file A, while Sally simultaneously locks and edits file B. But what if A and B depend on one another, and the changes made to each are semantically incompatible? Suddenly A and B don't work together anymore. The locking system was powerless to prevent the problem—yet it somehow provided a false sense of security. It's easy for Harry and Sally to imagine that by locking files, each is beginning a safe, insulated task, and thus not bother discussing their incompatible changes early on. Locking often becomes a substitute for real communication."
msgstr "<emphasis>锁定可能导致错误的安全状态。</emphasis>假设Harry锁定和编辑一个文件A，同时Sally锁定并编辑文件B，如果A和B互相依赖，这种变化是必须同时作的，这样A和B不能正确的工作了，锁定机制对防止此类问题将无能为力—从而产生了一种处于安全状态的假相。很容易想象Harry和Sally都以为自己锁住了文件，而且从一个安全，孤立的情况开始工作，因而没有尽早发现他们不匹配的修改。"

#: build/en/book.xml:12885(para)
msgid "Full Apache logging."
msgstr ""

#: build/en/book.xml:12887(para)
msgid "Network traffic can be encrypted via SSL."
msgstr ""

#: build/en/book.xml:12890(para)
msgid "HTTP(S) can usually go through corporate firewalls."
msgstr ""

#: build/en/book.xml:12893(para)
msgid "Built-in repository browsing via web browser."
msgstr ""

#: build/en/book.xml:12896(para)
#, fuzzy
msgid "Repository can be mounted as a network drive for transparent version control. (See <xref linkend=\"svn.webdav.autoversioning\"/>.)"
msgstr "如果出现，则修订版本是通过自动版本化特性创建，见<xref linkend=\"svn.webdav.autoversioning\"/>。"

#: build/en/book.xml:12909(para)
msgid "Noticeably slower than svnserve, because HTTP is a stateless protocol and requires more turnarounds."
msgstr ""

#: build/en/book.xml:12913(para)
#, fuzzy
msgid "Initial setup can be complex."
msgstr "初始设置"

#: build/en/book.xml:12925(title)
msgid "Recommendations"
msgstr "忠告"

#: build/en/book.xml:12927(para)
msgid "In general, the authors of this book recommend a vanilla <command moreinfo=\"none\">svnserve</command> installation for small teams just trying to get started with a Subversion server; it's the simplest to set up, and has the fewest maintenance issues. Remember, you can always switch to a more complex server deployment as your needs change."
msgstr ""

#: build/en/book.xml:12934(para)
msgid "Here are some general recommendations and tips, based on years of supporting users:"
msgstr ""

#: build/en/book.xml:12939(para)
msgid "If you're trying to set up the simplest possible server for your group, then a vanilla <command moreinfo=\"none\">svnserve</command> installation is the easiest, fastest route. Note, however, that your repository data will be transmitted in the clear over the network. If your deployment is entirely within your company's LAN or VPN, this isn't an issue. If the repository is exposed to the wide-open internet, then you might want to make sure the repository's contents aren't sensitive (e.g. it contains only open-source code.)"
msgstr ""

#: build/en/book.xml:12952(para)
msgid "If you need to integrate with existing identity systems (LDAP, Active Directory, NTLM, X.509, etc.), then an Apache-based server is your only real option. Similarly, if you absolutely need server-side logs of either server errors or client activities, then an Apache-based server is required."
msgstr ""

#: build/en/book.xml:12961(para)
msgid "If you've decided to use either Apache or stock <command moreinfo=\"none\">svnserve</command>, create a single <literal moreinfo=\"none\">svn</literal> user on your system and run the server process as that user. Be sure to make the repository directory wholly owned by the <literal moreinfo=\"none\">svn</literal> user as well. From a security point of view, this keeps the repository data nicely siloed and protected by operating system filesystem permissions, changeable by only the Subversion server process itself."
msgstr ""

#: build/en/book.xml:12974(para)
msgid "If you have an existing infrastructure heavily based on SSH accounts, and if your users already have system accounts on your server machine, then it makes sense to deploy an svnserve-over-ssh solution. Otherwise, we don't widely recommend this option to the public. It's generally considered safer to have your users access the repository via (imaginary) accounts managed by <command moreinfo=\"none\">svnserve</command> or Apache, rather than by full-blown system accounts. If your deep desire for encrypted communication still draws you to this option, we recommend using Apache with SSL instead."
msgstr ""

#: build/en/book.xml:12988(para)
msgid "Do <emphasis>not</emphasis> be seduced by the simple idea of having all of your users access a repository directly via <literal moreinfo=\"none\">file://</literal> URLs. Even if the repository is readily available to everyone via network share, this is a bad idea. It removes any layers of protection between the users and the repository: users can accidentally (or intentionally) corrupt the repository database, it becomes hard to take the repository offline for inspection or upgrade, and it can lead to a mess of file-permissions problems (see <xref linkend=\"svn.serverconfig.multimethod\"/>.) Note that this is also one of the reasons we warn against accessing repositories via <literal moreinfo=\"none\">svn+ssh://</literal> URLs — from a security standpoint, it's effectively the same as local users accessing via <literal moreinfo=\"none\">file://</literal>, and can entail all the same problems if the administrator isn't careful."
msgstr ""

#: build/en/book.xml:13017(title)
msgid "svnserve, a custom server"
msgstr "svnserve，一个自定义的服务器"

#: build/en/book.xml:13019(para)
msgid "The <command moreinfo=\"none\">svnserve</command> program is a lightweight server, capable of speaking to clients over TCP/IP using a custom, stateful protocol. Clients contact an <command moreinfo=\"none\">svnserve</command> server by using URLs that begin with the <literal moreinfo=\"none\">svn://</literal> or <literal moreinfo=\"none\">svn+ssh://</literal> schema. This section will explain the different ways of running <command moreinfo=\"none\">svnserve</command>, how clients authenticate themselves to the server, and how to configure appropriate access control to your repositories."
msgstr "<command moreinfo=\"none\">svnserve</command>是一个轻型的服务器，可以同客户端通过在TCP/IP基础上的自定义有状态协议通讯，客户端通过使用开头为<literal moreinfo=\"none\">svn://</literal>或者<literal moreinfo=\"none\">svn+ssh://</literal><command moreinfo=\"none\">svnserve</command>的URL来访问一个<command moreinfo=\"none\">svnserve</command>服务器。这一小节将会解释运行<command moreinfo=\"none\">svnserve</command>的不同方式，客户端怎样实现服务器的认证，怎样配置版本库恰当的访问控制。"

#: build/en/book.xml:13031(title)
msgid "Invoking the Server"
msgstr "调用服务器"

#: build/en/book.xml:13033(para)
#, fuzzy
msgid "There are a few different ways to run the <command moreinfo=\"none\">svnserve</command> program:"
msgstr "这是使用<command moreinfo=\"none\">svn revert</command>的好机会。"

#: build/en/book.xml:13037(para)
#, fuzzy
msgid "Run <command moreinfo=\"none\">svnserve</command> as a standalone daemon, listening for requests."
msgstr "<command moreinfo=\"none\">svnlook</command> 的语法很直接："

#: build/en/book.xml:13040(para)
#, fuzzy
msgid "Have the Unix <command moreinfo=\"none\">inetd</command> daemon temporarily spawn <command moreinfo=\"none\">svnserve</command> whenever a request comes in on a certain port."
msgstr "像<command moreinfo=\"none\">svnserve</command>，<command moreinfo=\"none\">svnversion</command>没有子命令，只有选项。"

#: build/en/book.xml:13043(para)
#, fuzzy
msgid "Have SSH invoke a temporary <command moreinfo=\"none\">svnserve</command> over an encrypted tunnel."
msgstr "如果一个客户端连接到<command moreinfo=\"none\">svnserve</command>进程，如下事情会发生："

#: build/en/book.xml:13046(para)
#, fuzzy
msgid "Run <command moreinfo=\"none\">svnserve</command> as a Windows service."
msgstr "<command moreinfo=\"none\">svnserve</command>选项"

#: build/en/book.xml:13052(title)
#, fuzzy
msgid "<command moreinfo=\"none\">svnserve</command> as Daemon"
msgstr "<command moreinfo=\"none\">svnserve</command>选项"

#: build/en/book.xml:13054(para)
#, fuzzy
msgid "The easiest option is to run <command moreinfo=\"none\">svnserve</command> as a standalone <quote>daemon</quote> process. Use the <option>-d</option> option for this:"
msgstr "<command moreinfo=\"none\">svnserve</command>的第二个选项是作为独立<quote>守护</quote>进程，为此要使用<option>-d</option>选项："

#: build/en/book.xml:13058(screen)
#, no-wrap
msgid ""
"\n"
"$ svnserve -d\n"
"$               # svnserve is now running, listening on port 3690\n"
msgstr ""
"\n"
"$ svnserve -d\n"
"$               # svnserve is now running, listening on port 3690\n"

#: build/en/book.xml:13063(para)
msgid "When running <command moreinfo=\"none\">svnserve</command> in daemon mode, you can use the <option>--listen-port=</option> and <option>--listen-host=</option> options to customize the exact port and hostname to <quote>bind</quote> to."
msgstr "当以守护模式运行<command moreinfo=\"none\">svnserve</command>时，你可以使用<option>--listen-port=</option>和<option>--listen-host=</option>选项来自定义<quote>绑定</quote>的端口和主机名。"

#: build/en/book.xml:13068(para)
#, fuzzy
msgid "Once the <command moreinfo=\"none\">svnserve</command> program is running, it makes every repository on your system available to the network. A client needs to specify an <emphasis>absolute</emphasis> path in the repository URL. For example, if a repository is located at <filename moreinfo=\"none\">/usr/local/repositories/project1</filename>, then a client would reach it via <uri>svn://host.example.com/usr/local/repositories/project1</uri>. To increase security, you can pass the <option>-r</option> option to <command moreinfo=\"none\">svnserve</command>, which restricts it to exporting only repositories below that path. For example:"
msgstr "一旦<command moreinfo=\"none\">svnserve</command>已经运行，它会将你系统中所有版本库发布到网络，一个客户端需要指定版本库在URL中的<emphasis>绝对</emphasis>路径，举个例子，如果一个版本库是位于<filename moreinfo=\"none\">/usr/local/repositories/project1</filename>，则一个客户端可以使用<systemitem class=\"url\" moreinfo=\"none\">svn://host.example.com/usr/local/repositories/project1 </systemitem>来进行访问，为了提高安全性，你可以使用<command moreinfo=\"none\">svnserve</command>的<option>-r</option>选项，这样会限制只输出指定路径下的版本库："

#: build/en/book.xml:13080(screen)
#, no-wrap
msgid ""
"\n"
"$ svnserve -d -r /usr/local/repositories\n"
"…\n"
msgstr ""
"\n"
"$ svnserve -d -r /usr/local/repositories\n"
"…\n"

#: build/en/book.xml:13085(para)
msgid "Using the <option>-r</option> option effectively modifies the location that the program treats as the root of the remote filesystem space. Clients then use URLs that have that path portion removed from them, leaving much shorter (and much less revealing) URLs:"
msgstr "使用<option>-r</option>可以有效地改变文件系统的根位置，客户端可以使用去掉前半部分的路径，留下的要短一些的（更加有提示性）URL："

#: build/en/book.xml:1309(title)
msgid "The Copy-Modify-Merge Solution"
msgstr "拷贝-修改-合并 方案1"

#: build/en/book.xml:13091(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout svn://host.example.com/project1\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout svn://host.example.com/project1\n"
"…\n"

#: build/en/book.xml:13100(title)
#, fuzzy
msgid "<command moreinfo=\"none\">svnserve</command> via <command moreinfo=\"none\">inetd</command>"
msgstr "像<command moreinfo=\"none\">svnserve</command>，<command moreinfo=\"none\">svnversion</command>没有子命令，只有选项。"

#: build/en/book.xml:13102(para)
#, fuzzy
msgid "If you want <command moreinfo=\"none\">inetd</command> launch the process, then you can pass the <option>-i</option> (<option>--inetd</option>) option:"
msgstr "还有一个<command moreinfo=\"none\">proplist</command>变种命令会列出所有属性的名称和值，只需要设置<option>--verbose</option>（<option>-v</option>）选项。"

#: build/en/book.xml:13106(screen)
#, no-wrap
msgid ""
"\n"
"$ svnserve -i\n"
"( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )\n"
msgstr ""
"\n"
"$ svnserve -i\n"
"( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )\n"

#: build/en/book.xml:1311(para)
#, fuzzy
msgid "Subversion, CVS, and a number of other version control systems use a <firstterm>copy-modify-merge</firstterm> model as an alternative to locking. In this model, each user's client contacts the project repository and creates a personal <firstterm>working copy</firstterm>—a local reflection of the repository's files and directories. Users then work simultaneously and independently, modifying their private copies. Finally, the private copies are merged together into a new, final version. The version control system often assists with the merging, but ultimately a human being is responsible for making it happen correctly."
msgstr "Subversion，CVS和一些版本控制系统使用<firstterm>拷贝-修改-合并</firstterm>模型，在这种模型里，每一个客户联系项目版本库建立一个个人<firstterm>工作拷贝</firstterm>—版本库中文件和目录的本地映射。用户并行工作，修改各自的工作拷贝，最终，各个私有的拷贝合并在一起，成为最终的版本，这种系统通常可以辅助合并操作，但是最终要靠人工去确定正误。"

#: build/en/book.xml:13111(para)
msgid "When invoked with the <option>--inetd</option> option, <command moreinfo=\"none\">svnserve</command> attempts to speak with a Subversion client via <emphasis>stdin</emphasis> and <emphasis>stdout</emphasis> using a custom protocol. This is the standard behavior for a program being run via <command moreinfo=\"none\">inetd</command>. The IANA has reserved port 3690 for the Subversion protocol, so on a Unix-like system you can add lines to <filename moreinfo=\"none\">/etc/services</filename> like these (if they don't already exist):"
msgstr "当用参数<option>--inetd</option>调用时，<command moreinfo=\"none\">svnserve</command>会尝试使用自定义协议通过<emphasis>stdin</emphasis>和<emphasis>stdout</emphasis>来与Subversion客户端通话，这是使用<command moreinfo=\"none\">inetd</command>工作的标准方式，IANA为Subversion协议保留3690端口，所以在类Unix系统你可以在<filename moreinfo=\"none\">/etc/services</filename>添加如下的几行（如果他们还不存在）："

#: build/en/book.xml:13121(screen)
#, no-wrap
msgid ""
"\n"
"svn           3690/tcp   # Subversion\n"
"svn           3690/udp   # Subversion\n"
msgstr ""
"\n"
"svn           3690/tcp   # Subversion\n"
"svn           3690/udp   # Subversion\n"

#: build/en/book.xml:13126(para)
msgid "And if your system is using a classic Unix-like <command moreinfo=\"none\">inetd</command> daemon, you can add this line to <filename moreinfo=\"none\">/etc/inetd.conf</filename>:"
msgstr "如果系统是使用经典的类Unix的<command moreinfo=\"none\">inetd</command>守护进程，你可以在<filename moreinfo=\"none\">/etc/inetd.conf</filename>添加这几行："

#: build/en/book.xml:13130(screen)
#, no-wrap
msgid ""
"\n"
"svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i\n"
msgstr ""
"\n"
"svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i\n"

#: build/en/book.xml:13134(para)
#, fuzzy
msgid "Make sure <quote>svnowner</quote> is a user which has appropriate permissions to access your repositories. Now, when a client connection comes into your server on port 3690, <command moreinfo=\"none\">inetd</command> will spawn an <command moreinfo=\"none\">svnserve</command> process to service it. Of course, you may also want to add <option>-r</option> to the configuration line as well, to restrict which repositories are exported."
msgstr "确定<quote>svnowner</quote>用户拥有访问版本库的适当权限，现在如果一个客户连接来到你的服务器的端口3690，<command moreinfo=\"none\">inetd</command>会产生一个<command moreinfo=\"none\">svnserve</command>进程来做服务。"

#: build/en/book.xml:13147(title)
#, fuzzy
msgid "<command moreinfo=\"none\">svnserve</command> over a Tunnel"
msgstr "<command moreinfo=\"none\">svnserve</command>选项"

#: build/en/book.xml:13149(para)
#, fuzzy
msgid "A third way to invoke <command moreinfo=\"none\">svnserve</command> is in <quote>tunnel mode</quote>, with the <option>-t</option> option. This mode assumes that a remote-service program such as <command moreinfo=\"none\">RSH</command> or <command moreinfo=\"none\">SSH</command> has successfully authenticated a user and is now invoking a private <command moreinfo=\"none\">svnserve</command> process <emphasis>as that user</emphasis>. The <command moreinfo=\"none\">svnserve</command> program behaves normally (communicating via <emphasis>stdin</emphasis> and <emphasis>stdout</emphasis>), and assumes that the traffic is being automatically redirected over some sort of tunnel back to the client. When <command moreinfo=\"none\">svnserve</command> is invoked by a tunnel agent like this, be sure that the authenticated user has full read and write access to the repository database files. It's essentially the same as a local user accessing the repository via <literal moreinfo=\"none\">file://</literal> URLs."
msgstr "也一直有第三种方式，使用<option>-t</option>选项的<quote>管道模式</quote>，这个模式假定一个分布式服务程序如<command moreinfo=\"none\">RSH</command>或<command moreinfo=\"none\">SSH</command>已经验证了一个用户，并且<emphasis>以这个用户</emphasis>调用了一个私有<command moreinfo=\"none\">svnserve</command>进程，<command moreinfo=\"none\">svnserve</command>运作如常（通过<emphasis>stdin</emphasis>和<emphasis>stdout</emphasis>通讯），并且可以设想通讯是自动转向到一种通道传递回客户端，当<command moreinfo=\"none\">svnserve</command>被这样的通道代理调用，确定认证用户对版本数据库有完全的读写权限，（见<xref linkend=\"svn.serverconfig.svnserve.invoking.sb-1\"/>。）这与本地用户通过<literal moreinfo=\"none\">file:///</literal>URl访问版本库同样重要。"

#: build/en/book.xml:13166(para)
msgid "This option is described in much more detail in <xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>."
msgstr ""

#: build/en/book.xml:13173(title)
#, fuzzy
msgid "<command moreinfo=\"none\">svnserve</command> as Windows Service"
msgstr "<command moreinfo=\"none\">svnserve</command>选项"

#: build/en/book.xml:13175(para)
msgid "If your Windows system is a descendant of Windows NT (2000, 2003, XP, Vista), then you can run <command moreinfo=\"none\">svnserve</command> as a standard Windows service. This is typically a much nicer experience than running it as a standalone daemon with the <option>--daemon (-d)</option> option. Using daemon-mode requires launching a console, typing a command, and then leaving the console window running indefinitely. A Windows service, however, runs in the background, can start at boot time automatically, and can be started and stopped using the same consistent administration interface as other Windows services."
msgstr ""

#: build/en/book.xml:13188(para)
msgid "You'll need to define the new service using the command-line tool <command moreinfo=\"none\">SC.EXE</command>. Much like the <command moreinfo=\"none\">inetd</command> configuration line, you must specify an exact invocation of <command moreinfo=\"none\">svnserve</command> for Windows to run at start-up time:"
msgstr ""

#: build/en/book.xml:13194(screen)
#, no-wrap
msgid ""
"\n"
"C:\\&gt; sc create svn\n"
"        binpath= \"C:\\svn\\bin\\svnserve.exe --service -r C:\\repos\"\n"
"        displayname= \"Subversion Server\"\n"
"        depend= Tcpip\n"
"        start= auto\n"
msgstr ""
"\n"
"C:\\&gt; sc create svn\n"
"        binpath= \"C:\\svn\\bin\\svnserve.exe --service -r C:\\repos\"\n"
"        displayname= \"Subversion Server\"\n"
"        depend= Tcpip\n"
"        start= auto\n"

#: build/en/book.xml:13202(para)
msgid "This defines a new Windows service named <quote>svn</quote>, and which executes a particular <command moreinfo=\"none\">svnserve.exe</command> command when started (in this case, rooted at <filename moreinfo=\"none\">C:\\repos</filename>.) There are a number of caveats in the prior example, however."
msgstr ""

#: build/en/book.xml:13209(para)
msgid "First, notice that the <command moreinfo=\"none\">svnserve.exe</command> program must always be invoked with the <option>--service</option> option. Any other options to <command moreinfo=\"none\">svnserve</command> must then be specified on the same line, but you cannot add conflicting options such as <option>--daemon (-d)</option>, <option>--tunnel</option>, or <option>--inetd (-i)</option>. Options such as <option>-r</option> or <option>--listen-port</option> are fine, though. Second, be careful about spaces when invoking the <command moreinfo=\"none\">SC.EXE</command> command: the <literal moreinfo=\"none\">key= value</literal> patterns must have no spaces between <literal moreinfo=\"none\">key=</literal> and exactly one space before the <literal moreinfo=\"none\">value</literal>. Lastly, be careful about spaces in your command-line to be invoked. If a directory name contains spaces (or other characters that need escaping), place the entire inner value of <literal moreinfo=\"none\">binpath</literal> in double-quotes, by escaping them:"
msgstr ""

#: build/en/book.xml:13229(screen)
#, no-wrap
msgid ""
"\n"
"C:\\&gt; sc create svn\n"
"        binpath= \"\\\"C:\\program files\\svn\\bin\\svnserve.exe\\\" --service -r C:\\repos\"\n"
"        displayname= \"Subversion Server\"\n"
"        depend= Tcpip\n"
"        start= auto\n"
msgstr ""
"\n"
"C:\\&gt; sc create svn\n"
"        binpath= \"\\\"C:\\program files\\svn\\bin\\svnserve.exe\\\" --service -r C:\\repos\"\n"
"        displayname= \"Subversion Server\"\n"
"        depend= Tcpip\n"
"        start= auto\n"

#: build/en/book.xml:1323(para)
msgid "Here's an example. Say that Harry and Sally each create working copies of the same project, copied from the repository. They work concurrently, and make changes to the same file A within their copies. Sally saves her changes to the repository first. When Harry attempts to save his changes later, the repository informs him that his file A is <firstterm>out-of-date</firstterm>. In other words, that file A in the repository has somehow changed since he last copied it. So Harry asks his client to <firstterm>merge</firstterm> any new changes from the repository into his working copy of file A. Chances are that Sally's changes don't overlap with his own; so once he has both sets of changes integrated, he saves his working copy back to the repository. <xref linkend=\"svn.basic.vsn-models.copy-merge.dia-1\"/> and <xref linkend=\"svn.basic.vsn-models.copy-merge.dia-2\"/> show this process."
msgstr "这是一个例子，Harry和Sally为同一个项目各自建立了一个工作拷贝，工作是并行的，修改了同一个文件A，Sally首先保存修改到版本库，当Harry想去提交修改的时候，版本库提示文件A已经<firstterm>过期</firstterm>，换句话说，A在他上次更新之后已经更改了，所以当他通过客户端请求<firstterm>合并</firstterm>版本库和他的工作拷贝之后，碰巧Sally的修改和他的不冲突，所以一旦他把所有的修改集成到一起，他可以将工作拷贝保存到版本库，<xref linkend=\"svn.basic.vsn-models.copy-merge.dia-1\"/>和<xref linkend=\"svn.basic.vsn-models.copy-merge.dia-2\"/>展示了这一过程。"

#: build/en/book.xml:13237(para)
msgid "Once the service is defined, it can stopped, started, or queried using standard GUI tools (The Services administrative control panel), or at the command line as well:"
msgstr ""

#: build/en/book.xml:13242(screen)
#, no-wrap
msgid ""
"\n"
"C:\\&gt; net stop svn\n"
"C:\\&gt; net start svn\n"
msgstr ""
"\n"
"C:\\&gt; net stop svn\n"
"C:\\&gt; net start svn\n"

#: build/en/book.xml:13247(para)
msgid "The service can also be uninstalled (i.e. undefined) by deleting its definition: <literal moreinfo=\"none\">sc delete svn</literal>. Just be sure to stop the service first! The <command moreinfo=\"none\">SC.EXE</command> program has many other subcommands and options, run <literal moreinfo=\"none\">sc /?</literal> to learn more about it."
msgstr ""

#: build/en/book.xml:13260(title)
msgid "Built-in authentication and authorization"
msgstr "内置的认证和授权"

#: build/en/book.xml:13262(para)
msgid "When a client connects to an <command moreinfo=\"none\">svnserve</command> process, the following things happen:"
msgstr "如果一个客户端连接到<command moreinfo=\"none\">svnserve</command>进程，如下事情会发生："

#: build/en/book.xml:13266(para)
msgid "The client selects a specific repository."
msgstr "客户端选择特定的版本库。"

#: build/en/book.xml:13269(para)
msgid "The server processes the repository's <filename moreinfo=\"none\">conf/svnserve.conf</filename> file, and begins to enforce any authentication and authorization policies defined therein."
msgstr "服务器处理版本库的<filename moreinfo=\"none\">conf/svnserve.conf</filename>文件，并且执行里面定义的所有认证和授权政策。"

#: build/en/book.xml:13274(para)
msgid "Depending on the situation and authorization policies,"
msgstr "依赖于位置和授权政策，"

#: build/en/book.xml:13278(para)
msgid "the client may be allowed to make requests anonymously, without ever receiving an authentication challenge, OR"
msgstr "如果没有收到认证请求，客户端可能被允许匿名访问，或者"

#: build/en/book.xml:13282(para)
msgid "the client may be challenged for authentication at any time, OR"
msgstr "客户端收到认证请求，或者"

#: build/en/book.xml:13285(para)
msgid "if operating in <quote>tunnel mode</quote>, the client will declare itself to be already externally authenticated."
msgstr "如果操作在<quote>通道模式</quote>，客户端会宣布自己已经在外部得到认证。"

#: build/en/book.xml:13293(para)
#, fuzzy
msgid "At the time of writing, the server only knows how to send a CRAM-MD5 <placeholder-1/> authentication challenge. In essence, the server sends a small amount of data to the client. The client uses the MD5 hash algorithm to create a fingerprint of the data and password combined, then sends the fingerprint as a response. The server performs the same computation with the stored password to verify that the result is identical. <emphasis>At no point does the actual password travel over the network.</emphasis>"
msgstr "在撰写本文时，服务器还只知道怎样发送CRAM-MD5<placeholder-1/>认证请求，本质上讲，就是服务器发送一些数据到客户端，客户端使用MD5哈希算法创建这些数据组合密码的指纹，然后返回指纹，服务器执行同样的计算并且来计算结果的一致性，<emphasis>真正的密码并没有在互联网上传递。</emphasis>"

#: build/en/book.xml:13294(para)
msgid "See RFC 2195."
msgstr "见RFC 2195。"

#: build/en/book.xml:13304(para)
msgid "It's also possible, of course, for the client to be externally authenticated via a tunnel agent, such as <command moreinfo=\"none\">SSH</command>. In that case, the server simply examines the user it's running as, and uses it as the authenticated username. For more on this, see <xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>."
msgstr "当然也有可能，如果客户端在外部通过通道代理认证，如<command moreinfo=\"none\">SSH</command>，在那种情况下，服务器简单的检验作为那个用户的运行，然后使用它作为认证用户名，更多信息请看<xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>。"

#: build/en/book.xml:13310(para)
msgid "As you've already guessed, a repository's <filename moreinfo=\"none\">svnserve.conf</filename> file is the central mechanism for controlling authentication and authorization policies. The file has the same format as other configuration files (see <xref linkend=\"svn.advanced.confarea\"/>): section names are marked by square brackets (<literal moreinfo=\"none\">[</literal> and <literal moreinfo=\"none\">]</literal>), comments begin with hashes (<literal moreinfo=\"none\">#</literal>), and each section contains specific variables that can be set (<literal moreinfo=\"none\">variable = value</literal>). Let's walk through this file and learn how to use them."
msgstr "像你已经猜测到的，版本库的<filename moreinfo=\"none\">svnserve.conf</filename>文件是控制认证和授权政策的中央机构，这文件与其它配置文件格式相同（见<xref linkend=\"svn.advanced.confarea\"/>）：小节名称使用方括号标记（<literal moreinfo=\"none\">[</literal>和<literal moreinfo=\"none\">]</literal>），注释以井号（<literal moreinfo=\"none\">#</literal>）开始，每一小节都有一些参数可以设置（<literal moreinfo=\"none\">variable = value</literal>），让我们浏览这个文件并且学习怎样使用它们。"

#: build/en/book.xml:13324(title)
msgid "Create a 'users' file and realm"
msgstr "创建一个用户文件和域"

#: build/en/book.xml:13326(para)
msgid "For now, the <literal moreinfo=\"none\">[general]</literal> section of the <filename moreinfo=\"none\">svnserve.conf</filename> has all the variables you need. Begin by defining a file which contains usernames and passwords, and an authentication realm:"
msgstr "此时，<filename moreinfo=\"none\">svnserve.conf</filename>文件的<literal moreinfo=\"none\">[general]</literal>部分包括所有你需要的变量，开始先定义一个保存用户名和密码的文件和一个认证域："

#: build/en/book.xml:13331(screen)
#, no-wrap
msgid ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
msgstr ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"

#: build/en/book.xml:13337(para)
msgid "The <literal moreinfo=\"none\">realm</literal> is a name that you define. It tells clients which sort of <quote>authentication namespace</quote> they're connecting to; the Subversion client displays it in the authentication prompt, and uses it as a key (along with the server's hostname and port) for caching credentials on disk (see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>). The <literal moreinfo=\"none\">password-db</literal> variable points to a separate file that contains a list of usernames and passwords, using the same familiar format. For example:"
msgstr "<literal moreinfo=\"none\">realm</literal>是你定义的名称，这告诉客户端连接的<quote>认证命名空间</quote>，Subversion会在认证提示里显示，并且作为凭证缓存（见<xref linkend=\"svn.serverconfig.netmodel.credcache\"/>。）的关键字（还有服务器的主机名和端口），<literal moreinfo=\"none\">password-db</literal>参数指出了保存用户和密码列表文件，这个文件使用同样熟悉的格式，举个例子："

#: build/en/book.xml:13347(screen)
#, no-wrap
msgid ""
"\n"
"[users]\n"
"harry = foopassword\n"
"sally = barpassword\n"
msgstr ""
"\n"
"[users]\n"
"harry = foopassword\n"
"sally = barpassword\n"

#: build/en/book.xml:13353(para)
msgid "The value of <literal moreinfo=\"none\">password-db</literal> can be an absolute or relative path to the users file. For many admins, it's easy to keep the file right in the <filename moreinfo=\"none\">conf/</filename> area of the repository, alongside <filename moreinfo=\"none\">svnserve.conf</filename>. On the other hand, it's possible you may want to have two or more repositories share the same users file; in that case, the file should probably live in a more public place. The repositories sharing the users file should also be configured to have the same realm, since the list of users essentially defines an authentication realm. Wherever the file lives, be sure to set the file's read and write permissions appropriately. If you know which user(s) <command moreinfo=\"none\">svnserve</command> will run as, restrict read access to the user file as necessary."
msgstr "<literal moreinfo=\"none\">password-db</literal>的值可以是用户文件的绝对或相对路径，对许多管理员来说，把文件保存在版本库<filename moreinfo=\"none\">conf/</filename>下的<filename moreinfo=\"none\">svnserve.conf</filename>旁边是一个简单的方法。另一方面，可能你的多个版本库使用同一个用户文件，此时，这个文件应该在更公开的地方，版本库分享用户文件时必须配置为相同的域，因为用户列表本质上定义了一个认证域，无论这个文件在哪里，必须设置好文件的读写权限，如果你知道运行<command moreinfo=\"none\">svnserve</command>的用户，限定这个用户对这个文件有读权限是必须的。"

#: build/en/book.xml:13372(title)
msgid "Set access controls"
msgstr "设置访问控制"

#: build/en/book.xml:13374(para)
msgid "There are two more variables to set in the <filename moreinfo=\"none\">svnserve.conf</filename> file: they determine what unauthenticated (anonymous) and authenticated users are allowed to do. The variables <literal moreinfo=\"none\">anon-access</literal> and <literal moreinfo=\"none\">auth-access</literal> can be set to the values <literal moreinfo=\"none\">none</literal>, <literal moreinfo=\"none\">read</literal>, or <literal moreinfo=\"none\">write</literal>. Setting the value to <literal moreinfo=\"none\">none</literal> restricts all access of any kind; <literal moreinfo=\"none\">read</literal> allows read-only access to the repository, and <literal moreinfo=\"none\">write</literal> allows complete read/write access to the repository. For example:"
msgstr "<filename moreinfo=\"none\">svnserve.conf</filename>有两个或多个参数需要设置：它们确定未认证（匿名）和认证用户可以做的事情，参数<literal moreinfo=\"none\">anon-access</literal>和<literal moreinfo=\"none\">auth-access</literal>可以设置为<literal moreinfo=\"none\">none</literal>、<literal moreinfo=\"none\">read</literal>或者<literal moreinfo=\"none\">write</literal>，设置为<literal moreinfo=\"none\">none</literal>会限制所有方式的访问，<literal moreinfo=\"none\">read</literal>允许只读访问，而<literal moreinfo=\"none\">write</literal>允许对版本库完全的读/写权限："

#: build/en/book.xml:13386(screen)
#, no-wrap
msgid ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# anonymous users can only read the repository\n"
"anon-access = read\n"
"\n"
"# authenticated users can both read and write\n"
"auth-access = write\n"
msgstr ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# anonymous users can only read the repository\n"
"anon-access = read\n"
"\n"
"# authenticated users can both read and write\n"
"auth-access = write\n"

#: build/en/book.xml:1339(title)
msgid "The copy-modify-merge solution"
msgstr "拷贝-修改-合并 方案"

#: build/en/book.xml:13398(para)
msgid "The example settings are, in fact, the default values of the variables, should you forget to define them. If you want to be even more conservative, you can block anonymous access completely:"
msgstr "实例中的设置实际上是参数的缺省值，你一定不要忘了设置它们，如果你希望更保守一点，你可以完全封锁匿名访问："

#: build/en/book.xml:13403(screen)
#, no-wrap
msgid ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# anonymous users aren't allowed\n"
"anon-access = none\n"
"\n"
"# authenticated users can both read and write\n"
"auth-access = write\n"
msgstr ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# anonymous users aren't allowed\n"
"anon-access = none\n"
"\n"
"# authenticated users can both read and write\n"
"auth-access = write\n"

#: build/en/book.xml:13415(para)
msgid "The server process not only understands these <quote>blanket</quote> access controls to the repository, but also finer-grained access restrictions placed on specific files and directories within the repository. To make use of this feature, you need to define a file containing more detailed rules, and then set the <literal moreinfo=\"none\">authz-db</literal> variable to point to it:"
msgstr ""

#: build/en/book.xml:13423(screen)
#, no-wrap
msgid ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# Specific access rules for specific locations\n"
"authz-db = authzfile\n"
msgstr ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# Specific access rules for specific locations\n"
"authz-db = authzfile\n"

#: build/en/book.xml:13432(para)
msgid "The syntax of the <filename moreinfo=\"none\">authzfile</filename> file is discussed in detail in <xref linkend=\"svn.serverconfig.pathbasedauthz\"/>. Note that the <literal moreinfo=\"none\">authz-db</literal> variable isn't mutually exclusive with the <literal moreinfo=\"none\">anon-access</literal> and <literal moreinfo=\"none\">auth-access</literal> variables; if all the variables are defined at once, then <emphasis>all</emphasis> of the rules must be satisfied before access is allowed."
msgstr ""

#: build/en/book.xml:1344(title)
msgid "The copy-modify-merge solution (continued)"
msgstr "拷贝-修改-合并 方案（续）"

#: build/en/book.xml:13446(title)
msgid "Tunneling over SSH"
msgstr ""

#: build/en/book.xml:13448(para)
msgid "<command moreinfo=\"none\">svnserve</command>'s built-in authentication can be very handy, because it avoids the need to create real system accounts. On the other hand, some administrators already have well-established SSH authentication frameworks in place. In these situations, all of the project's users already have system accounts and the ability to <quote>SSH into</quote> the server machine."
msgstr "<command moreinfo=\"none\">svnserve</command>的内置认证会非常容易得到，因为它避免了创建真实的系统帐号，另一方面，一些管理员已经创建好了SSH认证框架，在这种情况下，所有的项目用户已经拥有了系统帐号和有能力<quote>SSH到</quote>服务器。"

#: build/en/book.xml:13456(para)
msgid "It's easy to use SSH in conjunction with <command moreinfo=\"none\">svnserve</command>. The client simply uses the <literal moreinfo=\"none\">svn+ssh://</literal> URL schema to connect:"
msgstr "SSH与<command moreinfo=\"none\">svnserve</command>结合很简单，客户端只需要使用<literal moreinfo=\"none\">svn+ssh://</literal>的URL模式来连接："

#: build/en/book.xml:13460(screen)
#, no-wrap
msgid ""
"\n"
"$ whoami\n"
"harry\n"
"\n"
"$ svn list svn+ssh://host.example.com/repos/project\n"
"harry@host.example.com's password:  *****\n"
"\n"
"foo\n"
"bar\n"
"baz\n"
"…\n"
msgstr ""
"\n"
"$ whoami\n"
"harry\n"
"\n"
"$ svn list svn+ssh://host.example.com/repos/project\n"
"harry@host.example.com's password:  *****\n"
"\n"
"foo\n"
"bar\n"
"baz\n"
"…\n"

#: build/en/book.xml:13473(para)
msgid "In this example, the Subversion client is invoking a local <command moreinfo=\"none\">ssh</command> process, connecting to <literal moreinfo=\"none\">host.example.com</literal>, authenticating as the user <literal moreinfo=\"none\">harry</literal>, then spawning a private <command moreinfo=\"none\">svnserve</command> process on the remote machine running as the user <literal moreinfo=\"none\">harry</literal>. The <command moreinfo=\"none\">svnserve</command> command is being invoked in tunnel mode (<option>-t</option>) and its network protocol is being <quote>tunneled</quote> over the encrypted connection by <command moreinfo=\"none\">ssh</command>, the tunnel-agent. <command moreinfo=\"none\">svnserve</command> is aware that it's running as the user <literal moreinfo=\"none\">harry</literal>, and if the client performs a commit, the authenticated username will be attributed as the author of the new revision."
msgstr "在这个例子里，Subversion客户端会调用一个<command moreinfo=\"none\">ssh</command>进程，连接到<literal moreinfo=\"none\">host.example.com</literal>，使用用户<literal moreinfo=\"none\">harry</literal>认证，然后会有一个<command moreinfo=\"none\">svnserve</command>私有进程以用户<literal moreinfo=\"none\">harry</literal>运行。<command moreinfo=\"none\">svnserve</command>是以管道模式调用的（<option>-t</option>），它的网络协议是通过<command moreinfo=\"none\">ssh</command><quote>封装的</quote>，被管道代理的<command moreinfo=\"none\">svnserve</command>会知道程序是以用户<literal moreinfo=\"none\">harry</literal>运行的，如果客户执行一个提交，认证的用户名会作为版本的参数保存到新的修订本。"

#: build/en/book.xml:1348(para)
msgid "But what if Sally's changes <emphasis>do</emphasis> overlap with Harry's changes? What then? This situation is called a <firstterm>conflict</firstterm>, and it's usually not much of a problem. When Harry asks his client to merge the latest repository changes into his working copy, his copy of file A is somehow flagged as being in a state of conflict: he'll be able to see both sets of conflicting changes, and manually choose between them. Note that software can't automatically resolve conflicts; only humans are capable of understanding and making the necessary intelligent choices. Once Harry has manually resolved the overlapping changes—perhaps after a discussion with Sally—he can safely save the merged file back to the repository."
msgstr "但是如果Sally和Harry的修改<emphasis>交迭</emphasis>了该怎么办？这种情况叫做<firstterm>冲突</firstterm>，这通常不是个大问题，当Harry告诉他的客户端去合并版本库的最新修改到自己的工作拷贝时，他的文件A就会处于冲突状态：他可以看到一对冲突的修改集，并手工的选择保留一组修改。需要注意的是软件不能自动的解决冲突，只有人可以理解并作出智能的选择，一旦Harry手工的解决了冲突—也许需要与Sally讨论—它可以安全的把合并的文件保存到版本库。"

#: build/en/book.xml:13488(para)
msgid "The important thing to understand here is that the Subversion client is <emphasis>not</emphasis> connecting to a running <command moreinfo=\"none\">svnserve</command> daemon. This method of access doesn't require a daemon, nor does it notice one if present. It relies wholly on the ability of <command moreinfo=\"none\">ssh</command> to spawn a temporary <command moreinfo=\"none\">svnserve</command> process, which then terminates when the network connection is closed."
msgstr "这里要理解的最重要的事情是Subversion客户端<emphasis>不</emphasis>是连接到运行中的<command moreinfo=\"none\">svnserve</command>守护进程，这种访问方法不需要一个运行的守护进程，也不需要在必要时唤醒一个，它依赖于<command moreinfo=\"none\">ssh</command>来发起一个<command moreinfo=\"none\">svnserve</command>进程，然后网络断开后终止进程。"

#: build/en/book.xml:13497(para)
msgid "When using <literal moreinfo=\"none\">svn+ssh://</literal> URLs to access a repository, remember that it's the <command moreinfo=\"none\">ssh</command> program prompting for authentication, and <emphasis>not</emphasis> the <command moreinfo=\"none\">svn</command> client program. That means there's no automatic password caching going on (see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>). The Subversion client often makes multiple connections to the repository, though users don't normally notice this due to the password caching feature. When using <literal moreinfo=\"none\">svn+ssh://</literal> URLs, however, users may be annoyed by <command moreinfo=\"none\">ssh</command> repeatedly asking for a password for every outbound connection. The solution is to use a separate SSH password-caching tool like <command moreinfo=\"none\">ssh-agent</command> on a Unix-like system, or <command moreinfo=\"none\">pageant</command> on Windows."
msgstr "当使用<literal moreinfo=\"none\">svn+ssh://</literal>的URL访问版本库时，记住是<command moreinfo=\"none\">ssh</command>提示请求认证，而<emphasis>不</emphasis>是<command moreinfo=\"none\">svn</command>客户端程序。这意味着密码不会有自动缓存（见<xref linkend=\"svn.serverconfig.netmodel.credcache\"/>），Subversion客户端通常会建立多个版本库的连接，但用户通常会因为密码缓存特性而没有注意到这一点，当使用<literal moreinfo=\"none\">svn+ssh://</literal>的URL时，用户会为<command moreinfo=\"none\">ssh</command>在每次建立连接时重复的询问密码感到讨厌，解决方案是用一个独立的SSH密码缓存工具，像类Unix系统的<command moreinfo=\"none\">ssh-agent</command>或者是Windows下的<command moreinfo=\"none\">pageant</command>。"

#: build/en/book.xml:13513(para)
#, fuzzy
msgid "When running over a tunnel, authorization is primarily controlled by operating system permissions to the repository's database files; it's very much the same as if Harry were accessing the repository directly via a <literal moreinfo=\"none\">file://</literal> URL. If multiple system users are going to be accessing the repository directly, you may want to place them into a common group, and you'll need to be careful about umasks. (Be sure to read <xref linkend=\"svn.serverconfig.multimethod\"/>.) But even in the case of tunneling, the <filename moreinfo=\"none\">svnserve.conf</filename> file can still be used to block access, by simply setting <literal moreinfo=\"none\">auth-access = read</literal> or <literal moreinfo=\"none\">auth-access = none</literal>. <placeholder-1/>"
msgstr "当在一个管道上运行时，认证通常是基于操作系统对版本库数据库文件的访问控制，这同Harry直接通过<literal moreinfo=\"none\">file:///</literal>的URL直接访问版本库非常类似，如果有多个系统用户要直接访问版本库，你会希望将他们放到一个常见的组里，你应该小心的使用umasks。（确定要阅读<xref linkend=\"svn.serverconfig.multimethod\"/>）但是即使是在管道模式时，文件<filename moreinfo=\"none\">svnserve.conf</filename>还是可以阻止用户访问，如<literal moreinfo=\"none\">auth-access = read</literal>或者<literal moreinfo=\"none\">auth-access = none</literal>。"

#: build/en/book.xml:13526(para)
#, fuzzy
msgid "Note that using any sort of <command moreinfo=\"none\">svnserve</command>-enforced access control at all is a bit pointless; the user already has direct access to the repository database."
msgstr "常规的系统用户连接使用SSH调用的访问版本库的<command moreinfo=\"none\">svnserve</command>进程（以它们自己运行）；"

#: build/en/book.xml:13533(para)
msgid "You'd think that the story of SSH tunneling would end here, but it doesn't. Subversion allows you to create custom tunnel behaviors in your run-time <filename moreinfo=\"none\">config</filename> file (see <xref linkend=\"svn.advanced.confarea\"/>). For example, suppose you want to use RSH instead of SSH. In the <literal moreinfo=\"none\">[tunnels]</literal> section of your <filename moreinfo=\"none\">config</filename> file, simply define it like this:"
msgstr "你会认为SSH管道的故事该结束了，但还不是，Subversion允许你在运行配置文件<filename moreinfo=\"none\">config</filename>（见<xref linkend=\"svn.advanced.confarea\"/>）创建一个自定义的管道行为方式，举个例子，假定你希望使用RSH而不是SSH，在<filename moreinfo=\"none\">config</filename>文件的<literal moreinfo=\"none\">[tunnels]</literal>部分作如下定义："

#: build/en/book.xml:13542(screen)
#, no-wrap
msgid ""
"\n"
"[tunnels]\n"
"rsh = rsh\n"
msgstr ""
"\n"
"[tunnels]\n"
"rsh = rsh\n"

#: build/en/book.xml:13547(para)
msgid "And now, you can use this new tunnel definition by using a URL schema that matches the name of your new variable: <literal moreinfo=\"none\">svn+rsh://host/path</literal>. When using the new URL schema, the Subversion client will actually be running the command <command moreinfo=\"none\">rsh host svnserve -t</command> behind the scenes. If you include a username in the URL (for example, <literal moreinfo=\"none\">svn+rsh://username@host/path</literal>) the client will also include that in its command (<command moreinfo=\"none\">rsh username@host svnserve -t</command>). But you can define new tunneling schemes to be much more clever than that:"
msgstr "现在你可以通过指定与定义匹配的URL模式来使用新的管道定义：<literal moreinfo=\"none\">svn+rsh://host/path</literal>。当使用新的URL模式时，Subversion客户端实际上会在后台运行<command moreinfo=\"none\">rsh host svnserve -t</command>这个命令，如果你在URL中包括一个用户名（例如，<literal moreinfo=\"none\">svn+rsh://username@host/path</literal>），客户端也会在自己的命令中包含这部分（<command moreinfo=\"none\">rsh username@host svnserve -t</command>），但是你可以定义比这个更加智能的新的管道模式："

#: build/en/book.xml:13558(screen)
#, no-wrap
msgid ""
"\n"
"[tunnels]\n"
"joessh = $JOESSH /opt/alternate/ssh -p 29934\n"
msgstr ""
"\n"
"[tunnels]\n"
"joessh = $JOESSH /opt/alternate/ssh -p 29934\n"

#: build/en/book.xml:13563(para)
msgid "This example demonstrates a couple of things. First, it shows how to make the Subversion client launch a very specific tunneling binary (the one located at <filename moreinfo=\"none\">/opt/alternate/ssh</filename>) with specific options. In this case, accessing a <literal moreinfo=\"none\">svn+joessh://</literal> URL would invoke the particular SSH binary with <option>-p 29934</option> as arguments—useful if you want the tunnel program to connect to a non-standard port."
msgstr "这个例子里论证了一些事情，首先，它展现了如何让Subversion客户端启动一个特定的管道程序（这个在<filename moreinfo=\"none\">/opt/alternate/ssh</filename>），在这个例子里，使用<literal moreinfo=\"none\">svn+joessh://</literal>的URL会以<option>-p 29934</option>参数调用特定的SSH程序—对连接到非标准端口的程序非常有用。"

#: build/en/book.xml:13573(para)
msgid "Second, it shows how to define a custom environment variable that can override the name of the tunneling program. Setting the <literal moreinfo=\"none\">SVN_SSH</literal> environment variable is a convenient way to override the default SSH tunnel agent. But if you need to have several different overrides for different servers, each perhaps contacting a different port or passing a different set of options to SSH, you can use the mechanism demonstrated in this example. Now if we were to set the <literal moreinfo=\"none\">JOESSH</literal> environment variable, its value would override the entire value of the tunnel variable—<command moreinfo=\"none\">$JOESSH</command> would be executed instead of <command moreinfo=\"none\">/opt/alternate/ssh -p 29934</command>."
msgstr "第二点，它展示了怎样定义一个自定义的环境变量来覆盖管道程序中的名字，设置<literal moreinfo=\"none\">SVN_SSH</literal>环境变量是覆盖缺省的SSH管道的一种简便方法，但是如果你需要为多个服务器做出多个不同的覆盖，或许每一个都联系不同的端口或传递不同的SSH选项，你可以使用本例论述的机制。现在如果我们设置<literal moreinfo=\"none\">JOESSH</literal>环境变量，它的值会覆盖管道中的变量值—会执行<command moreinfo=\"none\">$JOESSH</command>而不是<command moreinfo=\"none\">/opt/alternate/ssh -p 29934</command>。"

#: build/en/book.xml:13591(title)
msgid "SSH configuration tricks"
msgstr "SSH配置技巧"

#: build/en/book.xml:13593(para)
msgid "It's not only possible to control the way in which the client invokes <command moreinfo=\"none\">ssh</command>, but also to control the behavior of <command moreinfo=\"none\">sshd</command> on your server machine. In this section, we'll show how to control the exact <command moreinfo=\"none\">svnserve</command> command executed by <command moreinfo=\"none\">sshd</command>, as well as how to have multiple users share a single system account."
msgstr "不仅仅是可以控制客户端调用<command moreinfo=\"none\">ssh</command>方式，也可以控制服务器中的<command moreinfo=\"none\">sshd</command>的行为方式，在本小节，我们会展示怎样控制<command moreinfo=\"none\">sshd</command>执行<command moreinfo=\"none\">svnserve</command>，包括如何让多个用户分享同一个系统帐户。"

#: build/en/book.xml:13605(para)
msgid "To begin, locate the home directory of the account you'll be using to launch <command moreinfo=\"none\">svnserve</command>. Make sure the account has an SSH public/private keypair installed, and that the user can log in via public-key authentication. Password authentication will not work, since all of the following SSH tricks revolve around using the SSH <filename moreinfo=\"none\">authorized_keys</filename> file."
msgstr "作为开始，定位到你启动<command moreinfo=\"none\">svnserve</command>的帐号的主目录，确定这个账户已经安装了一套SSH公开/私有密钥对，用户可以通过公开密钥认证，因为所有如下的技巧围绕着使用SSH<filename moreinfo=\"none\">authorized_keys</filename>文件，密码认证在这里不会工作。"

#: build/en/book.xml:13613(para)
msgid "If it doesn't already exist, create the <filename moreinfo=\"none\">authorized_keys</filename> file (on Unix, typically <filename moreinfo=\"none\">~/.ssh/authorized_keys</filename>). Each line in this file describes a public key that is allowed to connect. The lines are typically of the form:"
msgstr "如果这个文件还不存在，创建一个<filename moreinfo=\"none\">authorized_keys</filename>文件（在UNIX下通常是<filename moreinfo=\"none\">~/.ssh/authorized_keys</filename>），这个文件的每一行描述了一个允许连接的公钥，这些行通常是下面的形式："

#: build/en/book.xml:1362(para)
#, fuzzy
msgid "The copy-modify-merge model may sound a bit chaotic, but in practice, it runs extremely smoothly. Users can work in parallel, never waiting for one another. When they work on the same files, it turns out that most of their concurrent changes don't overlap at all; conflicts are infrequent. And the amount of time it takes to resolve conflicts is usually far less than the time lost by a locking system."
msgstr "拷贝-修改-合并模型感觉是有一点混乱，但在实践中，通常运行的很平稳，用户可以并行的工作，不必等待别人，当工作在同一个文件上时，也很少会有交迭发生，冲突并不频繁，处理冲突的时间远比等待解锁花费的时间少。"

#: build/en/book.xml:13620(screen)
#, no-wrap
msgid ""
"\n"
"  ssh-dsa AAAABtce9euch… user@example.com\n"
msgstr ""
"\n"
"  ssh-dsa AAAABtce9euch.... user@example.com\n"

#: build/en/book.xml:13624(para)
msgid "The first field describes the type of key, the second field is the uuencoded key itself, and the third field is a comment. However, it's a lesser known fact that the entire line can be preceded by a <literal moreinfo=\"none\">command</literal> field:"
msgstr "第一个字段描述了密钥的类型，第二个字段是未加密的密钥本身，第三个字段是注释。然而，这是一个很少人知道的事实，可以使用一个<literal moreinfo=\"none\">command</literal>来处理整行："

#: build/en/book.xml:13630(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"program\" ssh-dsa AAAABtce9euch… user@example.com\n"
msgstr ""
"\n"
"  command=\"program\" ssh-dsa AAAABtce9euch.... user@example.com\n"

#: build/en/book.xml:13634(para)
msgid "When the <literal moreinfo=\"none\">command</literal> field is set, the SSH daemon will run the named program instead of the typical <command moreinfo=\"none\">svnserve -t</command> invocation that the Subversion client asks for. This opens the door to a number of server-side tricks. In the following examples, we abbreviate the lines of the file as:"
msgstr "当<literal moreinfo=\"none\">command</literal>字段设置后，SSH守护进程运行命名的程序而不是通常Subversion客户端询问的<command moreinfo=\"none\">svnserve -t</command>。这为实施许多服务器端技巧开启了大门，在下面的例子里，我们简写了文件的这些行："

#: build/en/book.xml:13641(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"program\" TYPE KEY COMMENT\n"
msgstr ""
"\n"
"  command=\"program\" TYPE KEY COMMENT\n"

#: build/en/book.xml:13649(title)
msgid "Controlling the invoked command"
msgstr "控制调用的命令"

#: build/en/book.xml:13651(para)
msgid "Because we can specify the executed server-side command, it's easy to name a specific <command moreinfo=\"none\">svnserve</command> binary to run and to pass it extra arguments:"
msgstr "因为我们可以指定服务器端执行的命令，我们很容易来选择运行一个特定的<command moreinfo=\"none\">svnserve</command>程序来并且传递给它额外的参数："

#: build/en/book.xml:13655(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"/path/to/svnserve -t -r /virtual/root\" TYPE KEY COMMENT\n"
msgstr ""
"\n"
"  command=\"/path/to/svnserve -t -r /virtual/root\" TYPE KEY COMMENT\n"

#: build/en/book.xml:13659(para)
msgid "In this example, <filename moreinfo=\"none\">/path/to/svnserve</filename> might be a custom wrapper script around <command moreinfo=\"none\">svnserve</command> which sets the umask (see <xref linkend=\"svn.serverconfig.multimethod\"/>). It also shows how to anchor <command moreinfo=\"none\">svnserve</command> in a virtual root directory, just as one often does when running <command moreinfo=\"none\">svnserve</command> as a daemon process. This might be done either to restrict access to parts of the system, or simply to relieve the user of having to type an absolute path in the <literal moreinfo=\"none\">svn+ssh://</literal> URL."
msgstr "在这个例子里，<filename moreinfo=\"none\">/path/to/svnserve</filename>也许会是一个<command moreinfo=\"none\">svnserve</command>程序的包裹脚本，会来设置umask（见<xref linkend=\"svn.serverconfig.multimethod\"/>）。它也展示了怎样在虚拟根目录定位一个<command moreinfo=\"none\">svnserve</command>，就像我们经常在使用守护进程模式下运行<command moreinfo=\"none\">svnserve</command>一样。这样做不仅可以把访问限制在系统的一部分，也可以使用户不需要在<literal moreinfo=\"none\">svn+ssh://</literal>URL里输入绝对路径。"

#: build/en/book.xml:13671(para)
msgid "It's also possible to have multiple users share a single account. Instead of creating a separate system account for each user, generate a public/private keypair for each person. Then place each public key into the <filename moreinfo=\"none\">authorized_users</filename> file, one per line, and use the <option>--tunnel-user</option> option:"
msgstr "多个用户也可以共享同一个帐号，作为为每个用户创建系统帐户的替代，我们创建一个公开/私有密钥对，然后在<filename moreinfo=\"none\">authorized_users</filename>文件里放置各自的公钥，一个用户一行，使用<option>--tunnel-user</option>选项："

#: build/en/book.xml:13679(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"svnserve -t --tunnel-user=harry\" TYPE1 KEY1 harry@example.com\n"
"  command=\"svnserve -t --tunnel-user=sally\" TYPE2 KEY2 sally@example.com\n"
msgstr ""
"\n"
"  command=\"svnserve -t --tunnel-user=harry\" TYPE1 KEY1 harry@example.com\n"
"  command=\"svnserve -t --tunnel-user=sally\" TYPE2 KEY2 sally@example.com\n"

#: build/en/book.xml:13684(para)
msgid "This example allows both Harry and Sally to connect to the same account via public-key authentication. Each of them has a custom command that will be executed; the <option>--tunnel-user</option> option tells <command moreinfo=\"none\">svnserve -t</command> to assume that the named argument is the authenticated user. Without <option>--tunnel-user</option>, it would appear as though all commits were coming from the one shared system account."
msgstr "这个例子允许Harry和Sally通过公钥认证连接同一个的账户，每个人自定义的命令将会执行。<option>--tunnel-user</option>选项告诉<command moreinfo=\"none\">svnserve -t</command>命令采用命名的参数作为经过认证的用户，如果没有<option>--tunnel-user</option>，所有的提交会作为共享的系统帐户提交。"

#: build/en/book.xml:13694(para)
msgid "A final word of caution: giving a user access to the server via public-key in a shared account might still allow other forms of SSH access, even if you've set the <literal moreinfo=\"none\">command</literal> value in <filename moreinfo=\"none\">authorized_keys</filename>. For example, the user may still get shell access through SSH, or be able to perform X11 or general port-forwarding through your server. To give the user as little permission as possible, you may want to specify a number of restrictive options immediately after the <literal moreinfo=\"none\">command</literal>:"
msgstr "最后要小心：设定通过公钥共享账户进行用户访问时还会允许其它形式的SSH访问，即使你设置了<filename moreinfo=\"none\">authorized_keys</filename>的<literal moreinfo=\"none\">command</literal>值，举个例子，用户仍然可以通过SSH得到shell访问，或者是通过服务器执行X11或者是端口转发。为了给用户尽可能少的访问权限，你或许希望在<literal moreinfo=\"none\">command</literal>命令之后指定一些限制选项："

#: build/en/book.xml:1370(para)
msgid "In the end, it all comes down to one critical factor: user communication. When users communicate poorly, both syntactic and semantic conflicts increase. No system can force users to communicate perfectly, and no system can detect semantic conflicts. So there's no point in being lulled into a false promise that a locking system will somehow prevent conflicts; in practice, locking seems to inhibit productivity more than anything else."
msgstr "最后，一切都要归结到一条重要的因素：用户交流。当用户交流贫乏，语法和语义的冲突就会增加，没有系统可以强制用户完美的交流，没有系统可以检测语义上的冲突，所以没有任何证据能够承诺锁定系统可以防止冲突，实践中，锁定除了约束了生产力，并没有做什么事。"

#: build/en/book.xml:13705(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"svnserve -t --tunnel-user=harry\",no-port-forwarding,\\\n"
"           no-agent-forwarding,no-X11-forwarding,no-pty \\\n"
"           TYPE1 KEY1 harry@example.com\n"
msgstr ""
"\n"
"  command=\"svnserve -t --tunnel-user=harry\",no-port-forwarding,\\\n"
"           no-agent-forwarding,no-X11-forwarding,no-pty \\\n"
"           TYPE1 KEY1 harry@example.com\n"

#: build/en/book.xml:13723(title)
msgid "httpd, the Apache HTTP server"
msgstr "httpd，Apache的HTTP服务器"

#: build/en/book.xml:13725(para)
#, fuzzy
msgid "The Apache HTTP Server is a <quote>heavy duty</quote> network server that Subversion can leverage. Via a custom module, <command moreinfo=\"none\">httpd</command> makes Subversion repositories available to clients via the WebDAV/DeltaV protocol, which is an extension to HTTP 1.1 (see <ulink url=\"http://www.webdav.org/\"/> for more information). This protocol takes the ubiquitous HTTP protocol that is the core of the World Wide Web, and adds writing—specifically, versioned writing—capabilities. The result is a standardized, robust system that is conveniently packaged as part of the Apache 2.0 software, is supported by numerous operating systems and third-party products, and doesn't require network administrators to open up yet another custom port. <placeholder-1/> While an Apache-Subversion server has more features than <command moreinfo=\"none\">svnserve</command>, it's also a bit more difficult to set up. With flexibility often comes more complexity."
msgstr "Apache的HTTP服务器是一个Subversion可以利用的<quote>重型</quote>网络服务器，通过一个自定义模块，<command moreinfo=\"none\">httpd</command>可以让Subversion版本库通过WebDAV/DeltaV协议在客户端前可见，WebDAV/DeltaV协议是HTTP 1.1的扩展（见<ulink url=\"http://www.webdav.org/\"/>来查看详细信息）。这个协议利用了无处不在的HTTP协议是广域网的核心这一点，添加了写能力—更明确一点，版本化的写—能力。结果就是这样一个标准化的健壮的系统，作为Apache 2.0软件的一部分打包，被许多操作系统和第三方产品支持，网络管理员也不需要打开另一个自定义端口。 <footnote><placeholder-1/></footnote>这样一个Apache-Subversion服务器具备了许多<command moreinfo=\"none\">svnserve</command>没有的特性，但是也有一点难于配置，灵活通常会带来复杂性。"

#: build/en/book.xml:13739(para)
msgid "They really hate doing that."
msgstr "他们讨厌这样做。"

#: build/en/book.xml:13745(para)
msgid "Much of the following discussion includes references to Apache configuration directives. While some examples are given of the use of these directives, describing them in full is outside the scope of this chapter. The Apache team maintains excellent documentation, publicly available on their website at <ulink url=\"http://httpd.apache.org\"/>. For example, a general reference for the configuration directives is located at <ulink url=\"       http://httpd.apache.org/docs-2.0/mod/directives.html\"/>."
msgstr "下面的讨论包括了对Apache配置指示的引用，给了一些使用这些指示的例子，详细地描述不在本章的范围之内，Apache小组维护了完美的文档，公开存放在他们的站点<ulink url=\"http://httpd.apache.org\"/>。例如，一个一般的配置参考位于<ulink url=\"       http://httpd.apache.org/docs-2.0/mod/directives.html\"/>。"

#: build/en/book.xml:13753(para)
msgid "Also, as you make changes to your Apache setup, it is likely that somewhere along the way a mistake will be made. If you are not already familiar with Apache's logging subsystem, you should become aware of it. In your <filename moreinfo=\"none\">httpd.conf</filename> file are directives that specify the on-disk locations of the access and error logs generated by Apache (the <literal moreinfo=\"none\">CustomLog</literal> and <literal moreinfo=\"none\">ErrorLog</literal> directives, respectively). Subversion's mod_dav_svn uses Apache's error logging interface as well. You can always browse the contents of those files for information that might reveal the source of a problem that is not clearly noticeable otherwise."
msgstr "同样，当你修改你的Apache设置，很有可能会出现一些错误，如果你还不熟悉Apache的日志子系统，你一定需要认识到这一点。在你的文件<filename moreinfo=\"none\">httpd.conf</filename>里会指定Apache生成的访问和错误日志（<literal moreinfo=\"none\">CustomLog</literal>和<literal moreinfo=\"none\">ErrorLog</literal>指示）的磁盘位置。Subversion的mod_dav_svn使用Apache的错误日志接口，你可以浏览这个文件的内容查看信息来查找难于发现的问题根源。"

#: build/en/book.xml:13767(title)
msgid "Why Apache 2?"
msgstr "为什么是Apache 2？"

#: build/en/book.xml:13769(para)
msgid "If you're a system administrator, it's very likely that you're already running the Apache web server and have some prior experience with it. At the time of writing, Apache 1.3 is by far the most popular version of Apache. The world has been somewhat slow to upgrade to the Apache 2.X series for various reasons: some people fear change, especially changing something as critical as a web server. Other people depend on plug-in modules that only work against the Apache 1.3 API, and are waiting for a 2.X port. Whatever the reason, many people begin to worry when they first discover that Subversion's Apache module is written specifically for the Apache 2 API."
msgstr "如果你系统管理员，很有可能是你已经运行了Apache服务器，并且有一些高级经验。写本文的时候，Apache 1.3是Apache最流行的版本，这个世界因为许多原因而放缓升级到2.X系列：如人们害怕改变，特别是像web服务器这种重要的变化，有些人需要一些在Apache 1.3 API下工作的插件模块，在等待2.X的版本。无论什么原因，许多人会在首次发现Subversion的Apache模块只是为Apache 2 API写的后开始担心。"

#: build/en/book.xml:13781(para)
msgid "The proper response to this problem is: don't worry about it. It's easy to run Apache 1.3 and Apache 2 side-by-side; simply install them to separate places, and use Apache 2 as a dedicated Subversion server that runs on a port other than 80. Clients can access the repository by placing the port number into the URL:"
msgstr "对此问题的适当反应是：不需要担心，同时运行Apache 1.3和Apache 2非常简单，只需要安装到不同的位置，用Apache 2作为Subversion的专用服务器，并且不使用80端口，客户端可以访问版本库时在URL里指定端口："

#: build/en/book.xml:13788(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://host.example.com:7382/repos/project\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout http://host.example.com:7382/repos/project\n"
"…\n"

#: build/en/book.xml:13797(title)
msgid "Prerequisites"
msgstr "必备条件"

#: build/en/book.xml:13799(para)
msgid "To network your repository over HTTP, you basically need four components, available in two packages. You'll need Apache <command moreinfo=\"none\">httpd</command> 2.0, the <command moreinfo=\"none\">mod_dav</command> DAV module that comes with it, Subversion, and the <command moreinfo=\"none\">mod_dav_svn</command> filesystem provider module distributed with Subversion. Once you have all of those components, the process of networking your repository is as simple as:"
msgstr "为了让你的版本库使用HTTP网络，你基本上需要两个包里的四个部分。你需要Apache <command moreinfo=\"none\">httpd</command> 2.0和包括的<command moreinfo=\"none\">mod_dav</command> DAV模块，Subversion和与之一同分发的<command moreinfo=\"none\">mod_dav_svn</command>文件系统提供者模块，如果你有了这些组件，网络化你的版本库将非常简单，如："

#: build/en/book.xml:138(para)
msgid "The three co-authors of the new book were thus presented with an unusual opportunity. Officially, their task was to write a book top-down, starting from a table of contents and an initial draft. But they also had access to a steady stream—indeed, an uncontrollable geyser—of bottom-up source material. Subversion was already in the hands of thousands of early adopters, and those users were giving tons of feedback, not only about Subversion, but about its existing documentation."
msgstr "新书的三位合著者因而面临着一个不寻常的机会。从职责上讲，他们的任务是从一个目录和一些草稿为基础，自上而下的写一部专著。但事实上，他们的灵感源泉则来自一些具体的内容，稳定却难以组织。Subversion被数以千计的早期用户采用，这些用户提供了大量的反馈，不仅仅针对Subversion，还包括业已存在的文档。"

#: build/en/book.xml:1380(title)
msgid "When Locking is Necessary"
msgstr "什么时候锁定是必需的"

#: build/en/book.xml:13810(para)
msgid "getting httpd 2.0 up and running with the mod_dav module,"
msgstr "配置好httpd 2.0，并且使用mod_dav启动，"

#: build/en/book.xml:13814(para)
msgid "installing the mod_dav_svn plugin to mod_dav, which uses Subversion's libraries to access the repository, and"
msgstr "为mod_dav安装mod_dav_svn插件，它会使用Subversion的库访问版本库，并且"

#: build/en/book.xml:13819(para)
msgid "configuring your <filename moreinfo=\"none\">httpd.conf</filename> file to export (or expose) the repository."
msgstr "配置你的<filename moreinfo=\"none\">httpd.conf</filename>来输出（或者说暴露）版本库。"

#: build/en/book.xml:1382(para)
msgid "While the lock-modify-unlock model is considered generally harmful to collaboration, there are still times when locking is appropriate."
msgstr "锁定-修改-解锁模型被认为不利于协作，但有时候锁定会更好。"

#: build/en/book.xml:13824(para)
msgid "You can accomplish the first two items either by compiling <command moreinfo=\"none\">httpd</command> and Subversion from source code, or by installing pre-built binary packages of them on your system. For the most up-to-date information on how to compile Subversion for use with the Apache HTTP Server, as well as how to compile and configure Apache itself for this purpose, see the <filename moreinfo=\"none\">INSTALL</filename> file in the top level of the Subversion source code tree."
msgstr "你可以通过从源代码编译<command moreinfo=\"none\">httpd</command>和Subversion来完成前两个项目，也可以通过你的系统上的已经编译好的二进制包来安装。最新的使用Apache HTTP的Subversion的编译方法和Apache的配置方式可以看Subversion源代码树根目录的<filename moreinfo=\"none\">INSTALL</filename>文件。"

#: build/en/book.xml:13837(title)
msgid "Basic Apache Configuration"
msgstr "基本的Apache配置"

#: build/en/book.xml:13839(para)
msgid "Once you have all the necessary components installed on your system, all that remains is the configuration of Apache via its <filename moreinfo=\"none\">httpd.conf</filename> file. Instruct Apache to load the mod_dav_svn module using the <literal moreinfo=\"none\">LoadModule</literal> directive. This directive must precede any other Subversion-related configuration items. If your Apache was installed using the default layout, your <command moreinfo=\"none\">mod_dav_svn</command> module should have been installed in the <filename moreinfo=\"none\">modules</filename> subdirectory of the Apache install location (often <filename moreinfo=\"none\">/usr/local/apache2</filename>). The <literal moreinfo=\"none\">LoadModule</literal> directive has a simple syntax, mapping a named module to the location of a shared library on disk:"
msgstr "一旦你安装了必须的组件，剩下的工作就是在<filename moreinfo=\"none\">httpd.conf</filename>里配置Apache，使用<literal moreinfo=\"none\">LoadModule</literal>来加载mod_dav_svn模块，这个指示必须先与其它Subversion相关的其它配置出现，如果你的Apache使用缺省布局安装，你的<command moreinfo=\"none\">mod_dav_svn</command>模块一定在Apache安装目录（通常是在<filename moreinfo=\"none\">/usr/local/apache2</filename>）的<filename moreinfo=\"none\">modules</filename>子目录，<literal moreinfo=\"none\">LoadModule</literal>指示的语法很简单，影射一个名字到它的共享库的物理位置："

#: build/en/book.xml:13854(screen)
#, no-wrap
msgid ""
"\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"
msgstr ""
"\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"

#: build/en/book.xml:13858(para)
msgid "Note that if <command moreinfo=\"none\">mod_dav</command> was compiled as a shared object (instead of statically linked directly to the <command moreinfo=\"none\">httpd</command> binary), you'll need a similar <literal moreinfo=\"none\">LoadModule</literal> statement for it, too. Be sure that it comes before the <command moreinfo=\"none\">mod_dav_svn</command> line:"
msgstr "注意，如果<command moreinfo=\"none\">mod_dav</command>是作为共享对象编译（而不是静态链接到<command moreinfo=\"none\">httpd</command>程序），你需要为它使用使用<literal moreinfo=\"none\">LoadModule</literal>语句，一定确定它在<command moreinfo=\"none\">mod_dav_svn</command>之前："

#: build/en/book.xml:1386(para)
msgid "The copy-modify-merge model is based on the assumption that files are contextually mergeable: that is, that the majority of the files in the repository are line-based text files (such as program source code). But for files with binary formats, such as artwork or sound, it's often impossible to merge conflicting changes. In these situations, it really is necessary to users to take strict turns when changing the file. Without serialized access, somebody ends up wasting time on changes that are ultimately discarded."
msgstr "拷贝-修改-合并模型假定文件是可以根据上下文合并的：就是版本库的文件主要是以行为基础的文本文件（例如程序源代码）。但对于二进制格式，例如艺术品或声音，在这种情况下，十分有必要让用户轮流修改文件，如果没有线性的访问，有些人的许多工作就最终要被放弃。"

#: build/en/book.xml:13864(screen)
#, no-wrap
msgid ""
"\n"
"LoadModule dav_module         modules/mod_dav.so\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"
msgstr ""
"\n"
"LoadModule dav_module         modules/mod_dav.so\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"

#: build/en/book.xml:13870(para)
msgid "At a later location in your configuration file, you now need to tell Apache where you keep your Subversion repository (or repositories). The <literal moreinfo=\"none\">Location</literal> directive has an XML-like notation, starting with an opening tag, and ending with a closing tag, with various other configuration directives in the middle. The purpose of the <literal moreinfo=\"none\">Location</literal> directive is to instruct Apache to do something special when handling requests that are directed at a given URL or one of its children. In the case of Subversion, you want Apache to simply hand off support for URLs that point at versioned resources to the DAV layer. You can instruct Apache to delegate the handling of all URLs whose path portions (the part of the URL that follows the server's name and the optional port number) begin with <filename moreinfo=\"none\">/repos/</filename> to a DAV provider whose repository is located at <filename moreinfo=\"none\">/absolute/path/to/repository</filename> using the following <filename moreinfo=\"none\">httpd.conf</filename> syntax:"
msgstr "在你的配置文件后面的位置，你需要告诉Apache你在什么地方保存Subversion版本库（也许是多个），<literal moreinfo=\"none\">位置</literal>指示有一个很像XML的符号，开始于一个开始标签，以一个结束标签结束，配合中间许多的其它配置。<literal moreinfo=\"none\">Location</literal>指示的目的是告诉Apache在特定的URL以及子URL下需要特殊的处理，如果是为Subversion准备的，你希望可以通过告诉Apache特定URL是指向版本化的资源，从而把支持转交给DAV层，你可以告诉Apache将所有路径部分（URL中服务器名称和端口之后的部分）以<filename moreinfo=\"none\">/repos/</filename>开头的URL交由DAV服务提供者处理。一个DAV服务提供者的版本库位于<filename moreinfo=\"none\">/absolute/path/to/repository</filename>，可以使用如下的<filename moreinfo=\"none\">httpd.conf</filename>语法："

#: build/en/book.xml:13889(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNPath /absolute/path/to/repository\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNPath /absolute/path/to/repository\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:13896(para)
#, fuzzy
msgid "If you plan to support multiple Subversion repositories that will reside in the same parent directory on your local disk, you can use an alternative directive, the <literal moreinfo=\"none\">SVNParentPath</literal> directive, to indicate that common parent directory. For example, if you know you will be creating multiple Subversion repositories in a directory <filename moreinfo=\"none\">/usr/local/svn</filename> that would be accessed via URLs like <uri>http://my.server.com/svn/repos1</uri>, <uri>http://my.server.com/svn/repos2</uri>, and so on, you could use the <filename moreinfo=\"none\">httpd.conf</filename> configuration syntax in the following example:"
msgstr "如果你计划支持多个具备相同父目录的Subversion版本库，你有另外的选择，<literal moreinfo=\"none\">SVNParentPath</literal>指示，来表示共同的父目录。举个例子，如果你知道你会在<filename moreinfo=\"none\">/usr/local/svn</filename>下创建多个Subversion版本库，并且通过类似<systemitem class=\"url\" moreinfo=\"none\">http://my.server.com/svn/repos1</systemitem>，<systemitem class=\"url\" moreinfo=\"none\">http://my.server.com/svn/repos2</systemitem>的URL访问，你可以用后面例子中的<filename moreinfo=\"none\">httpd.conf</filename>配置语法："

#: build/en/book.xml:13908(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"\n"
"  # any \"/svn/foo\" URL will map to a repository /usr/local/svn/foo\n"
"  SVNParentPath /usr/local/svn\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"\n"
"  # any \"/svn/foo\" URL will map to a repository /usr/local/svn/foo\n"
"  SVNParentPath /usr/local/svn\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:13917(para)
msgid "Using the previous syntax, Apache will delegate the handling of all URLs whose path portions begin with <filename moreinfo=\"none\">/svn/</filename> to the Subversion DAV provider, which will then assume that any items in the directory specified by the <literal moreinfo=\"none\">SVNParentPath</literal> directive are actually Subversion repositories. This is a particularly convenient syntax in that, unlike the use of the <literal moreinfo=\"none\">SVNPath</literal> directive, you don't have to restart Apache in order to create and network new repositories."
msgstr "使用上面的语法，Apache会代理所有URL路径部分为<filename moreinfo=\"none\">/svn/</filename>的请求到Subversion的DAV提供者，Subversion会认为<literal moreinfo=\"none\">SVNParentPath</literal>指定的目录下的所有项目是真实的Subversion版本库，这通常是一个便利的语法，不像是用<literal moreinfo=\"none\">SVNPath</literal>指示，我们在此不必为创建新的版本库而重启Apache。"

#: build/en/book.xml:13928(para)
#, fuzzy
msgid "Be sure that when you define your new <literal moreinfo=\"none\">Location</literal>, it doesn't overlap with other exported Locations. For example, if your main <literal moreinfo=\"none\">DocumentRoot</literal> is exported to <filename moreinfo=\"none\">/www</filename>, do not export a Subversion repository in <literal moreinfo=\"none\">&lt;Location /www/repos&gt;</literal>. If a request comes in for the URI <filename moreinfo=\"none\">/www/repos/foo.c</filename>, Apache won't know whether to look for a file <filename moreinfo=\"none\">repos/foo.c</filename> in the <literal moreinfo=\"none\">DocumentRoot</literal>, or whether to delegate <command moreinfo=\"none\">mod_dav_svn</command> to return <filename moreinfo=\"none\">foo.c</filename> from the Subversion repository."
msgstr "请确定当你定义新的<literal moreinfo=\"none\">位置</literal>，不会与其它输出的位置重叠，例如你的主要<literal moreinfo=\"none\">DocumentRoot</literal>是<filename moreinfo=\"none\">/www</filename>，不要把Subversion版本库输出到<literal moreinfo=\"none\">&lt;Location /www/repos&gt;</literal>，如果一个请求的URI是<filename moreinfo=\"none\">/www/repos/foo.c</filename>，Apache不知道是直接到<filename moreinfo=\"none\">repos/foo.c</filename>访问这个文件还是让<command moreinfo=\"none\">mod_dav_svn</command>代理从Subversion版本库返回<filename moreinfo=\"none\">foo.c</filename>。"

#: build/en/book.xml:13943(title)
msgid "Server Names and the COPY Request"
msgstr "服务器名称和拷贝请求"

#: build/en/book.xml:13945(para)
msgid "Subversion makes use of the <literal moreinfo=\"none\">COPY</literal> request type to perform server-side copies of files and directories. As part of the sanity checking done by the Apache modules, the source of the copy is expected to be located on the same machine as the destination of the copy. To satisfy this requirement, you might need to tell mod_dav the name you use as the hostname of your server. Generally, you can use the <literal moreinfo=\"none\">ServerName</literal> directive in <filename moreinfo=\"none\">httpd.conf</filename> to accomplish this."
msgstr "Subversion利用<literal moreinfo=\"none\">COPY</literal>请求类型来执行服务器端的文件和目录拷贝，作为一个健全的Apache模块的一部分，拷贝源和拷贝的目标通常坐落在同一个机器上，为了满足这个需求，你或许需要告诉mod_dav服务器主机的名称，通常你可以使用<filename moreinfo=\"none\">httpd.conf</filename>的<literal moreinfo=\"none\">ServerName</literal>指示来完成此目的。"

#: build/en/book.xml:13955(screen)
#, no-wrap
msgid ""
"\n"
"ServerName svn.example.com\n"
msgstr ""
"\n"
"ServerName svn.example.com\n"

#: build/en/book.xml:13959(para)
msgid "If you are using Apache's virtual hosting support via the <literal moreinfo=\"none\">NameVirtualHost</literal> directive, you may need to use the <literal moreinfo=\"none\">ServerAlias</literal> directive to specify additional names that your server is known by. Again, refer to the Apache documentation for full details."
msgstr "如果你通过<literal moreinfo=\"none\">NameVirtualHost</literal>指示使用Apache的虚拟主机，你或许需要<literal moreinfo=\"none\">ServerAlias</literal>指示来指定额外的名称，再说一次，可以查看Apache文档的来得到更多细节。"

#: build/en/book.xml:13967(para)
#, fuzzy
msgid "At this stage, you should strongly consider the question of permissions. If you've been running Apache for some time now as your regular web server, you probably already have a collection of content—web pages, scripts and such. These items have already been configured with a set of permissions that allows them to work with Apache, or more appropriately, that allows Apache to work with those files. Apache, when used as a Subversion server, will also need the correct permissions to read and write to your Subversion repository."
msgstr "在本阶段，你一定要考虑访问权限问题，如果你已经作为普通的web服务器运行过Apache，你一定有了一些内容—网页、脚本和其他。这些项目已经配置了许多在Apache下可以工作的访问许可，或者更准确一点，允许Apache与这些文件一起工作。Apache当作为Subversion服务器运行时，同样需要正确的访问许可来读写你的Subversion版本库。（见<xref linkend=\"svn.serverconfig.svnserve.invoking.sb-1\"/>。）"

#: build/en/book.xml:1397(para)
#, fuzzy
msgid "While Subversion is still primarily a copy-modify-merge system, it still recognizes the need to lock an occasional file ands provide mechanisms for this. This feature is discussed later in this book, in <xref linkend=\"svn.advanced.locking\"/>."
msgstr "尽管CVS和Subversion一直主要是拷贝-修改-合并系统，它们都意识到了需要锁定一些文件，并且提供这种锁定机制。见<xref linkend=\"svn.advanced.locking\"/>。"

#: build/en/book.xml:13978(para)
msgid "You will need to determine a permission system setup that satisfies Subversion's requirements without messing up any previously existing web page or script installations. This might mean changing the permissions on your Subversion repository to match those in use by other things that Apache serves for you, or it could mean using the <literal moreinfo=\"none\">User</literal> and <literal moreinfo=\"none\">Group</literal> directives in <filename moreinfo=\"none\">httpd.conf</filename> to specify that Apache should run as the user and group that owns your Subversion repository. There is no single correct way to set up your permissions, and each administrator will have different reasons for doing things a certain way. Just be aware that permission-related problems are perhaps the most common oversight when configuring a Subversion repository for use with Apache."
msgstr "你会需要检验权限系统的设置满足Subversion的需求，同时不会把以前的页面和脚本搞乱。这或许意味着修改Subversion的访问许可来配合Apache服务器已经使用的工具，或者可能意味着需要使用<filename moreinfo=\"none\">httpd.conf</filename>的<literal moreinfo=\"none\">User</literal>和<literal moreinfo=\"none\">Group</literal>指示来指定Apache作为运行的用户和Subversion版本库的组。并不是只有一条正确的方式来设置许可，每个管理员都有不同的原因来以特定的方式操作，只需要意识到许可关联的问题经常在为Apache配置Subversion版本库的过程中被疏忽。"

#: build/en/book.xml:13998(title)
msgid "Authentication Options"
msgstr "认证选项"

#: build/en/book.xml:14(edition)
msgid "Second"
msgstr ""

#: build/en/book.xml:14000(para)
msgid "At this point, if you configured <filename moreinfo=\"none\">httpd.conf</filename> to contain something like"
msgstr "此时，如果你配置的<filename moreinfo=\"none\">httpd.conf</filename>保存如下的内容"

#: build/en/book.xml:14003(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14010(para)
msgid "…then your repository is <quote>anonymously</quote> accessible to the world. Until you configure some authentication and authorization policies, the Subversion repositories you make available via the <literal moreinfo=\"none\">Location</literal> directive will be generally accessible to everyone. In other words,"
msgstr "这样你的版本库对全世界是可以<quote>匿名</quote>访问的，直到你配置了一些认证授权政策，你通过<literal moreinfo=\"none\">Location</literal>指示来使Subversion版本库可以被任何人访问，换句话说，"

#: build/en/book.xml:14019(para)
msgid "anyone can use their Subversion client to checkout a working copy of a repository URL (or any of its subdirectories),"
msgstr "任何人可以使用Subversion客户端来从版本库URL取出一个工作拷贝（或者是它的子目录），"

#: build/en/book.xml:14024(para)
msgid "anyone can interactively browse the repository's latest revision simply by pointing their web browser to the repository URL, and"
msgstr "任何人可以在浏览器输入版本库URL交互浏览的方式来查看版本库的最新修订版本，并且"

#: build/en/book.xml:14029(para)
msgid "anyone can commit to the repository."
msgstr "任何人可以提交到版本库。"

#: build/en/book.xml:14033(para)
msgid "Of course, you might have already set up a <filename moreinfo=\"none\">pre-commit</filename> hook script to prevent commits (see <xref linkend=\"svn.reposadmin.create.hooks\"/>). But as you read on, you'll see that it's also possible use Apache's built-in methods to restrict access in specific ways."
msgstr ""

#: build/en/book.xml:14042(title)
msgid "Basic HTTP Authentication"
msgstr "基本HTTP认证"

#: build/en/book.xml:14044(para)
msgid "The easiest way to authenticate a client is via the HTTP Basic authentication mechanism, which simply uses a username and password to verify that a user is who she says she is. Apache provides an <command moreinfo=\"none\">htpasswd</command> utility for managing the list of acceptable usernames and passwords, those to whom you wish to grant special access to your Subversion repository. Let's grant commit access to Sally and Harry. First, we need to add them to the password file."
msgstr "最简单的客户端认证方式是通过HTTP基本认证机制，简单的使用用户名和密码来验证一个用户所自称的身份，Apache提供了一个<command moreinfo=\"none\">htpasswd</command>工具来管理可接受的用户名和密码，这些就是你希望赋予Subversion特别权限的用户，让我们给Sally和Harry赋予提交权限，首先，我们需要添加他们到密码文件。"

#: build/en/book.xml:14054(screen)
#, no-wrap
msgid ""
"\n"
"$ ### First time: use -c to create the file\n"
"$ ### Use -m to use MD5 encryption of the password, which is more secure\n"
"$ htpasswd -cm /etc/svn-auth-file harry\n"
"New password: *****\n"
"Re-type new password: *****\n"
"Adding password for user harry\n"
"$ htpasswd -m /etc/svn-auth-file sally\n"
"New password: *******\n"
"Re-type new password: *******\n"
"Adding password for user sally\n"
"$\n"
msgstr ""
"\n"
"$ ### First time: use -c to create the file\n"
"$ ### Use -m to use MD5 encryption of the password, which is more secure\n"
"$ htpasswd -cm /etc/svn-auth-file harry\n"
"New password: *****\n"
"Re-type new password: *****\n"
"Adding password for user harry\n"
"$ htpasswd -m /etc/svn-auth-file sally\n"
"New password: *******\n"
"Re-type new password: *******\n"
"Adding password for user sally\n"
"$\n"

#: build/en/book.xml:14068(para)
msgid "Next, you need to add some more <filename moreinfo=\"none\">httpd.conf</filename> directives inside your <literal moreinfo=\"none\">Location</literal> block to tell Apache what to do with your new password file. The <literal moreinfo=\"none\">AuthType</literal> directive specifies the type of authentication system to use. In this case, we want to specify the <literal moreinfo=\"none\">Basic</literal> authentication system. <literal moreinfo=\"none\">AuthName</literal> is an arbitrary name that you give for the authentication domain. Most browsers will display this name in the pop-up dialog box when the browser is querying the user for his name and password. Finally, use the <literal moreinfo=\"none\">AuthUserFile</literal> directive to specify the location of the password file you created using <command moreinfo=\"none\">htpasswd</command>."
msgstr "下一步，你需要在<filename moreinfo=\"none\">httpd.conf</filename>的<literal moreinfo=\"none\">Location</literal>区里添加一些指示来告诉Apache如何来使用这些密码文件，<literal moreinfo=\"none\">AuthType</literal>指示指定系统使用的认证类型，这种情况下，我们需要指定<literal moreinfo=\"none\">Basic</literal>认证系统，<literal moreinfo=\"none\">AuthName</literal>是你提供给认证域一个任意名称，大多数浏览器会在向用户询问名称和密码的弹出窗口里显示这个名称，最终，使用<literal moreinfo=\"none\">AuthUserFile</literal>指示来指定使用<command moreinfo=\"none\">htpasswd</command>创建的密码文件的位置。"

#: build/en/book.xml:14083(para)
msgid "After adding these three directives, your <literal moreinfo=\"none\">&lt;Location&gt;</literal> block should look something like this:"
msgstr "添加完这三个指示，你的<literal moreinfo=\"none\">&lt;Location&gt;</literal>区块一定像这个样子："

#: build/en/book.xml:14087(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /etc/svn-auth-file\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /etc/svn-auth-file\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14097(para)
msgid "This <literal moreinfo=\"none\">&lt;Location&gt;</literal> block is not yet complete, and will not do anything useful. It's merely telling Apache that whenever authorization is required, Apache should harvest a username and password from the Subversion client. What's missing here, however, are directives that tell Apache <emphasis>which</emphasis> sorts of client requests require authorization. Wherever authorization is required, Apache will demand authentication as well. The simplest thing to do is protect all requests. Adding <literal moreinfo=\"none\">Require valid-user</literal> tells Apache that all requests require an authenticated user:"
msgstr "这个<literal moreinfo=\"none\">&lt;Location&gt;</literal>区块还没有结束，还不能做任何有用的事情，它只是告诉Apache当需要授权时，要去向Subversion客户端索要用户名和密码。我们这里遗漏的，是一些告诉Apache<emphasis>什么样</emphasis>客户端需要授权的指示。哪里需要授权，Apache就会在哪里要求认证，最简单的方式是保护所有的请求，添加<literal moreinfo=\"none\">Require valid-user</literal>来告诉Apache任何请求需要认证的用户："

#: build/en/book.xml:14110(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /etc/svn-auth-file\n"
"  Require valid-user\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /etc/svn-auth-file\n"
"  Require valid-user\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14121(para)
msgid "Be sure to read the next section (<xref linkend=\"svn.serverconfig.httpd.authz\"/>) for more detail on the <literal moreinfo=\"none\">Require</literal> directive and other ways to set authorization policies."
msgstr "一定要阅读后面的部分（<xref linkend=\"svn.serverconfig.httpd.authz\"/>）来得到<literal moreinfo=\"none\">Require</literal>的细节，和授权政策的其他设置方法。"

#: build/en/book.xml:14125(para)
#, fuzzy
msgid "One word of warning: HTTP Basic Auth passwords pass in very nearly plain-text over the network, and thus are extremely insecure. If you're worried about password snooping, it may be best to use some sort of SSL encryption, so that clients authenticate via <literal moreinfo=\"none\">https://</literal> instead of <literal moreinfo=\"none\">http://</literal>; at a bare minimum, you can configure Apache to use a self-signed server certificate. <placeholder-1/> Consult Apache's documentation (and OpenSSL documentation) about how to do that."
msgstr "需要警惕：HTTP基本认证的密码是用明文传输，因此非常不可靠的，如果你担心密码偷窥，最好是使用某种SSL加密，所以客户端认证使用<literal moreinfo=\"none\">https://</literal>而不是<literal moreinfo=\"none\">http://</literal>，为了方便，你可以配置Apache为自签名认证。 <footnote><placeholder-1/></footnote> 参考Apache的文档（和OpenSSL文档）来查看怎样做。"

#: build/en/book.xml:14134(para)
msgid "While self-signed server certificates are still vulnerable to a <quote>man in the middle</quote> attack, such an attack is still much more difficult for a casual observer to pull off, compared to sniffing unprotected passwords."
msgstr "当使用自签名的服务器时仍会遭受<quote>中间人</quote>攻击，但是与偷取未保护的密码相比，这样的攻击比一个偶然的获取要艰难许多。"

#: build/en/book.xml:14148(title)
msgid "SSL Certificate Management"
msgstr "SSL证书管理"

#: build/en/book.xml:1415(title)
msgid "Subversion in Action"
msgstr "Subversion实战"

#: build/en/book.xml:14150(para)
msgid "Businesses that need to expose their repositories for access outside the company firewall should be conscious of the possibility that unauthorized parties could be <quote>sniffing</quote> their network traffic. SSL makes that kind of unwanted attention less likely to result in sensitive data leaks."
msgstr "商业应用需要越过公司防火墙的版本库访问，防火墙需要小心的考虑非认证用户<quote>吸取</quote>他们的网络流量的情况，SSL让那种形式的关注更不容易导致敏感数据泄露。"

#: build/en/book.xml:14157(para)
msgid "If a Subversion client is compiled to use OpenSSL, then it gains the ability to speak to an Apache server via <literal moreinfo=\"none\">https://</literal> URLs. The Neon library used by the Subversion client is not only able to verify server certificates, but can also supply client certificates when challenged. When the client and server have exchanged SSL certificates and successfully authenticated one another, all further communication is encrypted via a session key."
msgstr "如果Subversion使用OpenSSL编译，它就会具备与Subversion服务器使用<literal moreinfo=\"none\">https://</literal>的URL通讯的能力，Subversion客户端使用的Neon库不仅仅可以用来验证服务器证书，也可以必要时提供客户端证书，如果客户端和服务器交换了SSL证书并且成功地互相认证，所有剩下的交流都会通过一个会话关键字加密。"

#: build/en/book.xml:14166(para)
msgid "It's beyond the scope of this book to describe how to generate client and server certificates, and how to configure Apache to use them. Many other books, including Apache's own documentation, describe this task. But what <emphasis>can</emphasis> be covered here is how to manage server and client certificates from an ordinary Subversion client."
msgstr "怎样产生客户端和服务器端证书以及怎样使用它们已经超出了本书的范围，许多书籍，包括Apache自己的文档，描述这个任务，现在我们<emphasis>可以</emphasis>覆盖的是普通的客户端怎样来管理服务器与客户端证书。"

#: build/en/book.xml:1417(para)
msgid "It's time to move from the abstract to the concrete. In this section, we'll show real examples of Subversion being used."
msgstr "是时候从抽象转到具体了，在本小节，我们会展示一个Subversion真实使用的例子。"

#: build/en/book.xml:14174(para)
msgid "When speaking to Apache via <literal moreinfo=\"none\">https://</literal>, a Subversion client can receive two different types of information:"
msgstr "当通过<literal moreinfo=\"none\">https://</literal>与Apache通讯时，一个Subversion客户端可以接收两种类型的信息："

#: build/en/book.xml:14179(para)
msgid "a server certificate"
msgstr "一个服务器证书"

#: build/en/book.xml:14180(para)
msgid "a demand for a client certificate"
msgstr "一个客户端证书的要求"

#: build/en/book.xml:14183(para)
msgid "If the client receives a server certificate, it needs to verify that it trusts the certificate: is the server really who it claims to be? The OpenSSL library does this by examining the signer of the server certificate, or <firstterm>certifying authority</firstterm> (CA). If OpenSSL is unable to automatically trust the CA, or if some other problem occurs (such as an expired certificate or hostname mismatch), the Subversion command-line client will ask you whether you want to trust the server certificate anyway:"
msgstr "如果客户端接收了一个服务器证书，它需要去验证它是可以相信的：这个服务器是它自称的那一个吗？OpenSSL库会去检验服务器证书的签名人或者是<firstterm>核证机构</firstterm>（CA）。如果OpenSSL不可以自动信任这个CA，或者是一些其他的问题（如证书过期或者是主机名不匹配），Subversion命令行客户端会询问你是否愿意仍然信任这个证书："

#: build/en/book.xml:14194(screen)
#, no-wrap
msgid ""
"\n"
"$ svn list https://host.example.com/repos/project\n"
"\n"
"Error validating server certificate for 'https://host.example.com:443':\n"
" - The certificate is not issued by a trusted authority. Use the\n"
"   fingerprint to validate the certificate manually!\n"
"Certificate information:\n"
" - Hostname: host.example.com\n"
" - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT\n"
" - Issuer: CA, example.com, Sometown, California, US\n"
" - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b\n"
"\n"
"(R)eject, accept (t)emporarily or accept (p)ermanently?\n"
msgstr ""
"\n"
"$ svn list https://host.example.com/repos/project\n"
"\n"
"Error validating server certificate for 'https://host.example.com:443':\n"
" - The certificate is not issued by a trusted authority. Use the\n"
"   fingerprint to validate the certificate manually!\n"
"Certificate information:\n"
" - Hostname: host.example.com\n"
" - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT\n"
" - Issuer: CA, example.com, Sometown, California, US\n"
" - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b\n"
"\n"
"(R)eject, accept (t)emporarily or accept (p)ermanently?\n"

#: build/en/book.xml:14209(para)
msgid "This dialogue should look familiar; it's essentially the same question you've probably seen coming from your web browser (which is just another HTTP client like Subversion!). If you choose the (p)ermanent option, the server certificate will be cached in your private run-time <filename moreinfo=\"none\">auth/</filename> area in just the same way your username and password are cached (see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>). If cached, Subversion will automatically remember to trust this certificate in future negotiations."
msgstr "这个对话看起来很熟悉，这是你会在web浏览器（另一种HTTP客户端，就像Subversion）经常看到的问题，如果你选择(p)ermanent选项，服务器证书会存放在你存放那个用户名和密码缓存（见<xref linkend=\"svn.serverconfig.netmodel.credcache\"/>。）的私有运行区<filename moreinfo=\"none\">auth/</filename>中，缓存后，Subversion会自动记住在以后的交流中信任这个证书。"

#: build/en/book.xml:14219(para)
msgid "Your run-time <filename moreinfo=\"none\">servers</filename> file also gives you the ability to make your Subversion client automatically trust specific CAs, either globally or on a per-host basis. Simply set the <literal moreinfo=\"none\">ssl-authority-files</literal> variable to a semicolon-separated list of PEM-encoded CA certificates:"
msgstr "你的运行中<filename moreinfo=\"none\">servers</filename>文件也会给你能力可以让Subversion客户端自动信任特定的CA，包括全局的或是每主机为基础的，只需要设置<literal moreinfo=\"none\">ssl-authority-files</literal>为一组逗号隔开的PEM加密的CA证书列表："

#: build/en/book.xml:14226(screen)
#, no-wrap
msgid ""
"\n"
"[global]\n"
"ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem\n"
msgstr ""
"\n"
"[global]\n"
"ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem\n"

#: build/en/book.xml:1423(title)
msgid "Subversion Repository URLs"
msgstr "Subversion版本库URL"

#: build/en/book.xml:14231(para)
msgid "Many OpenSSL installations also have a pre-defined set of <quote>default</quote> CAs that are nearly universally trusted. To make the Subversion client automatically trust these standard authorities, set the <literal moreinfo=\"none\">ssl-trust-default-ca</literal> variable to <literal moreinfo=\"none\">true</literal>."
msgstr "许多OpenSSL安装包括一些预先定义好的可以普遍信任的<quote>缺省的</quote>CA，为了让Subversion客户端自动信任这些标准权威，设置<literal moreinfo=\"none\">ssl-trust-default-ca</literal>为<literal moreinfo=\"none\">true</literal>。"

#: build/en/book.xml:14238(para)
msgid "When talking to Apache, a Subversion client might also receive a challenge for a client certificate. Apache is asking the client to identify itself: is the client really who it says it is? If all goes correctly, the Subversion client sends back a private certificate signed by a CA that Apache trusts. A client certificate is usually stored on disk in encrypted format, protected by a local password. When Subversion receives this challenge, it will ask you for both a path to the certificate and the password which protects it:"
msgstr "当与Apache通话时，Subversion客户端也会收到一个证书的要求，Apache是询问客户端来证明自己的身份：这个客户端是否是他所说的那一个？如果一切正常，Subversion客户端会发送回一个通过Apache信任的CA签名的私有证书，一个客户端证书通常会以加密方式存放在磁盘，使用本地密码保护，当Subversion收到这个要求，它会询问你证书的路径和保护用的密码："

#: build/en/book.xml:14249(screen)
#, no-wrap
msgid ""
"\n"
"$ svn list https://host.example.com/repos/project\n"
"\n"
"Authentication realm: https://host.example.com:443\n"
"Client certificate filename: /path/to/my/cert.p12\n"
"Passphrase for '/path/to/my/cert.p12':  ********\n"
"…\n"
msgstr ""
"\n"
"$ svn list https://host.example.com/repos/project\n"
"\n"
"Authentication realm: https://host.example.com:443\n"
"Client certificate filename: /path/to/my/cert.p12\n"
"Passphrase for '/path/to/my/cert.p12':  ********\n"
"…\n"

#: build/en/book.xml:1425(para)
#, fuzzy
msgid "Throughout this book, Subversion uses URLs to identify versioned files and directories in Subversion repositories. For the most part, these URLs use the standard syntax, allowing for server names and port numbers to be specified as part of the URL:"
msgstr "正如我们在整本书里描述的，Subversion使用URL来识别Subversion版本库中的版本化资源，通常情况下，这些URL使用标准的语法，允许服务器名称和端口作为URL的一部分："

#: build/en/book.xml:14258(para)
msgid "Notice that the client certificate is a <quote>p12</quote> file. To use a client certificate with Subversion, it must be in PKCS#12 format, which is a portable standard. Most web browsers are already able to import and export certificates in that format. Another option is to use the OpenSSL command-line tools to convert existing certificates into PKCS#12."
msgstr "注意这个客户端证书是一个<quote>p12</quote>文件，为了让Subversion使用客户端证书，它必须是运输标准的PKCS#12格式，大多数浏览器可以导入和导出这种格式的证书，另一个选择是用OpenSSL命令行工具来转化存在的证书为PKCS#12格式。"

#: build/en/book.xml:14266(para)
msgid "Again, the runtime <filename moreinfo=\"none\">servers</filename> file allows you to automate this challenge on a per-host basis. Either or both pieces of information can be described in runtime variables:"
msgstr "再次，运行中<filename moreinfo=\"none\">servers</filename>文件允许你为每个主机自动响应这种要求，单个或两条信息可以用运行参数来描述："

#: build/en/book.xml:14271(screen)
#, no-wrap
msgid ""
"\n"
"[groups]\n"
"examplehost = host.example.com\n"
"\n"
"[examplehost]\n"
"ssl-client-cert-file = /path/to/my/cert.p12\n"
"ssl-client-cert-password = somepassword\n"
msgstr ""
"\n"
"[groups]\n"
"examplehost = host.example.com\n"
"\n"
"[examplehost]\n"
"ssl-client-cert-file = /path/to/my/cert.p12\n"
"ssl-client-cert-password = somepassword\n"

#: build/en/book.xml:14280(para)
#, fuzzy
msgid "Once you've set the <literal moreinfo=\"none\">ssl-client-cert-file</literal> and <literal moreinfo=\"none\">ssl-client-cert-password</literal> variables, the Subversion client can automatically respond to a client certificate challenge without prompting you. <placeholder-1/>"
msgstr "一旦你设置了<literal moreinfo=\"none\">ssl-client-cert-file</literal>和 <literal moreinfo=\"none\">ssl-client-cert-password</literal>参数，Subversion客户端可以自动响应客户端证书请求而不会打扰你。 <footnote><placeholder-1/></footnote>"

#: build/en/book.xml:14286(para)
msgid "More security-conscious folk might not want to store the client certificate password in the runtime <filename moreinfo=\"none\">servers</filename> file."
msgstr "更多有安全意识的人不会希望在运行中<filename moreinfo=\"none\">servers</filename>文件保存客户端证书密码。"

#: build/en/book.xml:14298(title)
msgid "Authorization Options"
msgstr "授权选项"

#: build/en/book.xml:14300(para)
msgid "At this point, you've configured authentication, but not authorization. Apache is able to challenge clients and confirm identities, but it has not been told how to allow or restrict access to the clients bearing those identities. This section describes two strategies for controlling access to your repositories."
msgstr "此刻，你已经配置了认证，但是没有配置授权，Apache可以要求用户认证并且确定身份，但是并没有说明这个身份的怎样允许和限制，这个部分描述了两种控制访问版本库的策略。"

#: build/en/book.xml:14309(title)
msgid "Blanket Access Control"
msgstr "整体访问控制"

#: build/en/book.xml:1431(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://svn.example.com:9834/repos\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout http://svn.example.com:9834/repos\n"
"…\n"

#: build/en/book.xml:14311(para)
msgid "The simplest form of access control is to authorize certain users for either read-only access to a repository, or read/write access to a repository."
msgstr "最简单的访问控制形式是授权特定用户为只读版本库访问或者是读/写访问版本库。"

#: build/en/book.xml:14315(para)
msgid "You can restrict access on all repository operations by adding the <literal moreinfo=\"none\">Require valid-user</literal> directive to your <literal moreinfo=\"none\">&lt;Location&gt;</literal> block. Using our previous example, this would mean that only clients that claimed to be either <literal moreinfo=\"none\">harry</literal> or <literal moreinfo=\"none\">sally</literal>, and provided the correct password for their respective username, would be allowed to do anything with the Subversion repository:"
msgstr "你可以通过在<literal moreinfo=\"none\">&lt;Location&gt;</literal>区块添加<literal moreinfo=\"none\">Require valid-user</literal>指示来限制所有的版本库操作，使用我们前面的例子，这意味着只有客户端只可以是<literal moreinfo=\"none\">harry</literal>或者<literal moreinfo=\"none\">sally</literal>，而且他们必须提供正确的用户名及对应密码，这样允许对Subversion版本库做任何事："

#: build/en/book.xml:14324(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"\n"
"  # only authenticated users may access the repository\n"
"  Require valid-user\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"\n"
"  # only authenticated users may access the repository\n"
"  Require valid-user\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14339(para)
msgid "Sometimes you don't need to run such a tight ship. For example, Subversion's own source code repository at <ulink url=\"http://svn.collab.net/repos/svn\"/> allows anyone in the world to perform read-only repository tasks (like checking out working copies and browsing the repository with a web browser), but restricts all write operations to authenticated users. To do this type of selective restriction, you can use the <literal moreinfo=\"none\">Limit</literal> and <literal moreinfo=\"none\">LimitExcept</literal> configuration directives. Like the <literal moreinfo=\"none\">Location</literal> directive, these blocks have starting and ending tags, and you would nest them inside your <literal moreinfo=\"none\">&lt;Location&gt;</literal> block."
msgstr "有时候，你不需要这样严密，举个例子，Subversion自己在<ulink url=\"http://svn.collab.net/repos/svn\"/>的源代码允许全世界的人执行版本库的只读操作（例如检出我们的工作拷贝和使用浏览器浏览版本库），但是限定只有认证用户可以执行写操作。为了执行特定的限制，你可以使用<literal moreinfo=\"none\">Limit</literal>和<literal moreinfo=\"none\">LimitExcept</literal>配置指示，就像<literal moreinfo=\"none\">Location</literal>指示，这个区块有开始和结束标签，你需要在<literal moreinfo=\"none\">&lt;Location&gt;</literal>中添加这个指示。"

#: build/en/book.xml:14353(para)
msgid "The parameters present on the <literal moreinfo=\"none\">Limit</literal> and <literal moreinfo=\"none\">LimitExcept</literal> directives are HTTP request types that are affected by that block. For example, if you wanted to disallow all access to your repository except the currently supported read-only operations, you would use the <literal moreinfo=\"none\">LimitExcept</literal> directive, passing the <literal moreinfo=\"none\">GET</literal>, <literal moreinfo=\"none\">PROPFIND</literal>, <literal moreinfo=\"none\">OPTIONS</literal>, and <literal moreinfo=\"none\">REPORT</literal> request type parameters. Then the previously mentioned <literal moreinfo=\"none\">Require valid-user</literal> directive would be placed inside the <literal moreinfo=\"none\">&lt;LimitExcept&gt;</literal> block instead of just inside the <literal moreinfo=\"none\">&lt;Location&gt;</literal> block."
msgstr "在<literal moreinfo=\"none\">Limit</literal>和<literal moreinfo=\"none\">LimitExcept</literal>中使用的参数是可以被这个区块影响的HTTP请求类型，举个例子，如果你希望禁止所有的版本库访问，只是保留当前支持的只读操作，你可以使用<literal moreinfo=\"none\">LimitExcept</literal>指示，并且使用<literal moreinfo=\"none\">GET</literal>，<literal moreinfo=\"none\">PROPFIND</literal>，<literal moreinfo=\"none\">OPTIONS</literal>和<literal moreinfo=\"none\">REPORT</literal>请求类型参数，然后前面提到过的<literal moreinfo=\"none\">Require valid-user</literal>指示将会在<literal moreinfo=\"none\">&lt;LimitExcept&gt;</literal>区块中而不是在<literal moreinfo=\"none\">&lt;Location&gt;</literal>区块。"

#: build/en/book.xml:1436(para)
#, fuzzy
msgid "But there are some nuances in Subversion's handling of URLs that are notable. For example, URLs containing the <literal moreinfo=\"none\">file://</literal> access method (used for local repositories) must, in accordance with convention, have either a server name of <literal moreinfo=\"none\">localhost</literal> or no server name at all:"
msgstr "但是Subversion处理URL的一些细微的不同之处需要注意，例如，使用<literal moreinfo=\"none\">file:</literal>访问方法的URL（用来访问本地版本库）必须与习惯一致，可以包括一个<literal moreinfo=\"none\">localhost</literal>服务器名或者没有服务器名："

#: build/en/book.xml:14367(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"\n"
"  # For any operations other than these, require an authenticated user.\n"
"  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;\n"
"    Require valid-user\n"
"  &lt;/LimitExcept&gt;\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"\n"
"  # For any operations other than these, require an authenticated user.\n"
"  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;\n"
"    Require valid-user\n"
"  &lt;/LimitExcept&gt;\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14384(para)
msgid "These are only a few simple examples. For more in-depth information about Apache access control and the <literal moreinfo=\"none\">Require</literal> directive, take a look at the <literal moreinfo=\"none\">Security</literal> section of the Apache documentation's tutorials collection at <ulink url=\"http://httpd.apache.org/docs-2.0/misc/tutorials.html\"/>."
msgstr "这里只是一些简单的例子，想看关于Apache访问控制<literal moreinfo=\"none\">Require</literal>指示的更深入信息，可以查看Apache文档中的教程集<ulink url=\"http://httpd.apache.org/docs-2.0/misc/tutorials.html\"/>中的<literal moreinfo=\"none\">Security</literal>部分。"

#: build/en/book.xml:14395(title)
msgid "Per-Directory Access Control"
msgstr "每目录访问控制"

#: build/en/book.xml:14397(para)
msgid "It's possible to set up finer-grained permissions using a second Apache httpd module, <command moreinfo=\"none\">mod_authz_svn</command>. This module grabs the various opaque URLs passing from client to server, asks <command moreinfo=\"none\">mod_dav_svn</command> to decode them, and then possibly vetoes requests based on access policies defined in a configuration file."
msgstr "也可以使用Apache的httpd模块<command moreinfo=\"none\">mod_authz_svn</command>更加细致的设置访问权限，这个模块收集客户端传递过来的不同的晦涩的URL信息，询问<command moreinfo=\"none\">mod_dav_svn</command>来解码，然后根据在配置文件定义的访问政策来裁决请求。"

#: build/en/book.xml:14405(para)
msgid "If you've built Subversion from source code, <command moreinfo=\"none\">mod_authz_svn</command> is automatically built and installed alongside <command moreinfo=\"none\">mod_dav_svn</command>. Many binary distributions install it automatically as well. To verify that it's installed correctly, make sure it comes right after <command moreinfo=\"none\">mod_dav_svn</command>'s <literal moreinfo=\"none\">LoadModule</literal> directive in <filename moreinfo=\"none\">httpd.conf</filename>:"
msgstr "如果你从源代码创建Subversion，<command moreinfo=\"none\">mod_authz_svn</command>会自动附加到<command moreinfo=\"none\">mod_dav_svn</command>，许多二进制分发版本也会自动安装，为了验证它是安装正确，确定它是在<filename moreinfo=\"none\">httpd.conf</filename>的<literal moreinfo=\"none\">LoadModule</literal>指示中的<command moreinfo=\"none\">mod_dav_svn</command>后面："

#: build/en/book.xml:14414(screen)
#, no-wrap
msgid ""
"\n"
"LoadModule dav_module         modules/mod_dav.so\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"
"LoadModule authz_svn_module   modules/mod_authz_svn.so\n"
msgstr ""
"\n"
"LoadModule dav_module         modules/mod_dav.so\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"
"LoadModule authz_svn_module   modules/mod_authz_svn.so\n"

#: build/en/book.xml:14420(para)
msgid "To activate this module, you need to configure your <literal moreinfo=\"none\">Location</literal> block to use the <literal moreinfo=\"none\">AuthzSVNAccessFile</literal> directive, which specifies a file containing the permissions policy for paths within your repositories. (In a moment, we'll discuss the format of that file.)"
msgstr "为了激活这个模块，你需要配置你的<literal moreinfo=\"none\">Location</literal>区块的<literal moreinfo=\"none\">AuthzSVNAccessFile</literal>指示，指定保存路径中的版本库访问政策的文件。（一会儿我们将会讨论这个文件的格式。）"

#: build/en/book.xml:14427(para)
msgid "Apache is flexible, so you have the option to configure your block in one of three general patterns. To begin, choose one of these basic configuration patterns. (The examples below are very simple; look at Apache's own documentation for much more detail on Apache authentication and authorization options.)"
msgstr "Apache非常的灵活，你可以从三种模式里选择一种来配置你的区块，作为开始，你选择一种基本的配置模式。（下面的例子非常简单；见Apache自己的文档中的认证和授权选项来查看更多的细节。）"

#: build/en/book.xml:1443(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout file:///path/to/repos\n"
"…\n"
"$ svn checkout file://localhost/path/to/repos\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout file:///path/to/repos\n"
"…\n"
"$ svn checkout file://localhost/path/to/repos\n"
"…\n"

#: build/en/book.xml:14434(para)
msgid "The simplest block is to allow open access to everyone. In this scenario, Apache never sends authentication challenges, so all users are treated as <quote>anonymous</quote>."
msgstr "最简单的区块是允许任何人可以访问，在这个场景里，Apache决不会发送认证请求，所有的用户作为<quote>匿名</quote>对待。"

#: build/en/book.xml:14440(title)
msgid "A sample configuration for anonymous access."
msgstr "匿名访问的配置实例。"

#: build/en/book.xml:14441(programlisting)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"&lt;/Location&gt;\n"
"          "
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"&lt;/Location&gt;\n"
"          "

#: build/en/book.xml:14452(para)
msgid "On the opposite end of the paranoia scale, you can configure your block to demand authentication from everyone. All clients must supply credentials to identify themselves. Your block unconditionally requires authentication via the <literal moreinfo=\"none\">Require valid-user</literal> directive, and defines a means to authenticate."
msgstr "在另一个极端，你可以配置为拒绝所有人的认证，所有客户端必须提供证明自己身份的证书，你通过<literal moreinfo=\"none\">Require valid-user</literal>指示来阻止无条件的认证，并且定义一种认证的手段。"

#: build/en/book.xml:14460(title)
msgid "A sample configuration for authenticated access."
msgstr "一个认证访问的配置实例。"

#: build/en/book.xml:14461(programlisting)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"\n"
"  # only authenticated users may access the repository\n"
"  Require valid-user\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"&lt;/Location&gt;\n"
"          "
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"\n"
"  # only authenticated users may access the repository\n"
"  Require valid-user\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"&lt;/Location&gt;\n"
"          "

#: build/en/book.xml:14480(para)
msgid "A third very popular pattern is to allow a combination of authenticated and anonymous access. For example, many administrators want to allow anonymous users to read certain repository directories, but want only authenticated users to read (or write) more sensitive areas. In this setup, all users start out accessing the repository anonymously. If your access control policy demands a real username at any point, Apache will demand authentication from the client. To do this, you use both the <literal moreinfo=\"none\">Satisfy Any</literal> and <literal moreinfo=\"none\">Require valid-user</literal> directives together."
msgstr "第三种流行的模式是允许认证和匿名用户的组合，举个例子，许多管理员希望允许匿名用户读取特定的版本库路径，但希望只有认证用户可以读（或者写）更多敏感的区域，在这个设置里，所有的用户开始时用匿名用户访问版本库，如果你的访问控制策略在任何时候要求一个真实的用户名，Apache将会要求认证客户端，为­¤，你可以同时使用<literal moreinfo=\"none\">Satisfy Any</literal>和<literal moreinfo=\"none\">Require valid-user</literal>指示。"

#: build/en/book.xml:14493(title)
msgid "A sample configuration for mixed authenticated/anonymous access."
msgstr "一个混合认证/匿名访问的配置实例。"

#: build/en/book.xml:14495(programlisting)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"\n"
"  # try anonymous access first, resort to real\n"
"  # authentication if necessary.\n"
"  Satisfy Any\n"
"  Require valid-user\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"&lt;/Location&gt;\n"
"          "
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"\n"
"  # try anonymous access first, resort to real\n"
"  # authentication if necessary.\n"
"  Satisfy Any\n"
"  Require valid-user\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"&lt;/Location&gt;\n"
"          "

#: build/en/book.xml:1450(para)
#, fuzzy
msgid "Also, users of the <literal moreinfo=\"none\">file://</literal> scheme on Windows platforms will need to use an unofficially <quote>standard</quote> syntax for accessing repositories that are on the same machine, but on a different drive than the client's current working drive. Either of the two following URL path syntaxes will work where <literal moreinfo=\"none\">X</literal> is the drive on which the repository resides:"
msgstr "同样在Windows平台下使用<literal moreinfo=\"none\">file:</literal>模式时需要使用一个非正式的<quote>标准</quote>语法来访问本机上不在同一个磁盘分区中的版本库。下面的任意一个URL路径语法都可以工作，其中的<literal moreinfo=\"none\">X</literal>表示版本库所在的磁盘分区："

#: build/en/book.xml:14516(para)
msgid "Once you've settled on one of these three basic <filename moreinfo=\"none\">httpd.conf</filename> templates, you need to create your file containing access rules for particular paths within the repository. This is described in <xref linkend=\"svn.serverconfig.pathbasedauthz\"/>."
msgstr ""

#: build/en/book.xml:14526(title)
msgid "Disabling Path-based Checks"
msgstr "关闭路径为基础的检查"

#: build/en/book.xml:14528(para)
msgid "The <command moreinfo=\"none\">mod_dav_svn</command> module goes through a lot of work to make sure that data you've marked <quote>unreadable</quote> doesn't get accidentally leaked. This means that it needs to closely monitor all of the paths and file-contents returned by commands like <command moreinfo=\"none\">svn checkout</command> or <command moreinfo=\"none\">svn update</command> commands. If these commands encounter a path that isn't readable according to some authorization policy, then the path is typically omitted altogether. In the case of history or rename tracing—e.g. running a command like <command moreinfo=\"none\">svn cat -r OLD foo.c</command> on a file that was renamed long ago—the rename tracking will simply halt if one of the object's former names is determined to be read-restricted."
msgstr "<command moreinfo=\"none\">mod_dav_svn</command>模块做了许多工作来确定你标记为<quote>不可读</quote>的数据不会因意外而泄露，这意味着需要紧密监控通过<command moreinfo=\"none\">svn checkout</command>或是<command moreinfo=\"none\">svn update</command>返回的路径和文件内容，如果这些命令遇到一些根据认证策略不是可读的路径，这个路径通常会被一起忽略，在历史或者重命名操作时—例如运行一个类似<command moreinfo=\"none\">svn cat -r OLD foo.c</command>的命令来操作一个很久以前改过名字的文件 — 如果一个对象的以前的名字检测到是只读的，重命令追踪就会终止。"

#: build/en/book.xml:14543(para)
#, fuzzy
msgid "All of this path-checking can sometimes be quite expensive, especially in the case of <command moreinfo=\"none\">svn log</command>. When retrieving a list of revisions, the server looks at every changed path in each revision and checks it for readability. If an unreadable path is discovered, then it's omitted from the list of the revision's changed paths (normally seen with the <option>--verbose</option> option), and the whole log message is suppressed. Needless to say, this can be time-consuming on revisions that affect a large number of files. This is the cost of security: even if you haven't configured a module like <command moreinfo=\"none\">mod_authz_svn</command> at all, the <command moreinfo=\"none\">mod_dav_svn</command> module is still asking Apache <command moreinfo=\"none\">httpd</command> to run authorization checks on every path. The <command moreinfo=\"none\">mod_dav_svn</command> module has no idea what authorization modules have been installed, so all it can do is ask Apache to invoke whatever might be present."
msgstr "所有的路径检查在有时会非常昂贵，特别是<command moreinfo=\"none\">svn log</command>的情况。当检索一列修订版本时，服务器会查看所有修订版本修改的路径，并且检查可读性，如果发现了一个不可读路径，它会从修订版本的修改路径中忽略（可以查看<option>--verbose</option>选项），并且整个的日志信息会被禁止，不必多说，这种影响大量文件修订版本的操作会非常耗时。这是安全的代价：即使你并没有配置<command moreinfo=\"none\">mod_authz_svn</command>模块，<command moreinfo=\"none\">mod_dav_svn</command>还是会询问<command moreinfo=\"none\">httpd</command>来对所有路径运行认证检查，<command moreinfo=\"none\">mod_dav_svn</command>模块没有办法知道那个认证模块被安装，所以只有询问Apache来调用所提供的模块。"

#: build/en/book.xml:14562(para)
msgid "On the other hand, there's also an escape-hatch of sorts, one which allows you to trade security features for speed. If you're not enforcing any sort of per-directory authorization (i.e. not using <command moreinfo=\"none\">mod_authz_svn</command> or similar module), then you can disable all of this path-checking. In your <filename moreinfo=\"none\">httpd.conf</filename> file, use the <literal moreinfo=\"none\">SVNPathAuthz</literal> directive:"
msgstr "在另一方面，也有一个安全舱门允许你用安全特性来交换速度，如果你不是坚持要求有每目录授权（如不使用 <command moreinfo=\"none\">mod_authz_svn</command>和类似的模块），你就可以关闭所有的路径检查，在你的<filename moreinfo=\"none\">httpd.conf</filename>文件，使用<literal moreinfo=\"none\">SVNPathAuthz</literal>指示："

#: build/en/book.xml:14572(title)
msgid "Disabling path checks altogether"
msgstr "关闭所有的路经检查"

#: build/en/book.xml:14573(programlisting)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  SVNPathAuthz off\n"
"&lt;/Location&gt;\n"
"          "
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  SVNPathAuthz off\n"
"&lt;/Location&gt;\n"
"          "

#: build/en/book.xml:14583(para)
msgid "The <literal moreinfo=\"none\">SVNPathAuthz</literal> directive is <quote>on</quote> by default. When set <quote>off</quote>, all path-based authorization checking is disabled; <command moreinfo=\"none\">mod_dav_svn</command> stops invoking authorization checks on every path it discovers."
msgstr "<literal moreinfo=\"none\">SVNPathAuthz</literal>指示缺省是<quote>on</quote>，当设置为<quote>off</quote>时，所有的路径为基础的授权都会关闭；<command moreinfo=\"none\">mod_dav_svn</command>停止对每个目录调用授权检查。"

#: build/en/book.xml:1459(screen)
#, no-wrap
msgid ""
"\n"
"C:\\&gt; svn checkout file:///X:/path/to/repos\n"
"…\n"
"C:\\&gt; svn checkout \"file:///X|/path/to/repos\"\n"
"…\n"
msgstr ""
"\n"
"C:\\&gt; svn checkout file:///X:/path/to/repos\n"
"…\n"
"C:\\&gt; svn checkout \"file:///X|/path/to/repos\"\n"
"…\n"

#: build/en/book.xml:14595(title)
msgid "Extra Goodies"
msgstr "额外的糖果"

#: build/en/book.xml:14597(para)
msgid "We've covered most of the authentication and authorization options for Apache and mod_dav_svn. But there are a few other nice features that Apache provides."
msgstr "我们已经覆盖了关于认证和授权的Apache和mod_dav_svn的大多数选项，但是Apache还提供了许多很好的特性。"

#: build/en/book.xml:14603(title)
msgid "Repository Browsing"
msgstr "版本库浏览"

#: build/en/book.xml:14605(para)
#, fuzzy
msgid "One of the most useful benefits of an Apache/WebDAV configuration for your Subversion repository is that the youngest revisions of your versioned files and directories are immediately available for viewing via a regular web browser. Since Subversion uses URLs to identify versioned resources, those URLs used for HTTP-based repository access can be typed directly into a Web browser. Your browser will issue an HTTP <literal moreinfo=\"none\">GET</literal> request for that URL, and based on whether that URL represents a versioned directory or file, mod_dav_svn will respond with a directory listing or with file contents."
msgstr "一个非常有用的好处是使用Apache/WebDAV配置Subversion版本库时可以用普通的浏览器察看最新的版本库文件，因为Subversion使用URL来鉴别版本库版本化的资源，版本库使用的HTTP为基础的URL也可以直接输入到Web浏览器中，你的浏览器会发送一个<literal moreinfo=\"none\">GET</literal>请求到URL，根据访问的URL是指向一个版本化的目录还是文件，mod_dav_svn会负责列出目录列表或者是文件内容。"

#: build/en/book.xml:14617(para)
msgid "Since the URLs do not contain any information about which version of the resource you wish to see, mod_dav_svn will always answer with the youngest version. This functionality has the wonderful side-effect that you can pass around Subversion URLs to your peers as references to documents, and those URLs will always point at the latest manifestation of that document. Of course, you can even use the URLs as hyperlinks from other web sites, too."
msgstr "因为URL不能确定你所希望看到的资源的版本，mod_dav_svn会一直返回最新的版本，这样会有一些美妙的副作用，你可以直接把Subversion的URL传递给文档作为引用，这些URL会一直指向文档最新的材料，当然，你也可以在别的网站作为超链使用这些URL。"

#: build/en/book.xml:14627(title)
msgid "Can I view older revisions?"
msgstr "我可以看到老的修订版本吗？"

#: build/en/book.xml:14629(para)
msgid "With an ordinary web browser? In one word: nope. At least, not with <command moreinfo=\"none\">mod_dav_svn</command> as your only tool."
msgstr "通过一个普通的浏览器？一句话：不可以，至少是当你只使用<command moreinfo=\"none\">mod_dav_svn</command>作为唯一的工具时。"

#: build/en/book.xml:14633(para)
#, fuzzy
msgid "Your web browser only speaks ordinary HTTP. That means it only knows how to GET public URLs, which represent the latest versions of files and directories. According to the WebDAV/DeltaV specification, each server defines a private URL syntax for older versions of resources, and that syntax is opaque to clients. To find an older version of a file, a client must follow a specific procedure to <quote>discover</quote> the proper URL; the procedure involves issuing a series of WebDAV PROPFIND requests and understanding DeltaV concepts. This is something your web browser simply can't do."
msgstr "你的Web浏览器只会说普通的HTTP，也就是说它只会GET公共的URL，这个URL代表了最新版本的文件和目录，根据WebDAV/DeltaV规范，每种服务器定义了一种私有的URL语法来代表老的资源的版本，这个语法对客户端是不透明的，为了得到老的版本，一个客户端必须通过一种规范过程来<quote>发现</quote>正确的URL；这个过程包括执行一系列WebDAV PROPFIND请求和理解DeltaV概念，这些事情一般是你的web浏览器做不了的。"

#: build/en/book.xml:14645(para)
#, fuzzy
msgid "So to answer the question, one obvious way to see older revisions of files and directories is by passing the <option>--revision (-r)</option> argument to the <command moreinfo=\"none\">svn list</command> and <command moreinfo=\"none\">svn cat</command> commands. To browse old revisions with your web browser, however, you can use third-party software. A good example of this is ViewVC (<ulink url=\"http://viewvc.tigris.org/\"/>). ViewVC was originally written to display CVS repositories through the web, <placeholder-1/> and the latest releases are able to understand Subversion repositories as well."
msgstr "为了回答这些问题，一个明显的看老版本文件和目录的方式是带<option>--revision</option>参数的<command moreinfo=\"none\">svn list</command>和<command moreinfo=\"none\">svn cat</command>命令，为了在浏览器里察看老版本，你可以使用第三方的软件，一个好的例子是ViewVC（<ulink url=\"http://viewvc.tigris.org/\"/>），ViewVC最初写出来是为了在web显示CVS版本库，<footnote><placeholder-1/></footnote>最新的带血的（此时正在编写）版本也已经可以理解Subversion版本库了。"

#: build/en/book.xml:14656(para)
msgid "Back then, it was called <quote>ViewCVS</quote>."
msgstr "之前叫做<quote>ViewCVS</quote>。"

#: build/en/book.xml:1466(para)
#, fuzzy
msgid "In the second syntax, you need to quote the URL so that the vertical bar character is not interpreted as a pipe. Also, note that a URL uses forward slashes even though the native (non-URL) form of a path on Windows uses backslashes."
msgstr "在第二个语法，你需要使用引号包含整个URL，这样竖线字符才不会被解释为管道。当然，注意URL使用普通的斜线而不是Windows本地（不是URL）的反斜线。"

#: build/en/book.xml:14663(title)
msgid "Proper MIME Type"
msgstr ""

#: build/en/book.xml:14665(para)
msgid "When browsing a Subversion repository, the web browser gets a clue about how to render a file's contents by looking at the <literal moreinfo=\"none\">Content-Type:</literal> header returned in Apache's response to the HTTP <literal moreinfo=\"none\">GET</literal> request. The value of this header is some sort of MIME type. By default, Apache will tell the web browsers that all repository files are of the <quote>default</quote> MIME type, typically <literal moreinfo=\"none\">text/plain</literal>. This can be frustrating, however, if a user wishes repository files to render as something more meaningful — for example, it might be nice to have a <filename moreinfo=\"none\">foo.html</filename> file in the repository actually render as HTML when browsing."
msgstr ""

#: build/en/book.xml:14680(para)
msgid "To make this happen, you only need to make sure that your files have the proper <literal moreinfo=\"none\">svn:mime-type</literal> set. This is discussed in more detail in <xref linkend=\"svn.advanced.props.special.mime-type\"/>, and you can even configure your client to automatically attach proper <literal moreinfo=\"none\">svn:mime-type</literal> properties to files entering the repository for the first time; see <xref linkend=\"svn.advanced.props.auto\"/>."
msgstr ""

#: build/en/book.xml:14690(para)
msgid "So in our example, if one were to set the <literal moreinfo=\"none\">svn:mime-type</literal> property to <literal moreinfo=\"none\">text/html</literal> on file <filename moreinfo=\"none\">foo.html</filename>, then Apache would properly tell your web browser to render the file as HTML. One could also attach proper <literal moreinfo=\"none\">image/*</literal> mime-type properties to images, and by doing this, ultimately get an entire web site to be viewable directly from a repository! There's generalyl no problem with doing this, as long as the website doesn't contain any dynamically-generated content."
msgstr ""

#: build/en/book.xml:14706(title)
msgid "Customizing the Look"
msgstr ""

#: build/en/book.xml:14708(para)
msgid "You generally will get more use out of URLs to versioned files—after all, that's where the interesting content tends to lie. But you might have occasion to browse a Subversion directory listing, where you'll quickly note that the generated HTML used to display that listing is very basic, and certainly not intended to be aesthetically pleasing (or even interesting). To enable customization of these directory displays, Subversion provides an XML index feature. A single <literal moreinfo=\"none\">SVNIndexXSLT</literal> directive in your repository's <literal moreinfo=\"none\">Location</literal> block of <filename moreinfo=\"none\">httpd.conf</filename> will instruct mod_dav_svn to generate XML output when displaying a directory listing, and to reference the XSLT stylesheet of your choice:"
msgstr "你通常会在版本化的文件的URL之外得到更多地用处—毕竟那里是有趣的内容存在的地方，但是你会偶尔浏览一个Subversion的目录列表，你会很快发现展示列表生成的HTML非常基本，并且一定没有在外观上（或者是有趣上）下功夫，为了自定义这些目录显示，Subversion提供了一个XML目录特性，一个单独的<literal moreinfo=\"none\">SVNIndexXSLT</literal>指示在你的<filename moreinfo=\"none\">httpd.conf</filename>文件版本库的<literal moreinfo=\"none\">Location</literal>块里，它将会指导mod_dav_svn在显示目录列表的时候生成XML输出，并且引用你选择的XSLT样式表文件："

#: build/en/book.xml:1472(para)
#, fuzzy
msgid "Subversion's <literal moreinfo=\"none\">file://</literal> URLs cannot be used in a regular web browser the way typical <literal moreinfo=\"none\">file://</literal> URLs can. When you attempt to view a <literal moreinfo=\"none\">file://</literal> URL in a regular web browser, it reads and displays the contents of the file at that location by examining the filesystem directly. However, Subversion's resources exist in a virtual filesystem (see <xref linkend=\"svn.developer.layerlib.repos\"/>), and your browser will not understand how to interact with that filesystem."
msgstr "也必须意识到Subversion的<literal moreinfo=\"none\">file:</literal> URL不能和在普通的web服务器中的<literal moreinfo=\"none\">file:</literal> URL一样工作。当你尝试在web服务器查看一个<literal moreinfo=\"none\">file:</literal>的URL，它会通过直接检测文件系统读取和显示那个位置的文件内容，但是Subversion的资源存在于虚拟文件系统（见<xref linkend=\"svn.developer.layerlib.repos\"/>）中，你的浏览器不会理解怎样读取这个文件系统。"

#: build/en/book.xml:14724(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  SVNIndexXSLT \"/svnindex.xsl\"\n"
"  …\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  SVNIndexXSLT \"/svnindex.xsl\"\n"
"  …\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14733(para)
msgid "Using the <literal moreinfo=\"none\">SVNIndexXSLT</literal> directive and a creative XSLT stylesheet, you can make your directory listings match the color schemes and imagery used in other parts of your website. Or, if you'd prefer, you can use the sample stylesheets provided in the Subversion source distribution's <filename moreinfo=\"none\">tools/xslt/</filename> directory. Keep in mind that the path provided to the <literal moreinfo=\"none\">SVNIndexXSLT</literal> directory is actually a URL path—browsers need to be able to read your stylesheets in order to make use of them!"
msgstr "使用<literal moreinfo=\"none\">SVNIndexXSLT</literal>指示和创建一个XSLT样式表，你可以让你的目录列表的颜色模式与你的网站的其它部分匹配，否则，如果你愿意，你可以使用Subversion源分发版本中的<filename moreinfo=\"none\">tools/xslt/</filename>目录下的样例样式表。记住提供给<literal moreinfo=\"none\">SVNIndexXSLT</literal> 指示的路径是一个URL路径—浏览器需要阅读你的样式表来利用它们！"

#: build/en/book.xml:14747(title)
#, fuzzy
msgid "Listing Repositories"
msgstr "版本库的移植"

#: build/en/book.xml:14749(para)
msgid "If you're serving a colllection of repositories from a single URL via the <literal moreinfo=\"none\">SVNParentPath</literal> directive, then it's also possible to have Apache display all available repositories to a web browser. Just activate the <literal moreinfo=\"none\">SVNListParentPath</literal> directive:"
msgstr ""

#: build/en/book.xml:14756(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  SVNListParentPath on\n"
"  …\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  SVNListParentPath on\n"
"  …\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14765(para)
msgid "If a user now points her web browser to the URL <literal moreinfo=\"none\">http://host.example.com/svn/</literal>, she'll see list of all Subversion repositories sitting in <filename moreinfo=\"none\">/usr/local/svn</filename>. Obviously, this can be a security problem, so this feature is turned off by default."
msgstr ""

#: build/en/book.xml:14778(title)
msgid "Apache Logging"
msgstr ""

#: build/en/book.xml:14780(para)
msgid "Because Apache is an HTTP server at heart, it contains fantastically flexible logging feature. It's beyond the scope of this book to discuss all ways logging can be configured, but we should point out that even the most generic <filename moreinfo=\"none\">httpd.conf</filename> file will cause Apache to produce two logs: <filename moreinfo=\"none\">error_log</filename> and <filename moreinfo=\"none\">access_log</filename>. These logs may appear in different places, but are typically created in the logging area of your Apache installation. (On Unix, they often live in <filename moreinfo=\"none\">/usr/local/apache2/logs/</filename>.)"
msgstr ""

#: build/en/book.xml:14793(para)
msgid "The <filename moreinfo=\"none\">error_log</filename> describes any interal errors that Apache runs into as it works. The <filename moreinfo=\"none\">access_log</filename> file records every incoming HTTP request received by Apache. This makes it easy to see, for example, which IP addresses Subversion clients are coming from, how often particular clients use the server, which users are authenticating properly, and which requests succeed or fail."
msgstr ""

#: build/en/book.xml:148(para)
#, fuzzy
msgid "During the entire time they wrote this book, Ben, Mike, and Brian haunted the Subversion mailing lists and chat rooms incessantly, carefully noting the problems users were having in real-life situations. Monitoring such feedback was part of their job descriptions at CollabNet anyway, and it gave them a huge advantage when they set out to document Subversion. The book they produced is grounded firmly in the bedrock of experience, not in the shifting sands of wishful thinking; it combines the best aspects of user manual and FAQ sheet. This duality might not be noticeable on a first reading. Taken in order, front to back, the book is simply a straightforward description of a piece of software. There's the overview, the obligatory guided tour, the chapter on administrative configuration, some advanced topics, and of course a command reference and troubleshooting guide. Only when you come back to it later, seeking the solution to some specific problem, does its authenticity shine out: the telling details that can only result from encounters with the unexpected, the examples honed from genuine use cases, and most of all the sensitivity to the user's needs and the user's point of view."
msgstr "在写这本书的过程里，Ben，Mike 和 Brian一直像鬼魂一样游荡在Subversion邮件列表和聊天室中，仔细的研究用户实际遇到的问题。监视这些反馈是他们在CollabNet工作的一部分，这给他们撰写Subversion文档提供了巨大的便利。这本书建立在丰富的使用经验，而非在流沙般脆弱的想象之上，它结合了用户手册和FAQ的优点。初次阅读时，这种二元性的优势并不明显，按照顺序，从前到后，这本书只是简单的从头到尾描述了软件的细节。书中的内容包括一章概述，一章必不可少的快速指南，一章关于管理配置，一些高级主题，当然还包括命令参考手册和故障排除指南。而当你过一段时间之后，再次翻开本书查找一些特定问题的解决方案时，这种二元性才得以显现：这些生动的细节一定来自不可预测的实际用例的提炼，大多是源于用户的需要和视点。"

#: build/en/book.xml:14802(para)
msgid "Unfortunately, because HTTP is a stateless protocol, even the simplest Subversion client operation generates multiple network requests. It's very difficult to look at the <filename moreinfo=\"none\">access_log</filename> and deduce what the client was doing — most operations look like a series of cryptic <literal moreinfo=\"none\">PROPPATCH</literal>, <literal moreinfo=\"none\">GET</literal>, <literal moreinfo=\"none\">PUT</literal>, and <literal moreinfo=\"none\">REPORT</literal> requests. To make things worse, many client operations send nearly-identical series of requests, so it's even harder to tell them apart."
msgstr ""

#: build/en/book.xml:14813(para)
msgid "<literal moreinfo=\"none\">mod_dav_svn</literal>, however, can come to your aid. By activating an <quote>operational logging</quote> feature, you can ask <literal moreinfo=\"none\">mod_dav_svn</literal> to create a separate log file describing what sort of high-level operations your clients are performing."
msgstr ""

#: build/en/book.xml:14820(para)
msgid "To do this, you need to make use of Apache's <literal moreinfo=\"none\">CustomLog</literal> directive (which is explained in more detail in Apache's own documentation). Be sure to invoke this directive <emphasis>outside</emphasis> of your Subversion <literal moreinfo=\"none\">Location</literal> block:"
msgstr ""

#: build/en/book.xml:14827(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  …\n"
"&lt;/Location&gt;\n"
"\n"
"CustomLog logs/svn_logfile \"%t %u %{SVN-ACTION}e\" env=SVN-ACTION\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  …\n"
"&lt;/Location&gt;\n"
"\n"
"CustomLog logs/svn_logfile \"%t %u %{SVN-ACTION}e\" env=SVN-ACTION\n"

#: build/en/book.xml:1483(para)
msgid "Finally, it should be noted that the Subversion client will automatically encode URLs as necessary, just like a web browser does. For example, if a URL contains a space or upper-ASCII character:"
msgstr "最后，必须注意Subversion的客户端会根据需要自动编码URL，这一点和一般的web浏览器一样，举个例子，如果一个URL包含了空格或是一个字符编码大于128的ASCII字符："

#: build/en/book.xml:14836(para)
msgid "In this example, we're asking Apache to create a special logfile <filename moreinfo=\"none\">svn_logfile</filename> in the standard Apache <filename moreinfo=\"none\">logs</filename> directory. The <literal moreinfo=\"none\">%t</literal> and <literal moreinfo=\"none\">%u</literal> variables are replaced by the time and username of the request, respectively. The really important part are the two instances of <literal moreinfo=\"none\">SVN-ACTION</literal>. When Apache sees that variable, it substitutes the value of the <literal moreinfo=\"none\">SVN-ACTION</literal> environment variable, which is automatically set by <literal moreinfo=\"none\">mod_dav_svn</literal> whenever it detects a high-level client action."
msgstr ""

#: build/en/book.xml:14848(para)
#, fuzzy
msgid "So instead of having to interpret a traditional <filename moreinfo=\"none\">access_log</filename> like this:"
msgstr "取出一个工作拷贝到<filename moreinfo=\"none\">mine</filename>："

#: build/en/book.xml:14852(screen)
#, no-wrap
msgid ""
"\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc/!svn/vcc/default HTTP/1.1\" 207 398\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc/!svn/bln/59 HTTP/1.1\" 207 449\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc HTTP/1.1\" 207 647\n"
"[26/Jan/2007:22:25:29 -0600] \"REPORT /svn/calc/!svn/vcc/default HTTP/1.1\" 200 607\n"
"[26/Jan/2007:22:25:31 -0600] \"OPTIONS /svn/calc HTTP/1.1\" 200 188\n"
"[26/Jan/2007:22:25:31 -0600] \"MKACTIVITY /svn/calc/!svn/act/e6035ef7-5df0-4ac0-b811-4be7c823f998 HTTP/1.1\" 201 227\n"
"…\n"
msgstr ""
"\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc/!svn/vcc/default HTTP/1.1\" 207 398\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc/!svn/bln/59 HTTP/1.1\" 207 449\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc HTTP/1.1\" 207 647\n"
"[26/Jan/2007:22:25:29 -0600] \"REPORT /svn/calc/!svn/vcc/default HTTP/1.1\" 200 607\n"
"[26/Jan/2007:22:25:31 -0600] \"OPTIONS /svn/calc HTTP/1.1\" 200 188\n"
"[26/Jan/2007:22:25:31 -0600] \"MKACTIVITY /svn/calc/!svn/act/e6035ef7-5df0-4ac0-b811-4be7c823f998 HTTP/1.1\" 201 227\n"
"…\n"

#: build/en/book.xml:14862(para)
#, fuzzy
msgid "… you can instead peruse a much more intelligible <filename moreinfo=\"none\">svn_logfile</filename> like this:"
msgstr "取出一个工作拷贝到<filename moreinfo=\"none\">mine</filename>："

#: build/en/book.xml:14865(screen)
#, no-wrap
msgid ""
"\n"
"[26/Jan/2007:22:24:20 -0600] - list-dir '/'\n"
"[26/Jan/2007:22:24:27 -0600] - update '/'\n"
"[26/Jan/2007:22:25:29 -0600] - remote-status '/'\n"
"[26/Jan/2007:22:25:31 -0600] sally commit r60\n"
msgstr ""
"\n"
"[26/Jan/2007:22:24:20 -0600] - list-dir '/'\n"
"[26/Jan/2007:22:24:27 -0600] - update '/'\n"
"[26/Jan/2007:22:25:29 -0600] - remote-status '/'\n"
"[26/Jan/2007:22:25:31 -0600] sally commit r60\n"

#: build/en/book.xml:14876(title)
msgid "Other Features"
msgstr "其它特性"

#: build/en/book.xml:14878(para)
#, fuzzy
msgid "Several of the features already provided by Apache in its role as a robust Web server can be leveraged for increased functionality or security in Subversion as well. Subversion communicates with Apache using Neon, which is a generic HTTP/WebDAV library with support for such mechanisms as SSL (the Secure Socket Layer, discussed earlier). If your Subversion client is built to support SSL, then it can access your Apache server using <literal moreinfo=\"none\">https://</literal>."
msgstr "Apache作为一个健壮的Web服务器的许多特性也可以用来增加Subversion的功能性和安全性，Subversion使用Neon与Apache通讯，这是一种一般的HTTP/WebDAV库，可以支持SSL和Deflate压缩（是<command moreinfo=\"none\">gzip</command>和<command moreinfo=\"none\">PKZIP</command>程序用来<quote>压缩</quote>文件为数据块的一样的算法）之类的机制。你只需要编译你希望Subversion和Apache需要的特性，并且正确的配置程序来使用这些特性。"

#: build/en/book.xml:1488(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout \"http://host/path with space/project/españa\"\n"
msgstr ""
"\n"
"$ svn checkout \"http://host/path with space/project/españa\"\n"

#: build/en/book.xml:14888(para)
#, fuzzy
msgid "Equally useful are other features of the Apache and Subversion relationship, such as the ability to specify a custom port (instead of the default HTTP port 80) or a virtual domain name by which the Subversion repository should be accessed, or the ability to access the repository through an HTTP proxy. These things are all supported by Neon, so Subversion gets that support for free."
msgstr "不怎么有趣，但同样重要，是Apache和Subversion关系的一些特性，像可以指定自定义的端口（而不是缺省的HTTP的80）或者是一个Subversion可以被访问的虚拟主机名，或者是通过代理服务器访问的能力，这些特性都是Neon所支持的，所以Subversion轻易得到这些支持。"

#: build/en/book.xml:14896(para)
#, fuzzy
msgid "Finally, because <command moreinfo=\"none\">mod_dav_svn</command> is speaking a subset of the WebDAV/DeltaV protocol, it's possible to access the repository via third-party DAV clients. Most modern operating systems (Win32, OS X, and Linux) have the built-in ability to mount a DAV server as a standard network share. This is a complicated topic; for details, read <xref linkend=\"svn.webdav\"/>."
msgstr "最后，因为<command moreinfo=\"none\">mod_dav_svn</command>是使用一个半完成的WebDAV/DeltaV方言，所以通过第三方的DAV客户端访问也是可能的，几乎所有的现代操作系统（Win32、OS X和Linux）都有把DAV服务器影射为普通的网络<quote>共享</quote>的内置能力，这是一个复杂的主题；察看<xref linkend=\"svn.webdav\"/>来得到更多细节。"

#: build/en/book.xml:14915(title)
msgid "Path-Based Authorization"
msgstr "基于路径的授权"

#: build/en/book.xml:14917(para)
msgid "Both Apache and <command moreinfo=\"none\">svnserve</command> are capable of granting (or denying) permissions to users. Typically this is done over the entire repository: a user can read the repository (or not), and she can write to the repository (or not). It's also possible, however, to define finer-grained access rules. One set of users may have permssion to write to a certain directory in the repository, but not others; another directory might not even be readable by all but a few special people."
msgstr ""

#: build/en/book.xml:1492(para)
msgid "…then Subversion will escape the unsafe characters and behave as if you had typed:"
msgstr "…Subversion会回避这些不安全字符，并且会像你输入了这些字符一样工作："

#: build/en/book.xml:14927(para)
msgid "Both servers use a common file format to describe these path-based access rules. In the case of Apache, one needs to load the <command moreinfo=\"none\">mod_authz_svn</command> module and then add the <literal moreinfo=\"none\">AuthzSVNAccessFile</literal> directive (within the <filename moreinfo=\"none\">httpd.conf</filename> file) pointing to your own rules-file. (For a full explanation, see <xref linkend=\"svn.serverconfig.httpd.authz.perdir\"/>.) If you're using <command moreinfo=\"none\">svnserve</command>, then you need to make the <literal moreinfo=\"none\">authz-db</literal> variable (within <filename moreinfo=\"none\">svnserve.conf</filename>) point to your rules-file."
msgstr ""

#: build/en/book.xml:14940(title)
msgid "Do you really need path-based access control?"
msgstr ""

#: build/en/book.xml:14942(para)
msgid "A lot of administrators setting up Subversion for the first time tend to jump into path-based access control without giving it a lot of thought. The administrator usually knows which teams of people are working on which projects, so it's easy to jump in and grant certain teams access to certain directories and not others. It seems like a natural thing, and it appeases the administrator's desire to maintain tight control of the repository."
msgstr ""

#: build/en/book.xml:1495(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://host/path%20with%20space/project/espa%C3%B1a\n"
msgstr ""
"\n"
"$ svn checkout http://host/path%20with%20space/project/espa%C3%B1a\n"

#: build/en/book.xml:14951(para)
msgid "Note, though, that there are often invisible (and visible!) costs associated with this feature. In the visible category, the server needs to do a lot more work to ensure that the user has the right to read or write each specific path; in certain situations, there's very noticeable performance loss. In the invisible category, consider the culture you're creating. Most of the time, while certain users <emphasis>shouldn't</emphasis> be committing changes to certain parts of the repository, that social contract doesn't need to be technologically enforced. Teams can sometimes spontaneously collaborate with each other; someone may want to help someone else out by committing to an area she doesn't normally work on. By preventing this sort of thing at the server level, you're setting up barriers to unexpected collaboration. You're also creating a bunch of rules that need to be maintained as projects develop, new users are added, and so on. It's a bunch of extra work to maintain."
msgstr ""

#: build/en/book.xml:14970(para)
msgid "Remember that this is a version control system! Even if somebody accidentally commits a change to something they shouldn't, it's easy to undo the change. And if a user commits to the wrong place with deliberate malice, then it's a social problem anyway, and that the problem needs to be dealt with outside of Subversion."
msgstr ""

#: build/en/book.xml:14977(para)
msgid "So before you begin restricting users' access rights, ask yourself if there's a real, honest need for this, or if it's just something that <quote>sounds good</quote> to an administrator. Decide whether it's worth sacrificing some server speed for, and remember that there's very little risk involved; it's bad to become dependent on technology as a crutch for social problems.<placeholder-1/>."
msgstr ""

#: build/en/book.xml:14983(para)
msgid "A common theme in this book!"
msgstr ""

#: build/en/book.xml:14986(para)
msgid "As an example to ponder, consider that the Subversion project itself has always had a notion of who is allowed to commit where, but it's always been enforced socially. This is a good model of community trust, especially for open-source projects. Of course, sometimes there <emphasis>are</emphasis> truly legitimate needs for path-based access control; within corporations, for example, certain types of data really can be sensitive, and access needs to be genuinely restricted to small groups of people."
msgstr ""

#: build/en/book.xml:1499(para)
msgid "If the URL contains spaces, be sure to place it within quote marks, so that your shell treats the whole thing as a single argument to the <command moreinfo=\"none\">svn</command> program."
msgstr "如果URL包含空格，一定要使用引号，这样你的脚本才会把它做一个单独的<command moreinfo=\"none\">svn</command>参数。"

#: build/en/book.xml:14998(para)
msgid "Once your server knows where to find your rules-file, it's time to define the rules."
msgstr ""

#: build/en/book.xml:15(isbn)
msgid "?-?????-???-?"
msgstr "?-?????-???-?"

#: build/en/book.xml:15001(para)
#, fuzzy
msgid "The syntax of the file is the same familiar one used by <command moreinfo=\"none\">svnserve.conf</command> and the runtime configuration files. Lines that start with a hash (<literal moreinfo=\"none\">#</literal>) are ignored. In its simplest form, each section names a repository and path within it, and the authenticated usernames are the option names within each section. The value of each option describes the user's level of access to the repository path: either <literal moreinfo=\"none\">r</literal> (read-only) or <literal moreinfo=\"none\">rw</literal> (read-write). If the user is not mentioned at all, no access is allowed."
msgstr "访问文件的语法与<command moreinfo=\"none\">svnserve.conf</command>和运行中配置文件非常相似，以（<literal moreinfo=\"none\">#</literal>）开头的行会被忽略，在它的简单形式里，每一小节命名一个版本库和一个里面的路径，认证用户名是在每个小节中的选项名，每个选项的值描述了用户访问版本库的级别：<literal moreinfo=\"none\">r</literal>（只读）或者<literal moreinfo=\"none\">rw</literal>（读写），如果用户没有提到，访问是不允许的。"

#: build/en/book.xml:15013(para)
msgid "To be more specific: the value of the section-names are either of the form <literal moreinfo=\"none\">[repos-name:path]</literal> or the form <literal moreinfo=\"none\">[path]</literal>. If you're using the <literal moreinfo=\"none\">SVNParentPath</literal> directive, then it's important to specify the repository names in your sections. If you omit them, then a section like <literal moreinfo=\"none\">[/some/dir]</literal> will match the path <filename moreinfo=\"none\">/some/dir</filename> in <emphasis>every</emphasis> repository. If you're using the <literal moreinfo=\"none\">SVNPath</literal> directive, however, then it's fine to only define paths in your sections—after all, there's only one repository."
msgstr "具体一点：这个小节的名称是<literal moreinfo=\"none\">[repos-name:path]</literal>或者<literal moreinfo=\"none\">[path]</literal>的形式，如果你使用<literal moreinfo=\"none\">SVNParentPath</literal>指示，指定版本库的名字是很重要的，如果你漏掉了他们，<literal moreinfo=\"none\">[/some/dir]</literal>部分就会与<filename moreinfo=\"none\">/some/dir</filename>的所有版本库匹配，如果你使用<literal moreinfo=\"none\">SVNPath</literal>指示，因此在你的小节中只是定义路径也很好—毕竟只有一个版本库。"

#: build/en/book.xml:15025(screen)
#, no-wrap
msgid ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
msgstr ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"

#: build/en/book.xml:15031(para)
msgid "In this first example, the user <literal moreinfo=\"none\">harry</literal> has full read and write access on the <filename moreinfo=\"none\">/branches/calc/bug-142</filename> directory in the <literal moreinfo=\"none\">calc</literal> repository, but the user <literal moreinfo=\"none\">sally</literal> has read-only access. Any other users are blocked from accessing this directory."
msgstr "在第一个例子里，用户<literal moreinfo=\"none\">harry</literal>对<literal moreinfo=\"none\">calc</literal>版本库中<filename moreinfo=\"none\">/branches/calc/bug-142</filename>具备完全的读写权利，但是用户<literal moreinfo=\"none\">sally</literal>只有读权利，任何其他用户禁止访问这个目录。"

#: build/en/book.xml:15038(para)
msgid "Of course, permissions are inherited from parent to child directory. That means that we can specify a subdirectory with a different access policy for Sally:"
msgstr "当然，访问控制是父目录传递给子目录的，这意味着我们可以为Sally指定一个子目录的不同访问策略："

#: build/en/book.xml:15042(screen)
#, no-wrap
msgid ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
"\n"
"# give sally write access only to the 'testing' subdir\n"
"[calc:/branches/calc/bug-142/testing]\n"
"sally = rw\n"
msgstr ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
"\n"
"# give sally write access only to the 'testing' subdir\n"
"[calc:/branches/calc/bug-142/testing]\n"
"sally = rw\n"

#: build/en/book.xml:15052(para)
msgid "Now Sally can write to the <filename moreinfo=\"none\">testing</filename> subdirectory of the branch, but can still only read other parts. Harry, meanwhile, continues to have complete read-write access to the whole branch."
msgstr "现在Sally可以读取分支的<filename moreinfo=\"none\">testing</filename>子目录，但对其他部分还是只可以读，同时，Harry对整个分支还继续有完全的读写权限。"

#: build/en/book.xml:15057(para)
msgid "It's also possible to explicitly deny permission to someone via inheritance rules, by setting the username variable to nothing:"
msgstr "也可以通过继承规则明确的的拒绝某人的访问，只需要设置用户名参数为空："

#: build/en/book.xml:15061(screen)
#, no-wrap
msgid ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
"\n"
"[calc:/branches/calc/bug-142/secret]\n"
"harry =\n"
msgstr ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
"\n"
"[calc:/branches/calc/bug-142/secret]\n"
"harry =\n"

#: build/en/book.xml:1507(title)
msgid "Working Copies"
msgstr "工作拷贝"

#: build/en/book.xml:15070(para)
msgid "In this example, Harry has read-write access to the entire <filename moreinfo=\"none\">bug-142</filename> tree, but has absolutely no access at all to the <filename moreinfo=\"none\">secret</filename> subdirectory within it."
msgstr "在这个例子里，Harry对<filename moreinfo=\"none\">bug-142</filename>目录树有完全的读写权限，但是对<filename moreinfo=\"none\">secret</filename>子目录没有任何访问权利。"

#: build/en/book.xml:15075(para)
#, fuzzy
msgid "The thing to remember is that the most specific path always matches first. The server tries to match the path itself, and then the parent of the path, then the parent of that, and so on. The net effect is that mentioning a specific path in the accessfile will always override any permissions inherited from parent directories."
msgstr "有一件事需要记住的是需要找到最匹配的目录，<command moreinfo=\"none\">mod_authz_svn</command>模块首先找到匹配自己的目录，然后父目录，然后父目录的父目录，就这样继续下去，更具体的路径控制会覆盖所有继承下来的访问控制。"

#: build/en/book.xml:15082(para)
msgid "By default, nobody has any access to the repository at all. That means that if you're starting with an empty file, you'll probably want to give at least read permission to all users at the root of the repository. You can do this by using the asterisk variable (<literal moreinfo=\"none\">*</literal>), which means <quote>all users</quote>:"
msgstr "缺省情况下，没有人对版本库有任何访问，这意味着如果你已经从一个空文件开始，你会希望给所有用户对版本库根目录具备读权限，你可以使用<literal moreinfo=\"none\">*</literal>实现，用来代表<quote>所有用户</quote>："

#: build/en/book.xml:15089(screen)
#, no-wrap
msgid ""
"\n"
"[/]\n"
"* = r\n"
msgstr ""
"\n"
"[/]\n"
"* = r\n"

#: build/en/book.xml:1509(para)
msgid "You've already read about working copies; now we'll demonstrate how the Subversion client creates and uses them."
msgstr "你已经阅读过了关于工作拷贝的内容，现在我们要讲一讲客户端怎样建立和使用它。"

#: build/en/book.xml:15094(para)
#, fuzzy
msgid "This is a common setup; notice that there's no repository name mentioned in the section name. This makes all repositories world readable to all users. Once all users have read-access to the repositories, you can give explicit <literal moreinfo=\"none\">rw</literal> permission to certain users on specific subdirectories within specific repositories."
msgstr "这是一个普通的设置；注意在小节名中没有提到版本库名称，这让所有版本库对所有的用户可读，不管你是使用<literal moreinfo=\"none\">SVNPath</literal>或是<literal moreinfo=\"none\">SVNParentPath</literal>。当所有用户对版本库有了读权利，你可以赋予特定用户对特定子目录的<literal moreinfo=\"none\">rw</literal>权限。"

#: build/en/book.xml:15101(para)
#, fuzzy
msgid "The asterisk variable (<literal moreinfo=\"none\">*</literal>) is also worth special mention here: it's the <emphasis>only</emphasis> pattern which matches an anonymous user. If you've configured your server block to allow a mixture of anonymous and authenticated access, all users start out accessing anonymously. The server looks for a <literal moreinfo=\"none\">*</literal> value defined for the path being accessed; if it can't find one, then it demands real authentication from the client."
msgstr "星号（<literal moreinfo=\"none\">*</literal>）参数需要在这里详细强调：这是匹配匿名用户的<emphasis>唯一</emphasis>模式，如果你已经配置了你的<literal moreinfo=\"none\">Location</literal>区块允许匿名和认证用户的混合访问，所有用户作为Apache匿名用户开始访问，<command moreinfo=\"none\">mod_authz_svn</command>会在要访问路径的定义中查找<literal moreinfo=\"none\">*</literal>值；如果找不到，Apache就会要求真实的客户端认证。"

#: build/en/book.xml:15111(para)
msgid "The access file also allows you to define whole groups of users, much like the Unix <filename moreinfo=\"none\">/etc/group</filename> file:"
msgstr "访问文件也允许你定义一组的用户，很像Unix的<filename moreinfo=\"none\">/etc/group</filename>文件："

#: build/en/book.xml:15115(screen)
#, no-wrap
msgid ""
"\n"
"[groups]\n"
"calc-developers = harry, sally, joe\n"
"paint-developers = frank, sally, jane\n"
"everyone = harry, sally, joe, frank, sally, jane\n"
msgstr ""
"\n"
"[groups]\n"
"calc-developers = harry, sally, joe\n"
"paint-developers = frank, sally, jane\n"
"everyone = harry, sally, joe, frank, sally, jane\n"

#: build/en/book.xml:15122(para)
msgid "Groups can be granted access control just like users. Distinguish them with an <quote>at</quote> (<literal moreinfo=\"none\">@</literal>) prefix:"
msgstr "组可以被赋予通用户一样的访问权限，使用<quote>at</quote>（<literal moreinfo=\"none\">@</literal>）前缀来加以区别："

#: build/en/book.xml:15126(screen)
#, no-wrap
msgid ""
"\n"
"[calc:/projects/calc]\n"
"@calc-developers = rw\n"
"\n"
"[paint:/projects/paint]\n"
"@paint-developers = rw\n"
"jane = r\n"
msgstr ""
"\n"
"[calc:/projects/calc]\n"
"@calc-developers = rw\n"
"\n"
"[paint:/projects/paint]\n"
"@paint-developers = rw\n"
"jane = r\n"

#: build/en/book.xml:1513(para)
msgid "A Subversion working copy is an ordinary directory tree on your local system, containing a collection of files. You can edit these files however you wish, and if they're source code files, you can compile your program from them in the usual way. Your working copy is your own private work area: Subversion will never incorporate other people's changes, nor make your own changes available to others, until you explicitly tell it to do so. You can even have multiple working copies of the same project."
msgstr "一个Subversion工作拷贝是你本地机器一个普通的目录，保存着一些文件，你可以任意的编辑文件，而且如果是源代码文件，你可以像平常一样编译，你的工作拷贝是你的私有工作区，在你明确的做了特定操作之前，Subversion不会把你的修改与其他人的合并，也不会把你的修改展示给别人，你甚至可以拥有同一个项目的多个工作拷贝。"

#: build/en/book.xml:15135(para)
msgid "Groups can also be defined to contain other groups:"
msgstr "组中也可以定义为包含其它的组："

#: build/en/book.xml:15137(screen)
#, no-wrap
msgid ""
"\n"
"[groups]\n"
"calc-developers = harry, sally, joe\n"
"paint-developers = frank, sally, jane\n"
"everyone = @calc-developers, @paint-developers\n"
msgstr ""
"\n"
"[groups]\n"
"calc-developers = harry, sally, joe\n"
"paint-developers = frank, sally, jane\n"
"everyone = @calc-developers, @paint-developers\n"

#: build/en/book.xml:15152(title)
msgid "Supporting Multiple Repository Access Methods"
msgstr "支持多种版本库访问方法"

#: build/en/book.xml:15154(para)
msgid "You've seen how a repository can be accessed in many different ways. But is it possible—or safe—for your repository to be accessed by multiple methods simultaneously? The answer is yes, provided you use a bit of foresight."
msgstr "你已经看到了一个版本库可以用多种方式访问，但是可以—或者说安全的—用几种方式同时并行的访问你的版本库吗？回答是可以，倘若你有一些深谋远虑的使用。"

#: build/en/book.xml:15159(para)
msgid "At any given time, these processes may require read and write access to your repository:"
msgstr "在任何给定的时间，这些进程会要求读或者写访问你的版本库："

#: build/en/book.xml:15164(para)
#, fuzzy
msgid "regular system users using a Subversion client (as themselves) to access the repository directly via <literal moreinfo=\"none\">file://</literal> URLs;"
msgstr "常规的系统用户使用Subversion客户端（客户端程序本身）通过<literal moreinfo=\"none\">file:///</literal>URL直接访问版本库；"

#: build/en/book.xml:15169(para)
msgid "regular system users connecting to SSH-spawned private <command moreinfo=\"none\">svnserve</command> processes (running as themselves) which access the repository;"
msgstr "常规的系统用户连接使用SSH调用的访问版本库的<command moreinfo=\"none\">svnserve</command>进程（以它们自己运行）；"

#: build/en/book.xml:15174(para)
msgid "an <command moreinfo=\"none\">svnserve</command> process—either a daemon or one launched by <command moreinfo=\"none\">inetd</command>—running as a particular fixed user;"
msgstr "一个<command moreinfo=\"none\">svnserve</command>进程—是一个守护进程或是通过<command moreinfo=\"none\">inetd</command>启动的—作为一个固定的用户运行；"

#: build/en/book.xml:15180(para)
msgid "an Apache <command moreinfo=\"none\">httpd</command> process, running as a particular fixed user."
msgstr "一个Apache <command moreinfo=\"none\">httpd</command>进程，以一个固定用户运行。"

#: build/en/book.xml:15185(para)
msgid "The most common problem administrators run into is repository ownership and permissions. Does every process (or user) in the previous list have the rights to read and write the Berkeley DB files? Assuming you have a Unix-like operating system, a straightforward approach might be to place every potential repository user into a new <literal moreinfo=\"none\">svn</literal> group, and make the repository wholly owned by that group. But even that's not enough, because a process may write to the database files using an unfriendly umask—one that prevents access by other users."
msgstr "最通常的一个问题是管理进入到版本库的所有权和访问许可，是前面例子的所有进程 （或者说是用户）都有读写Berkeley DB的权限？假定你有一个类Unix的操作系统，一个直接的办法是在新的<literal moreinfo=\"none\">svn</literal>组添加所有潜在的用户，然后让这个组完全拥有版本库，但这样还不足够，因为一个进程会使用不友好的umask来写数据库文件—用来防止别的用户的访问。"

#: build/en/book.xml:15196(para)
msgid "So the next step beyond setting up a common group for repository users is to force every repository-accessing process to use a sane umask. For users accessing the repository directly, you can make the <command moreinfo=\"none\">svn</command> program into a wrapper script that first sets <command moreinfo=\"none\">umask 002</command> and then runs the real <command moreinfo=\"none\">svn</command> client program. You can write a similar wrapper script for the <command moreinfo=\"none\">svnserve</command> program, and add a <command moreinfo=\"none\">umask 002</command> command to Apache's own startup script, <filename moreinfo=\"none\">apachectl</filename>. For example:"
msgstr "所以下一步我们不选择为每个版本库用户设置一个共同的组的方法，而是强制每个版本库访问进程使用一个健全的umask。对直接访问版本库的用户，你可以使用<command moreinfo=\"none\">svn</command>的包裹脚本来首先设置<command moreinfo=\"none\">umask 002</command>，然后运行真实的<command moreinfo=\"none\">svn</command>客户端程序，你可以为<command moreinfo=\"none\">svnserve</command>写相同的脚本，并且增加<command moreinfo=\"none\">umask 002</command>命令到Apache自己的启动脚本<filename moreinfo=\"none\">apachectl</filename>中。例如："

#: build/en/book.xml:15207(screen)
#, no-wrap
msgid ""
"\n"
"$ cat /usr/bin/svn\n"
"\n"
"#!/bin/sh\n"
"\n"
"umask 002\n"
"/usr/bin/svn-real \"$@\"\n"
"\n"
msgstr ""
"\n"
"$ cat /usr/bin/svn\n"
"\n"
"#!/bin/sh\n"
"\n"
"umask 002\n"
"/usr/bin/svn-real \"$@\"\n"
"\n"

#: build/en/book.xml:15217(para)
msgid "Another common problem is often encountered on Unix-like systems. As a repository is used, Berkeley DB occasionally creates new log files to journal its actions. Even if the repository is wholly owned by the <command moreinfo=\"none\">svn</command> group, these newly created files won't necessarily be owned by that same group, which then creates more permissions problems for your users. A good workaround is to set the group SUID bit on the repository's <filename moreinfo=\"none\">db</filename> directory. This causes all newly-created log files to have the same group owner as the parent directory."
msgstr "另一个在类Unix系统下常见的问题是，当版本库在使用时，BerkeleyDB有时候创建一个新的日志文件来记录它的东西，即使这个版本库是完全由<command moreinfo=\"none\">svn</command>组拥有，这个新创建的文件不是必须被同一个组拥有，这给你的用户造成了更多地许可问题。一个好的工作区应该设置组的SUID字节到版本库的<filename moreinfo=\"none\">db</filename>目录，这会导致所有新创建的日志文件拥有同父目录相同的组拥有者。"

#: build/en/book.xml:15228(para)
msgid "Once you've jumped through these hoops, your repository should be accessible by all the necessary processes. It may seem a bit messy and complicated, but the problems of having multiple users sharing write-access to common files are classic ones that are not often elegantly solved."
msgstr "一旦你跳过了这些障碍，你的版本库一定是可以通过各种可能的手段访问了，这看起来有点凌乱和复杂，但是这个让多个用户分享对一个文件的写权限的问题是一个经典问题，并且经常是没有优雅的解决。"

#: build/en/book.xml:1523(para)
msgid "After you've made some changes to the files in your working copy and verified that they work properly, Subversion provides you with commands to <quote>publish</quote> your changes to the other people working with you on your project (by writing to the repository). If other people publish their own changes, Subversion provides you with commands to merge those changes into your working directory (by reading from the repository)."
msgstr "当你在工作拷贝作了一些修改并且确认它们工作正常之后，Subversion提供了一个命令可以<quote>发布</quote>你的修改给项目中的其他人（通过写到版本库），如果别人发布了各自的修改，Subversion提供了手段可以把这些修改与你的工作目录进行合并（通过读取版本库）。"

#: build/en/book.xml:15234(para)
msgid "Fortunately, most repository administrators will never <emphasis>need</emphasis> to have such a complex configuration. Users who wish to access repositories that live on the same machine are not limited to using <literal moreinfo=\"none\">file://</literal> access URLs—they can typically contact the Apache HTTP server or <command moreinfo=\"none\">svnserve</command> using <literal moreinfo=\"none\">localhost</literal> for the server name in their <literal moreinfo=\"none\">http://</literal> or <literal moreinfo=\"none\">svn://</literal> URLs. And to maintain multiple server processes for your Subversion repositories is likely to be more of a headache than necessary. We recommend you choose the server that best meets your needs and stick with it!"
msgstr "幸运的是，大多数版本库管理员不<emphasis>需要</emphasis>这样复杂的配置，用户如果希望访问本机的版本库，并不是一定要通过<literal moreinfo=\"none\">file://</literal>的URL—他们可以用<literal moreinfo=\"none\">localhost</literal>机器名联系Apache的HTTP服务器或者是<command moreinfo=\"none\">svnserve</command>，协议分别是<literal moreinfo=\"none\">http://</literal>或<literal moreinfo=\"none\">svn://</literal>。为你的Subversion版本库维护多个服务器进程，版本库会变得超出需要的头痛，我们建议你选择最符合你的需要的版本库，并且坚持使用！"

#: build/en/book.xml:15248(title)
msgid "The svn+ssh:// server checklist"
msgstr "svn+ssh://服务器检查列表"

#: build/en/book.xml:15250(para)
msgid "It can be quite tricky to get a bunch of users with existing SSH accounts to share a repository without permissions problems. If you're confused about all the things that you (as an administrator) need to do on a Unix-like system, here's a quick checklist that resummarizes some of things discussed in this section:"
msgstr "让一些用户通过存在的SSH帐户来共享版本库而没有访问许可问题是一件很有技巧的事情，如果你为自己需要在（作为一个管理员）类Unix系统上做的事情感到迷惑，这里是一些快速的检查列表，总结了本小节讨论的事情："

#: build/en/book.xml:15259(para)
msgid "All of your SSH users need to be able to read and write to the repository. Put all the SSH users into a single group. Make the repository wholly owned by that group, and set the group permissions to read/write."
msgstr "所有的SSH用户需要能够读写版本库，把所有的SSH用户放到同一个组里，让版本库完全属于这个组，设置组的权限是读/写。"

#: build/en/book.xml:15266(para)
msgid "Your users need to use a sane umask when accessing the repository. Make sure that <command moreinfo=\"none\">svnserve</command> (<filename moreinfo=\"none\">/usr/bin/svnserve</filename>, or wherever it lives in <literal moreinfo=\"none\">$PATH</literal>) is actually a wrapper script which sets <command moreinfo=\"none\">umask 002</command> and executes the real <command moreinfo=\"none\">svnserve</command> binary. Take similar measures when using <command moreinfo=\"none\">svnlook</command> and <command moreinfo=\"none\">svnadmin</command>. Either run them with a sane umask, or wrap them as described above."
msgstr "你的用户在访问版本库时需要使用一个健全的umask，确定<command moreinfo=\"none\">svnserve</command>（<filename moreinfo=\"none\">/usr/bin/svnserve</filename>或者是任何一个<literal moreinfo=\"none\">$PATH</literal>说明的位置）是一个设置了<command moreinfo=\"none\">umask 002</command>和执行真正的<command moreinfo=\"none\">svnserve</command>程序的包裹脚本，对<command moreinfo=\"none\">svnlook</command>和<command moreinfo=\"none\">svnadmin</command>使用相同的措施，或者是使用一个健全的umask运行或者是使用上面说明的包裹。"

#: build/en/book.xml:15295(title)
msgid "Customizing Your Subversion Experience"
msgstr ""

#: build/en/book.xml:15297(para)
msgid "### TODO: Chapter opening ###"
msgstr ""

#: build/en/book.xml:15299(para)
msgid "### TODO: Gut the runtime config stuff like I did the property stuff, making larger topical sections to which the runtime config stuff generally refers. Like already exists for external diff/diff3, add, for example, a section on external editors. ###"
msgstr ""

#: build/en/book.xml:15309(title)
msgid "Runtime Configuration Area"
msgstr "运行配置区"

#: build/en/book.xml:15311(para)
msgid "Subversion provides many optional behaviors that can be controlled by the user. Many of these options are of the kind that a user would wish to apply to all Subversion operations. So, rather than forcing users to remember command-line arguments for specifying these options, and to use them for each and every operation they perform, Subversion uses configuration files, segregated into a Subversion configuration area."
msgstr "Subversion提供了许多用户可以控制的可选行为方式，许多是用户希望添加到所有的Subversion操作中的选项，为了避免强制用户记住命令行参数并且在每个命令中使用，Subversion使用配置文件，并且将配置文件保存在独立的Subversion配置区。"

#: build/en/book.xml:15319(para)
msgid "The Subversion <firstterm>configuration area</firstterm> is a two-tiered hierarchy of option names and their values. Usually, this boils down to a special directory that contains <firstterm>configuration files</firstterm> (the first tier), which are just text files in standard INI format (with <quote>sections</quote> providing the second tier). These files can be easily edited using your favorite text editor (such as Emacs or vi), and contain directives read by the client to determine which of several optional behaviors the user prefers."
msgstr "Subversion<firstterm>配置区</firstterm>是一个双层结构，保存了可选项的名称和值。通常，Subversion配置区是一个保存<firstterm>配置文件</firstterm>的特殊目录（第一层结构），目录中保存了一些标准INI格式的文本文件（文件中的<quote>section</quote>形成第二层结构）。这些文件可以简单用你喜欢的文本编辑器编辑（如Emacs或vi），而且保存了客户端可以读取的指示，用来指导用户的一些行为选项。"

#: build/en/book.xml:1532(para)
msgid "A working copy also contains some extra files, created and maintained by Subversion, to help it carry out these commands. In particular, each directory in your working copy contains a subdirectory named <filename moreinfo=\"none\">.svn</filename>, also known as the working copy <firstterm>administrative directory</firstterm>. The files in each administrative directory help Subversion recognize which files contain unpublished changes, and which files are out-of-date with respect to others' work."
msgstr "一个工作拷贝也包括一些由Subversion创建并维护的额外文件，用来协助执行这些命令。通常情况下，你的工作拷贝每一个文件夹有一个以<filename moreinfo=\"none\">.svn</filename>为名的文件夹，也被叫做工作拷贝<firstterm>管理目录</firstterm>，这个目录里的文件能够帮助Subversion识别哪一个文件做过修改，哪一个文件相对于别人的工作已经过期了。"

#: build/en/book.xml:15332(title)
msgid "Configuration Area Layout"
msgstr "配置区布局"

#: build/en/book.xml:15334(para)
#, fuzzy
msgid "The first time that the <command moreinfo=\"none\">svn</command> command-line client is executed, it creates a per-user configuration area. On Unix-like systems, this area appears as a directory named <filename moreinfo=\"none\">.subversion</filename> in the user's home directory. On Win32 systems, Subversion creates a folder named <filename moreinfo=\"none\">Subversion</filename>, typically inside the <filename moreinfo=\"none\">Application Data</filename> area of the user's profile directory (which, by the way, is usually a hidden directory). However, on this platform the exact location differs from system to system, and is dictated by the Windows registry. <placeholder-1/> We will refer to the per-user configuration area using its Unix name, <filename moreinfo=\"none\">.subversion</filename>."
msgstr "<command moreinfo=\"none\">svn</command>命令行客户端第一次执行时，会创建一个用户配置区，在类Unix系统中，配置区位于用户主目录中，名为<filename moreinfo=\"none\">.subversion</filename>。在Win32系统，Subversion创建一个名为<filename moreinfo=\"none\">Subversion</filename>的目录，这个目录通常位于用户配置目录（顺便说一句，通常是一个隐藏目录）的<filename moreinfo=\"none\">Application Data</filename>子目录下。然而，在Win32平台上，此目录的具体位置在不同的系统上是不一样的，由Windows注册表决定。 <footnote><placeholder-1/></footnote> 我们以Unix下的名字<filename moreinfo=\"none\">.subversion</filename>来表示用户配置区。"

#: build/en/book.xml:15346(para)
msgid "The <literal moreinfo=\"none\">APPDATA</literal> environment variable points to the <filename moreinfo=\"none\">Application Data</filename> area, so you can always refer to this folder as <filename moreinfo=\"none\">%APPDATA%\\Subversion</filename>."
msgstr "<literal moreinfo=\"none\">APPDATA</literal>环境变量指向<filename moreinfo=\"none\">Application Data</filename>目录，所以你可以通过<filename moreinfo=\"none\">%APPDATA%\\Subversion</filename>引用用户配置区目录。"

#: build/en/book.xml:15354(para)
msgid "In addition to the per-user configuration area, Subversion also recognizes the existence of a system-wide configuration area. This gives system administrators the ability to establish defaults for all users on a given machine. Note that the system-wide configuration area does not alone dictate mandatory policy—the settings in the per-user configuration area override those in the system-wide one, and command-line arguments supplied to the <command moreinfo=\"none\">svn</command> program have the final word on behavior. On Unix-like platforms, the system-wide configuration area is expected to be the <filename moreinfo=\"none\">/etc/subversion</filename> directory; on Windows machines, it looks for a <filename moreinfo=\"none\">Subversion</filename> directory inside the common <filename moreinfo=\"none\">Application Data</filename> location (again, as specified by the Windows Registry). Unlike the per-user case, the <command moreinfo=\"none\">svn</command> program does not attempt to create the system-wide configuration area."
msgstr "除了用户配置区，Subversion也提供了系统配置区，通过系统配置区，系统管理员可以为某个机器的所有用户建立缺省配置值。注意系统配置区不会规定强制性的策略—每个用户配置区都可以覆盖系统配置区中的配置项，而<command moreinfo=\"none\">svn</command>的命令行参数决定了最后的行为。在类Unix的平台上，系统配置区位于<filename moreinfo=\"none\">/etc/subversion</filename>目录下，在Windows平台上，系统配置区位于<filename moreinfo=\"none\">Application Data</filename>（再说一次，是由Windows注册表决定的）的<filename moreinfo=\"none\">Subversion</filename>目录中。与用户配置区不同，<command moreinfo=\"none\">svn</command>不会试图创建系统配置区。"

#: build/en/book.xml:15372(para)
#, fuzzy
msgid "The per-user configuration area currently contains three files—two configuration files (<filename moreinfo=\"none\">config</filename> and <filename moreinfo=\"none\">servers</filename>), and a <filename moreinfo=\"none\">README.txt</filename> file which describes the INI format. At the time of their creation, the files contain default values for each of the supported Subversion options, mostly commented out and grouped with textual descriptions about how the values for the key affect Subversion's behavior. To change a certain behavior, you need only to load the appropriate configuration file into a text editor, and modify the desired option's value. If at any time you wish to have the default configuration settings restored, you can simply remove (or rename) your configuration directory and then run some innocuous <command moreinfo=\"none\">svn</command> command, such as <command moreinfo=\"none\">svn --version</command>. A new configuration directory with the default contents will be created."
msgstr "目前，Subversion的配置区包含三个文件—两个配置文件（<filename moreinfo=\"none\">config</filename>和<filename moreinfo=\"none\">servers</filename>），和一个INI文件格式的<filename moreinfo=\"none\">README.txt</filename>描述文件。配置文件创建的时候，Subversion的选项都设置为默认值。配置文件中的选项都按功能划分成组，大多数选项还有详细的文字描述注释，说明这些选项的值对Subversion的主要影响。要修改选项，只需用文本编辑器打开并编辑配置文件。如果想要恢复缺省的配置，可以直接删除（或者重命名）配置目录，并且运行一些如<command moreinfo=\"none\">svn --version</command>之类的无关紧要的<command moreinfo=\"none\">svn</command>命令，一个包含缺省值的新配置目录就会创建起来。"

#: build/en/book.xml:15389(para)
msgid "The per-user configuration area also contains a cache of authentication data. The <filename moreinfo=\"none\">auth</filename> directory holds a set of subdirectories that contain pieces of cached information used by Subversion's various supported authentication methods. This directory is created in such a way that only the user herself has permission to read its contents."
msgstr "用户配置区也缓存了认证信息，<filename moreinfo=\"none\">auth</filename>目录下的子目录中缓存了一些Subversion支持的各种认证方法的信息，这个目录需要相应的用户权限才可以访问。"

#: build/en/book.xml:15401(title)
msgid "Configuration and the Windows Registry"
msgstr "配置和Windows注册表"

#: build/en/book.xml:15403(para)
msgid "In addition to the usual INI-based configuration area, Subversion clients running on Windows platforms may also use the Windows registry to hold the configuration data. The option names and their values are the same as in the INI files. The <quote>file/section</quote> hierarchy is preserved as well, though addressed in a slightly different fashion—in this schema, files and sections are just levels in the registry key tree."
msgstr "除了基于INI文件的配置区，运行在Windows平台的Subversion客户端也可以使用Windows注册表来保存配置数据。注册表中保存的选项名称和值的含义与INI文件中相同，<quote>file/section</quote>在注册表中表现为注册表键树的层级，使得双层结构得以保留下来。"

#: build/en/book.xml:15412(para)
msgid "Subversion looks for system-wide configuration values under the <literal moreinfo=\"none\">HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion</literal> key. For example, the <literal moreinfo=\"none\">global-ignores</literal> option, which is in the <literal moreinfo=\"none\">miscellany</literal> section of the <filename moreinfo=\"none\">config</filename> file, would be found at <literal moreinfo=\"none\">HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Config\\Miscellany\\global-ignores</literal>. Per-user configuration values should be stored under <literal moreinfo=\"none\">HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion</literal>."
msgstr "Subversion的系统配置值保存在键<literal moreinfo=\"none\">HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion</literal>下。举个例子，<literal moreinfo=\"none\">global-ignores</literal>选项位于<filename moreinfo=\"none\">config</filename>文件的<literal moreinfo=\"none\">miscellany</literal>小节，在Windows注册表中，则位于<literal moreinfo=\"none\">HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Config\\Miscellany\\global-ignores</literal>。用户配置值存放在<literal moreinfo=\"none\">HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion</literal>下。"

#: build/en/book.xml:1542(para)
msgid "A typical Subversion repository often holds the files (or source code) for several projects; usually, each project is a subdirectory in the repository's filesystem tree. In this arrangement, a user's working copy will usually correspond to a particular subtree of the repository."
msgstr "一个典型的Subversion的版本库经常包含许多项目的文件（或者说源代码），通常每一个项目都是版本库的子目录，在这种安排下，一个用户的工作拷贝往往对应版本库的的一个子目录。"

#: build/en/book.xml:15423(para)
msgid "Registry-based configuration options are parsed <emphasis>before</emphasis> their file-based counterparts, so are overridden by values found in the configuration files. In other words, configuration priority is granted in the following order on a Windows system:"
msgstr "基于注册表的配置项在基于文件的配置项<emphasis>之前</emphasis>解析，所以其配置项的值会被配置文件中相同配置项的值覆盖，换句话说，在Windows系统下配置项的优先级是："

#: build/en/book.xml:15431(para)
msgid "Command-line options"
msgstr "命令行选项"

#: build/en/book.xml:15434(para)
msgid "The per-user INI files"
msgstr "用户INI配置文件"

#: build/en/book.xml:15437(para)
msgid "The per-user Registry values"
msgstr "用户注册表值"

#: build/en/book.xml:15440(para)
msgid "The system-wide INI files"
msgstr "系统INI配置文件"

#: build/en/book.xml:15443(para)
msgid "The system-wide Registry values"
msgstr "系统注册表值"

#: build/en/book.xml:15447(para)
msgid "Also, the Windows Registry doesn't really support the notion of something being <quote>commented out</quote>. However, Subversion will ignore any option key whose name begins with a hash (<literal moreinfo=\"none\">#</literal>) character. This allows you to effectively comment out a Subversion option without deleting the entire key from the Registry, obviously simplifying the process of restoring that option."
msgstr "此外，虽然Windows注册表不支持<quote>注释掉</quote>这种概念，但是Subversion会忽略所有以井号（<literal moreinfo=\"none\">#</literal>）开始的字符，这允许你快速的取消一个选项而不需要删除整个注册表键，明显简化了恢复选项的过程。"

#: build/en/book.xml:15455(para)
msgid "The <command moreinfo=\"none\">svn</command> command-line client never attempts to write to the Windows Registry, and will not attempt to create a default configuration area there. You can create the keys you need using the <command moreinfo=\"none\">REGEDIT</command> program. Alternatively, you can create a <filename moreinfo=\"none\">.reg</filename> file, and then double-click on that file from the Explorer shell, which will cause the data to be merged into your registry."
msgstr "<command moreinfo=\"none\">svn</command>命令行客户端不会尝试写Windows注册表，也不会在注册表中创建默认配置区。不过可以使用<command moreinfo=\"none\">REGEDIT</command>创建所需的键。此外，还可以创建一个<filename moreinfo=\"none\">.reg</filename>文件，并在文件浏览器中双击这个文件，文件中的数据就会合并到注册表中。"

#: build/en/book.xml:15465(title)
msgid "Sample Registration Entries (.reg) File."
msgstr "注册表条目（.reg）样本文件。"

#: build/en/book.xml:15467(programlisting)
#, no-wrap
msgid ""
"\n"
"REGEDIT4\n"
"\n"
"[HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Servers\\groups]\n"
"\n"
"[HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Servers\\global]\n"
"\"#http-proxy-host\"=\"\"\n"
"\"#http-proxy-port\"=\"\"\n"
"\"#http-proxy-username\"=\"\"\n"
"\"#http-proxy-password\"=\"\"\n"
"\"#http-proxy-exceptions\"=\"\"\n"
"\"#http-timeout\"=\"0\"\n"
"\"#http-compression\"=\"yes\"\n"
"\"#neon-debug-mask\"=\"\"\n"
"\"#ssl-authority-files\"=\"\"\n"
"\"#ssl-trust-default-ca\"=\"\"\n"
"\"#ssl-client-cert-file\"=\"\"\n"
"\"#ssl-client-cert-password\"=\"\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\auth]\n"
"\"#store-passwords\"=\"yes\"\n"
"\"#store-auth-creds\"=\"yes\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\helpers]\n"
"\"#editor-cmd\"=\"notepad\"\n"
"\"#diff-cmd\"=\"\"\n"
"\"#diff3-cmd\"=\"\"\n"
"\"#diff3-has-program-arg\"=\"\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\tunnels]\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\miscellany]\n"
"\"#global-ignores\"=\"*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store\"\n"
"\"#log-encoding\"=\"\"\n"
"\"#use-commit-times\"=\"\"\n"
"\"#no-unlock\"=\"\"\n"
"\"#enable-auto-props\"=\"\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\auto-props]\n"
"\n"
msgstr ""
"\n"
"REGEDIT4\n"
"\n"
"[HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Servers\\groups]\n"
"\n"
"[HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Servers\\global]\n"
"\"#http-proxy-host\"=\"\"\n"
"\"#http-proxy-port\"=\"\"\n"
"\"#http-proxy-username\"=\"\"\n"
"\"#http-proxy-password\"=\"\"\n"
"\"#http-proxy-exceptions\"=\"\"\n"
"\"#http-timeout\"=\"0\"\n"
"\"#http-compression\"=\"yes\"\n"
"\"#neon-debug-mask\"=\"\"\n"
"\"#ssl-authority-files\"=\"\"\n"
"\"#ssl-trust-default-ca\"=\"\"\n"
"\"#ssl-client-cert-file\"=\"\"\n"
"\"#ssl-client-cert-password\"=\"\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\auth]\n"
"\"#store-passwords\"=\"yes\"\n"
"\"#store-auth-creds\"=\"yes\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\helpers]\n"
"\"#editor-cmd\"=\"notepad\"\n"
"\"#diff-cmd\"=\"\"\n"
"\"#diff3-cmd\"=\"\"\n"
"\"#diff3-has-program-arg\"=\"\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\tunnels]\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\miscellany]\n"
"\"#global-ignores\"=\"*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store\"\n"
"\"#log-encoding\"=\"\"\n"
"\"#use-commit-times\"=\"\"\n"
"\"#no-unlock\"=\"\"\n"
"\"#enable-auto-props\"=\"\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\auto-props]\n"
"\n"

#: build/en/book.xml:1548(para)
msgid "For example, suppose you have a repository that contains two software projects, <literal moreinfo=\"none\">paint</literal> and <literal moreinfo=\"none\">calc</literal>. Each project lives in its own top-level subdirectory, as shown in <xref linkend=\"svn.basic.in-action.wc.dia-1\"/>."
msgstr "举一个例子，你的版本库包含两个软件项目，<literal moreinfo=\"none\">paint</literal>和<literal moreinfo=\"none\">calc</literal>。每个项目在它们各自的顶级子目录下，见<xref linkend=\"svn.basic.in-action.wc.dia-1\"/>。"

#: build/en/book.xml:15510(para)
msgid "The previous example shows the contents of a <filename moreinfo=\"none\">.reg</filename> file which contains some of the most commonly used configuration options and their default values. Note the presence of both system-wide (for network proxy-related options) and per-user settings (editor programs and password storage, among others). Also note that all the options are effectively commented out. You need only to remove the hash (<literal moreinfo=\"none\">#</literal>) character from the beginning of the option names, and set the values as you desire."
msgstr "上面例子里显示的<filename moreinfo=\"none\">.reg</filename>文件中，包含了一些最常用的配置选项和它们的缺省值。注意，上面的例子中不仅包含了系统设置（关于网络代理相关的选项），也包含了用户设置（指定的编辑器程序，是否保存密码，以及其它选项）。同时要注意的是，所有选项都注释掉了，要启用其中的选项，只需删除该选项名称前面的井号（<literal moreinfo=\"none\">#</literal>），然后设置相应的值就可以了。"

#: build/en/book.xml:15525(title)
msgid "Configuration Options"
msgstr "配置选项"

#: build/en/book.xml:15527(para)
msgid "### TODO: Rework and move this section to the Reference ###"
msgstr ""

#: build/en/book.xml:15529(para)
msgid "In this section, we will discuss the specific run-time configuration options that are currently supported by Subversion."
msgstr "本节我们会详细讨论Subversion目前支持的运行配置选项。"

#: build/en/book.xml:15535(title)
msgid "Servers"
msgstr "服务器"

#: build/en/book.xml:15537(para)
msgid "The <filename moreinfo=\"none\">servers</filename> file contains Subversion configuration options related to the network layers. There are two special section names in this file—<literal moreinfo=\"none\">groups</literal> and <literal moreinfo=\"none\">global</literal>. The <literal moreinfo=\"none\">groups</literal> section is essentially a cross-reference table. The keys in this section are the names of other sections in the file; their values are <firstterm>globs</firstterm>—textual tokens which possibly contain wildcard characters—that are compared against the hostnames of the machine to which Subversion requests are sent."
msgstr "<filename moreinfo=\"none\">servers</filename>文件保存了Subversion关于网络层的配置选项，这个文件有两个特别的小节：<literal moreinfo=\"none\">groups</literal> 和<literal moreinfo=\"none\">global</literal>。<literal moreinfo=\"none\">groups</literal>小节是一个交叉引用表，其中的关键字是<filename moreinfo=\"none\">servers</filename>文件中其它小节的名字，值则是一个可以包含通配符的字符序列，对应于接收Subversion请求的主机名，称为glob。"

#: build/en/book.xml:1554(title)
msgid "The repository's filesystem"
msgstr "版本库的文件系统"

#: build/en/book.xml:15549(programlisting)
#, no-wrap
msgid ""
"\n"
"[groups]\n"
"beanie-babies = *.red-bean.com\n"
"collabnet = svn.collab.net\n"
"\n"
"[beanie-babies]\n"
"…\n"
"\n"
"[collabnet]\n"
"…\n"
msgstr ""
"\n"
"[groups]\n"
"beanie-babies = *.red-bean.com\n"
"collabnet = svn.collab.net\n"
"\n"
"[beanie-babies]\n"
"…\n"
"\n"
"[collabnet]\n"
"…\n"

#: build/en/book.xml:15561(para)
msgid "When Subversion is used over a network, it attempts to match the name of the server it is trying to reach with a group name under the <literal moreinfo=\"none\">groups</literal> section. If a match is made, Subversion then looks for a section in the <filename moreinfo=\"none\">servers</filename> file whose name is the matched group's name. From that section it reads the actual network configuration settings."
msgstr "当通过网络访问Subversion服务器时，客户端会设法匹配正在尝试连接的服务器名字和<literal moreinfo=\"none\">groups</literal>小节中的glob名称，如果发现匹配，Subversion会在<filename moreinfo=\"none\">servers</filename>文件中查找对应于这个glob名称的小节，并从该小节中去读取真实的网络配置设置。"

#: build/en/book.xml:15569(para)
msgid "The <literal moreinfo=\"none\">global</literal> section contains the settings that are meant for all of the servers not matched by one of the globs under the <literal moreinfo=\"none\">groups</literal> section. The options available in this section are exactly the same as those valid for the other server sections in the file (except, of course, the special <literal moreinfo=\"none\">groups</literal> section), and are as follows:"
msgstr "如果没有能够匹配到<literal moreinfo=\"none\">groups</literal>中的glob名称，<literal moreinfo=\"none\">global</literal>小节中的选项就会发生作用。<literal moreinfo=\"none\">global</literal>小节中的选项与其他小节一样（当然是除了<literal moreinfo=\"none\">groups</literal>小节），这些选项是："

#: build/en/book.xml:1558(para)
msgid "To get a working copy, you must <firstterm>check out</firstterm> some subtree of the repository. (The term <quote>check out</quote> may sound like it has something to do with locking or reserving resources, but it doesn't; it simply creates a private copy of the project for you.) For example, if you check out <filename moreinfo=\"none\">/calc</filename>, you will get a working copy like this:"
msgstr "为了得到一个工作拷贝，你必须<firstterm>检出</firstterm>（<firstterm>check out</firstterm>）版本库的一个子树，（术语<quote>check out</quote>听起来像是锁定或者保存资源，实际上不是，只是简单的得到一个项目的私有拷贝），举个例子，你检出 <filename moreinfo=\"none\">/calc</filename>，你可以得到这样的工作拷贝："

#: build/en/book.xml:15580(literal)
msgid "http-proxy-host"
msgstr "http-proxy-host"

#: build/en/book.xml:15582(para)
msgid "This specifies the hostname of the proxy computer through which your HTTP-based Subversion requests must pass. It defaults to an empty value, which means that Subversion will not attempt to route HTTP requests through a proxy computer, and will instead attempt to contact the destination machine directly."
msgstr "代理服务器的详细主机名，是HTTP为基础的Subversion请求必须通过的，缺省值为空，意味着Subversion不会尝试通过代理服务器进行HTTP请求，而会尝试直接连接目标机器。"

#: build/en/book.xml:15591(literal)
msgid "http-proxy-port"
msgstr "http-proxy-port"

#: build/en/book.xml:15593(para)
msgid "This specifies the port number on the proxy host to use. It defaults to an empty value."
msgstr "代理服务器的详细端口，缺省值为空。"

#: build/en/book.xml:15598(literal)
msgid "http-proxy-username"
msgstr "http-proxy-username"

#: build/en/book.xml:15600(para)
msgid "This specifies the username to supply to the proxy machine. It defaults to an empty value."
msgstr "代理服务器的用户名，缺省值为空。"

#: build/en/book.xml:15605(literal)
msgid "http-proxy-password"
msgstr "http-proxy-password"

#: build/en/book.xml:15607(para)
msgid "This specifies the password to supply to the proxy machine. It defaults to an empty value."
msgstr "代理服务器的密码，缺省为空。"

#: build/en/book.xml:15612(literal)
msgid "http-timeout"
msgstr "http-timeout"

#: build/en/book.xml:15614(para)
msgid "This specifies the amount of time, in seconds, to wait for a server response. If you experience problems with a slow network connection causing Subversion operations to timeout, you should increase the value of this option. The default value is <literal moreinfo=\"none\">0</literal>, which instructs the underlying HTTP library, Neon, to use its default timeout setting."
msgstr "等待服务器响应的时间，以秒为单位，如果你的网络速度较慢，导致Subversion的操作超时，你可以加大这个数值，缺省值是<literal moreinfo=\"none\">0</literal>，意思是让HTTP库Neon使用自己的缺省值。"

#: build/en/book.xml:15625(literal)
msgid "http-compression"
msgstr "http-compression"

#: build/en/book.xml:15627(para)
msgid "This specifies whether or not Subversion should attempt to compress network requests made to DAV-ready servers. The default value is <literal moreinfo=\"none\">yes</literal> (though compression will only occur if that capability is compiled into the network layer). Set this to <literal moreinfo=\"none\">no</literal> to disable compression, such as when debugging network transmissions."
msgstr "这说明是否在与设置好DAV的服务器通讯时使用网络压缩请求，缺省值是<literal moreinfo=\"none\">yes</literal>（尽管只有在这个功能编译到网络层时压缩才会有效），设置<literal moreinfo=\"none\">no</literal>来关闭压缩，如调试网络传输时。"

#: build/en/book.xml:15637(literal)
msgid "neon-debug-mask"
msgstr "neon-debug-mask"

#: build/en/book.xml:15639(para)
msgid "This is an integer mask that the underlying HTTP library, Neon, uses for choosing what type of debugging output to yield. The default value is <literal moreinfo=\"none\">0</literal>, which will silence all debugging output. For more information about how Subversion makes use of Neon, see <xref linkend=\"svn.developer\"/>."
msgstr "只是一个整形的掩码，底层的HTTP库Neon用来选择产生调试的输出，缺省值是<literal moreinfo=\"none\">0</literal>，意思是关闭所有的调试输出，关于Subversion使用Neon的详细信息，见<xref linkend=\"svn.developer\"/>。"

#: build/en/book.xml:15648(literal)
msgid "ssl-authority-files"
msgstr "ssl-authority-files"

#: build/en/book.xml:15650(para)
msgid "This is a semicolon-delimited list of paths to files containing certificates of the certificate authorities (or CAs) that are accepted by the Subversion client when accessing the repository over HTTPS."
msgstr "这是一个分号分割的路径和文件列表，这些文件包含了Subversion客户端在用HTTPS访问时可以接受的认证授权（或者CA）证书。"

#: build/en/book.xml:15658(literal)
msgid "ssl-trust-default-ca"
msgstr "ssl-trust-default-ca"

#: build/en/book.xml:1566(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://svn.example.com/repos/calc\n"
"A    calc/Makefile\n"
"A    calc/integer.c\n"
"A    calc/button.c\n"
"Checked out revision 56.\n"
"\n"
"$ ls -A calc\n"
"Makefile  integer.c  button.c  .svn/\n"
msgstr ""
"\n"
"$ svn checkout http://svn.example.com/repos/calc\n"
"A    calc/Makefile\n"
"A    calc/integer.c\n"
"A    calc/button.c\n"
"Checked out revision 56.\n"
"\n"
"$ ls -A calc\n"
"Makefile  integer.c  button.c  .svn/\n"

#: build/en/book.xml:15660(para)
msgid "Set this variable to <literal moreinfo=\"none\">yes</literal> if you want Subversion to automatically trust the set of default CAs that ship with OpenSSL."
msgstr "如果你希望Subversion可以自动相信OpenSSL携带的缺省的CA，可以设置为<literal moreinfo=\"none\">yes</literal>。"

#: build/en/book.xml:15666(literal)
msgid "ssl-client-cert-file"
msgstr "ssl-client-cert-file"

#: build/en/book.xml:15668(para)
msgid "If a host (or set of hosts) requires an SSL client certificate, you'll normally be prompted for a path to your certificate. By setting this variable to that same path, Subversion will be able to find your client certificate automatically without prompting you. There's no standard place to store your certificate on disk; Subversion will grab it from any path you specify."
msgstr "如果一个主机（或是一些主机）需要一个SSL客户端证书，你会收到一个提示说需要证书的路径。通过设置这个路径你的Subversion客户端可以自动找到你的证书而不会打扰你。没有标准的存放位置；Subversion会从任何你指定的路径得到这个文件。"

#: build/en/book.xml:15679(literal)
msgid "ssl-client-cert-password"
msgstr "ssl-client-cert-password"

#: build/en/book.xml:15681(para)
msgid "If your SSL client certificate file is encrypted by a passphrase, Subversion will prompt you for the passphrase whenever the certificate is used. If you find this annoying (and don't mind storing the password in the <filename moreinfo=\"none\">servers</filename> file), then you can set this variable to the certificate's passphrase. You won't be prompted anymore."
msgstr "如果你的SSL客户端证书文件是用密码加密的，Subversion会在每次使用证书时请你输入密码，如果你发现这很讨厌（并且不介意把密码存放在<filename moreinfo=\"none\">servers</filename>文件中），你可以设置这个参数为证书的密码，这样就不会再收到密码输入提示了。"

#: build/en/book.xml:15696(title)
msgid "Config"
msgstr "config"

#: build/en/book.xml:15698(para)
msgid "The <filename moreinfo=\"none\">config</filename> file contains the rest of the currently available Subversion run-time options, those not related to networking. There are only a few options in use at this time, but they are again grouped into sections in expectation of future additions."
msgstr "其它的Subversion运行选项保存在<filename moreinfo=\"none\">config</filename>文件中，这些运行选项与网络连接无关，只是一些正在使用的选项，但是为了应对未来的扩展，也按小节划分成组。"

#: build/en/book.xml:15704(para)
msgid "The <literal moreinfo=\"none\">auth</literal> section contains settings related to Subversion's authentication and authorization against the repository. It contains:"
msgstr "<literal moreinfo=\"none\">auth</literal>小节保存了Subversion相关的认证和授权的设置，它包括："

#: build/en/book.xml:15710(literal)
msgid "store-passwords"
msgstr "store-passwords"

#: build/en/book.xml:15712(para)
msgid "This instructs Subversion to cache, or not to cache, passwords that are supplied by the user in response to server authentication challenges. The default value is <literal moreinfo=\"none\">yes</literal>. Set this to <literal moreinfo=\"none\">no</literal> to disable this on-disk password caching. You can override this option for a single instance of the <command moreinfo=\"none\">svn</command> command using the <option>--no-auth-cache</option> command-line parameter (for those subcommands that support it). For more information, see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>."
msgstr "这告诉Subversion是否缓存服务器认证要求时用户提供的密码，缺省值是<literal moreinfo=\"none\">yes</literal>。设置为<literal moreinfo=\"none\">no</literal>可以关闭在存盘的密码缓存，你可以通过<command moreinfo=\"none\">svn</command>的<option>--no-auth-cache</option>命令行参数（那些支持这个参数的子命令）来覆盖这个设置，详细信息请见<xref linkend=\"svn.serverconfig.netmodel.credcache\"/>。"

#: build/en/book.xml:15725(literal)
msgid "store-auth-creds"
msgstr "store-auth-creds"

#: build/en/book.xml:15727(para)
msgid "This setting is the same as <literal moreinfo=\"none\">store-passwords</literal>, except that it enables or disables disk-caching of <emphasis>all</emphasis> authentication information: usernames, passwords, server certificates, and any other types of cacheable credentials."
msgstr "这个设置与<literal moreinfo=\"none\">store-passwords</literal>相似，不过设置了这个选项将会保存<emphasis>所有</emphasis>认证信息，如用户名、密码、服务器证书，以及其他任何类型的可以缓存的凭证。"

#: build/en/book.xml:15737(para)
msgid "The <literal moreinfo=\"none\">helpers</literal> section controls which external applications Subversion uses to accomplish its tasks. Valid options in this section are:"
msgstr "<literal moreinfo=\"none\">helpers</literal>小节控制完成Subversion任务的外部程序，正确的选项包括："

#: build/en/book.xml:15743(literal)
msgid "editor-cmd"
msgstr "editor-cmd"

#: build/en/book.xml:15745(para)
msgid "This specifies the program Subversion will use to query the user for a log message during a commit operation, such as when using <command moreinfo=\"none\">svn commit</command> without either the <option>--message</option> (<option>-m</option>) or <option>--file</option> (<option>-F</option>) options. This program is also used with the <command moreinfo=\"none\">svn propedit</command> command—a temporary file is populated with the current value of the property the user wishes to edit, and the edits take place right in the editor program (see <xref linkend=\"svn.advanced.props\"/>). This option's default value is empty. The order of priority for determining the editor command is:"
msgstr "Subversion在提交操作时用来询问用户日志信息的程序，例如使用<command moreinfo=\"none\">svn commit</command>而没有指定<option>--message</option>（<option>-m</option>）或者<option>--file</option>（<option>-F</option>）选项。这个程序也会与<command moreinfo=\"none\">svn propedit</command>一起使用—一个临时文件跳出来包含已经存在的用户希望编辑的属性，然后用户可以对这个属性进行编辑（见<xref linkend=\"svn.advanced.props\"/>），这个选项的缺省值为空，检测编辑器的顺序如下："

#: build/en/book.xml:15760(para)
msgid "Command-line option <literal moreinfo=\"none\">--editor-cmd</literal>"
msgstr "命令行选项<literal moreinfo=\"none\">--editor-cmd</literal>"

#: build/en/book.xml:15763(para)
msgid "Environment variable <literal moreinfo=\"none\">SVN_EDITOR</literal>"
msgstr "环境变量<literal moreinfo=\"none\">SVN_EDITOR</literal>"

#: build/en/book.xml:15766(para)
msgid "Configuration option <literal moreinfo=\"none\">editor-cmd</literal>"
msgstr "配置选项<literal moreinfo=\"none\">editor-cmd</literal>"

#: build/en/book.xml:15769(para)
msgid "Environment variable <literal moreinfo=\"none\">VISUAL</literal>"
msgstr "环境变量<literal moreinfo=\"none\">VISUAL</literal>"

#: build/en/book.xml:1577(para)
msgid "The list of letter A's indicates that Subversion is adding a number of items to your working copy. You now have a personal copy of the repository's <filename moreinfo=\"none\">/calc</filename> directory, with one additional entry—<filename moreinfo=\"none\">.svn</filename>—which holds the extra information needed by Subversion, as mentioned earlier."
msgstr "列表中的A表示Subversion增加了一些条目到工作拷贝，你现在有了一个<filename moreinfo=\"none\">/calc</filename>的个人拷贝，有一个附加的目录—<filename moreinfo=\"none\">.svn</filename>—保存着前面提及的Subversion需要的额外信息。"

#: build/en/book.xml:15772(para)
msgid "Environment variable <literal moreinfo=\"none\">EDITOR</literal>"
msgstr "环境变量<literal moreinfo=\"none\">EDITOR</literal>"

#: build/en/book.xml:15775(para)
msgid "Possibly, a default value built in to Subversion (not present in the official builds)"
msgstr "也有可能Subversion会有一个内置的缺省值（官方编译版本不是如此）"

#: build/en/book.xml:15779(para)
msgid "The value of any of these options or variables is (unlike <literal moreinfo=\"none\">diff-cmd</literal>) the beginning of a command line to be executed by the shell. Subversion appends a space and the pathname of the temporary file to be edited. The editor should modify the temporary file and return a zero exit code to indicate success."
msgstr "所有这些选项和变量（不像<literal moreinfo=\"none\">diff-cmd</literal>）的值的开头都是shell中要执行的命令行，Subversion会追加一个空格和一个需要编辑的临时文件，编辑器必须修改临时文件，并且返回一个0来表明成功。"

#: build/en/book.xml:15788(literal)
msgid "diff-cmd"
msgstr "diff-cmd"

#: build/en/book.xml:15790(para)
msgid "This specifies the absolute path of a differencing program, used when Subversion generates <quote>diff</quote> output (such as when using the <command moreinfo=\"none\">svn diff</command> command). By default Subversion uses an internal differencing library—setting this option will cause it to perform this task using an external program. See <xref linkend=\"svn.advanced.externaldifftools\"/> for more details on using such programs."
msgstr "这个命令是比较程序的绝对路径，当Subversion生成了<quote>diff</quote>输出时（例如当使用<command moreinfo=\"none\">svn diff</command>命令）就会使用，缺省Subversion会使用一个内置的比较库—设置这个参数会强制它使用外部程序执行这个任务，此类程序的更多信息见<xref linkend=\"svn.advanced.externaldifftools\"/>。"

#: build/en/book.xml:15802(literal)
msgid "diff3-cmd"
msgstr "diff3-cmd"

#: build/en/book.xml:15804(para)
msgid "This specifies the absolute path of a three-way differencing program. Subversion uses this program to merge changes made by the user with those received from the repository. By default Subversion uses an internal differencing library—setting this option will cause it to perform this task using an external program. See <xref linkend=\"svn.advanced.externaldifftools\"/> for more details on using such programs."
msgstr "这指定了一个三向的比较程序，Subversion使用这个程序来合并用户和从版本库接受的修改，缺省Subversion会使用一个内置的比较库—设置这个参数会导致它会使用外部程序执行这个任务，此类程序的更多信息见<xref linkend=\"svn.advanced.externaldifftools\"/>。"

#: build/en/book.xml:15815(literal)
msgid "diff3-has-program-arg"
msgstr "diff3-has-program-arg"

#: build/en/book.xml:15817(para)
msgid "This flag should be set to <literal moreinfo=\"none\">true</literal> if the program specified by the <literal moreinfo=\"none\">diff3-cmd</literal> option accepts a <option>--diff-program</option> command-line parameter."
msgstr "如果<literal moreinfo=\"none\">diff3-cmd</literal>选项设置的程序接受一个<option>--diff-program</option>命令行参数，这个标记必须设置为<literal moreinfo=\"none\">true</literal>。"

#: build/en/book.xml:15826(para)
msgid "The <literal moreinfo=\"none\">tunnels</literal> section allows you to define new tunnel schemes for use with <command moreinfo=\"none\">svnserve</command> and <literal moreinfo=\"none\">svn://</literal> client connections. For more details, see <xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>."
msgstr "<literal moreinfo=\"none\">tunnels</literal>小节允许你定义一个<command moreinfo=\"none\">svnserve</command>和<literal moreinfo=\"none\">svn://</literal>客户端连接使用的管道模式，更多细节见<xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>。"

#: build/en/book.xml:15831(para)
#, fuzzy
msgid "The <literal moreinfo=\"none\">miscellany</literal> section is where everything that doesn't belong elsewhere winds up. <placeholder-1/> In this section, you can find:"
msgstr "<literal moreinfo=\"none\">miscellany</literal>小节是一些没法归到别处的选项。 <footnote><placeholder-1/></footnote> 在本小节，你会找到："

#: build/en/book.xml:15834(para)
msgid "Anyone for potluck dinner?"
msgstr "就是一个大杂烩？"

#: build/en/book.xml:15840(literal)
msgid "global-ignores"
msgstr "global-ignores"

#: build/en/book.xml:15842(para)
msgid "When running the <command moreinfo=\"none\">svn status</command> command, Subversion lists unversioned files and directories along with the versioned ones, annotating them with a <literal moreinfo=\"none\">?</literal> character (see <xref linkend=\"svn.tour.cycle.examine.status\"/>). Sometimes, it can be annoying to see uninteresting, unversioned items—for example, object files that result from a program's compilation—in this display. The <literal moreinfo=\"none\">global-ignores</literal> option is a list of whitespace-delimited globs which describe the names of files and directories that Subversion should not display unless they are versioned. The default value is <literal moreinfo=\"none\">*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store</literal>."
msgstr "当运行<command moreinfo=\"none\">svn status</command>命令时，Subversion会和版本化的文件一样列出未版本化的文件和目录，并使用<literal moreinfo=\"none\">?</literal>字符（见see <xref linkend=\"svn.tour.cycle.examine.status\"/>）标记，有时候察看无关的未版本化文件会很讨厌—比如程序编译产生的对象文件—的显示出来。<literal moreinfo=\"none\">global-ignores</literal>选项是一个空格分隔的列表，用来描述Subversion在它们版本化之前不想显示的文件和目录，缺省值是<literal moreinfo=\"none\">*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store</literal>。"

#: build/en/book.xml:15856(para)
msgid "As well as <command moreinfo=\"none\">svn status</command>, the <command moreinfo=\"none\">svn add</command> and <command moreinfo=\"none\">svn import</command> commands also ignore files that match the list when they are scanning a directory. You can override this behaviour for a single instance of any of these commands by explicitly specifying the file name, or by using the <option>--no-ignore</option> command-line flag."
msgstr "就像<command moreinfo=\"none\">svn status</command>，<command moreinfo=\"none\">svn add</command>和<command moreinfo=\"none\">svn import</command>命令也会忽略匹配这个列表的文件，你可以用单个的<option>--no-ignore</option>命令行参数来覆盖这个选项，关于更加细致的控制忽略的项目，见<xref linkend=\"svn.advanced.props.special.ignore\"/>。"

#: build/en/book.xml:1586(title)
msgid "Repository URLs"
msgstr "版本库的URL"

#: build/en/book.xml:15864(para)
msgid "For information on more fine-grained control of ignored items, see <xref linkend=\"svn.advanced.props.special.ignore\"/>."
msgstr "For information on more fine-grained control of ignored items, see <xref linkend=\"svn.advanced.props.special.ignore\"/>."

#: build/en/book.xml:15870(literal)
msgid "enable-auto-props"
msgstr "enable-auto-props"

#: build/en/book.xml:15872(para)
msgid "This instructs Subversion to automatically set properties on newly added or imported files. The default value is <literal moreinfo=\"none\">no</literal>, so set this to <literal moreinfo=\"none\">yes</literal> to enable Auto-props. The <literal moreinfo=\"none\">auto-props</literal> section of this file specifies which properties are to be set on which files."
msgstr "这里指示Subversion自动对新加的或者导入的文件设置属性，缺省值是<literal moreinfo=\"none\">no</literal>，可以设置为<literal moreinfo=\"none\">yes</literal>来开启自动添加属性，这个文件的<literal moreinfo=\"none\">auto-props</literal>小节会说明哪些属性会被设置到哪些文件。"

#: build/en/book.xml:1588(para)
#, fuzzy
msgid "Subversion repositories can be accessed through many different methods—on local disk, or through various network protocols, depending on how your administrator has set things up for you. A repository location, however, is always a URL. <xref linkend=\"svn.basic.in-action.wc.tbl-1\"/> describes how different URL schemas map to the available access methods."
msgstr "Subversion可以通过多种方式访问—本地磁盘访问，或各种各样不同的网络协议，但一个版本库地址永远都是一个URL，<xref linkend=\"svn.basic.in-action.wc.tbl-1\"/>描述了不同的URL模式对应的访问方法。"

#: build/en/book.xml:15882(literal)
msgid "log-encoding"
msgstr "log-encoding"

#: build/en/book.xml:15884(para)
msgid "This variable sets the default character set encoding for commit log messages. It's a permanent form of the <option>--encoding</option> option (see <xref linkend=\"svn.ref.svn.sw\"/>). The Subversion repository stores log messages in UTF-8, and assumes that your log message is written using your operating system's native locale. You should specify a different encoding if your commit messages are written in any other encoding."
msgstr "这个变量设置提交日志缺省的字符集，是<option>--encoding</option>选项（见<xref linkend=\"svn.ref.svn.sw\"/>）的永久形式，Subversion版本库保存了一些UTF-8的日志信息，并且假定你的日志信息是用操作系统的本地编码，如果你提交的信息使用别的编码方式，你一定要指定不同的编码。"

#: build/en/book.xml:15897(literal)
msgid "use-commit-times"
msgstr "use-commit-times"

#: build/en/book.xml:15899(para)
msgid "Normally your working copy files have timestamps that reflect the last time they were touched by any process, whether that be your own editor or by some <command moreinfo=\"none\">svn</command> subcommand. This is generally convenient for people developing software, because build systems often look at timestamps as a way of deciding which files need to be recompiled."
msgstr "通常你的工作拷贝文件会有最后一次被进程访问的时间戳，不管是你自己的编辑器还是用<command moreinfo=\"none\">svn</command>子命令。这通常对人们开发软件提供了便利，因为编译系统通常会通过查看时间戳来决定那些文件需要重新编译。"

#: build/en/book.xml:15907(para)
msgid "In other situations, however, it's sometimes nice for the working copy files to have timestamps that reflect the last time they were changed in the repository. The <command moreinfo=\"none\">svn export</command> command always places these <quote>last-commit timestamps</quote> on trees that it produces. By setting this config variable to <literal moreinfo=\"none\">yes</literal>, the <command moreinfo=\"none\">svn checkout</command>, <command moreinfo=\"none\">svn update</command>, <command moreinfo=\"none\">svn switch</command>, and <command moreinfo=\"none\">svn revert</command> commands will also set last-commit timestamps on files that they touch."
msgstr "在其他情形，有时候如果工作拷贝的文件时间戳反映了上一次在版本库中更改的时间会非常好，<command moreinfo=\"none\">svn export</command>命令会一直放置这些<quote>上次提交的时间戳</quote>放到它创建的目录树。通过设置这个config参数为<literal moreinfo=\"none\">yes</literal>，<command moreinfo=\"none\">svn checkout</command>、<command moreinfo=\"none\">svn update</command>、 <command moreinfo=\"none\">svn switch</command>和<command moreinfo=\"none\">svn revert</command>命令也会为它们操作的文件设置上次提交的时间戳。"

#: build/en/book.xml:15926(para)
msgid "The <literal moreinfo=\"none\">auto-props</literal> section controls the Subversion client's ability to automatically set properties on files when they are added or imported. It contains any number of key-value pairs in the format <literal moreinfo=\"none\">PATTERN = PROPNAME=PROPVALUE</literal> where <literal moreinfo=\"none\">PATTERN</literal> is a file pattern that matches a set of filenames and the rest of the line is the property and its value. Multiple matches on a file will result in multiple propsets for that file; however, there is no guarantee that auto-props will be applied in the order in which they are listed in the config file, so you can't have one rule <quote>override</quote> another. You can find several examples of auto-props usage in the <filename moreinfo=\"none\">config</filename> file. Lastly, don't forget to set <literal moreinfo=\"none\">enable-auto-props</literal> to <literal moreinfo=\"none\">yes</literal> in the <literal moreinfo=\"none\">miscellany</literal> section if you want to enable auto-props."
msgstr "<literal moreinfo=\"none\">auto-props</literal>小节控制Subversion客户端自动设置提交和导入的文件的属性的能力，它可以包含任意数量的键-值对，格式是<literal moreinfo=\"none\">PATTERN = PROPNAME=PROPVALUE</literal>，其中<literal moreinfo=\"none\">PATTERN</literal>是一个文件模式，匹配一系列文件名，此行其它两项为属性和值。如果一个文件匹配多次，会导致有多个属性集；然而，没有手段保障自动属性不会按照配置文件中的顺序应用，所以你可以一个规则<quote>覆盖</quote>另一个。你可以在<filename moreinfo=\"none\">config</filename>文件找到许多自动属性的用法实例。最后，如果你希望开启自动属性，不要忘了设置<literal moreinfo=\"none\">miscellany</literal>小节的<literal moreinfo=\"none\">enable-auto-props</literal>为<literal moreinfo=\"none\">yes</literal>。"

#: build/en/book.xml:15954(title)
msgid "Localization"
msgstr "本地化"

#: build/en/book.xml:15956(para)
msgid "<firstterm>Localization</firstterm> is the act of making programs behave in a region-specific way. When a program formats numbers or dates in a way specific to your part of the world, or prints messages (or accepts input) in your native language, the program is said to be <firstterm>localized</firstterm>. This section describes steps Subversion has made towards localization."
msgstr "<firstterm>本地化</firstterm>是让程序按照地区特定方式运行的行为，如果一个程序的格式、数字或者是日期是你的本地方式，或者是打印的信息（或者是接受的输入）是你本地的语言，这个程序被叫做已经<firstterm>本地化了</firstterm>，这部分描述了针对本地化的Subversion的步骤。"

#: build/en/book.xml:15966(title)
msgid "Understanding locales"
msgstr "理解地区"

#: build/en/book.xml:15968(para)
msgid "Most modern operating systems have a notion of the <quote>current locale</quote>—that is, the region or country whose localization conventions are honored. These conventions—typically chosen by some runtime configuration mechanism on the computer—affect the way in which programs present data to the user, as well as the way in which they accept user input."
msgstr "许多现代操作系统都有一个<quote>当前地区</quote>的概念—也就是本地化习惯服务的国家和地区。这些习惯—通常是被一些运行配置机制选择—影响程序展现数据的方式，也有接受用户输入的方式。"

#: build/en/book.xml:15976(para)
msgid "On Unix-like systems, you can check the values of the locale-related runtime configuration options by running the <command moreinfo=\"none\">locale</command> command:"
msgstr "在类Unix的系统，你可以运行<command moreinfo=\"none\">locale</command>命令来检查本地关联的运行配置的选项值："

#: build/en/book.xml:1598(title)
msgid "Repository Access URLs"
msgstr "版本库访问URL"

#: build/en/book.xml:15980(screen)
#, no-wrap
msgid ""
"\n"
"$ locale\n"
"LANG=\n"
"LC_COLLATE=\"C\"\n"
"LC_CTYPE=\"C\"\n"
"LC_MESSAGES=\"C\"\n"
"LC_MONETARY=\"C\"\n"
"LC_NUMERIC=\"C\"\n"
"LC_TIME=\"C\"\n"
"LC_ALL=\"C\"\n"
msgstr ""
"\n"
"$ locale\n"
"LANG=\n"
"LC_COLLATE=\"C\"\n"
"LC_CTYPE=\"C\"\n"
"LC_MESSAGES=\"C\"\n"
"LC_MONETARY=\"C\"\n"
"LC_NUMERIC=\"C\"\n"
"LC_TIME=\"C\"\n"
"LC_ALL=\"C\"\n"

#: build/en/book.xml:15992(para)
msgid "The output is a list of locale-related environment variables and their current values. In this example, the variables are all set to the default <literal moreinfo=\"none\">C</literal> locale, but users can set these variables to specific country/language code combinations. For example, if one were to set the <literal moreinfo=\"none\">LC_TIME</literal> variable to <literal moreinfo=\"none\">fr_CA</literal>, then programs would know to present time and date information formatted according a French-speaking Canadian's expectations. And if one were to set the <literal moreinfo=\"none\">LC_MESSAGES</literal> variable to <literal moreinfo=\"none\">zh_TW</literal>, then programs would know to present human-readable messages in Traditional Chinese. Setting the <literal moreinfo=\"none\">LC_ALL</literal> variable has the effect of changing every locale variable to the same value. The value of <literal moreinfo=\"none\">LANG</literal> is used as a default value for any locale variable that is unset. To see the list of available locales on a Unix system, run the command <command moreinfo=\"none\">locale -a</command>."
msgstr "输出是一个本地相关的环境变量和它们的值，在这个例子里，所有的变量设置为缺省的<literal moreinfo=\"none\">C</literal>地区，但是用户可以设置这些变量为特定的国家/语言代码组合。举个例子，如果有人设置<literal moreinfo=\"none\">LC_TIME</literal>变量为<literal moreinfo=\"none\">fr_CA</literal>，然后程序会知道使用讲法语的加拿大期望的格式来显示时间和日期信息。如果一个人会设置<literal moreinfo=\"none\">LC_MESSAGES</literal>变量为<literal moreinfo=\"none\">zh_TW</literal>，程序会知道使用繁体中文显示可读信息。如果设置<literal moreinfo=\"none\">LC_ALL</literal>的效果同分别设置所有的位置变量为同一个值有相同的效果。<literal moreinfo=\"none\">LANG</literal>用来作为没有设置地区变量的缺省值，为了查看Unix系统所有的地区列表，运行<command moreinfo=\"none\">locale -a</command>命令。"

#: build/en/book.xml:16011(para)
msgid "On Windows, locale configuration is done via the <quote>Regional and Language Options</quote> control panel item. There you can view and select the values of individual settings from the available locales, and even customize (at a sickening level of detail) several of the display formatting conventions."
msgstr "在Windows，地区配置是通过<quote>地区和语言选项</quote>控制面板管理的，可以从已存在的地区查看选择，甚至可以自定义（会是个很讨厌的复杂事情）许多显示格式习惯。"

#: build/en/book.xml:1602(entry)
msgid "Schema"
msgstr "模式"

#: build/en/book.xml:16022(title)
msgid "Subversion's use of locales"
msgstr "Subversion对地区的支持"

#: build/en/book.xml:16024(para)
msgid "The Subversion client, <command moreinfo=\"none\">svn</command>, honors the current locale configuration in two ways. First, it notices the value of the <literal moreinfo=\"none\">LC_MESSAGES</literal> variable and attempts to print all messages in the specified language. For example:"
msgstr "Subversion客户端，<command moreinfo=\"none\">svn</command>通过两种方式支持当前的地区配置。首先，它会注意<literal moreinfo=\"none\">LC_MESSAGES</literal>的值，然后尝试使用特定的语言打印所有的信息，例如："

#: build/en/book.xml:1603(entry)
msgid "Access Method"
msgstr "访问方法"

#: build/en/book.xml:16030(screen)
#, no-wrap
msgid ""
"\n"
"$ export LC_MESSAGES=de_DE\n"
"$ svn help cat\n"
"cat: Gibt den Inhalt der angegebenen Dateien oder URLs aus.\n"
"Aufruf: cat ZIEL[@REV]...\n"
"…\n"
msgstr ""
"\n"
"$ export LC_MESSAGES=de_DE\n"
"$ svn help cat\n"
"cat: Gibt den Inhalt der angegebenen Dateien oder URLs aus.\n"
"Aufruf: cat ZIEL[@REV]...\n"
"…\n"

#: build/en/book.xml:16038(para)
msgid "This behavior works identically on both Unix and Windows systems. Note, though, that while your operating system might have support for a certain locale, the Subversion client still may not be able to speak the particular language. In order to produce localized messages, human volunteers must provide translations for each language. The translations are written using the GNU gettext package, which results in translation modules that end with the <filename moreinfo=\"none\">.mo</filename> filename extension. For example, the German translation file is named <filename moreinfo=\"none\">de.mo</filename>. These translation files are installed somewhere on your system. On Unix, they typically live in <filename moreinfo=\"none\">/usr/share/locale/</filename>, while on Windows they're often found in the <filename moreinfo=\"none\">\\share\\locale\\</filename> folder in Subversion's installation area. Once installed, a module is named after the program it provides translations for. For example, the <filename moreinfo=\"none\">de.mo</filename> file may ultimately end up installed as <filename moreinfo=\"none\">/usr/share/locale/de/LC_MESSAGES/subversion.mo</filename>. By browsing the installed <filename moreinfo=\"none\">.mo</filename> files, you can see which languages the Subversion client is able to speak."
msgstr "这个行为在Unix和Windows上同样工作，注意，尽管有时你的操作系统支持某个地区，Subversion客户端可能不能讲特定的语言。为了制作本地化信息，志愿者可以提供各种语言的翻译。翻译使用GNU gettext包编写，相关的翻译模块使用<filename moreinfo=\"none\">.mo</filename>作为后缀名。举个例子，德国翻译文件为<filename moreinfo=\"none\">de.mo</filename>。翻译文件安装到你的系统的某个位置，在Unix它们会在<filename moreinfo=\"none\">/usr/share/locale/</filename>，而在Windows它们通常会在Subversion安装的<filename moreinfo=\"none\">\\share\\locale\\</filename>目录。一旦安装，一个命名在程序后面的模块会为此提供翻译。举个例子，<filename moreinfo=\"none\">de.mo</filename>会最终安装到<filename moreinfo=\"none\">/usr/share/locale/de/LC_MESSAGES/subversion.mo</filename>，通过查看安装的<filename moreinfo=\"none\">.mo</filename>文件，我们可以看到Subversion支持的语言。"

#: build/en/book.xml:16061(para)
msgid "The second way in which the locale is honored involves how <command moreinfo=\"none\">svn</command> interprets your input. The repository stores all paths, filenames, and log messages in Unicode, encoded as UTF-8. In that sense, the repository is <firstterm>internationalized</firstterm>—that is, the repository is ready to accept input in any human language. This means, however, that the Subversion client is responsible for sending only UTF-8 filenames and log messages into the repository. In order to do this, it must convert the data from the native locale into UTF-8."
msgstr "第二种支持地区设置的方式包括<command moreinfo=\"none\">svn</command>怎样解释你的输入，版本库使用UTF-8保存了所有的路径，文件名和日志信息。在这种情况下，版本库是<firstterm>国际化的</firstterm>—也就是版本库准备接受任何人类的语言。这意味着，无论如何Subversion客户端要负责发送UTF-8的文件名和日志信息到版本库，为此，必须将数据从本地位置转化为UTF-8。"

#: build/en/book.xml:16072(para)
#, fuzzy
msgid "For example, suppose you create a file named <filename moreinfo=\"none\">caffè.txt</filename>, and then when committing the file, you write the log message as <quote>Adesso il caffè è più forte</quote>. Both the filename and log message contain non-ASCII characters, but because your locale is set to <literal moreinfo=\"none\">it_IT</literal>, the Subversion client knows to interpret them as Italian. It uses an Italian character set to convert the data to UTF-8 before sending them off to the repository."
msgstr "举个例子，你创建了一个文件叫做<filename moreinfo=\"none\">caffè.txt</filename>，然后提交了这个文件，你写的日志信息是<quote>Adesso il caffè è più forte</quote>，文件名和日志信息都包含非ASCII字符，但是因为你的位置设置为<literal moreinfo=\"none\">it_IT</literal>，Subversion知道把它们作为意大利语解释，在发送到版本库之前，它用一个意大利字符集转化数据为UTF-8。"

#: build/en/book.xml:1608(literal)
msgid "file:///"
msgstr "file:///"

#: build/en/book.xml:16082(para)
msgid "Note that while the repository demands UTF-8 filenames and log messages, it <emphasis>does not</emphasis> pay attention to file contents. Subversion treats file contents as opaque strings of bytes, and neither client nor server makes an attempt to understand the character set or encoding of the contents."
msgstr "注意当版本库要求UTF-8文件名和日志信息时，它<emphasis>不会</emphasis>注意到文件的内容，Subversion会把文件内容看作字节串，没有任何客户端和服务器会尝试理解或是编码这些内容。"

#: build/en/book.xml:1609(entry)
msgid "direct repository access (on local disk)"
msgstr "直接版本库访问（本地磁盘）。"

#: build/en/book.xml:16090(title)
msgid "Character set conversion errors"
msgstr "字符集转换错误"

#: build/en/book.xml:16092(para)
msgid "While using Subversion, you might get hit with an error related to character set conversions:"
msgstr "当使用Subversion，你或许会碰到一个字符集转化关联的错误："

#: build/en/book.xml:16095(screen)
#, no-wrap
msgid ""
"\n"
"svn: Can't convert string from native encoding to 'UTF-8':\n"
"…\n"
"svn: Can't convert string from 'UTF-8' to native encoding:\n"
"…\n"
msgstr ""
"\n"
"svn: Can't convert string from native encoding to 'UTF-8':\n"
"…\n"
"svn: Can't convert string from 'UTF-8' to native encoding:\n"
"…\n"

#: build/en/book.xml:16102(para)
msgid "Errors like this typically occur when the Subversion client has received a UTF-8 string from the repository, but not all of the characters in that string can be represented using the encoding of the current locale. For example, if your locale is <literal moreinfo=\"none\">en_US</literal> but a collaborator has committed a Japanese filename, you're likely to see this error when you receive the file during an <command moreinfo=\"none\">svn update</command>."
msgstr "这个错误信息通常会发生在Subversion客户端从版本库接收到一个UTF-8串，但字符不能转化为当前的地区文字时，举个例子，如果你的地区设置是<literal moreinfo=\"none\">en_US</literal>，但是一个写作者使用日本文件名提交，你会在<command moreinfo=\"none\">svn update</command>接受文件时会看到这个错误。"

#: build/en/book.xml:16111(para)
msgid "The solution is either to set your locale to something which <emphasis>can</emphasis> represent the incoming UTF-8 data, or to change the filename or log message in the repository. (And don't forget to slap your collaborator's hand—projects should decide on common languages ahead of time, so that all participants are using the same locale.)"
msgstr "解决方案或者是设置你的地区为<emphasis>可以</emphasis>表示即将到来的UTF-8数据，或者是修改版本库的文件名或信息。（不要忘记和你的合作者拍拍手—项目必须首先决定通用的语言，这样所有的参与者会使用相同的地区设置。）"

#: build/en/book.xml:1612(literal) build/en/book.xml:1618(literal)
msgid "http://"
msgstr "http://"

#: build/en/book.xml:16128(title)
msgid "Using External Differencing Tools"
msgstr "使用外置区别工具"

#: build/en/book.xml:1613(entry)
msgid "access via WebDAV protocol to Subversion-aware Apache server"
msgstr "通过配置Subversion的Apache服务器的WebDAV协议。"

#: build/en/book.xml:16130(para)
msgid "The presence of <option>--diff-cmd</option> and <option>--diff3-cmd</option> options, and similarly named runtime configuration parameters (see <xref linkend=\"svn.advanced.confarea.opts.config\"/>), can lead to a false notion of how easy it is to use external differencing (or <quote>diff</quote>) and merge tools with Subversion. While Subversion can use most of popular such tools available, the effort invested in setting this up often turns out to be non-trivial."
msgstr "选项<option>--diff-cmd</option>和<option>--diff3-cmd</option>的形式相似，也有类似名称的运行配置参数（见<xref linkend=\"svn.advanced.confarea.opts.config\"/>），这会导致一个错误的观念，也就是在Subversion中使用外置的比较（或<quote>diff</quote>）和合并工具会非常的容易，虽然Subversion可以使用大多数类似的工具，但是设置这些工具绝非易事。"

#: build/en/book.xml:16139(para)
#, fuzzy
msgid "The interface between Subversion and external diff and merge tools harkens back to a time when Subversion's only contextual differencing capabilities were built around invocations of the GNU diffutils toolchain, specifically the <command moreinfo=\"none\">diff</command> and <command moreinfo=\"none\">diff3</command> utilities. To get the kind of behavior Subversion needed, it called these utilities with more than a handful of options and parameters, most of which were quite specific to the utilities. Some time later, Subversion grew its own internal differencing library, and as a failover mechanism, <placeholder-1/> the <option>--diff-cmd</option> and <option>--diff3-cmd</option> options were added to the Subversion command-line client so users could more easily indicate that they preferred to use the GNU diff and diff3 utilities instead of the newfangled internal diff library. If those options were used, Subversion would simply ignore the internal diff library, and fall back to running those external programs, lengthy argument lists and all. And that's where things remain today."
msgstr "Subversion和外置比较和合并工具的接口可以追溯到很久以前，当时Subversion的唯一文本比较能力是建立在GNU的工具链之上，特别是<command moreinfo=\"none\">diff</command>和<command moreinfo=\"none\">diff3</command>工具，为了得到Subversion需要的方式，它使用非常复杂的选项和参数调用这些工具，而这些选项和参数都是工具特定的，渐渐的，Subversion发展了自己的比较区别库作为备份机制。<placeholder-1/><option>--diff-cmd</option>和<option>--diff3-cmd</option>选项是添加到Subversion的命令行客户端，所以用户可以更加容易的指明他们最喜欢的使用的GNU diff和diff3工具，而不是新奇的内置比较库，如果使用了这些选项，Subversion会忽略内置的比较库，转而使用外置程序，使用冗长的参数列表。现在还是这样。"

#: build/en/book.xml:16150(para)
msgid "Subversion developers are good, but even the best make mistakes."
msgstr "Subversion的开发者很好，但最好的也会发生错误。"

#: build/en/book.xml:16162(para)
msgid "It didn't take long for folks to realize that having such easy configuration mechanisms for specifying that Subversion should use the external GNU diff and diff3 utilities located at a particular place on the system could be applied toward the use of other diff and merge tools, too. After all, Subversion didn't actually verify that the things it was being told to run were members of the GNU diffutils toolchain. But the only configurable aspect of using those external tools is their location on the system—not the option set, parameter order, etc. Subversion continues throwing all those GNU utility options at your external diff tool regardless of whether or not that program can understand those options. And that's where things get unintuitive for most users."
msgstr "人们很快意识到使用简单的配置机制必须使Subversion使用位于特定位置的GNU diff和diff3工具，毕竟，Subversion并不验证其被告之要执行的程序是否是GNU的工具链的比较工具。唯一可以配置的方面是外置工具在系统的位置—而不是选项集，参数顺序等等。Subversion一直将这些GNU工具选项发给你的外置比较工具，而不管程序是否可以理解那些选项，那不是所有用户直觉的方式。"

#: build/en/book.xml:1617(literal)
msgid "https://"
msgstr "https://"

#: build/en/book.xml:16176(para)
msgid "The key to using external diff and merge tools (other than GNU diff and diff3, of course) with Subversion is to use wrapper scripts which convert the input from Subversion into something that your differencing tool can understand, and then to convert the output of your tool back into a format which Subversion expects—the format that the GNU tools would have used. The following sections cover the specifics of those expectations."
msgstr "使用外置比较和合并工具的关键是使用包裹脚本将Subversion的输出转化为你的脚本程序可以理解的形式，然后将这些比较工具的输出转化为你的Subversion期望的格式—GNU工具可能使用的格式，下面的小节覆盖了那些期望格式的细节。"

#: build/en/book.xml:1618(entry)
msgid "same as <placeholder-1/>, but with SSL encryption."
msgstr "与<placeholder-1/>相似，但是包括SSL加密。"

#: build/en/book.xml:16186(para)
msgid "The decision on when to fire off a contextual diff or merge as part of a larger Subversion operation is made entirely by Subversion, and is affected by, among other things, whether or not the files being operated on are human-readable as determined by their <literal moreinfo=\"none\">svn:mime-type</literal> property. This means, for example, that even if you had the niftiest Microsoft Word-aware differencing or merging tool in the Universe, it would never be invoked by Subversion so long as your versioned Word documents had a configured MIME type that denoted that they were not human-readable (such as <literal moreinfo=\"none\">application/msword</literal>). For more about MIME type settings, see <xref linkend=\"svn.advanced.props.special.mime-type\"/>"
msgstr "何时启动文本比较或合并的决定完全是Subversion的决定，而这个决定是根据文件的<literal moreinfo=\"none\">svn:mime-type</literal>属性作出的，这意味着，例如，即使你有一个可以识别Microsoft Word格式的比较或合并工具，当你对一个Word文件设置为非人工可读（例如<literal moreinfo=\"none\">application/msword</literal>）时，依然不会调用这个识别Word的工具。关于MIME type的设定，可以见<xref linkend=\"svn.advanced.props.special.mime-type\"/>。"

#: build/en/book.xml:16203(title)
msgid "External diff"
msgstr "外置diff"

#: build/en/book.xml:16205(para)
#, fuzzy
msgid "Subversion calls external diff programs with parameters suitable for the GNU diff utility, and expects only that the external program return with a successful error code. For most alternative diff program, only the sixth and seventh arguments, the paths of the files which represent the left and right sides of the diff, respectively, are of interest. Note that Subversion runs the diff program once per modified file covered by the Subversion operation, so if your program runs in an asynchronous fashion (or <quote>backgrounded</quote>), you might have several instances of it all running simultaneously. Finally, Subversion expects that your program return an errorcode of 1 if your program detected differences, or 0 if it did not—any other errorcode is considered a fatal error. <placeholder-1/>"
msgstr "Subversion可以调用适合GNU参数的diff工具，并期望外置程序能够返回成功的错误代码。对于大多数可用的diff程序，只有第6、7参数，diff两边文件的路径。需要注意Subversion对于每个修改的文件都要以异步方式（或<quote>后台</quote>）运行diff程序，你会得到许多并行的实例。最后，Subversion期望你的程序在发现区别时返回错误代码0，没有区别则返回1—任何其他的返回值都被认为是严重错误。 <footnote><placeholder-1/></footnote>"

#: build/en/book.xml:1622(literal) build/en/book.xml:1628(literal)
msgid "svn://"
msgstr "svn://"

#: build/en/book.xml:16220(para)
msgid "The GNU diff manual page puts it this way: <quote>An exit status of 0 means no differences were found, 1 means some differences were found, and 2 means trouble.</quote>"
msgstr "GNU的diff手册这样说的：<quote>返回0意味着没有区别，1是有有区别，其它值意味着出现问题。</quote>"

#: build/en/book.xml:16226(para)
msgid "<xref linkend=\"svn.advanced.externaldifftools.diff.ex-1\"/> and <xref linkend=\"svn.advanced.externaldifftools.diff.ex-2\"/> are templates for external diff tool wrappers in the Bourne shell and Windows batch scripting languages, respectively."
msgstr "<xref linkend=\"svn.advanced.externaldifftools.diff.ex-1\"/>和<xref linkend=\"svn.advanced.externaldifftools.diff.ex-2\"/>分别是Bourne shell和Windows批处理外置diff工具的包裹器模版。"

#: build/en/book.xml:1623(entry)
msgid "access via custom protocol to an <placeholder-1/> server"
msgstr "通过<placeholder-1/>服务自定义的协议。"

#: build/en/book.xml:16233(title)
msgid "diffwrap.sh"
msgstr "diffwrap.sh"

#: build/en/book.xml:16234(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh\n"
"\n"
"# Configure your favorite diff program here.\n"
"DIFF=\"/usr/local/bin/my-diff-tool\"\n"
"\n"
"# Subversion provides the paths we need as the sixth and seventh \n"
"# parameters.\n"
"LEFT=${6}\n"
"RIGHT=${7}\n"
"\n"
"# Call the diff command (change the following line to make sense for\n"
"# your merge program).\n"
"$DIFF --left $LEFT --right $RIGHT\n"
"\n"
"# Return an errorcode of 0 if no differences were detected, 1 if some were.\n"
"# Any other errorcode will be treated as fatal.\n"
msgstr ""
"\n"
"#!/bin/sh\n"
"\n"
"# Configure your favorite diff program here.\n"
"DIFF=\"/usr/local/bin/my-diff-tool\"\n"
"\n"
"# Subversion provides the paths we need as the sixth and seventh \n"
"# parameters.\n"
"LEFT=${6}\n"
"RIGHT=${7}\n"
"\n"
"# Call the diff command (change the following line to make sense for\n"
"# your merge program).\n"
"$DIFF --left $LEFT --right $RIGHT\n"
"\n"
"# Return an errorcode of 0 if no differences were detected, 1 if some were.\n"
"# Any other errorcode will be treated as fatal.\n"

#: build/en/book.xml:16255(title)
msgid "diffwrap.bat"
msgstr "diffwrap.bat"

#: build/en/book.xml:16256(programlisting)
#, no-wrap
msgid ""
"\n"
"@ECHO OFF\n"
"\n"
"REM Configure your favorite diff program here.\n"
"SET DIFF=\"C:\\Program Files\\Funky Stuff\\My Diff Tool.exe\"\n"
"\n"
"REM Subversion provides the paths we need as the sixth and seventh \n"
"REM parameters.\n"
"SET LEFT=%6\n"
"SET RIGHT=%7\n"
"\n"
"REM Call the diff command (change the following line to make sense for\n"
"REM your merge program).\n"
"%DIFF% --left %LEFT% --right %RIGHT%\n"
"\n"
"REM Return an errorcode of 0 if no differences were detected, 1 if some were.\n"
"REM Any other errorcode will be treated as fatal.\n"
msgstr ""
"\n"
"@ECHO OFF\n"
"\n"
"REM Configure your favorite diff program here.\n"
"SET DIFF=\"C:\\Program Files\\Funky Stuff\\My Diff Tool.exe\"\n"
"\n"
"REM Subversion provides the paths we need as the sixth and seventh \n"
"REM parameters.\n"
"SET LEFT=%6\n"
"SET RIGHT=%7\n"
"\n"
"REM Call the diff command (change the following line to make sense for\n"
"REM your merge program).\n"
"%DIFF% --left %LEFT% --right %RIGHT%\n"
"\n"
"REM Return an errorcode of 0 if no differences were detected, 1 if some were.\n"
"REM Any other errorcode will be treated as fatal.\n"

#: build/en/book.xml:1627(literal)
msgid "svn+ssh://"
msgstr "svn+ssh://"

#: build/en/book.xml:16279(title)
msgid "External diff3"
msgstr "外置diff3"

#: build/en/book.xml:1628(entry)
msgid "same as <placeholder-1/>, but through an SSH tunnel."
msgstr "与<placeholder-1/>相似，但通过SSH封装。"

#: build/en/book.xml:16281(para)
msgid "Subversion calls external merge programs with parameters suitable for the GNU diff3 utility, expecting that the external program return with a successful error code and that the full file contents which result from the completed merge operation are printed on the standard output stream (so that Subversion can redirect them into the appropriate version controlled file). For most alternative merge programs, only the ninth, tenth, and eleventh arguments, the paths of the files which represent the <quote>mine</quote>, <quote>older</quote>, and <quote>yours</quote> inputs, respectively, are of interest. Note that because Subversion depends on the output of your merge program, you wrapper script must not exit before that output has been delivered to Subversion. When it finally does exit, it should return an errorcode of 0 if the merge was successful, or 1 if unresolved conflicts remain in the output—any other errorcode is considered a fatal error."
msgstr "Subversion按照符合GNU的diff3的参数调用合并程序，期望外置程序会返回成功的错误代码，并且完整合并的文件结果打印到标准输出（这样Subversion可以重定向这些东西到适当的版本控制下的文件）。对于大多数可选的合并程序，只有第9、10和11参数，分别代表<quote>mine</quote>、<quote>older</quote>和<quote>yours</quote>的路径。需要注意，因为Subversion依赖于你的合并程序的输出，你的包裹脚本在输出发送到Subversion之前不要退出。当最终退出，如果合并成功返回0，如果有为解决的冲突则返回1—其它返回值都是严重错误。"

#: build/en/book.xml:16299(para)
msgid "<xref linkend=\"svn.advanced.externaldifftools.diff3.ex-1\"/> and <xref linkend=\"svn.advanced.externaldifftools.diff3.ex-2\"/> are templates for external merge tool wrappers in the Bourne shell and Windows batch scripting languages, respectively."
msgstr "<xref linkend=\"svn.advanced.externaldifftools.diff3.ex-1\"/>和<xref linkend=\"svn.advanced.externaldifftools.diff3.ex-2\"/>分别是Bourne shell和Windows批处理外置diff工具的包裹器模版。"

#: build/en/book.xml:16305(title)
msgid "diff3wrap.sh"
msgstr "diff3wrap.sh"

#: build/en/book.xml:16306(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh\n"
"\n"
"# Configure your favorite diff3/merge program here.\n"
"DIFF3=\"/usr/local/bin/my-merge-tool\"\n"
"\n"
"# Subversion provides the paths we need as the ninth, tenth, and eleventh \n"
"# parameters.\n"
"MINE=${9}\n"
"OLDER=${10}\n"
"YOURS=${11}\n"
"\n"
"# Call the merge command (change the following line to make sense for\n"
"# your merge program).\n"
"$DIFF3 --older $OLDER --mine $MINE --yours $YOURS\n"
"\n"
"# After performing the merge, this script needs to print the contents\n"
"# of the merged file to stdout.  Do that in whatever way you see fit.\n"
"# Return an errorcode of 0 on successful merge, 1 if unresolved conflicts\n"
"# remain in the result.  Any other errorcode will be treated as fatal.\n"
msgstr ""
"\n"
"#!/bin/sh\n"
"\n"
"# Configure your favorite diff3/merge program here.\n"
"DIFF3=\"/usr/local/bin/my-merge-tool\"\n"
"\n"
"# Subversion provides the paths we need as the ninth, tenth, and eleventh \n"
"# parameters.\n"
"MINE=${9}\n"
"OLDER=${10}\n"
"YOURS=${11}\n"
"\n"
"# Call the merge command (change the following line to make sense for\n"
"# your merge program).\n"
"$DIFF3 --older $OLDER --mine $MINE --yours $YOURS\n"
"\n"
"# After performing the merge, this script needs to print the contents\n"
"# of the merged file to stdout.  Do that in whatever way you see fit.\n"
"# Return an errorcode of 0 on successful merge, 1 if unresolved conflicts\n"
"# remain in the result.  Any other errorcode will be treated as fatal.\n"

#: build/en/book.xml:16330(title)
msgid "diff3wrap.bat"
msgstr "diff3wrap.bat"

#: build/en/book.xml:16331(programlisting)
#, no-wrap
msgid ""
"\n"
"@ECHO OFF\n"
"\n"
"REM Configure your favorite diff3/merge program here.\n"
"SET DIFF3=\"C:\\Program Files\\Funky Stuff\\My Merge Tool.exe\"\n"
"\n"
"REM Subversion provides the paths we need as the ninth, tenth, and eleventh \n"
"REM parameters.  But we only have access to nine parameters at a time, so we\n"
"REM shift our nine-parameter window twice to let us get to what we need.\n"
"SHIFT\n"
"SHIFT\n"
"SET MINE=%7\n"
"SET OLDER=%8\n"
"SET YOURS=%9\n"
"\n"
"REM Call the merge command (change the following line to make sense for\n"
"REM your merge program).\n"
"%DIFF3% --older %OLDER% --mine %MINE% --yours %YOURS%\n"
"\n"
"REM After performing the merge, this script needs to print the contents\n"
"REM of the merged file to stdout.  Do that in whatever way you see fit.\n"
"REM Return an errorcode of 0 on successful merge, 1 if unresolved conflicts\n"
"REM remain in the result.  Any other errorcode will be treated as fatal.\n"
msgstr ""
"\n"
"@ECHO OFF\n"
"\n"
"REM Configure your favorite diff3/merge program here.\n"
"SET DIFF3=\"C:\\Program Files\\Funky Stuff\\My Merge Tool.exe\"\n"
"\n"
"REM Subversion provides the paths we need as the ninth, tenth, and eleventh \n"
"REM parameters.  But we only have access to nine parameters at a time, so we\n"
"REM shift our nine-parameter window twice to let us get to what we need.\n"
"SHIFT\n"
"SHIFT\n"
"SET MINE=%7\n"
"SET OLDER=%8\n"
"SET YOURS=%9\n"
"\n"
"REM Call the merge command (change the following line to make sense for\n"
"REM your merge program).\n"
"%DIFF3% --older %OLDER% --mine %MINE% --yours %YOURS%\n"
"\n"
"REM After performing the merge, this script needs to print the contents\n"
"REM of the merged file to stdout.  Do that in whatever way you see fit.\n"
"REM Return an errorcode of 0 on successful merge, 1 if unresolved conflicts\n"
"REM remain in the result.  Any other errorcode will be treated as fatal.\n"

#: build/en/book.xml:1635(para)
#, fuzzy
msgid "For more information on how Subversion parses URLs, see <xref linkend=\"svn.advanced.reposurls\"/>. For more information on the different types of network servers available for Subversion, see <xref linkend=\"svn.serverconfig\"/>."
msgstr "关于Subversion解析URL的更多信息，见<xref linkend=\"svn.advanced.reposurls\"/>。"

#: build/en/book.xml:16369(title)
#, fuzzy
msgid "Embedding Subversion"
msgstr "安装Subversion"

#: build/en/book.xml:16371(para)
msgid "Subversion has a modular design, written in C and implemented as a collection of libraries. Each library has a well-defined purpose and Application Programming Interface (API), and that interface is available not only for Subversion itself to use, but for any software that wishes to embed or otherwise programmatically control Subversion. Additionally, Subversion's API is available not only to other C programs, but also to programs written in higher-level languages such as Python, Perl, Java, or Ruby."
msgstr ""

#: build/en/book.xml:16381(para)
#, fuzzy
msgid "This chapter is for those who wish to interact with Subversion through its public API or its various language bindings. If you wish to write robust wrapper scripts around Subversion functionality to simplify your own life, are trying to develop more complex integrations between Subversion and other pieces of software, or just have an interest in Subversion's various library modules and what they offer, this chapter is for you. If, however, you don't foresee yourself participating with Subversion at such a level, feel free to skip this chapter with the confidence that your experience as a Subversion user will not be affected."
msgstr "本章是为那些希望实际参与源代码编写来帮助Subversion不断进步的人们准备的。我们要知道，在这里我们会涉及到许多软件内在的细节，在开发Subversion本身—或利用Subversion库开发全新工具时—所用到的许多核心技术。如果你无法预测你是否会以这种层级参与到这个软件中来，那么也可以随意跳过这一章，而你作为一个Subversion用户的体验不会受到任何影响。"

#: build/en/book.xml:16397(title)
msgid "Layered Library Design"
msgstr "分层的库设计"

#: build/en/book.xml:16399(para)
#, fuzzy
msgid "Each of Subversion's core libraries can be said to exist in one of three main layers—the Repository Layer, the Repository Access (RA) Layer, or the Client Layer. We will examine these layers shortly, but first, let's briefly summarize Subversion's various libraries. For the sake of consistency, we will refer to the libraries by their extensionless Unix library names (libsvn_fs, libsvn_wc, mod_dav_svn, etc.)."
msgstr "Subversion有一个模块化的设计，通过一套C库来实现。每一个库都有一套定义良好的目标与接口，据称，大部分模块都属于三层中的某一层—版本库层、版本库访问（RA）层或是客户端层。我们很快就会考察这些层，但首先让我们看一下<xref linkend=\"svn.developer.layerlib.tbl-1\"/>中的有关于Subversion库的摘要目录，为了一致性，我们将通过它们的无扩展Unix库名（例如libsvn_fs、libsvn_wc和mod_dav_svn）来引用它们。"

#: build/en/book.xml:16409(term)
msgid "libsvn_client"
msgstr "libsvn_client"

#: build/en/book.xml:16410(para)
msgid "Primary interface for client programs"
msgstr "客户端程序的主要接口"

#: build/en/book.xml:16414(term)
msgid "libsvn_delta"
msgstr "libsvn_delta"

#: build/en/book.xml:16415(para)
msgid "Tree and byte-stream differencing routines"
msgstr "目录树和文本区别程序"

#: build/en/book.xml:16419(term)
msgid "libsvn_diff"
msgstr "libsvn_diff"

#: build/en/book.xml:16420(para)
msgid "Contextual differencing and merging routines"
msgstr "上下文区别和合并例程"

#: build/en/book.xml:16424(term)
msgid "libsvn_fs"
msgstr "libsvn_fs"

#: build/en/book.xml:16425(para)
msgid "Filesystem commons and module loader"
msgstr "Subversion文件系统库和模块加载器"

#: build/en/book.xml:16429(term)
msgid "libsvn_fs_base"
msgstr "libsvn_fs_base"

#: build/en/book.xml:1643(para)
msgid "Suppose you make changes to <filename moreinfo=\"none\">button.c</filename>. Since the <filename moreinfo=\"none\">.svn</filename> directory remembers the file's modification date and original contents, Subversion can tell that you've changed the file. However, Subversion does not make your changes public until you explicitly tell it to. The act of publishing your changes is more commonly known as <firstterm>committing</firstterm> (or <firstterm>checking in</firstterm>) changes to the repository."
msgstr "假定你修改了<filename moreinfo=\"none\">button.c</filename>，因为<filename moreinfo=\"none\">.svn</filename>目录记录着文件的修改日期和原始内容，Subversion可以告诉你已经修改了文件，然而，在你明确告诉它之前，Subversion不会将你的改变公开。将改变公开的操作被叫做提交（<firstterm>committing</firstterm>，或者是<firstterm>checking in</firstterm>）修改到版本库。"

#: build/en/book.xml:16430(para)
msgid "The Berkeley DB filesystem back-end"
msgstr "Berkeley DB文件系统后端"

#: build/en/book.xml:16434(term)
msgid "libsvn_fs_fs"
msgstr "libsvn_fs_fs"

#: build/en/book.xml:16435(para)
msgid "The native filesystem (FSFS) back-end"
msgstr "本地文件系统（FSFS）后端"

#: build/en/book.xml:16439(term)
msgid "libsvn_ra"
msgstr "libsvn_ra"

#: build/en/book.xml:16440(para)
msgid "Repository Access commons and module loader"
msgstr "版本库访问通用组件和模块装载器"

#: build/en/book.xml:16444(term)
msgid "libsvn_ra_dav"
msgstr "libsvn_ra_dav"

#: build/en/book.xml:16445(para)
msgid "The WebDAV Repository Access module"
msgstr "WebDAV版本库访问模块"

#: build/en/book.xml:16449(term)
msgid "libsvn_ra_local"
msgstr "libsvn_ra_local"

#: build/en/book.xml:16450(para)
msgid "The local Repository Access module"
msgstr "本地版本库访问模块"

#: build/en/book.xml:16454(term)
msgid "libsvn_ra_serf"
msgstr "libsvn_ra_serf"

#: build/en/book.xml:16455(para)
#, fuzzy
msgid "Another (experimental) WebDAV Repository Access module"
msgstr "WebDAV版本库访问模块"

#: build/en/book.xml:16459(term)
msgid "libsvn_ra_svn"
msgstr "libsvn_ra_svn"

#: build/en/book.xml:16460(para)
msgid "The custom protocol Repository Access module"
msgstr "一个自定义版本库访问模块"

#: build/en/book.xml:16464(term)
msgid "libsvn_repos"
msgstr "libsvn_repos"

#: build/en/book.xml:16465(para)
msgid "Repository interface"
msgstr "版本库接口"

#: build/en/book.xml:16468(term)
msgid "libsvn_subr"
msgstr "libsvn_subr"

#: build/en/book.xml:16469(para)
msgid "Miscellaneous helpful subroutines"
msgstr "各色各样的有用的子程序"

#: build/en/book.xml:16473(term)
msgid "libsvn_wc"
msgstr "libsvn_wc"

#: build/en/book.xml:16474(para)
msgid "The working copy management library"
msgstr "工作拷贝管理库"

#: build/en/book.xml:16478(term)
msgid "mod_authz_svn"
msgstr "mod_authz_svn"

#: build/en/book.xml:16479(para)
msgid "Apache authorization module for Subversion repositories access via WebDAV"
msgstr "使用WebDAV访问Subversion版本库的Apache授权模块"

#: build/en/book.xml:16484(para)
msgid "Apache module for mapping WebDAV operations to Subversion ones"
msgstr "影射WebDAV操作为Subversion操作的Apache模块"

#: build/en/book.xml:16489(para)
#, fuzzy
msgid "The fact that the word <quote>miscellaneous</quote> only appears once in the previous list is a good sign. The Subversion development team is serious about making sure that functionality lives in the right layer and libraries. Perhaps the greatest advantage of the modular design is its lack of complexity from a developer's point of view. As a developer, you can quickly formulate that kind of <quote>big picture</quote> that allows you to pinpoint the location of certain pieces of functionality with relative ease."
msgstr "单词<quote>各色各样的</quote>只在列表<xref linkend=\"svn.developer.layerlib.tbl-1\"/>中出现过一次是一个好的迹象。Subversion开发团队非常注意将功能归入合适的层和库，或许模块化设计最大的好处就是从开发者的角度看减少了复杂性。作为一个开发者，你可以很快就描画出一副<quote>大图像</quote>，以便于你更精确地，也相对容易地找出某一功能所在的位置。"

#: build/en/book.xml:16499(para)
#, fuzzy
msgid "Another benefit of modularity is the ability to replace a given module with a whole new library that implements the same API without affecting the rest of the code base. In some sense, this happens within Subversion already. The libsvn_ra_dav, libsvn_ra_local, libsvn_ra_serf, and libsvn_ra_svn libraries each implement the same interface, all working as plugins to libsvn_ra. And all four communicate with the Repository Layer—libsvn_ra_local connects to the repository directly; the other three do so over a network. The libsvn_fs_base and libsvn_fs_fs libraries are another pair of libraries that implement the same functionality in different ways—both are plugins to the common libsvn_fs library."
msgstr "模块化的另一个好处是我们有能力去构造一个全新的，能够完全实现相同API功能的库，以替换整个给定的模块，而又不会影响基础代码。在某种意义上，Subversion已经这样做了。libsvn_ra_dav、libsvn_ra_local和libsvn_ra_svn all都实现了相同的接口，三者均与版本库层进行通讯—libsvn_ra_dav和libsvn_ra_svn通过网络，而libsvn_ra_local则是直接连接，libsvn_fs_base和libsvn_fs_fs是另外两个例子。"

#: build/en/book.xml:16512(para)
msgid "The client itself also highlights the benefits of modularity in the Subversion design. Subversion's libsvn_client library is a one-stop shop for most of the functionality necessary for designing a working Subversion client (see <xref linkend=\"svn.developer.layerlib.client\"/>). So while the Subversion distribution provides only the <command moreinfo=\"none\">svn</command> command-line client program, there are several third-party programs which provide various forms of graphical client UI. These GUIs use the same APIs that the stock command-line client does. This type of modularity has played a large role in the proliferation of available Subversion clients and IDE integrations and, by extension, to the tremendous adoption rate of Subversion itself."
msgstr ""

#: build/en/book.xml:1652(para)
#, fuzzy
msgid "To publish your changes to others, you can use Subversion's <command moreinfo=\"none\">commit</command> command."
msgstr "发布你的修改给别人，你可以使用Subversion的提交（<command moreinfo=\"none\">commit</command>）命令："

#: build/en/book.xml:16527(title)
msgid "Repository Layer"
msgstr "版本库层"

#: build/en/book.xml:16529(para)
#, fuzzy
msgid "When referring to Subversion's Repository Layer, we're generally talking about two basic concepts—the versioned filesystem implementation (accessed via libsvn_fs, and supported by its libsvn_fs_base and libsvn_fs_fs plugins), and the repository logic that wraps it (as implemented in libsvn_repos). These libraries provide the storage and reporting mechanisms for the various revisions of your version-controlled data. This layer is connected to the Client Layer via the Repository Access Layer, and is, from the perspective of the Subversion user, the stuff at the <quote>other end of the line.</quote>"
msgstr "当提到Subversion版本库层时，我们通常会讨论两个库—版本库（函数）库和文件系统（函数）库。这两个库为你的版本控制数据的各个修订版本提供了存储和报告机制，该层通过版本库访问层连接到客户层，而且，从Subversion用户的角度看，这是资料存储过程中的<quote>链接的另一端</quote>。"

#: build/en/book.xml:16541(para)
#, fuzzy
msgid "The Subversion Filesystem is not a kernel-level filesystem that one would install in an operating system (like the Linux ext2 or NTFS), but a virtual filesystem. Rather than storing <quote>files</quote> and <quote>directories</quote> as real files and directories (as in, the kind you can navigate through using your favorite shell program), it uses one of two available abstract storage backends—either a Berkeley DB database environment, or a flat-file representation. (To learn more about the two repository back-ends, see <xref linkend=\"svn.reposadmin.basics.backends\"/>.) There has even been considerable interest by the development community in giving future releases of Subversion the ability to use other back-end database systems, perhaps through a mechanism such as Open Database Connectivity (ODBC). In fact, Google did something similar to this before launching the Google Code Project Hosting service, announcing in mid-2006 that members of its Open Source team had written a new proprietary Subversion filesystem plugin which used their ultra-scalable Bigtable database for its storage."
msgstr "Subversion文件系统通过libsvn_fs API来访问，它并不是一个安装在操作系统之上的内核级的文件系统（例如Linux ext2或NTFS），而是一个虚拟文件系统。它并未将<quote>文件</quote>和<quote>目录</quote>保存为真实的文件和目录（也就是用你熟知的shell程序可以浏览的那种），而是采用了一种抽象的后端存储方式，这个后端存储方式有两种—一个是Berkeley DB数据库环境，另一个是普通文件表示。（要了解更多关于版本库后端的信息，请看<xref linkend=\"svn.reposadmin.basics.backends\"/>）。除此之外，开发社区也非常有兴趣考虑在Subversion的未来版本 中提供某种使用其它后端数据库系统的能力，也许是开放式数据库连接（ODBC）的机制。"

#: build/en/book.xml:1655(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit button.c -m \"Fixed a typo in button.c.\"\n"
"Sending        button.c\n"
"Transmitting file data .\n"
"Committed revision 57.\n"
msgstr ""
"\n"
"$ svn commit button.c -m \"Fixed a typo in button.c.\"\n"
"Sending        button.c\n"
"Transmitting file data .\n"
"Committed revision 57.\n"

#: build/en/book.xml:16560(para)
#, fuzzy
msgid "The filesystem API exported by libsvn_fs contains the kinds of functionality you would expect from any other filesystem API—you can create and remove files and directories, copy and move them around, modify file contents, and so on. It also has features that are not quite as common, such as the ability to add, modify, and remove metadata (<quote>properties</quote>) on each file or directory. Furthermore, the Subversion Filesystem is a versioning filesystem, which means that as you make changes to your directory tree, Subversion remembers what your tree looked like before those changes. And before the previous changes. And the previous ones. And so on, all the way back through versioning time to (and just beyond) the moment you first started adding things to the filesystem."
msgstr "libsvn_fs支持的文件系统API包含了所有其他文件系统的功能：你可以创建和删除文件和目录、拷贝和移动、修改文件内容等等。它也包含了一些不太常用的特性，如对任意文件和目录添加、修改和删除元数据（<quote>properties</quote>）的能力。此外，Subversion文件系统是一个版本化的文件系统，意味着你修改你的目录树时，Subversion会记住修改以前的样子。等等，可以回到所有初始化版本库之后（且仅仅之后）的版本。"

#: build/en/book.xml:16575(para)
#, fuzzy
msgid "All the modifications you make to your tree are done within the context of a Subversion commit transaction. The following is a simplified general routine for modifying your filesystem:"
msgstr "所有你对目录树的修改包含在Subversion事务的上下文中，下面描述了修改文件系统的例程："

#: build/en/book.xml:16582(para)
#, fuzzy
msgid "Begin a Subversion commit transaction."
msgstr "开始Subversion事务。"

#: build/en/book.xml:16585(para)
msgid "Make your changes (adds, deletes, property modifications, etc.)."
msgstr "作出修改（添加、删除、属性修改等等。）。"

#: build/en/book.xml:16589(para)
msgid "Commit your transaction."
msgstr "提交事务。"

#: build/en/book.xml:16593(para)
msgid "Once you have committed your transaction, your filesystem modifications are permanently stored as historical artifacts. Each of these cycles generates a single new revision of your tree, and each revision is forever accessible as an immutable snapshot of <quote>the way things were.</quote>"
msgstr "一旦你提交了你的事务，你的文件系统修改就会永久的作为历史保存起来，每个这样的周期会产生一个新的树，所有的修订版本都是永远可以访问的一个不变的快照。"

#: build/en/book.xml:16600(title)
msgid "The Transaction Distraction"
msgstr "事务其它"

#: build/en/book.xml:16602(para)
#, fuzzy
msgid "The notion of a Subversion transaction can become easily confused with the transaction support provided by the underlying database itself, especially given the former's close proximity to the Berkeley DB database code in libsvn_fs_base. Both types of transaction exist to provide atomicity and isolation. In other words, transactions give you the ability to perform a set of actions in an all-or-nothing fashion—either all the actions in the set complete with success, or they all get treated as if <emphasis>none</emphasis> of them ever happened—and in a way that does not interfere with other processes acting on the data."
msgstr "Subversion的事务概念，特别是在libsvn_fs中的数据库附近的代码，很容易与低层提供支持的数据库事务混淆。两种类型事务都提供了原子和隔离操作，换句话说，事务给你能力可以用<quote>全部或者没有</quote>样式执行一系列的动作—所有的动作都完全成功，或者是所有的<emphasis>没有</emphasis>发生—而且不会干扰别人操作数据。"

#: build/en/book.xml:16615(para)
#, fuzzy
msgid "Database transactions generally encompass small operations related specifically to the modification of data in the database itself (such as changing the contents of a table row). Subversion transactions are larger in scope, encompassing higher-level operations like making modifications to a set of files and directories which are intended to be stored as the next revision of the filesystem tree. If that isn't confusing enough, consider the fact that Subversion uses a database transaction during the creation of a Subversion transaction (so that if the creation of Subversion transaction fails, the database will look as if we had never attempted that creation in the first place)!"
msgstr "数据库事务通常围绕着一些对数据库本身的数据修改相关的小操作（如修改表行的内容），Subversion是更大范围的事务，围绕着一些高一级的操作，如下一个修订版本文件系统的一组文件和目录的修改。如果这还不是很混乱，考虑这个：Subversion在创建Subversion事务（所以如果Subversion创建事务失败，数据库会看起来我们从来没有尝试创建）时会使用一个数据库事务！"

#: build/en/book.xml:1662(para)
#, fuzzy
msgid "Now your changes to <filename moreinfo=\"none\">button.c</filename> have been committed to the repository, with a note describing your change (namely, that you fixed a typo). If another user checks out a working copy of <filename moreinfo=\"none\">/calc</filename>, they will see your changes in the latest version of the file."
msgstr "这时你对<filename moreinfo=\"none\">button.c</filename>的修改已经提交到了版本库，如果其他人取出了<filename moreinfo=\"none\">/calc</filename>的一个工作拷贝，他们会看到这个文件最新的版本。"

#: build/en/book.xml:16629(para)
msgid "Fortunately for users of the filesystem API, the transaction support provided by the database system itself is hidden almost entirely from view (as should be expected from a properly modularized library scheme). It is only when you start digging into the implementation of the filesystem itself that such things become visible (or interesting)."
msgstr "很幸运的是用户的文件系统API，数据库提供的事务支持本身几乎完全从外表隐藏（也是一个完全模块化的模式所应该的）。只有当你开始研究文件系统本身的实现时，这些事情才可见（或者是开始感兴趣）。"

#: build/en/book.xml:16639(para)
#, fuzzy
msgid "Most of the functionality provided by the filesystem interface is the result of an action that occurs on a filesystem path. That is, from outside of the filesystem, the primary mechanism for describing and accessing the individual revisions of files and directories comes through the use of path strings like <filename moreinfo=\"none\">/foo/bar</filename>, just as if you were addressing files and directories through your favorite shell program. You add new files and directories by passing their paths-to-be to the right API functions. You query for information about them by the same mechanism."
msgstr "大多数文件系统接口提供的功能作为一个动作发生在一个文件系统路径上，也就是，从文件系统的外部，描述和访问文件和目录独立版本的主要机制是经过如<filename moreinfo=\"none\">/foo/bar</filename>的路径，就像你在喜欢的shell程序中定位文件和目录。你通过传递它们的路径到相应的API功能来添加新的文件和目录，查询这些信息也是同样的机制。"

#: build/en/book.xml:16650(para)
msgid "Unlike most filesystems, though, a path alone is not enough information to identify a file or directory in Subversion. Think of a directory tree as a two-dimensional system, where a node's siblings represent a sort of left-and-right motion, and descending into subdirectories a downward motion. <xref linkend=\"svn.developer.layerlib.repos.dia-1\"/> shows a typical representation of a tree as exactly that."
msgstr "然而，不像大多数文件系统，一个单独的路径不足以在Subversion定位一个文件或目录，可以把目录树看作一个二维的系统，一个节点的兄弟代表了一种从左到右的动作，并且递减到子目录是一个向下的动作，<xref linkend=\"svn.developer.layerlib.repos.dia-1\"/>展示了一个典型的树的形式。"

#: build/en/book.xml:16659(title)
msgid "Files and directories in two dimensions"
msgstr "二维的文件目录"

#: build/en/book.xml:16663(para)
#, fuzzy
msgid "The different here is that the Subversion filesystem has a nifty third dimension that most filesystems do not have—Time! <placeholder-1/> In the filesystem interface, nearly every function that has a <parameter moreinfo=\"none\">path</parameter> argument also expects a <parameter moreinfo=\"none\">root</parameter> argument. This <structname>svn_fs_root_t</structname> argument describes either a revision or a Subversion transaction (which is simply a revision-in-the-making), and provides that third-dimensional context needed to understand the difference between <filename moreinfo=\"none\">/foo/bar</filename> in revision 32, and the same path as it exists in revision 98. <xref linkend=\"svn.developer.layerlib.repos.dia-2\"/> shows revision history as an added dimension to the Subversion filesystem universe."
msgstr "当然，Subversion文件系统有一个其它文件系统所没有的第三维—时间！ <footnote><placeholder-1/></footnote> 在一个文件系统接口，几乎所有的功能都有个<parameter moreinfo=\"none\">路径</parameter>参数，也期望一个<parameter moreinfo=\"none\">root</parameter>参数。<structname>svn_fs_root_t</structname>参数不仅描述了一个修订版本或一个Subversion事务（通常正好是一个修订版本），而且提供了用来区分修订版本32的<filename moreinfo=\"none\">/foo/bar</filename>和修订版本98在同样路径的三维上下文环境。<xref linkend=\"svn.developer.layerlib.repos.dia-2\"/>展示了修订版本历史作为添加的纬度进入到Subversion文件系统领域。"

#: build/en/book.xml:16667(para)
msgid "We understand that this may come as a shock to sci-fi fans who have long been under the impression that Time was actually the <emphasis>fourth</emphasis> dimension, and we apologize for any emotional trauma induced by our assertion of a different theory."
msgstr "我们理解这一定会给科幻小说迷带来一个震撼，他们认为时间是<emphasis>第四</emphasis>维的，我们要为提出这样一个不同理论的断言而伤害了他们的作出道歉。"

#: build/en/book.xml:16686(title)
msgid "Versioning time—the third dimension!"
msgstr "版本时间—第三维！"

#: build/en/book.xml:1669(para)
msgid "Suppose you have a collaborator, Sally, who checked out a working copy of <filename moreinfo=\"none\">/calc</filename> at the same time you did. When you commit your change to <filename moreinfo=\"none\">button.c</filename>, Sally's working copy is left unchanged; Subversion only modifies working copies at the user's request."
msgstr "假设你有个合作者，Sally，她和你同时取出了<filename moreinfo=\"none\">/calc</filename>的一个工作拷贝，你提交了你对<filename moreinfo=\"none\">button.c</filename>的修改，Sally的工作拷贝并没有改变，Subversion只在用户要求的时候才改变工作拷贝。"

#: build/en/book.xml:16690(para)
msgid "As we mentioned earlier, the libsvn_fs API looks and feels like any other filesystem, except that it has this wonderful versioning capability. It was designed to be usable by any program interested in a versioning filesystem. Not coincidentally, Subversion itself is interested in that functionality. But while the filesystem API should be sufficient for basic file and directory versioning support, Subversion wants more—and that is where libsvn_repos comes in."
msgstr "像之前我们提到的，libsvn_fs的API感觉像是其它文件系统，只是有一个美妙的版本化能力。它设计为为所有对版本化的文件系统有兴趣的程序使用，不是巧合，Subversion本身也对这个功能很有兴趣。但是虽然文件系统API一定必须对基本的文件和目录版本化提供足够的支持，Subversion需要的更多—这是libsvn_repos到来的地方。"

#: build/en/book.xml:16700(para)
#, fuzzy
msgid "The Subversion repository library (libsvn_repos) sits (logically speaking) atop the libsvn_fs API, providing additional functionality beyond that of the underlying versioned filesystem logic. It does not completely wrap each and every filesystem function—only certain major steps in the general cycle of filesystem activity are wrapped by the repository interface. Some of these include the creation and commit of Subversion transactions, and the modification of revision properties. These particular events are wrapped by the repository layer because they have hooks associated with them. A repository hook system is not strictly related to implementing a versioning filesystem, so it lives in the repository wrapper library."
msgstr "希望使用libsvn_repos的API的开发者会发现它不是文件系统的一个完全包裹，只有文件系统常规周期中的主要事件使用版本库接口包裹，如包括Subversion事务的创建和提交，修订版本属性的修改。这些特别的事件使用版本库库包裹是因为它们有一些关联的钩子，在将来，别的事件也将会使用版本库API包裹。所有其它的文件系统交互会直接通过libsvn_fs的API发生。"

#: build/en/book.xml:16714(para)
#, fuzzy
msgid "The hooks mechanism is but one of the reasons for the abstraction of a separate repository library from the rest of the filesystem code. The libsvn_repos API provides several other important utilities to Subversion. These include the abilities to:"
msgstr "钩子机制需求是从文件系统代码的其它部分中抽象出单独的版本库库的一个原因，libsvn_repos的API提供了许多其他有用的工具，它们可以做到："

#: build/en/book.xml:16722(para)
msgid "create, open, destroy, and perform recovery steps on a Subversion repository and the filesystem included in that repository."
msgstr "在Subversion版本库和版本库包括的文件系统的上创建、打开、销毁和执行恢复步骤。"

#: build/en/book.xml:16727(para)
msgid "describe the differences between two filesystem trees."
msgstr "描述两个文件系统树的区别。"

#: build/en/book.xml:16731(para)
msgid "query for the commit log messages associated with all (or some) of the revisions in which a set of files was modified in the filesystem."
msgstr "关于所有（或者部分）修订版本中的文件系统中的一组文件的提交日志信息的查询"

#: build/en/book.xml:16736(para)
msgid "generate a human-readable <quote>dump</quote> of the filesystem, a complete representation of the revisions in the filesystem."
msgstr "产生可读的文件系统<quote>导出</quote>，一个文件系统修订版本的完整展现。"

#: build/en/book.xml:16741(para)
msgid "parse that dump format, loading the dumped revisions into a different Subversion repository."
msgstr "解析导出格式，加载导出的版本到一个不同的Subversion版本库。"

#: build/en/book.xml:16746(para)
msgid "As Subversion continues to evolve, the repository library will grow with the filesystem library to offer increased functionality and configurable option support."
msgstr "伴随着Subversion的发展，版本库库会随着文件系统提供更多的功能和配置选项而不断成长。"

#: build/en/book.xml:16754(title)
msgid "Repository Access Layer"
msgstr "版本库访问层"

#: build/en/book.xml:16756(para)
#, fuzzy
msgid "If the Subversion Repository Layer is at <quote>the other end of the line</quote>, the Repository Access (RA) Layer is the line itself. Charged with marshaling data between the client libraries and the repository, this layer includes the libsvn_ra module loader library, the RA modules themselves (which currently includes libsvn_ra_dav, libsvn_ra_local, libsvn_ra_serf, and libsvn_ra_svn), and any additional libraries needed by one or more of those RA modules, such as the mod_dav_svn Apache module with which libsvn_ra_dav communicates or libsvn_ra_svn's server, <command moreinfo=\"none\">svnserve</command>."
msgstr "如果说Subversion版本库层是在<quote>这条线的另一端</quote>，那版本库访问层就是这条线。负责在客户端库和版本库之间编码数据，这一层包括libsvn_ra模块加载模块，RA模块本身（现在包括了libsvn_ra_dav、libsvn_ra_local和libsvn_ra_svn），和所有一个或多个RA模块需要的附加库，例如与Apache模块mod_dav_svn通讯的libsvn_ra_dav或者是libsvn_ra_svn的服务器，<command moreinfo=\"none\">svnserve</command>。"

#: build/en/book.xml:1676(para)
msgid "To bring her project up to date, Sally can ask Subversion to <firstterm>update</firstterm> her working copy, by using the Subversion <command moreinfo=\"none\">update</command> command. This will incorporate your changes into her working copy, as well as any others that have been committed since she checked it out."
msgstr "要使项目最新，Sally可以要求Subversion<firstterm>更新</firstterm>她的工作备份，通过使用更新（<command moreinfo=\"none\">update</command>）命令，将结合你和所有其他人在她上次更新之后的改变到她的工作拷贝。"

#: build/en/book.xml:16768(para)
#, fuzzy
msgid "Since Subversion uses URLs to identify its repository resources, the protocol portion of the URL schema (usually <literal moreinfo=\"none\">file://</literal>, <literal moreinfo=\"none\">http://</literal>, <literal moreinfo=\"none\">https://</literal>, or <literal moreinfo=\"none\">svn://</literal>) is used to determine which RA module will handle the communications. Each module registers a list of the protocols it knows how to <quote>speak</quote> so that the RA loader can, at runtime, determine which module to use for the task at hand. You can determine which RA modules are available to the Subversion command-line client, and what protocols they claim to support, by running <command moreinfo=\"none\">svn --version</command>:"
msgstr "因为Subversion使用URL来识别版本库资源，URL模式的协议部分（通常是<literal moreinfo=\"none\">file:</literal>、<literal moreinfo=\"none\">http:</literal>、<literal moreinfo=\"none\">https:</literal>或<literal moreinfo=\"none\">svn:</literal>）用来监测那个RA模块用来处理通讯。每个模块注册一组它们知道如何<quote>说话</quote>的协议，所以RA加载器可以在运行中监测在手边的任务中使用哪个模块。通过运行<command moreinfo=\"none\">svn --version</command>，你可以监测Subversion命令行客户端所支持的RA模块和它们声明支持的协议："

#: build/en/book.xml:16780(screen)
#, no-wrap
msgid ""
"\n"
"$ svn --version\n"
"svn, version 1.4.3 (r23084)\n"
"   compiled Jan 18 2007, 07:47:40\n"
"\n"
"Copyright (C) 2000-2006 CollabNet.\n"
"Subversion is open source software, see http://subversion.tigris.org/\n"
"This product includes software developed by CollabNet (http://www.Collab.Net/).\n"
"\n"
"The following repository access (RA) modules are available:\n"
"\n"
"* ra_dav : Module for accessing a repository via WebDAV (DeltaV) protocol.\n"
"  - handles 'http' scheme\n"
"  - handles 'https' scheme\n"
"* ra_svn : Module for accessing a repository using the svn network protocol.\n"
"  - handles 'svn' scheme\n"
"* ra_local : Module for accessing a repository on local disk.\n"
"  - handles 'file' scheme\n"
"\n"
"$\n"
msgstr ""
"\n"
"$ svn --version\n"
"svn, version 1.4.3 (r23084)\n"
"   compiled Jan 18 2007, 07:47:40\n"
"\n"
"Copyright (C) 2000-2006 CollabNet.\n"
"Subversion is open source software, see http://subversion.tigris.org/\n"
"This product includes software developed by CollabNet (http://www.Collab.Net/).\n"
"\n"
"The following repository access (RA) modules are available:\n"
"\n"
"* ra_dav : Module for accessing a repository via WebDAV (DeltaV) protocol.\n"
"  - handles 'http' scheme\n"
"  - handles 'https' scheme\n"
"* ra_svn : Module for accessing a repository using the svn network protocol.\n"
"  - handles 'svn' scheme\n"
"* ra_local : Module for accessing a repository on local disk.\n"
"  - handles 'file' scheme\n"
"\n"
"$\n"

#: build/en/book.xml:16802(para)
msgid "The public API exported by the RA Layer contains functionality necessary for sending and recieving versioned data to and from the repository. And each of the available RA plugins is able to perform that task using a specific protocol—libsvn_ra_dav speaks HTTP/WebDAV (optionally using SSL encryption) with an Apache HTTP Server that is running the mod_dav_svn Subversion server module; libsvn_ra_svn speaks a custom network protocol with the <command moreinfo=\"none\">svnserve</command> program; and so on."
msgstr ""

#: build/en/book.xml:16812(para)
#, fuzzy
msgid "And for those who wish to access a Subversion repository using still another protocol, that is precisely why the Repository Access Layer is modularized! Developers can simply write a new library that implements the RA interface on one side and communicates with the repository on the other. Your new library can use existing network protocols, or you can invent your own. You could use inter-process communication (IPC) calls, or—let's get crazy, shall we?—you could even implement an email-based protocol. Subversion supplies the APIs; you supply the creativity."
msgstr "对那些一直希望使用另一个协议来访问Subversion版本库的人，正好是为什么版本库访问层是模块化的！开发者可以简单的编写一个新的库来在一侧实现RA接口并且与另一侧的版本库通讯。你的新库可以使用存在的网络协议，或者发明你自己的。你可以使用进程间的通讯调用，或者—让我们发狂，我们会吗？—你甚至可以实现一个电子邮件为基础的协议，Subversion提供了API，你提供创造性。"

#: build/en/book.xml:16827(title)
msgid "Client Layer"
msgstr "客户端层"

#: build/en/book.xml:16829(para)
msgid "On the client side, the Subversion working copy is where all the action takes place. The bulk of functionality implemented by the client-side libraries exists for the sole purpose of managing working copies—directories full of files and other subdirectories which serve as a sort of local, editable <quote>reflection</quote> of one or more repository locations—and propagating changes to and from the Repository Access layer."
msgstr "在客户端这一面，Subversion工作拷贝是所有动作发生的地方。大多数客户端库实现的功能是为了管理工作拷贝的目的实现的—满是文件子目录的目录是一个或多个版本库位置的可编辑的本地<quote>影射</quote>—从版本库访问层来回传递修改。"

#: build/en/book.xml:1683(screen)
#, no-wrap
msgid ""
"\n"
"$ pwd\n"
"/home/sally/calc\n"
"\n"
"$ ls -A \n"
".svn/ Makefile integer.c button.c\n"
"\n"
"$ svn update\n"
"U    button.c\n"
"Updated to revision 57.\n"
msgstr ""
"\n"
"$ pwd\n"
"/home/sally/calc\n"
"\n"
"$ ls -A \n"
".svn/ Makefile integer.c button.c\n"
"\n"
"$ svn update\n"
"U    button.c\n"
"Updated to revision 57.\n"

#: build/en/book.xml:16838(para)
msgid "Subversion's working copy library, libsvn_wc, is directly responsible for managing the data in the working copies. To accomplish this, the library stores administrative information about each working copy directory within a special subdirectory. This subdirectory, named <filename moreinfo=\"none\">.svn</filename>, is present in each working copy directory and contains various other files and directories which record state and provide a private workspace for administrative action. For those familiar with CVS, this <filename moreinfo=\"none\">.svn</filename> subdirectory is similar in purpose to the <filename moreinfo=\"none\">CVS</filename> administrative directories found in CVS working copies. For more information about the <filename moreinfo=\"none\">.svn</filename> administrative area, see <xref linkend=\"svn.developer.insidewc\"/>in this chapter."
msgstr "Subversion的工作拷贝库，libsvn_wc直接负责管理工作拷贝的数据，为了完成这一点，库会在工作拷贝的每个目录的特殊子目录中保存关于工作拷贝的管理性信息。这个子目录叫做<filename moreinfo=\"none\">.svn</filename>，出现在所有工作拷贝目录里，保存了各种记录了状态和用来在私有工作区工作的文件和目录。对那些熟悉CVS的用户，<filename moreinfo=\"none\">.svn</filename>子目录与<filename moreinfo=\"none\">CVS</filename>工作拷贝管理目录的作用类似，关于<filename moreinfo=\"none\">.svn</filename>管理区域的更多信息，见本章的<xref linkend=\"svn.developer.insidewc\"/>。"

#: build/en/book.xml:16852(para)
msgid "The Subversion client library, libsvn_client, has the broadest responsibility; its job is to mingle the functionality of the working copy library with that of the Repository Access Layer, and then to provide the highest-level API to any application that wishes to perform general revision control actions. For example, the function <function moreinfo=\"none\">svn_client_checkout()</function> takes a URL as an argument. It passes this URL to the RA layer and opens an authenticated session with a particular repository. It then asks the repository for a certain tree, and sends this tree into the working copy library, which then writes a full working copy to disk (<filename moreinfo=\"none\">.svn</filename> directories and all)."
msgstr "Subversion客户端库libsvn_client具备最广泛的职责；它的工作是结合工作拷贝库和版本库访问库的功能，然后为希望普通版本控制的应用提供最高级的API。举个例子，<function moreinfo=\"none\">svn_client_checkout()</function>方法是用一个URL作为参数，传递这个URL到RA层然后在特定版本库打开一个会话。然后向版本库要求一个特定的目录树，然后把目录树发送给工作拷贝库，然后把完全的工作拷贝写到磁盘（<filename moreinfo=\"none\">.svn</filename>目录和一切）。"

#: build/en/book.xml:16866(para)
#, fuzzy
msgid "The client library is designed to be used by any application. While the Subversion source code includes a standard command-line client, it should be very easy to write any number of GUI clients on top of the client library. New GUIs (or any new client, really) for Subversion need not be clunky wrappers around the included command-line client—they have full access via the libsvn_client API to same functionality, data, and callback mechanisms that the command-line client uses. In fact, the Subversion source code tree contains a small C program (which can be found at <filename moreinfo=\"none\">tools/examples/minimal_client.c</filename> that exemplifies how to wield the Subversion API to create a simple client program"
msgstr "客户端库是为任何程序使用设计的，尽管Subversion的源代码包括了一个标准的命令行客户端，用客户端库编写GUI客户端也是很简单，Subversion新的GUI（或者任何新的客户端，真的）不需要紧密围绕包含的命令行客户端—他们对具有相同功能、数据和回调机制的libsvn_client的API有完全的访问权利。"

#: build/en/book.xml:16881(title)
msgid "Binding Directly—A Word About Correctness"
msgstr "直接绑定—关于正确性"

#: build/en/book.xml:16883(para)
msgid "Why should your GUI program bind directly with a libsvn_client instead of acting as a wrapper around a command-line program? Besides simply being more efficient, this can address potential correctness issues as well. A command-line program (like the one supplied with Subversion) that binds to the client library needs to effectively translate feedback and requested data bits from C types to some form of human-readable output. This type of translation can be lossy. That is, the program may not display all of the information harvested from the API, or may combine bits of information for compact representation."
msgstr "为什么GUI程序要直接访问libsvn_client而不以命令行客户端的包裹运行？除了效率以外，这也关系到潜在的正确性问题。一个命令行客户端程序（如Subversion提供的）如果绑定了客户端库，需要将反馈和请求数据字节从C翻译为可读的输出，这种翻译是有损耗的，程序不能得到API所提供的所有信息，或者是得到紧凑的信息。"

#: build/en/book.xml:16895(para)
msgid "If you wrap such a command-line program with yet another program, the second program has access only to already-interpreted (and as we mentioned, likely incomplete) information, which it must <emphasis>again</emphasis> translate into <emphasis>its</emphasis> representation format. With each layer of wrapping, the integrity of the original data is potentially tainted more and more, much like the result of making a copy of a copy (of a copy …) of a favorite audio or video cassette."
msgstr "如果你已经包裹了这样一个命令行程序，第二个程序只能访问已经经过解释的（如我们提到的，不完全）信息，需要<emphasis>再次</emphasis>转化为<emphasis>它本身的</emphasis>展示格式。由于各层的包裹，原始数据的完整性越来越难以保证，结果很像对喜欢的录音带或录像带反复的拷贝（一个拷贝…）。"

#: build/en/book.xml:169(para)
msgid "Of course, no one can promise that this book will answer every question you have about Subversion. Sometimes, the precision with which it anticipates your questions will seem eerily telepathic; yet occasionally, you will stumble into a hole in the community's knowledge, and come away empty-handed. When this happens, the best thing you can do is email <email>users@subversion.tigris.org</email> and present your problem. The authors are still there, still watching, and they include not just the three listed on the cover, but many others who contributed corrections and original material. From the community's point of view, solving your problem is merely a pleasant side effect of a much larger project—namely, slowly adjusting this book, and ultimately Subversion itself, to more closely match the way people actually use it. They are eager to hear from you not merely because they can help you, but because you can help them. With Subversion as with all active free software projects, <emphasis>you are not alone</emphasis>."
msgstr "当然，没人可以承诺这本书可以回答所有问题。尽管有时候一些前人提问的惊人一致性让你感觉是心灵感应；你仍有可能在社区的知识库里摔跤，空手而归。如果有这种情况，最好的办法是写明问题发送email到<email>users@subversion.tigris.org</email>，作者还在那里关注着社区，不仅仅封面提到的三位，还包括许多曾经作出修正与提供原始材料的人。从社区的视角，帮你解决问题只是逐步的调整这本书，进一步调整Subversion本身以更合理的适合用户使用这样一个大工程的一个有趣的额外效用。他们渴望你的信息，不仅仅可以帮助你，也因为可以帮助他们。与Subversion这样活跃的自由软件项目一起，<emphasis>你并不孤单</emphasis>。"

#: build/en/book.xml:16905(para)
msgid "But the most compelling argument for binding directly to the APIs instead of wrapping other programs is that the Subversion project makes compatibility promises regarding its APIs. Across minor versions of those APIs (such as between 1.3 and 1.4), no function's prototype will change. In other words, you aren't forced to update your program's source code simply because you've upgraded to a new version of Subversion. Certain functions might be deprecated, but they still work, and this gives you a buffer of time to eventually embrace the newer APIs. These kinds of compatibility promises do not exist for Subversion command-line program output, which is subject to change from release to release."
msgstr ""

#: build/en/book.xml:16928(title)
msgid "Inside the Working Copy Administration Area"
msgstr "进入工作拷贝的管理区"

#: build/en/book.xml:16930(para)
msgid "As we mentioned earlier, each directory of a Subversion working copy contains a special subdirectory called <filename moreinfo=\"none\">.svn</filename> which houses administrative data about that working copy directory. Subversion uses the information in <filename moreinfo=\"none\">.svn</filename> to keep track of things like:"
msgstr "像我们前面提到的，每个Subversion工作拷贝包含了一个特别的子目录叫做<filename moreinfo=\"none\">.svn</filename>，这个目录包含了关于工作拷贝目录的管理数据，Subversion使用<filename moreinfo=\"none\">.svn</filename>中的信息来追踪如下的数据："

#: build/en/book.xml:16938(para)
msgid "Which repository location(s) are represented by the files and subdirectories in the working copy directory."
msgstr "工作拷贝中展示的目录和文件在版本库中的位置。"

#: build/en/book.xml:16943(para)
msgid "What revision of each of those files and directories are currently present in the working copy."
msgstr "工作拷贝中当前展示的文件和目录的修订版本。"

#: build/en/book.xml:16947(para)
msgid "Any user-defined properties that might be attached to those files and directories."
msgstr "所有附加在文件和目录上的用户定义属性。"

#: build/en/book.xml:1695(para)
msgid "The output from the <command moreinfo=\"none\">svn update</command> command indicates that Subversion updated the contents of <filename moreinfo=\"none\">button.c</filename>. Note that Sally didn't need to specify which files to update; Subversion uses the information in the <filename moreinfo=\"none\">.svn</filename> directory, and further information in the repository, to decide which files need to be brought up to date."
msgstr "<command moreinfo=\"none\">svn update</command>命令的输出表明Subversion更新了<filename moreinfo=\"none\">button.c</filename>的内容，注意，Sally不必指定要更新的文件，subversion利用<filename moreinfo=\"none\">.svn</filename>以及版本库的进一步信息决定哪些文件需要更新。"

#: build/en/book.xml:16951(para)
msgid "Pristine (un-edited) copies of the working copy files."
msgstr "初始（未编辑）的工作拷贝文件的拷贝。"

#: build/en/book.xml:16956(para)
msgid "The Subversion working copy administration area's layout and contents are considered implementation details not really intended for human consumption. Developers are encouraged to use Subversion's public APIs or provided tools to access and manipulate the working copy data, as opposed to directly reading or modifying the files of which the working copy administrative area is comprised. The file formats employed by the working copy library for its administrative data do change from time to time—a fact that the public APIs do a great job of successfully hiding from the average user. In this section, we expose some of these implementation details sheerly to appease your overwhelming curiousity."
msgstr ""

#: build/en/book.xml:16971(title)
msgid "The Entries File"
msgstr "条目文件"

#: build/en/book.xml:16973(para)
#, fuzzy
msgid "Perhaps the single most important file in the <filename moreinfo=\"none\">.svn</filename> directory is the <filename moreinfo=\"none\">entries</filename> file. The entries file is a single file which contains the bulk of the administrative information about a versioned item in a working copy directory. It is this one file which tracks the repository URLs, pristine revision, file checksums, pristine text and property timestamps, scheduling and conflict state information, last-known commit information (author, revision, timestamp), local copy history—practically everything that a Subversion client is interested in knowing about a versioned (or to-be-versioned) resource!"
msgstr "或许<filename moreinfo=\"none\">.svn</filename>目录中最重要的单个文件就是<filename moreinfo=\"none\">entries</filename>了，这个条目文件是一个XML文档，包含了关于工作拷贝中的版本化的资源的大多数管理性信息，这个文件保留了版本库URL、原始修订版本、可知的最后提交信息（作者、修订版本和时间戳）和本地拷贝历史—实际上是Subversion客户端关于一个版本化（或者是将要版本化的）资源的所有感兴趣的信息！"

#: build/en/book.xml:16986(para)
#, fuzzy
msgid "Folks familiar with CVS's administrative directories will have recognized at this point that Subversion's <filename moreinfo=\"none\">.svn/entries</filename> file serves the purposes of, among other things, CVS's <filename moreinfo=\"none\">CVS/Entries</filename>, <filename moreinfo=\"none\">CVS/Root</filename>, and <filename moreinfo=\"none\">CVS/Repository</filename> files combined."
msgstr "扫视一下典型的<filename moreinfo=\"none\">.svn</filename>目录会发现比CVS在<filename moreinfo=\"none\">CVS</filename>目录中的内容多一些，<filename moreinfo=\"none\">entries</filename>文件包含的XML描述了工作拷贝目录的当前状态，而且基本上合并了CVS的<filename moreinfo=\"none\">Entries</filename>、<filename moreinfo=\"none\">Root</filename>和<filename moreinfo=\"none\">Repository</filename>的功能。"

#: build/en/book.xml:16993(para)
msgid "The format of the <filename moreinfo=\"none\">.svn/entries</filename> file has changed over time. Originally an XML file, it now uses a custom—though still human-readable—file format. While XML was a great choice for early developers of Subversion who were frequently debugging the file's contents (and Subversion's behavior in light of them), the need for easy developer debugging has diminished as Subversion has matured, and has been replaced by the user's need for snappier performance. Of course, Subversion's working copy library makes upgrading from one working copy format to another a breeze—it reads the old formats, and writes the new."
msgstr ""

#: build/en/book.xml:17010(title)
msgid "Pristine Copies and Property Files"
msgstr "原始拷贝和属性文件"

#: build/en/book.xml:17012(para)
msgid "As mentioned before, the <filename moreinfo=\"none\">.svn</filename> directory also holds the pristine <quote>text-base</quote> versions of files. Those can be found in <filename moreinfo=\"none\">.svn/text-base</filename>. The benefits of these pristine copies are multiple—network-free checks for local modifications and difference reporting, network-free reversion of modified or missing files, smaller transmission of changes to the server—but comes at the cost of having each versioned file stored at least twice on disk. These days, this seems to be a negligible penalty for most files. However, the situation gets uglier as the size of your versioned files grows. Some attention is being given to making the presence of the <quote>text-base</quote> an option. Ironically though, it is as your versioned files' sizes get larger that the existence of the <quote>text-base</quote> becomes more crucial—who wants to transmit a huge file across a network just because they want to commit a tiny change to it?"
msgstr "如我们前面提到的，<filename moreinfo=\"none\">.svn</filename>也包含了一些原始的<quote>text-base</quote>文件版本，可以在<filename moreinfo=\"none\">.svn/text-base</filename>看到。这些原始文件的好处是多方面的—察看本地修改和区别不需要经过网络访问，减少传递修改时的数据—但是随之而来的代价是每个版本化的文件都在磁盘至少保存两次，现在看来这是对大多数文件可以忽略不计的一个惩罚。但是，当你版本控制的文件增多之后形势会变得很严峻，我们已经注意到了应该可以选择使用<quote>text-base</quote>，但是具有讽刺意味的是，当版本化文件增大时，<quote>text-base</quote>文件的存在会更加重要—谁会希望在提交一个小修改时在网络上传递一个大文件？"

#: build/en/book.xml:17031(para)
msgid "Similar in purpose to the <quote>text-base</quote> files are the property files and their pristine <quote>prop-base</quote> copies, located in <filename moreinfo=\"none\">.svn/props</filename> and <filename moreinfo=\"none\">.svn/prop-base</filename> respectively. Since directories can have properties, too, there are also <filename moreinfo=\"none\">.svn/dir-props</filename> and <filename moreinfo=\"none\">.svn/dir-prop-base</filename> files. Each of these property files (<quote>working</quote> and <quote>base</quote> versions) uses a simple <quote>hash-on-disk</quote> file format for storing the property names and values."
msgstr "同<quote>text-base</quote>文件的用途一样的还有属性文件和它们的<quote>prop-base</quote>拷贝，分别位于<filename moreinfo=\"none\">.svn/props</filename>和<filename moreinfo=\"none\">.svn/prop-base</filename>。因为目录也有属性，所以也有<filename moreinfo=\"none\">.svn/dir-props</filename>和<filename moreinfo=\"none\">.svn/dir-prop-base</filename>文件。所有的属性文件（<quote>working</quote>和<quote>base</quote>版本）都使用同样的<quote>hash-on-disk</quote>文件格式来排序属性名称和值。"

#: build/en/book.xml:17051(title)
msgid "Using the APIs"
msgstr "使用API"

#: build/en/book.xml:17053(para)
#, fuzzy
msgid "Developing applications against the Subversion library APIs is fairly straightforward. All of the public header files live in the <filename moreinfo=\"none\">subversion/include</filename> directory of the source tree. These headers are copied into your system locations when you build and install Subversion itself from source. These headers represent the entirety of the functions and types meant to be accessible by users of the Subversion libraries. The Subversion developer community is meticulous about ensuring that the public API is well-documented—refer directly to the header files for that documentation."
msgstr "使用Subversion库API开发应用看起来相当的直接，所有的公共头文件放在源文件的<filename moreinfo=\"none\">subversion/include</filename>目录，从源代码编译和安装Subversion本身，需要这些头文件拷贝到系统位置。这些头文件包括了所有用户可以访问的功能和类型。"

#: build/en/book.xml:17065(para)
#, fuzzy
msgid "When examining the public header files, the first thing you might notice is that Subversion's datatypes and functions are namespace protected. Every public Subversion symbol name begins with <literal moreinfo=\"none\">svn_</literal>, followed by a short code for the library in which the symbol is defined (such as <literal moreinfo=\"none\">wc</literal>, <literal moreinfo=\"none\">client</literal>, <literal moreinfo=\"none\">fs</literal>, etc.), followed by a single underscore (<literal moreinfo=\"none\">_</literal>) and then the rest of the symbol name. Semi-public functions (used among source files of a given library but not by code outside that library, and found inside the library directories themselves) differ from this naming scheme in that instead of a single underscore after the library code, they use a double underscore (<literal moreinfo=\"none\">__</literal>). Functions that are private to a given source file have no special prefixing, and are declared <literal moreinfo=\"none\">static</literal>. Of course, a compiler isn't interested in these naming conventions, but they help to clarify the scope of a given function or datatype."
msgstr "你首先应该注意Subversion的数据类型和方法是命名空间保护的，每一个公共Subversion对象名以<literal moreinfo=\"none\">svn_</literal>开头，然后紧跟一个这个对象定义（如<literal moreinfo=\"none\">wc</literal>、<literal moreinfo=\"none\">client</literal>和<literal moreinfo=\"none\">fs</literal>其他）所在的库的简短编码，然后是一个下划线（<literal moreinfo=\"none\">_</literal>）和后面的对象名称。半公开的方法（库使用，但是但库之外代码不可以使用并且只可以在库自己的目录看到）与这个命名模式不同，并不是库代码之后紧跟一个下划线，他们是用两个下划线（<literal moreinfo=\"none\">__</literal>）。给定源文件的私有方法没有特殊前缀，使用<literal moreinfo=\"none\">static</literal>声明。当然，一个编译器不会关心命名习惯，只是用来区分给定方法或数据类型。"

#: build/en/book.xml:1708(title)
msgid "Revisions"
msgstr "修订版本"

#: build/en/book.xml:17084(para)
msgid "Another good source of information about programming against the Subversion APIs is the project's own hacking guidelines, which can be found at <ulink url=\"http://subversion.tigris.org/hacking.html\"/>. This document contains useful information which, while aimed at developers and would-be developers of Subversion itself, is equally applicable to folks developing against Subversion as a set of third-party libraries. <placeholder-1/>"
msgstr ""

#: build/en/book.xml:17092(para)
msgid "After all, Subversion uses Subversion's APIs, too."
msgstr ""

#: build/en/book.xml:17099(title)
msgid "The Apache Portable Runtime Library"
msgstr "Apache可移植运行库"

#: build/en/book.xml:1710(para)
#, fuzzy
msgid "An <command moreinfo=\"none\">svn commit</command> operation publishes changes to any number of files and directories as a single atomic transaction. In your working copy, you can change files' contents, create, delete, rename and copy files and directories, and then commit a complete set of changes as an atomic transaction."
msgstr "一个<command moreinfo=\"none\">svn commit</command>操作可以作为一个原子事务操作发布任意数量文件和目录的修改，在你的工作拷贝里，你可以改变文件内容、删除、改名和拷贝文件和目录，然后作为一个整体提交。"

#: build/en/book.xml:17101(para)
msgid "Along with Subversion's own datatypes, you will see many references to datatypes that begin with <literal moreinfo=\"none\">apr_</literal>—symbols from the Apache Portable Runtime (APR) library. APR is Apache's portability library, originally carved out of its server code as an attempt to separate the OS-specific bits from the OS-independent portions of the code. The result was a library that provides a generic API for performing operations that differ mildly—or wildly—from OS to OS. While the Apache HTTP Server was obviously the first user of the APR library, the Subversion developers immediately recognized the value of using APR as well. This means that there are practically no OS-specific code portions in Subversion itself. Also, it means that the Subversion client compiles and runs anywhere that the server does. Currently this list includes all flavors of Unix, Win32, BeOS, OS/2, and Mac OS X."
msgstr "伴随Subversion自己的数据类型，你会看到许多<literal moreinfo=\"none\">apr</literal>开头的数据类型引用—来自Apache可移植运行库（APR）的对象。APR是Apache可移植运行库，源自为了服务器代码的多平台性，尝试将不同的操作系统特定字节与操作系统无关代码隔离。结果就提供了一个基础API的库，只有一些适度区别—或者是广泛的—来自各个操作系统。Apache HTTP服务器很明显是APR库的第一个用户，Subversion开发者立刻发现了使用APR库的价值。意味着Subversion没有操作系统特定的代码，也意味着Subversion客户端可以在Server存在的平台编译和运行。当前这个列表包括，各种类型的Unix、Win32、OS/2和Mac OS X。"

#: build/en/book.xml:17118(para)
#, fuzzy
msgid "In addition to providing consistent implementations of system calls that differ across operating systems, <placeholder-1/> APR gives Subversion immediate access to many custom datatypes, such as dynamic arrays and hash tables. Subversion uses these types extensively throughout the codebase. But perhaps the most pervasive APR datatype, found in nearly every Subversion API prototype, is the <structname>apr_pool_t</structname>—the APR memory pool. Subversion uses pools internally for all its memory allocation needs (unless an external library requires a different memory management schema for data passed through its API), <placeholder-2/> and while a person coding against the Subversion APIs is not required to do the same, they are required to provide pools to the API functions that need them. This means that users of the Subversion API must also link against APR, must call <function moreinfo=\"none\">apr_initialize()</function> to initialize the APR subsystem, and then must create and manage pools for use with Subversion API calls, typically by using <function moreinfo=\"none\">svn_pool_create()</function>, <function moreinfo=\"none\">svn_pool_clear()</function>, and <function moreinfo=\"none\">svn_pool_destroy()</function>."
msgstr "除了提供了跨平台一致的系统调用， <footnote><placeholder-1/></footnote> APR给Subversion对多种数据类型有快速的访问，如动态数组和哈希表。Subversion在代码中广泛使用这些类型，但是或许大多数普遍深入的APR数据类型可以在所有的Subversion的API原型中发现，是<structname>apr_pool_t</structname>—APR内存池，Subversion使用内部缓冲池用来进行内存分配（除非外部库在API传递参数时需要一个不同的内存管理模式）， <footnote><placeholder-2/></footnote> 而且一个人如果针对Subversion的API编码不需要做同样的事情，他们可以在需要时给API提供缓冲池，这意味着Subversion的API使用者也必须链接到APR，必须调用<function moreinfo=\"none\">apr_initialize()</function>来初始化APR字系统，然后必须得到一个缓冲池用来进行Subversion的API调用。详情见<xref linkend=\"svn.developer.pools\"/>。"

#: build/en/book.xml:17121(para)
msgid "Subversion uses ANSI system calls and datatypes as much as possible."
msgstr "Subversion使用尽可能多ANSI系统调用和数据类型。"

#: build/en/book.xml:17134(para)
msgid "Neon and Berkeley DB are examples of such libraries."
msgstr "Neon和Berkeley DB就是这种库的例子。"

#: build/en/book.xml:17148(title)
msgid "Programming with Memory Pools"
msgstr "使用内存池编程"

#: build/en/book.xml:17150(para)
#, fuzzy
msgid "Almost every developer who has used the C programming language has at some point sighed at the daunting task of managing memory usage. Allocating enough memory to use, keeping track of those allocations, freeing the memory when you no longer need it—these tasks can be quite complex. And of course, failure to do those things properly can result in a program that crashes itself, or worse, crashes the computer."
msgstr "几乎每一个使用过C语言的开发者曾经感叹令人畏缩的内存管理，分配足够的内存，并且追踪内存的分配，在不需要时释放内存—这个任务会非常复杂。当然，如果没有正确地做到这一点会导致程序毁掉自己，或者更加严重一点，把电脑搞瘫。幸运的是，Subversion所依赖的APR库为了移植性提供了<structname>apr_pool_t</structname>类型，代表了应用可以分配内存的池。"

#: build/en/book.xml:17159(para)
msgid "Higher-level languages, on the other hand, take the job of memory management away from the developer completely. <placeholder-1/> Languages like Java and Python use <firstterm>garbage collection</firstterm> principles, allocating memory for objects when needed, and automatically freeing that memory when the object is no longer in use."
msgstr ""

#: build/en/book.xml:17162(para)
msgid "Or at least make it something you only toy with when doing extremely tight program optimization."
msgstr ""

#: build/en/book.xml:1717(para)
#, fuzzy
msgid "By <quote>atomic transaction</quote>, we mean simply this: either all of the changes happen in the repository, or none of them happen. Subversion tries to retain this atomicity in the face of program crashes, system crashes, network problems, and other users' actions."
msgstr "在版本库中，每一次提交被当作一次原子事务操作：要么所有的改变发生，要么都不发生，Subversion努力保持原子性以应对程序错误、系统错误、网络问题和其他用户行为。"

#: build/en/book.xml:17170(para)
msgid "APR provides a middle-ground approach called pool-based memory management. It allows the developer to control memory usage at a lower resolution—per chunk (or <quote>pool</quote>) of memory, instead of per allocated object. Rather than using <function moreinfo=\"none\">malloc()</function> and friends to allocate enough memory for a given object, you ask APR to allocate the memory from a memory pool. When you're finished using the objects you've created in the pool, you destroy the pool, effectively de-allocating the memory consumed by the objects you allocated from it. Rather than keeping track of individual objects which need to be de-allocated, your program simply considers the general lifetimes of those objects, and allocates the objects in a pool whose lifetime (the time between the pool's creation and its deletion) matches the object's needs."
msgstr ""

#: build/en/book.xml:17192(title)
msgid "URL and Path Requirements"
msgstr "URL和路径需求"

#: build/en/book.xml:17194(para)
msgid "With remote version control operation as the whole point of Subversion's existence, it makes sense that some attention has been paid to internationalization (i18n) support. After all, while <quote>remote</quote> might mean <quote>across the office</quote>, it could just as well mean <quote>across the globe.</quote> To facilitate this, all of Subversion's public interfaces that accept path arguments expect those paths to be canonicalized, and encoded in UTF-8. This means, for example, that any new client binary that drives the libsvn_client interface needs to first convert paths from the locale-specific encoding to UTF-8 before passing those paths to the Subversion libraries, and then re-convert any resultant output paths from Subversion back into the locale's encoding before using those paths for non-Subversion purposes. Fortunately, Subversion provides a suite of functions (see <filename moreinfo=\"none\">subversion/include/svn_utf.h</filename>) that can be used by any program to do these conversions."
msgstr "因为分布式版本控制操作是Subversion存在的重点，有意义来关注一下国际化（i18n）支持。毕竟，当<quote>分布式</quote>或许意味着<quote>横跨办公室</quote>，它也意味着<quote>横跨全球</quote>。为了更容易一点，Subversion的所有公共接口只接受路径参数,这些参数是传统的，使用UTF-8编码。这意味着，举个例子，任何新的使用libsvn_client接口客户端库，在把这些参数传递给Subversion库前，需要首先将路径从本地代码转化为UTF-8代码，然后将Subversion传递回来的路径转换为本地代码，很幸运，Subversion提供了一组任何程序可以使用的转化方法（见<filename moreinfo=\"none\">subversion/include/svn_utf.h</filename>）。"

#: build/en/book.xml:17212(para)
#, fuzzy
msgid "Also, Subversion APIs require all URL parameters to be properly URI-encoded. So, instead of passing <uri>file:///home/username/My File.txt</uri> as the URL of a file named <literal moreinfo=\"none\">My File.txt</literal>, you need to pass <uri>file:///home/username/My%20File.txt</uri>. Again, Subversion supplies helper functions that your application can use—<function moreinfo=\"none\">svn_path_uri_encode()</function> and <function moreinfo=\"none\">svn_path_uri_decode()</function>, for URI encoding and decoding, respectively."
msgstr "同样，Subversion的API需要所有的URL参数是正确的URI编码，所以，我们不会传递<systemitem class=\"url\" moreinfo=\"none\">file:///home/username/My File.txt</systemitem>作为<literal moreinfo=\"none\">My File.txt</literal>的URL，而会传递<systemitem class=\"url\" moreinfo=\"none\">file:///home/username/My%20File.txt</systemitem>。再次，Subversion提供了一些你可以使用的助手方法—<function moreinfo=\"none\">svn_path_uri_encode()</function>和<function moreinfo=\"none\">svn_path_uri_decode()</function>，分别用来URI的编码和解码。"

#: build/en/book.xml:17224(title)
msgid "Using Languages Other than C and C++"
msgstr "使用C和C++以外的语言"

#: build/en/book.xml:17226(para)
msgid "If you are interested in using the Subversion libraries in conjunction with something other than a C program—say a Python or Perl script—Subversion has some support for this via the Simplified Wrapper and Interface Generator (SWIG). The SWIG bindings for Subversion are located in <filename moreinfo=\"none\">subversion/bindings/swig</filename> and whilst still maturing, they are in a usable state. These bindings allow you to call Subversion API functions indirectly, using wrappers that translate the datatypes native to your scripting language into the datatypes needed by Subversion's C libraries."
msgstr "除C语言以外，如果你对使用其他语言结合Subversion库感兴趣—如Python脚本或是Java应用—Subversion通过简单包裹生成器（SWIG）提供了最初的支持。Subversion的SWIG绑定位于<filename moreinfo=\"none\">subversion/bindings/swig</filename>，并且慢慢的走向成熟进入可用状态。这个绑定允许你直接调用Subversion的API方法，使用包裹器会把脚本数据类型转化为Subversion需要的C语言库类型。"

#: build/en/book.xml:1723(para)
msgid "Each time the repository accepts a commit, this creates a new state of the filesystem tree, called a <firstterm>revision</firstterm>. Each revision is assigned a unique natural number, one greater than the number of the previous revision. The initial revision of a freshly created repository is numbered zero, and consists of nothing but an empty root directory."
msgstr "每当版本库接受了一个提交，文件系统进入了一个新的状态，叫做一次修订（<firstterm>revision</firstterm>），每一个修订版本被赋予一个独一无二的自然数，一个比一个大，初始修订号是0，只创建了一个空目录，没有任何内容。"

#: build/en/book.xml:17237(para)
msgid "There is an obvious benefit to accessing the Subversion APIs via a language binding—simplicity. Generally speaking, languages such as Python and Perl are much more flexible and easy to use than C or C++. The sort of high-level datatypes and context-driven type checking provided by these languages are often better at handling information that comes from users. As you know, humans are proficient at botching up input to a program, and scripting languages tend to handle that misinformation more gracefully. Of course, often that flexibility comes at the cost of performance. That is why using a tightly-optimized, C-based interface and library suite, combined with a powerful, flexible binding language, is so appealing."
msgstr "通过语言绑定访问Subversion的API有一个明显的好处—简单性。通常来讲，Python和Perl之类的语言比C和C++更加的灵活和简单，这些语言的高级数据类型和上下文驱动类型更加易于处理用户提供的信息，就像你知道的，人们精于把程序搞坏，脚本语言可以更优雅的处理这些错误信息，当然，灵活性经常带来性能的损失，这就是为什么使用紧密优化的，C基础的接口和库组件，然后与一种高效的、灵活的绑定语言，是这样的吸引人。"

#: build/en/book.xml:17251(para)
#, fuzzy
msgid "Unfortunately, Subversion's language bindings tend to lack the level of developer attention given to the core Subversion modules. However, there have been significant efforts towards creating functional bindings for Python, Perl, and Ruby. To some extent, the work done preparing the SWIG interface files for these languages is reusable in efforts to generate bindings for other languages supported by SWIG (which include versions of C#, Guile, Java, MzScheme, OCaml, PHP, and Tcl, among others). However, some extra programming is required to compensate for complex APIs that SWIG needs some help translating between languages. For more information on SWIG itself, see the project's website at <ulink url=\"http://www.swig.org/\"/>."
msgstr "非常不幸，Subversion的语言绑定缺乏对核心Subversion模块的关注，但是，花了很多力气处理创建针对Python、Perl和Ruby的绑定，在一定程度上，在这些接口上的工作量可以在其他语言的SWIG（包括C#、Guile、Java、MzScheme、OCaml、PHP、Tcl等等）接口上得到重用。然而，一些接口仍然需要额外的编程工作，关于SWIG本身的更多信息可以看项目的网站<ulink url=\"http://www.swig.org/\"/>。"

#: build/en/book.xml:17268(title)
msgid "Code Samples"
msgstr "代码样例"

#: build/en/book.xml:17270(para)
msgid "<xref linkend=\"svn.developer.layerlib.repos.ex-1\"/> contains a code segment (written in C) that illustrates some of the concepts we've been discussing. It uses both the repository and filesystem interfaces (as can be determined by the prefixes <literal moreinfo=\"none\">svn_repos_</literal> and <literal moreinfo=\"none\">svn_fs_</literal> of the function names, respectively) to create a new revision in which a directory is added. You can see the use of an APR pool, which is passed around for memory allocation purposes. Also, the code reveals a somewhat obscure fact about Subversion error handling—all Subversion errors must be explicitly handled to avoid memory leakage (and in some cases, application failure)."
msgstr ""

#: build/en/book.xml:17285(title)
msgid "Using the Repository Layer"
msgstr "使用版本库层"

#: build/en/book.xml:17287(programlisting)
#, no-wrap
msgid ""
"\n"
"/* Convert a Subversion error into a simple boolean error code.\n"
" *\n"
" * NOTE:  Subversion errors must be consumed because they are allocated\n"
" *        from the global pool, else memory leaking occurs.\n"
" */\n"
"#define INT_ERR(expr)                           \\\n"
"  do {                                          \\\n"
"    svn_error_t *__temperr = (expr);            \\\n"
"    if (__temperr)                              \\\n"
"      {                                         \\\n"
"        svn_error_clear(__temperr);             \\\n"
"        return 1;                               \\\n"
"      }                                         \\\n"
"    return 0;                                   \\\n"
"  } while (0)\n"
"\n"
"/* Create a new directory at the path NEW_DIRECTORY in the Subversion\n"
" * repository located at REPOS_PATH.  Perform all memory allocation in\n"
" * POOL.  This function will create a new revision for the addition of\n"
" * NEW_DIRECTORY.  Return zero if the operation completes\n"
" * successfully, non-zero otherwise.\n"
" */\n"
"static int\n"
"make_new_directory(const char *repos_path,\n"
"                   const char *new_directory,\n"
"                   apr_pool_t *pool)\n"
"{\n"
"  svn_error_t *err;\n"
"  svn_repos_t *repos;\n"
"  svn_fs_t *fs;\n"
"  svn_revnum_t youngest_rev;\n"
"  svn_fs_txn_t *txn;\n"
"  svn_fs_root_t *txn_root;\n"
"  const char *conflict_str;\n"
"\n"
"  /* Open the repository located at REPOS_PATH. \n"
"   */\n"
"  INT_ERR(svn_repos_open(&amp;repos, repos_path, pool));\n"
"\n"
"  /* Get a pointer to the filesystem object that is stored in REPOS. \n"
"   */\n"
"  fs = svn_repos_fs(repos);\n"
"\n"
"  /* Ask the filesystem to tell us the youngest revision that\n"
"   * currently exists. \n"
"   */\n"
"  INT_ERR(svn_fs_youngest_rev(&amp;youngest_rev, fs, pool));\n"
"\n"
"  /* Begin a new transaction that is based on YOUNGEST_REV.  We are\n"
"   * less likely to have our later commit rejected as conflicting if we\n"
"   * always try to make our changes against a copy of the latest snapshot\n"
"   * of the filesystem tree. \n"
"   */\n"
"  INT_ERR(svn_fs_begin_txn(&amp;txn, fs, youngest_rev, pool));\n"
"\n"
"  /* Now that we have started a new Subversion transaction, get a root\n"
"   * object that represents that transaction. \n"
"   */\n"
"  INT_ERR(svn_fs_txn_root(&amp;txn_root, txn, pool));\n"
"  \n"
"  /* Create our new directory under the transaction root, at the path\n"
"   * NEW_DIRECTORY. \n"
"   */\n"
"  INT_ERR(svn_fs_make_dir(txn_root, new_directory, pool));\n"
"\n"
"  /* Commit the transaction, creating a new revision of the filesystem\n"
"   * which includes our added directory path.\n"
"   */\n"
"  err = svn_repos_fs_commit_txn(&amp;conflict_str, repos, \n"
"                                &amp;youngest_rev, txn, pool);\n"
"  if (! err)\n"
"    {\n"
"      /* No error?  Excellent!  Print a brief report of our success.\n"
"       */\n"
"      printf(\"Directory '%s' was successfully added as new revision \"\n"
"             \"'%ld'.\\n\", new_directory, youngest_rev);\n"
"    }\n"
"  else if (err-&gt;apr_err == SVN_ERR_FS_CONFLICT)\n"
"    {\n"
"      /* Uh-oh.  Our commit failed as the result of a conflict\n"
"       * (someone else seems to have made changes to the same area \n"
"       * of the filesystem that we tried to modify).  Print an error\n"
"       * message.\n"
"       */\n"
"      printf(\"A conflict occurred at path '%s' while attempting \"\n"
"             \"to add directory '%s' to the repository at '%s'.\\n\", \n"
"             conflict_str, new_directory, repos_path);\n"
"    }\n"
"  else\n"
"    {\n"
"      /* Some other error has occurred.  Print an error message.\n"
"       */\n"
"      printf(\"An error occurred while attempting to add directory '%s' \"\n"
"             \"to the repository at '%s'.\\n\", \n"
"             new_directory, repos_path);\n"
"    }\n"
"\n"
"  INT_ERR(err);\n"
"} \n"
msgstr ""
"\n"
"/* Convert a Subversion error into a simple boolean error code.\n"
" *\n"
" * NOTE:  Subversion errors must be consumed because they are allocated\n"
" *        from the global pool, else memory leaking occurs.\n"
" */\n"
"#define INT_ERR(expr)                           \\\n"
"  do {                                          \\\n"
"    svn_error_t *__temperr = (expr);            \\\n"
"    if (__temperr)                              \\\n"
"      {                                         \\\n"
"        svn_error_clear(__temperr);             \\\n"
"        return 1;                               \\\n"
"      }                                         \\\n"
"    return 0;                                   \\\n"
"  } while (0)\n"
"\n"
"/* Create a new directory at the path NEW_DIRECTORY in the Subversion\n"
" * repository located at REPOS_PATH.  Perform all memory allocation in\n"
" * POOL.  This function will create a new revision for the addition of\n"
" * NEW_DIRECTORY.  Return zero if the operation completes\n"
" * successfully, non-zero otherwise.\n"
" */\n"
"static int\n"
"make_new_directory(const char *repos_path,\n"
"                   const char *new_directory,\n"
"                   apr_pool_t *pool)\n"
"{\n"
"  svn_error_t *err;\n"
"  svn_repos_t *repos;\n"
"  svn_fs_t *fs;\n"
"  svn_revnum_t youngest_rev;\n"
"  svn_fs_txn_t *txn;\n"
"  svn_fs_root_t *txn_root;\n"
"  const char *conflict_str;\n"
"\n"
"  /* Open the repository located at REPOS_PATH. \n"
"   */\n"
"  INT_ERR(svn_repos_open(&amp;repos, repos_path, pool));\n"
"\n"
"  /* Get a pointer to the filesystem object that is stored in REPOS. \n"
"   */\n"
"  fs = svn_repos_fs(repos);\n"
"\n"
"  /* Ask the filesystem to tell us the youngest revision that\n"
"   * currently exists. \n"
"   */\n"
"  INT_ERR(svn_fs_youngest_rev(&amp;youngest_rev, fs, pool));\n"
"\n"
"  /* Begin a new transaction that is based on YOUNGEST_REV.  We are\n"
"   * less likely to have our later commit rejected as conflicting if we\n"
"   * always try to make our changes against a copy of the latest snapshot\n"
"   * of the filesystem tree. \n"
"   */\n"
"  INT_ERR(svn_fs_begin_txn(&amp;txn, fs, youngest_rev, pool));\n"
"\n"
"  /* Now that we have started a new Subversion transaction, get a root\n"
"   * object that represents that transaction. \n"
"   */\n"
"  INT_ERR(svn_fs_txn_root(&amp;txn_root, txn, pool));\n"
"  \n"
"  /* Create our new directory under the transaction root, at the path\n"
"   * NEW_DIRECTORY. \n"
"   */\n"
"  INT_ERR(svn_fs_make_dir(txn_root, new_directory, pool));\n"
"\n"
"  /* Commit the transaction, creating a new revision of the filesystem\n"
"   * which includes our added directory path.\n"
"   */\n"
"  err = svn_repos_fs_commit_txn(&amp;conflict_str, repos, \n"
"                                &amp;youngest_rev, txn, pool);\n"
"  if (! err)\n"
"    {\n"
"      /* No error?  Excellent!  Print a brief report of our success.\n"
"       */\n"
"      printf(\"Directory '%s' was successfully added as new revision \"\n"
"             \"'%ld'.\\n\", new_directory, youngest_rev);\n"
"    }\n"
"  else if (err-&gt;apr_err == SVN_ERR_FS_CONFLICT)\n"
"    {\n"
"      /* Uh-oh.  Our commit failed as the result of a conflict\n"
"       * (someone else seems to have made changes to the same area \n"
"       * of the filesystem that we tried to modify).  Print an error\n"
"       * message.\n"
"       */\n"
"      printf(\"A conflict occurred at path '%s' while attempting \"\n"
"             \"to add directory '%s' to the repository at '%s'.\\n\", \n"
"             conflict_str, new_directory, repos_path);\n"
"    }\n"
"  else\n"
"    {\n"
"      /* Some other error has occurred.  Print an error message.\n"
"       */\n"
"      printf(\"An error occurred while attempting to add directory '%s' \"\n"
"             \"to the repository at '%s'.\\n\", \n"
"             new_directory, repos_path);\n"
"    }\n"
"\n"
"  INT_ERR(err);\n"
"} \n"

#: build/en/book.xml:1731(para)
msgid "<xref linkend=\"svn.basic.in-action.revs.dia-1\"/> illustrates a nice way to visualize the repository. Imagine an array of revision numbers, starting at 0, stretching from left to right. Each revision number has a filesystem tree hanging below it, and each tree is a <quote>snapshot</quote> of the way the repository looked after a commit."
msgstr "<xref linkend=\"svn.basic.in-action.revs.dia-1\"/>可以更形象的描述版本库，想象有一组修订号，从0开始，从左到右，每一个修订号有一个目录树挂在它下面，每一个树好像是一次提交后的版本库<quote>快照</quote>。"

#: build/en/book.xml:1739(title)
msgid "The repository"
msgstr "版本库2"

#: build/en/book.xml:17390(para)
#, fuzzy
msgid "Note that in <xref linkend=\"svn.developer.layerlib.repos.ex-1\"/>, the code could just as easily have committed the transaction using <function moreinfo=\"none\">svn_fs_commit_txn()</function>. But the filesystem API knows nothing about the repository library's hook mechanism. If you want your Subversion repository to automatically perform some set of non-Subversion tasks every time you commit a transaction (like, for example, sending an email that describes all the changes made in that transaction to your developer mailing list), you need to use the libsvn_repos-wrapped version of that function was adds the hook triggering functionality—in this case, <function moreinfo=\"none\">svn_repos_fs_commit_txn()</function>. (For more information regarding Subversion's repository hooks, see <xref linkend=\"svn.reposadmin.create.hooks\"/>.)"
msgstr "在前面的代码片断中，同时调用了版本库和文件系统接口，我们可以正像这样简单的用<function moreinfo=\"none\">svn_fs_commit_txn()</function>提交事务。但是文件系统的API对版本库库的钩子一无所知，如果你希望你的Subversion版本库在每次提交一个事务时自动执行一些非Subversion的任务（例如，给开发者邮件组发送一个描述事务修改的邮件），你需要使用libsvn_repos包裹的功能版本—<function moreinfo=\"none\">svn_repos_fs_commit_txn()</function>。这个功能会实际上首先运行一个如果存在的<literal moreinfo=\"none\">pre-commit</literal>钩子脚本，然后提交事务，最后会运行一个<literal moreinfo=\"none\">post-commit</literal>钩子脚本。钩子提供了一种特别的报告机制，不是真的属于核心文件系统库本身。（关于Subversion版本库钩子的更多信息，见<xref linkend=\"svn.reposadmin.create.hooks\"/>。）"

#: build/en/book.xml:17404(para)
#, fuzzy
msgid "Now let's switch languages. <xref linkend=\"svn.developer.usingapi.otherlangs.ex-1\"/> is a sample program that uses Subversion's SWIG Python bindings to recursively crawl the youngest repository revision, and print the various paths reached during the crawl."
msgstr "让我们看看Subversion的Python SWIG绑定的实例，这个例子迭代遍历最新的修订版本，并且打印遍历到的路径。"

#: build/en/book.xml:17410(title)
msgid "Using the Repository Layer with Python"
msgstr "使用Python处理版本库层"

#: build/en/book.xml:17412(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/usr/bin/python\n"
"\n"
"\"\"\"Crawl a repository, printing versioned object path names.\"\"\"\n"
"\n"
"import sys\n"
"import os.path\n"
"import svn.fs, svn.core, svn.repos\n"
"\n"
"def crawl_filesystem_dir(root, directory):\n"
"    \"\"\"Recursively crawl DIRECTORY under ROOT in the filesystem, and return\n"
"    a list of all the paths at or below DIRECTORY.\"\"\"\n"
"\n"
"    # Print the name of this path.\n"
"    print directory + \"/\"\n"
"    \n"
"    # Get the directory entries for DIRECTORY.\n"
"    entries = svn.fs.svn_fs_dir_entries(root, directory)\n"
"\n"
"    # Loop over the entries.\n"
"    names = entries.keys()\n"
"    for name in names:\n"
"        # Calculate the entry's full path.\n"
"        full_path = directory + '/' + name\n"
"\n"
"        # If the entry is a directory, recurse.  The recursion will return\n"
"        # a list with the entry and all its children, which we will add to\n"
"        # our running list of paths.\n"
"        if svn.fs.svn_fs_is_dir(root, full_path):\n"
"            crawl_filesystem_dir(root, full_path)\n"
"        else:\n"
"            # Else it's a file, so print its path here.\n"
"            print full_path\n"
"\n"
"def crawl_youngest(repos_path):\n"
"    \"\"\"Open the repository at REPOS_PATH, and recursively crawl its\n"
"    youngest revision.\"\"\"\n"
"    \n"
"    # Open the repository at REPOS_PATH, and get a reference to its\n"
"    # versioning filesystem.\n"
"    repos_obj = svn.repos.svn_repos_open(repos_path)\n"
"    fs_obj = svn.repos.svn_repos_fs(repos_obj)\n"
"\n"
"    # Query the current youngest revision.\n"
"    youngest_rev = svn.fs.svn_fs_youngest_rev(fs_obj)\n"
"    \n"
"    # Open a root object representing the youngest (HEAD) revision.\n"
"    root_obj = svn.fs.svn_fs_revision_root(fs_obj, youngest_rev)\n"
"\n"
"    # Do the recursive crawl.\n"
"    crawl_filesystem_dir(root_obj, \"\")\n"
"    \n"
"if __name__ == \"__main__\":\n"
"    # Check for sane usage.\n"
"    if len(sys.argv) != 2:\n"
"        sys.stderr.write(\"Usage: %s REPOS_PATH\\n\"\n"
"                         % (os.path.basename(sys.argv[0])))\n"
"        sys.exit(1)\n"
"\n"
"    # Canonicalize the repository path.\n"
"    repos_path = svn.core.svn_path_canonicalize(sys.argv[1])\n"
"\n"
"    # Do the real work.\n"
"    crawl_youngest(repos_path)\n"
msgstr ""
"\n"
"#!/usr/bin/python\n"
"\n"
"\"\"\"Crawl a repository, printing versioned object path names.\"\"\"\n"
"\n"
"import sys\n"
"import os.path\n"
"import svn.fs, svn.core, svn.repos\n"
"\n"
"def crawl_filesystem_dir(root, directory):\n"
"    \"\"\"Recursively crawl DIRECTORY under ROOT in the filesystem, and return\n"
"    a list of all the paths at or below DIRECTORY.\"\"\"\n"
"\n"
"    # Print the name of this path.\n"
"    print directory + \"/\"\n"
"    \n"
"    # Get the directory entries for DIRECTORY.\n"
"    entries = svn.fs.svn_fs_dir_entries(root, directory)\n"
"\n"
"    # Loop over the entries.\n"
"    names = entries.keys()\n"
"    for name in names:\n"
"        # Calculate the entry's full path.\n"
"        full_path = directory + '/' + name\n"
"\n"
"        # If the entry is a directory, recurse.  The recursion will return\n"
"        # a list with the entry and all its children, which we will add to\n"
"        # our running list of paths.\n"
"        if svn.fs.svn_fs_is_dir(root, full_path):\n"
"            crawl_filesystem_dir(root, full_path)\n"
"        else:\n"
"            # Else it's a file, so print its path here.\n"
"            print full_path\n"
"\n"
"def crawl_youngest(repos_path):\n"
"    \"\"\"Open the repository at REPOS_PATH, and recursively crawl its\n"
"    youngest revision.\"\"\"\n"
"    \n"
"    # Open the repository at REPOS_PATH, and get a reference to its\n"
"    # versioning filesystem.\n"
"    repos_obj = svn.repos.svn_repos_open(repos_path)\n"
"    fs_obj = svn.repos.svn_repos_fs(repos_obj)\n"
"\n"
"    # Query the current youngest revision.\n"
"    youngest_rev = svn.fs.svn_fs_youngest_rev(fs_obj)\n"
"    \n"
"    # Open a root object representing the youngest (HEAD) revision.\n"
"    root_obj = svn.fs.svn_fs_revision_root(fs_obj, youngest_rev)\n"
"\n"
"    # Do the recursive crawl.\n"
"    crawl_filesystem_dir(root_obj, \"\")\n"
"    \n"
"if __name__ == \"__main__\":\n"
"    # Check for sane usage.\n"
"    if len(sys.argv) != 2:\n"
"        sys.stderr.write(\"Usage: %s REPOS_PATH\\n\"\n"
"                         % (os.path.basename(sys.argv[0])))\n"
"        sys.exit(1)\n"
"\n"
"    # Canonicalize the repository path.\n"
"    repos_path = svn.core.svn_path_canonicalize(sys.argv[1])\n"
"\n"
"    # Do the real work.\n"
"    crawl_youngest(repos_path)\n"

#: build/en/book.xml:1744(title)
msgid "Global Revision Numbers"
msgstr "全局修订号"

#: build/en/book.xml:1746(para)
#, fuzzy
msgid "Unlike most version control systems, Subversion's revision numbers apply to <emphasis>entire trees</emphasis>, not individual files. Each revision number selects an entire tree, a particular state of the repository after some committed change. Another way to think about it is that revision N represents the state of the repository filesystem after the Nth commit. When Subversion users talk about <quote>revision 5 of <filename moreinfo=\"none\">foo.c</filename></quote>, they really mean <quote><filename moreinfo=\"none\">foo.c</filename> as it appears in revision 5.</quote> Notice that in general, revisions N and M of a file do <emphasis>not</emphasis> necessarily differ! Many other version control systems use per-file revision numbers, so this concept may seem unusual at first. (Former CVS users might want to see <xref linkend=\"svn.forcvs\"/> for more details.)"
msgstr "不像其他版本控制系统，Subversion的修订号是针对整个<emphasis>目录树</emphasis>的，而不是单个文件。每一个修订号代表了一次提交后版本库整个目录树的特定状态，另一种理解是修订号N代表版本库已经经过了N次提交。当Subversion用户讨论<quote><filename moreinfo=\"none\">foo.c</filename>的修订号5</quote>时，他们的实际意思是<quote>在修订号5时的<filename moreinfo=\"none\">foo.c</filename></quote>。需要注意的是，修订号N和M并<emphasis>不</emphasis>表示一个文件需要不同。因为CVS使用每一个文件一个修订号的策略，CVS用户可能希望察看<xref linkend=\"svn.forcvs\"/>来得到更多细节。"

#: build/en/book.xml:17479(para)
#, fuzzy
msgid "This same program in C would need to deal with APR's memory pool system. But Python handles memory usage automatically, and Subversion's Python bindings adhere to that convention. In C, you'd be working with custom datatypes (such as those provided by the APR library) for representing the hash of entries and the list of paths, but Python has hashes (called <quote>dictionaries</quote>) and lists as built-in datatypes, and provides a rich collection of functions for operating on those types. So SWIG (with the help of some customizations in Subversion's language bindings layer) takes care of mapping those custom datatypes into the native datatypes of the target language. This provides a more intuitive interface for users of that language."
msgstr "同样的C程序为表示路径和条目的hash需要处理自定义的数据类型（例如APR提供的库），但是Python有hash（叫做<quote>dictionaries</quote>），并且是内置数据类型，而且还提供了一系列操作这些类型的函数，所以SWIG（通过Subversion的语言绑定层的自定义帮助）要小心的将这些自定义数据类型映射到目标语言的数据类型，这为目标语言的用户提供了一个更加直观的接口。"

#: build/en/book.xml:17493(para)
#, fuzzy
msgid "The Subversion Python bindings can be used for working copy operations, too. In the previous section of this chapter, we mentioned the <filename moreinfo=\"none\">libsvn_client</filename> interface, and how it exists for the sole purpose of simplifying the process of writing a Subversion client. <xref linkend=\"svn.developer.usingapi.otherlangs.ex-2\"/> is a brief example of how that library can be accessed via the SWIG Python bindings to recreate a scaled-down version of the <command moreinfo=\"none\">svn status</command> command."
msgstr "Subversion的Python绑定也可以用来进行工作拷贝的操作，在本章前面的小节中，我们提到过<filename moreinfo=\"none\">libsvn_client</filename>接口，它存在的目的就是简化编写Subversion客户端的难度，下面是一个例子，讲的是如何使用SWIG绑定创建一个扩展的<command moreinfo=\"none\">svn status</command>命令。"

#: build/en/book.xml:17503(title)
msgid "A Python Status Crawler"
msgstr "A Python Status Crawler"

#: build/en/book.xml:17505(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/usr/bin/env python\n"
"\n"
"\"\"\"Crawl a working copy directory, printing status information.\"\"\"\n"
"\n"
"import sys\n"
"import os.path\n"
"import getopt\n"
"import svn.core, svn.client, svn.wc\n"
"\n"
"def generate_status_code(status):\n"
"    \"\"\"Translate a status value into a single-character status code,\n"
"    using the same logic as the Subversion command-line client.\"\"\"\n"
"    code_map = { svn.wc.svn_wc_status_none        : ' ',\n"
"                 svn.wc.svn_wc_status_normal      : ' ',\n"
"                 svn.wc.svn_wc_status_added       : 'A',\n"
"                 svn.wc.svn_wc_status_missing     : '!',\n"
"                 svn.wc.svn_wc_status_incomplete  : '!',\n"
"                 svn.wc.svn_wc_status_deleted     : 'D',\n"
"                 svn.wc.svn_wc_status_replaced    : 'R',\n"
"                 svn.wc.svn_wc_status_modified    : 'M',\n"
"                 svn.wc.svn_wc_status_merged      : 'G',\n"
"                 svn.wc.svn_wc_status_conflicted  : 'C',\n"
"                 svn.wc.svn_wc_status_obstructed  : '~',\n"
"                 svn.wc.svn_wc_status_ignored     : 'I',\n"
"                 svn.wc.svn_wc_status_external    : 'X',\n"
"                 svn.wc.svn_wc_status_unversioned : '?',\n"
"               }\n"
"    return code_map.get(status, '?')\n"
"\n"
"def do_status(wc_path, verbose):\n"
"    # Calculate the length of the input working copy path.\n"
"    wc_path_len = len(wc_path)\n"
"\n"
"    # Build a client context baton.\n"
"    ctx = svn.client.svn_client_ctx_t()\n"
"\n"
"    def _status_callback(path, status, root_path_len=wc_path_len):\n"
"        \"\"\"A callback function for svn_client_status.\"\"\"\n"
"\n"
"        # Print the path, minus the bit that overlaps with the root of\n"
"        # the status crawl\n"
"        text_status = generate_status_code(status.text_status)\n"
"        prop_status = generate_status_code(status.prop_status)\n"
"        print '%s%s  %s' % (text_status, prop_status, path[wc_path_len + 1:])\n"
"        \n"
"    # Do the status crawl, using _status_callback() as our callback function.\n"
"    svn.client.svn_client_status(wc_path, None, _status_callback,\n"
"                                 1, verbose, 0, 0, ctx)\n"
"\n"
"def usage_and_exit(errorcode):\n"
"    \"\"\"Print usage message, and exit with ERRORCODE.\"\"\"\n"
"    stream = errorcode and sys.stderr or sys.stdout\n"
"    stream.write(\"\"\"Usage: %s OPTIONS WC-PATH\n"
"Options:\n"
"  --help, -h    : Show this usage message\n"
"  --verbose, -v : Show all statuses, even uninteresting ones\n"
"\"\"\" % (os.path.basename(sys.argv[0])))\n"
"    sys.exit(errorcode)\n"
"    \n"
"if __name__ == '__main__':\n"
"    # Parse command-line options.\n"
"    try:\n"
"        opts, args = getopt.getopt(sys.argv[1:], \"hv\", [\"help\", \"verbose\"])\n"
"    except getopt.GetoptError:\n"
"        usage_and_exit(1)\n"
"    verbose = 0\n"
"    for opt, arg in opts:\n"
"        if opt in (\"-h\", \"--help\"):\n"
"            usage_and_exit(0)\n"
"        if opt in (\"-v\", \"--verbose\"):\n"
"            verbose = 1\n"
"    if len(args) != 1:\n"
"        usage_and_exit(2)\n"
"            \n"
"    # Canonicalize the repository path.\n"
"    wc_path = svn.core.svn_path_canonicalize(args[0])\n"
"\n"
"    # Do the real work.\n"
"    try:\n"
"        do_status(wc_path, verbose)\n"
"    except svn.core.SubversionException, e:\n"
"        sys.stderr.write(\"Error (%d): %s\\n\" % (e[1], e[0]))\n"
"        sys.exit(1)\n"
msgstr ""
"\n"
"#!/usr/bin/env python\n"
"\n"
"\"\"\"Crawl a working copy directory, printing status information.\"\"\"\n"
"\n"
"import sys\n"
"import os.path\n"
"import getopt\n"
"import svn.core, svn.client, svn.wc\n"
"\n"
"def generate_status_code(status):\n"
"    \"\"\"Translate a status value into a single-character status code,\n"
"    using the same logic as the Subversion command-line client.\"\"\"\n"
"    code_map = { svn.wc.svn_wc_status_none        : ' ',\n"
"                 svn.wc.svn_wc_status_normal      : ' ',\n"
"                 svn.wc.svn_wc_status_added       : 'A',\n"
"                 svn.wc.svn_wc_status_missing     : '!',\n"
"                 svn.wc.svn_wc_status_incomplete  : '!',\n"
"                 svn.wc.svn_wc_status_deleted     : 'D',\n"
"                 svn.wc.svn_wc_status_replaced    : 'R',\n"
"                 svn.wc.svn_wc_status_modified    : 'M',\n"
"                 svn.wc.svn_wc_status_merged      : 'G',\n"
"                 svn.wc.svn_wc_status_conflicted  : 'C',\n"
"                 svn.wc.svn_wc_status_obstructed  : '~',\n"
"                 svn.wc.svn_wc_status_ignored     : 'I',\n"
"                 svn.wc.svn_wc_status_external    : 'X',\n"
"                 svn.wc.svn_wc_status_unversioned : '?',\n"
"               }\n"
"    return code_map.get(status, '?')\n"
"\n"
"def do_status(wc_path, verbose):\n"
"    # Calculate the length of the input working copy path.\n"
"    wc_path_len = len(wc_path)\n"
"\n"
"    # Build a client context baton.\n"
"    ctx = svn.client.svn_client_ctx_t()\n"
"\n"
"    def _status_callback(path, status, root_path_len=wc_path_len):\n"
"        \"\"\"A callback function for svn_client_status.\"\"\"\n"
"\n"
"        # Print the path, minus the bit that overlaps with the root of\n"
"        # the status crawl\n"
"        text_status = generate_status_code(status.text_status)\n"
"        prop_status = generate_status_code(status.prop_status)\n"
"        print '%s%s  %s' % (text_status, prop_status, path[wc_path_len + 1:])\n"
"        \n"
"    # Do the status crawl, using _status_callback() as our callback function.\n"
"    svn.client.svn_client_status(wc_path, None, _status_callback,\n"
"                                 1, verbose, 0, 0, ctx)\n"
"\n"
"def usage_and_exit(errorcode):\n"
"    \"\"\"Print usage message, and exit with ERRORCODE.\"\"\"\n"
"    stream = errorcode and sys.stderr or sys.stdout\n"
"    stream.write(\"\"\"Usage: %s OPTIONS WC-PATH\n"
"Options:\n"
"  --help, -h    : Show this usage message\n"
"  --verbose, -v : Show all statuses, even uninteresting ones\n"
"\"\"\" % (os.path.basename(sys.argv[0])))\n"
"    sys.exit(errorcode)\n"
"    \n"
"if __name__ == '__main__':\n"
"    # Parse command-line options.\n"
"    try:\n"
"        opts, args = getopt.getopt(sys.argv[1:], \"hv\", [\"help\", \"verbose\"])\n"
"    except getopt.GetoptError:\n"
"        usage_and_exit(1)\n"
"    verbose = 0\n"
"    for opt, arg in opts:\n"
"        if opt in (\"-h\", \"--help\"):\n"
"            usage_and_exit(0)\n"
"        if opt in (\"-v\", \"--verbose\"):\n"
"            verbose = 1\n"
"    if len(args) != 1:\n"
"        usage_and_exit(2)\n"
"            \n"
"    # Canonicalize the repository path.\n"
"    wc_path = svn.core.svn_path_canonicalize(args[0])\n"
"\n"
"    # Do the real work.\n"
"    try:\n"
"        do_status(wc_path, verbose)\n"
"    except svn.core.SubversionException, e:\n"
"        sys.stderr.write(\"Error (%d): %s\\n\" % (e[1], e[0]))\n"
"        sys.exit(1)\n"

#: build/en/book.xml:17592(para)
msgid "As was the case in <xref linkend=\"svn.developer.usingapi.otherlangs.ex-1\"/>, this program is pool-free and uses, for the most part, normal Python data types. The call to <function moreinfo=\"none\">svn_client_ctx_t()</function> is deceiving because the public Subversion API has no such function—this just happens to be a case where SWIG's automatic language generation bleeds through a little bit (the function is a sort of factory function for Python's version of the corresponding complex C structure). Also note that the path passed to this program (like the last one) gets run through <function moreinfo=\"none\">svn_path_canonicalize()</function>, because to <emphasis>not</emphasis> do so runs the risk of triggering the underlying Subversion C library's assertions about such things, which translate into rather immediate and unceremonious program abortion."
msgstr ""

#: build/en/book.xml:17620(title)
msgid "Subversion Complete Reference"
msgstr "Subversion完全参考"

#: build/en/book.xml:17622(para)
msgid "This chapter is intended to be a complete reference to using Subversion. This includes the command line client (<command moreinfo=\"none\">svn</command>) and all its subcommands, as well as the repository administration programs (<command moreinfo=\"none\">svnadmin</command> and <command moreinfo=\"none\">svnlook</command>) and their respective subcommands."
msgstr "本章是使用Subversion的一个完全手册，包括了命令行客户端（<command moreinfo=\"none\">svn</command>）和它的所有子命令，也有版本库管理程序（<command moreinfo=\"none\">svnadmin</command>和<command moreinfo=\"none\">svnlook</command>）和它们各自的子命令。"

#: build/en/book.xml:17634(title)
msgid "The Subversion Command Line Client: <command moreinfo=\"none\">svn</command>"
msgstr "Subversion命令行客户端：<command moreinfo=\"none\">svn</command>"

#: build/en/book.xml:17636(para)
msgid "To use the command line client, you type <command moreinfo=\"none\">svn</command>, the subcommand you wish to use <placeholder-1/>, and any switches or targets that you wish to operate on—there is no specific order that the subcommand and the switches must appear in. For example, all of the following are valid ways to use <command moreinfo=\"none\">svn status</command>:"
msgstr "为了使用命令行客户端，只需要输入<command moreinfo=\"none\">svn</command>和它的子命令<footnote><placeholder-1/></footnote>以及相关的选项或操作的对象—输入的子命令和选项没有特定的顺序，下面使用<command moreinfo=\"none\">svn status</command>的方式都是合法的："

#: build/en/book.xml:17638(para)
msgid "Yes, yes, you don't need a subcommand to use the <option>--version</option> switch, but we'll get to that in just a minute."
msgstr "是的，使用<option>--version</option>选项不需要子命令，几分钟后我们会到达那个部分。"

#: build/en/book.xml:1764(para)
msgid "It's important to note that working copies do not always correspond to any single revision in the repository; they may contain files from several different revisions. For example, suppose you check out a working copy from a repository whose most recent revision is 4:"
msgstr "需要特别注意的是，工作拷贝并不一定对应版本库中的单个修订版本，他们可能包含多个修订版本的文件。举个例子，你从版本库检出一个工作拷贝，最近的修订号是4："

#: build/en/book.xml:17646(screen)
#, no-wrap
msgid ""
"\n"
"$ svn -v status\n"
"$ svn status -v \n"
"$ svn status -v myfile\n"
msgstr ""
"\n"
"$ svn -v status\n"
"$ svn status -v \n"
"$ svn status -v myfile\n"

#: build/en/book.xml:17652(para)
msgid "You can find many more examples of how to use most client commands in <xref linkend=\"svn.tour\"/> and commands for managing properties in <xref linkend=\"svn.advanced.props\"/>."
msgstr "你可以在<xref linkend=\"svn.tour\"/>发现更多使用客户端命令的例子，以及<xref linkend=\"svn.advanced.props\"/>中的管理属性的命令。"

#: build/en/book.xml:17658(title)
msgid "<command moreinfo=\"none\">svn</command> Switches"
msgstr "<command moreinfo=\"none\">svn</command>选项"

#: build/en/book.xml:17660(para)
msgid "While Subversion has different switches for its subcommands, all switches are global—that is, each switch is guaranteed to mean the same thing regardless of the subcommand you use it with. For example, <option>--verbose</option> (<option>-v</option>) always means <quote>verbose output</quote>, regardless of the subcommand you use it with."
msgstr "虽然Subversion的子命令有一些不同的选项，但有的选项是全局的—也就是说，每个选项保证是表示同样的事情，而不管是哪个子命令使用的。举个例子，<option>--verbose</option>（<option>-v</option>）一直意味着<quote>冗长输出</quote>，而不管使用它的命令是什么。"

#: build/en/book.xml:17671(option)
msgid "--auto-props"
msgstr "--auto-props"

#: build/en/book.xml:17673(para)
msgid "Enables auto-props, overriding the <literal moreinfo=\"none\">enable-auto-props</literal> directive in the <filename moreinfo=\"none\">config</filename> file."
msgstr "开启auto-props，覆盖<filename moreinfo=\"none\">config</filename>文件中的<literal moreinfo