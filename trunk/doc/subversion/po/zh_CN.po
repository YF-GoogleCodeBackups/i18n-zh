# Copyright (C) 2007 the Subversion Book team
#
# Authors:
# Dongsheng Song <dongsheng.song@gmail.com>, 2007
# Xun Leasun <leasun@gmail.com>
# Daijun Sun <daijun@gmail.com>
msgid ""
msgstr ""
"Project-Id-Version: Subversion Book\n"
"POT-Creation-Date: 2007-05-14 15:14+0800\n"
"PO-Revision-Date: 2007-05-08 18:22+0800\n"
"Last-Translator: Dongsheng Song <dongsheng.song@gmail.com>\n"
"Language-Team: Subversion Book team <svnbook-dev@red-bean.com>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: build/en/book.xml:3(title)
msgid "Version Control with Subversion"
msgstr "Subversion 权威指南"

#: build/en/book.xml:7(subtitle)
msgid "For Subversion 1.4"
msgstr "针对 Subversion 1.4"

#. don't seem to render it.
#: build/en/book.xml:11(subtitle)
msgid "(Compiled from r2798)"
msgstr "(本书由 r2798 版本构建)"

#: build/en/book.xml:13(edition)
msgid "Second"
msgstr ""

#: build/en/book.xml:14(isbn)
msgid "?-?????-???-?"
msgstr "?-?????-???-?"

#: build/en/book.xml:18(firstname)
msgid "Ben"
msgstr "Ben"

#: build/en/book.xml:19(surname)
msgid "Collins-Sussman"
msgstr "Collins-Sussman"

#: build/en/book.xml:23(firstname)
msgid "Brian W."
msgstr "Brian W."

#: build/en/book.xml:24(surname)
msgid "Fitzpatrick"
msgstr "Fitzpatrick"

#: build/en/book.xml:28(firstname)
msgid "C. Michael"
msgstr "C. Michael"

#: build/en/book.xml:29(surname)
msgid "Pilato"
msgstr "Pilato"

#: build/en/book.xml:35(firstname)
msgid "Tatiana"
msgstr "Tatiana"

#: build/en/book.xml:36(surname)
msgid "Apandi"
msgstr "Apandi"

#: build/en/book.xml:39(pagenums)
msgid "350 pages (est.)"
msgstr "大约 350 页"

#: build/en/book.xml:40(pubdate)
msgid "(TBA)"
msgstr "(TBA)"

#: build/en/book.xml:43(year)
msgid "2002"
msgstr "2002"

#: build/en/book.xml:44(year)
msgid "2003"
msgstr "2003"

#: build/en/book.xml:45(year)
msgid "2004"
msgstr "2004"

#: build/en/book.xml:46(year)
msgid "2005"
msgstr "2005"

#: build/en/book.xml:47(year)
msgid "2006"
msgstr "2006"

#: build/en/book.xml:48(year)
msgid "2007"
msgstr "2007"

#: build/en/book.xml:49(holder)
msgid "Ben Collins-Sussman"
msgstr "Ben Collins-Sussman"

#: build/en/book.xml:50(holder)
msgid "Brian W. Fitzpatrick"
msgstr "Brian W. Fitzpatrick"

#: build/en/book.xml:51(holder)
msgid "C. Michael Pilato"
msgstr "C. Michael Pilato"

#: build/en/book.xml:54(para)
msgid "This work is licensed under the Creative Commons Attribution License. To view a copy of this license, visit <ulink url=\"http://creativecommons.org/licenses/by/2.0/\"/> or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA."
msgstr ""

#: build/en/book.xml:73(firstname)
msgid "Karl"
msgstr "Karl"

#: build/en/book.xml:74(surname)
msgid "Fogel"
msgstr "Fogel"

#: build/en/book.xml:76(pubdate)
msgid "Chicago, March 14, 2004"
msgstr "芝加哥，2004 年 3 月 14 日"

#: build/en/book.xml:79(title)
msgid "Foreword"
msgstr "前言"

#: build/en/book.xml:81(para)
msgid "A bad Frequently Asked Questions (FAQ) sheet is one that is composed not of the questions people actually asked, but of the questions the FAQ's author <emphasis>wished</emphasis> people had asked. Perhaps you've seen the type before:"
msgstr "一个差劲的常见问题列表（FAQ）总是充斥着作者<emphasis>渴望被问到的</emphasis>问题，而不是人们真正想要了解的问题。也许你曾经见过下面这类问题："

#: build/en/book.xml:87(para)
msgid "Q: How can I use Glorbosoft XYZ to maximize team productivity?"
msgstr "Q：怎样使用Glorbosoft XYZ最大程度的提高团队生产率？"

#: build/en/book.xml:92(para)
msgid "A: Many of our customers want to know how they can maximize productivity through our patented office groupware innovations. The answer is simple: first, click on the <quote><literal moreinfo=\"none\">File</literal></quote> menu, scroll down to <quote><literal moreinfo=\"none\">Increase Productivity</literal></quote>, then…"
msgstr "A：许多客户希望知道怎样利用我们革命性的独创的办公套件最大程度的提高生产率。答案非常简单：首先，点击<quote><literal moreinfo=\"none\">文件</literal></quote> 菜单，找到<quote><literal moreinfo=\"none\">提高生产率</literal></quote>菜单项，然后…"

#: build/en/book.xml:100(para)
msgid "The problem with such FAQs is that they are not, in a literal sense, FAQs at all. No one ever called the tech support line and asked, <quote>How can we maximize productivity?</quote>. Rather, people asked highly specific questions, like, <quote>How can we change the calendaring system to send reminders two days in advance instead of one?</quote> and so on. But it's a lot easier to make up imaginary Frequently Asked Questions than it is to discover the real ones. Compiling a true FAQ sheet requires a sustained, organized effort: over the lifetime of the software, incoming questions must be tracked, responses monitored, and all gathered into a coherent, searchable whole that reflects the collective experience of users in the wild. It calls for the patient, observant attitude of a field naturalist. No grand hypothesizing, no visionary pronouncements here—open eyes and accurate note-taking are what's needed most."
msgstr "类似的问题完全不符合FAQ的精神。没人会打电话给技术支援中心，询问<quote>怎样提高生产率？</quote>相反，人们经常询问一些非常具体的问题，像<quote>怎样让日程系统提前两天而不是一天提醒相关用户？</quote>等等。但是想象比发现真正的问题更容易。构建一个真实的问题列表需要持之以恒的、有组织的辛勤工作：跨越整个软件生命周期，追踪新提出的问题，监控反馈信息，所有的问题要整理成一个统一的、可查询的整体，并且能够真实的反映所有用户的感受。这需要耐心，如自然学家一样严谨的态度，没有浮华的假设，没有虚幻的断言—相反的，需要开放的视野和精确的记录。"

#: build/en/book.xml:117(para)
msgid "What I love about this book is that it grew out of just such a process, and shows it on every page. It is the direct result of the authors' encounters with users. It began with Ben Collins-Sussman's observation that people were asking the same basic questions over and over on the Subversion mailing lists: What are the standard workflows to use with Subversion? Do branches and tags work the same way as in other version control systems? How can I find out who made a particular change?"
msgstr "我很喜欢这本书，因为它正是按照这种精神建立起来的，这种精神体现在本书的每一页中。这是作者与用户直接交流的结果。而这一切是源于Ben Collins-Sussman's对于Subversion常见问题邮件列表的研究。他发现人们总是在邮件列表中重复询问一些基本问题：使用subversion的一般程序是怎样的？分支与标签同其它版本控制系统的工作方式一样吗？我怎样知道某一处修改是谁做的？"

#: build/en/book.xml:126(para)
msgid "Frustrated at seeing the same questions day after day, Ben worked intensely over a month in the summer of 2002 to write <citetitle>The Subversion Handbook</citetitle>, a sixty page manual that covered all the basics of using Subversion. The manual made no pretense of being complete, but it was distributed with Subversion and got users over that initial hump in the learning curve. When O'Reilly and Associates decided to publish a full-length Subversion book, the path of least resistance was obvious: just expand the Subversion handbook."
msgstr "日复一日看到相同问题的烦闷，促使Ben在2002年的夏天努力工作了一个月，撰写了一本<citetitle>Subversion手册</citetitle>，一本六十页厚的、涵盖了所有Subversion使用基础知识的手册。这本手册没有说明最终定稿的时间，但它随着Subversion的每个版本一起发布，帮助许多用户跨过学习之初的艰难。当O'Reilly和Associates决定出版一本完备的Subversion图书的时候，一条捷径浮出水面：扩充Subversion手册。"

#: build/en/book.xml:137(para)
msgid "The three co-authors of the new book were thus presented with an unusual opportunity. Officially, their task was to write a book top-down, starting from a table of contents and an initial draft. But they also had access to a steady stream—indeed, an uncontrollable geyser—of bottom-up source material. Subversion was already in the hands of thousands of early adopters, and those users were giving tons of feedback, not only about Subversion, but about its existing documentation."
msgstr "新书的三位合著者因而面临着一个不寻常的机会。从职责上讲，他们的任务是从一个目录和一些草稿为基础，自上而下的写一部专著。但事实上，他们的灵感源泉则来自一些具体的内容，稳定却难以组织。Subversion被数以千计的早期用户采用，这些用户提供了大量的反馈，不仅仅针对Subversion，还包括业已存在的文档。"

#: build/en/book.xml:147(para)
#, fuzzy
msgid "During the entire time they wrote this book, Ben, Mike, and Brian haunted the Subversion mailing lists and chat rooms incessantly, carefully noting the problems users were having in real-life situations. Monitoring such feedback was part of their job descriptions at CollabNet anyway, and it gave them a huge advantage when they set out to document Subversion. The book they produced is grounded firmly in the bedrock of experience, not in the shifting sands of wishful thinking; it combines the best aspects of user manual and FAQ sheet. This duality might not be noticeable on a first reading. Taken in order, front to back, the book is simply a straightforward description of a piece of software. There's the overview, the obligatory guided tour, the chapter on administrative configuration, some advanced topics, and of course a command reference and troubleshooting guide. Only when you come back to it later, seeking the solution to some specific problem, does its authenticity shine out: the telling details that can only result from encounters with the unexpected, the examples honed from genuine use cases, and most of all the sensitivity to the user's needs and the user's point of view."
msgstr "在写这本书的过程里，Ben，Mike 和 Brian一直像鬼魂一样游荡在Subversion邮件列表和聊天室中，仔细的研究用户实际遇到的问题。监视这些反馈是他们在CollabNet工作的一部分，这给他们撰写Subversion文档提供了巨大的便利。这本书建立在丰富的使用经验，而非在流沙般脆弱的想象之上，它结合了用户手册和FAQ的优点。初次阅读时，这种二元性的优势并不明显，按照顺序，从前到后，这本书只是简单的从头到尾描述了软件的细节。书中的内容包括一章概述，一章必不可少的快速指南，一章关于管理配置，一些高级主题，当然还包括命令参考手册和故障排除指南。而当你过一段时间之后，再次翻开本书查找一些特定问题的解决方案时，这种二元性才得以显现：这些生动的细节一定来自不可预测的实际用例的提炼，大多是源于用户的需要和视点。"

#: build/en/book.xml:168(para)
msgid "Of course, no one can promise that this book will answer every question you have about Subversion. Sometimes, the precision with which it anticipates your questions will seem eerily telepathic; yet occasionally, you will stumble into a hole in the community's knowledge, and come away empty-handed. When this happens, the best thing you can do is email <email>users@subversion.tigris.org</email> and present your problem. The authors are still there, still watching, and they include not just the three listed on the cover, but many others who contributed corrections and original material. From the community's point of view, solving your problem is merely a pleasant side effect of a much larger project—namely, slowly adjusting this book, and ultimately Subversion itself, to more closely match the way people actually use it. They are eager to hear from you not merely because they can help you, but because you can help them. With Subversion as with all active free software projects, <emphasis>you are not alone</emphasis>."
msgstr "当然，没人可以承诺这本书可以回答所有问题。尽管有时候一些前人提问的惊人一致性让你感觉是心灵感应；你仍有可能在社区的知识库里摔跤，空手而归。如果有这种情况，最好的办法是写明问题发送email到<email>users@subversion.tigris.org</email>，作者还在那里关注着社区，不仅仅封面提到的三位，还包括许多曾经作出修正与提供原始材料的人。从社区的视角，帮你解决问题只是逐步的调整这本书，进一步调整Subversion本身以更合理的适合用户使用这样一个大工程的一个有趣的额外效用。他们渴望你的信息，不仅仅可以帮助你，也因为可以帮助他们。与Subversion这样活跃的自由软件项目一起，<emphasis>你并不孤单</emphasis>。"

#: build/en/book.xml:187(para)
msgid "Let this book be your first companion."
msgstr "让这本书将成为你的第一个伙伴。"

#: build/en/book.xml:198(title)
msgid "Preface"
msgstr "序言"

#: build/en/book.xml:201(attribution)
msgid "Greg Hudson"
msgstr "Greg Hudson"

#: build/en/book.xml:202(quote)
msgid "It is important not to let the perfect become the enemy of the good, even when you can agree on what perfect is. Doubly so when you can't. As unpleasant as it is to be trapped by past mistakes, you can't make any progress by being afraid of your own shadow during design."
msgstr ""

#: build/en/book.xml:209(para)
#, fuzzy
msgid "<indexterm significance=\"normal\"><primary>Concurrent Versions System (CVS)</primary></indexterm> In the world of open-source software, the Concurrent Versions System (CVS) was the tool of choice for version control for many years. And rightly so. CVS was open-source software itself, and its non-restrictive modus operandi and support for networked operation allowed dozens of geographically dispersed programmers to share their work. It fit the collaborative nature of the open-source world very well. CVS and its semi-chaotic development model have since become cornerstones of open-source culture."
msgstr "在开源软件世界，长久以来，并行版本系统（CVS）一直是版本控制工具的唯一选择。事实证明，这个选择不错。CVS的自由软件身份，无约束的<foreignphrase>处事态度</foreignphrase>，和对网络化操作的支持（网络使众多身处不同地方的程序员可以共享他们的工作成果），正符合了开源世界协作的精神。CVS和它半混乱状态的开发模式已成为开源文化的基石。"

#: build/en/book.xml:224(para)
#, fuzzy
msgid "But CVS was not without its flaws, and simply fixing those flaws promised to be an enormous effort. Enter Subversion. Designed to be a successor to CVS, Subversion's originators set out to win the hearts of CVS users in two ways—by creating an open-source system with a design (and <quote>look and feel</quote>) similar to CVS, and by attempting to avoid most of CVS's noticeable flaws. While the result isn't necessarily the next great evolution in version control design, Subversion <emphasis>is</emphasis> very powerful, very usable, and very flexible. And for the most part, almost all newly-started open-source projects now choose Subversion instead of CVS."
msgstr "但是，和其它许多工具一样，CVS逐渐显露出衰老的迹象。而Subversion，则是以CVS继任者的面目出现的新型版本控制系统。Subversion的设计者们力图通过两方面的努力赢得CVS用户的青睐：保持构建开源软件版本控制系统的方式（以及视觉和感觉上）与CVS尽可能类似，同时尽力弥补CVS许多显著的缺陷。这些努力的结果使得从CVS迁移到Subversion不需要作出重大的变革，Subversion确实是非常强大、非常有用和非常灵活的工具。"

#: build/en/book.xml:236(para)
#, fuzzy
msgid "This book is written to document the 1.4 series of the Subversion version control system. We have made every attempt to be thorough in our coverage. However, Subversion has a thriving and energetic development community, so there are already a number of features and improvements planned for future versions of Subversion that may change some of the commands and specific notes in this book."
msgstr "本书是为Subversion 1.4系列撰写的。在书中，我们尽力涵盖Subversion的所有内容。但是，Subversion有一个兴盛和充满活力的开发社区，已有许多新的特性和改进措施计划在新版本的Subversion中实现，本书中讲述的命令和特性可能会有所变化。"

#: build/en/book.xml:250(title)
msgid "Audience"
msgstr "读者"

#: build/en/book.xml:252(para)
#, fuzzy
msgid "This book is written for computer-literate folk who want to use Subversion to manage their data. While Subversion runs on a number of different operating systems, its primary user interface is command-line based. That command-line tool (<command moreinfo=\"none\">svn</command>) and auxiliary program are the focus of this book."
msgstr "本书是为了那些在计算机领域有丰富知识，并且希望使用Subversion管理数据的人士准备的。尽管Subversion可以在多种不同的操作系统上运行，但其基本用户操作界面是工作于命令行界面下的，也就是我们将要在本书中讲述和使用的命令行工具（<command moreinfo=\"none\">svn</command>）。出于一致性的考虑，本书的例子假定读者使用的是类Unix的操作系统，并且熟悉Unix和命令行界面。"

#: build/en/book.xml:259(para)
#, fuzzy
msgid "For consistency, the examples in this book assume the reader is using a Unix-like operating system and relatively comfortable with Unix and command-line interfaces. That said, the <command moreinfo=\"none\">svn</command> program also runs on non-Unix platforms like Microsoft Windows. With a few minor exceptions, such as the use of backward slashes (<literal moreinfo=\"none\">\\</literal>) instead of forward slashes (<literal moreinfo=\"none\">/</literal>) for path separators, the input to and output from this tool when run on Windows are identical to its Unix counterpart."
msgstr "同样，<command moreinfo=\"none\">svn</command>程序也可以在入Microsoft Windows这样的非Unix平台上运行。除了一些微小的不同，如使用反斜线（<literal moreinfo=\"none\">\\</literal>）代替正斜线（<literal moreinfo=\"none\">/</literal>）作为路径分隔符，在Windows上运行svn程序的输入和输出与在Unix平台上运行完全一致。不过在Cygwin（Windows下的模拟Unix的环境）运行本书的例子可能更容易成功。"

#: build/en/book.xml:269(para)
#, fuzzy
msgid "Most readers are probably programmers or system administrators who need to track changes to source code. This is the most common use for Subversion, and therefore it is the scenario underlying all of the book's examples. But Subversion can be used to manage changes to any sort of information—images, music, databases, documentation, and so on. To Subversion, all data is just data."
msgstr "大多数读者可能是那些需要跟踪代码变化的程序员或者系统管理员。这是Subversion最普遍的用途，因此这个场景贯穿于整本书的例子中。但是Subversion是可以用来管理任何类型的数据：图像、音乐、数据库、文档，等等。对于Subversion，数据不过是数据而已。"

#: build/en/book.xml:277(para)
#, fuzzy
msgid "While this book is written with the assumption that the reader has never used a version control system, we've also tried to make it easy for users of CVS (and other systems) to make a painless leap into Subversion. Special sidebars may mention other version control systems from time to time, and a special appendix summarizes many of the differences between CVS and Subversion."
msgstr "本书假定读者从来没有使用过任何版本控制工具，同时，我们也努力使CVS用户能够轻而易举的跃入Subversion中。有时某些条目可能会涉及到CVS，此外，在附录的一个章节中总结了Subversion和CVS的区别。"

#: build/en/book.xml:285(para)
#, fuzzy
msgid "Note also that the source code examples used throughout the book are only examples. While they will compile with the proper compiler incantations, they are intended to illustrate a particular scenario, not necessarily serve as examples of good programming style or practices."
msgstr "需要说明的是，所有源代码示例仅仅是例子而已。这些例子需要通过正确编译参数进行编译，在这里列举它们只是为了说明眼前的问题，并非为了展示优秀的编码风格。"

#: build/en/book.xml:297(title)
msgid "How to Read this Book"
msgstr "怎样阅读本书"

#: build/en/book.xml:299(para)
msgid "This book aims to be useful to people of widely different backgrounds—from people with no previous experience in version control to experienced system administrators. Depending on your own background, certain chapters may be more or less important to you. The following can be considered a <quote>recommended reading list</quote> for various types of readers:"
msgstr "本书适用于具有不同背景知识的各个层次的读者—从未使用过版本控制的新手到经验丰富的系统管理员都能够从本书中获益。根据基础的不同，某些的章节可能对某些读者更有价值。下面的内容可以看作是为不同类型的读者提供的<quote>推荐阅读清单</quote>："

#: build/en/book.xml:309(term)
msgid "Experienced System Administrators"
msgstr "资深系统管理员"

#: build/en/book.xml:311(para)
#, fuzzy
msgid "The assumption here is that you've probably used version control before before, and are dying to get a Subversion server up and running ASAP. <xref linkend=\"svn.reposadmin\"/> and <xref linkend=\"svn.serverconfig\"/> will show you how to create your first repository and make it available over the network. After that's done, <xref linkend=\"svn.tour\"/> and <xref linkend=\"svn.forcvs\"/> are the fastest routes to learning the Subversion client."
msgstr "假设你从前使用过CVS，并且迫切需要建立起Subversion服务器并尽快运行起来，<xref linkend=\"svn.reposadmin\"/>和<xref linkend=\"svn.serverconfig\"/>将会告诉你如何建立起一个版本库，并使之加入网络大家庭。此后，依靠你的CVS使用经验，<xref linkend=\"svn.tour\"/>和<xref linkend=\"svn.forcvs\"/>将向你展示怎样使用Subversion客户端软件。"

#: build/en/book.xml:325(term)
msgid "New users"
msgstr "新用户"

#: build/en/book.xml:327(para)
#, fuzzy
msgid "Your administrator has probably set up Subversion already, and you need to learn how to use the client. If you've never used a version control system, then <xref linkend=\"svn.basic\"/> is a vital introduction to the ideas behind version control. <xref linkend=\"svn.tour\"/> is a guided tour of the Subversion client."
msgstr "如果管理员已经为你准备好了Subversion服务，你所需要的是学习如何使用客户端。如果你没有使用版本控制系统（像CVS）的经验，那么<xref linkend=\"svn.basic\"/>和<xref linkend=\"svn.tour\"/>是重要的入门教程。如果你已经是CVS的老手，第3章和附录A将是不错的开始。"

#: build/en/book.xml:337(term)
msgid "Advanced users"
msgstr "高级用户"

#: build/en/book.xml:339(para)
#, fuzzy
msgid "Whether you're a user or administrator, eventually your project will grow larger. You're going to want to learn how to do more advanced things with Subversion, such as how to use branches and perform merges (<xref linkend=\"svn.branchmerge\"/>), how to use Subversion's property support (<xref linkend=\"svn.advanced\"/>), how to configure runtime options (<xref linkend=\"svn.customization\"/>), and other things. These chapters aren't critical at first, but be sure to read them once you're comfortable with the basics."
msgstr "无论是用户还是管理员，项目终将会壮大起来。那时，就需要学习更多Subversion的高级功能，像如何使用分支和执行合并（<xref linkend=\"svn.branchmerge\"/>）、怎样使用Subversion的属性支持、怎样配制运行参数（<xref linkend=\"svn.advanced\"/>）等等。这两章在学习的初期并不重要，但熟悉了基本操作之后还是非常有必要了解一下的。"

#: build/en/book.xml:351(term)
msgid "Developers"
msgstr "开发者"

#: build/en/book.xml:353(para)
msgid "Presumably, you're already familiar with Subversion, and now want to either extend it or build new software on top of its many APIs. <xref linkend=\"svn.developer\"/> is just for you."
msgstr "你应该已经很熟悉Subversion了，并且想扩展它并使用它的API开发新软件。<xref linkend=\"svn.developer\"/>将最适合你。"

#: build/en/book.xml:361(para)
msgid "The book ends with reference material—<xref linkend=\"svn.ref\"/> is a reference guide for all Subversion commands, and the appendices cover a number of useful topics. These are the chapters you're mostly likely to come back to after you've finished the book."
msgstr "本书以参考材料作为结束—<xref linkend=\"svn.ref\"/>是一部Subversion全部命令的详细指南，此外，在附录中还有许多很有意义的主题。阅读完本书后，这些章节将会是你经常查阅的内容。"

#: build/en/book.xml:372(title)
msgid "Conventions Used in This Book"
msgstr "本书约定"

#: build/en/book.xml:374(para)
msgid "This section covers the various conventions used in this book."
msgstr "本节描述了本书中使用的各种约定。"

#: build/en/book.xml:379(title)
msgid "Typographic Conventions"
msgstr "排版习惯"

#: build/en/book.xml:384(command)
msgid "Constant width"
msgstr "等宽字体"

#: build/en/book.xml:386(para)
msgid "Used for commands, command output, and switches"
msgstr "用于命令，命令输出和开关"

#: build/en/book.xml:391(replaceable)
msgid "Constant width italic"
msgstr "等宽斜体"

#: build/en/book.xml:393(para)
msgid "Used for replaceable items in code and text"
msgstr "用于代码和文本中的可替换部分"

#: build/en/book.xml:398(filename)
msgid "Italic"
msgstr "斜体"

#: build/en/book.xml:400(para)
msgid "Used for file and directory names"
msgstr "用于文件和路径名"

#: build/en/book.xml:410(title)
msgid "Icons"
msgstr "图标"

#: build/en/book.xml:413(para)
msgid "This icon designates a note relating to the surrounding text."
msgstr "此图标表示旁边的文本内容需特别注意。"

#: build/en/book.xml:418(para)
msgid "This icon designates a helpful tip relating to the surrounding text."
msgstr "此图标表示旁边的文本描述了一个有用的小技巧。"

#: build/en/book.xml:423(para)
msgid "This icon designates a warning relating to the surrounding text."
msgstr "此图标表示旁边的文本是警告信息。"

#: build/en/book.xml:434(title)
msgid "Organization of This Book"
msgstr "本书的结构"

#: build/en/book.xml:436(para)
msgid "The chapters that follow and their contents are listed here:"
msgstr "以下是各个章节的内容介绍："

#: build/en/book.xml:444(para)
#, fuzzy
msgid "Covers the history of Subversion as well as its features, architecture, and components."
msgstr "回顾了Subversion的历史，描述了Subversion的特性、架构、组件和安装方法。还包含了一个快速入门指南。"

#: build/en/book.xml:452(para)
msgid "Explains the basics of version control and different versioning models, along with Subversion's repository, working copies, and revisions."
msgstr "介绍了版本控制的基础知识及不同的版本模型，同时讲述了Subversion的版本库，工作拷贝和修订版本的概念。"

#: build/en/book.xml:461(para)
#, fuzzy
msgid "Walks you through a day in the life of a Subversion user. It demonstrates how to use a Subversion client to obtain, modify, and commit data."
msgstr "引领你开始一个Subversion用户的工作。示范怎样使用Subversion获得、修改和提交数据。"

#: build/en/book.xml:470(para)
msgid "Covers more complex features that regular users will eventually come into contact with, such as versioned metadata, file locking, and peg revisions."
msgstr ""

#: build/en/book.xml:479(para)
msgid "Discusses branches, merges, and tagging, including best practices for branching and merging, common use cases, how to undo changes, and how to easily swing from one branch to the next."
msgstr "讨论分支、合并与标签，包括最佳实践的介绍，常见用例的描述，以及怎样取消修改，和怎样从一个分支转到另一个分支。"

#: build/en/book.xml:489(para)
msgid "Describes the basics of the Subversion repository, how to create, configure, and maintain a repository, and the tools you can use to do all of this."
msgstr "讲述Subversion版本库的基本概念，怎样建立、配置和维护版本库，以及哪些工具可以完成上述的工作。"

#: build/en/book.xml:498(para)
#, fuzzy
msgid "Explains how to configure your Subversion server and the three ways to access your repository: <literal moreinfo=\"none\">HTTP</literal>, the <literal moreinfo=\"none\">svn</literal> protocol, and local disk access. It also covers the details of authentication, authorization and anonymous access."
msgstr "描述了如何配置Subversion服务器，以及三种访问版本库的方式，<literal moreinfo=\"none\">HTTP</literal>、<literal moreinfo=\"none\">svn</literal>协议和本地访问。这里也介绍了认证的细节，以及授权与匿名访问方式。"

#: build/en/book.xml:510(para)
msgid "Explores the Subversion client configuration files, the handling of internationalized text, and how to make external tools cooperate with Subversion."
msgstr ""

#: build/en/book.xml:519(para)
msgid "Describes the internals of Subversion, the Subversion filesystem, and the working copy administrative areas from a programmer's point of view. Demonstrates how to use the public APIs to write a program that uses Subversion, and most importantly, how to contribute to the development of Subversion."
msgstr "介绍了Subversion的核心部件、Subversion的文件系统，以及程序员眼中的工作拷贝管理区域，展示了如何使用公共API编写Subversion应用程序。最重要的内容是，如何为Subversion的开发贡献力量。"

#: build/en/book.xml:531(para)
msgid "Explains in great detail every subcommand of <command moreinfo=\"none\">svn</command>, <command moreinfo=\"none\">svnadmin</command>, and <command moreinfo=\"none\">svnlook</command> with plenty of examples for the whole family!"
msgstr "以大量的实例，详细描述了<command moreinfo=\"none\">svn</command>、<command moreinfo=\"none\">svnadmin</command>和<command moreinfo=\"none\">svnlook</command>的所有子命令。"

#: build/en/book.xml:541(para)
msgid "For the impatient, a whirlwind explanation of how to install Subversion and start using it immediately. You have been warned."
msgstr ""

#: build/en/book.xml:550(para)
msgid "Covers the similarities and differences between Subversion and CVS, with numerous suggestions on how to break all the bad habits you picked up from years of using CVS. Included are descriptions of Subversion revision numbers, versioned directories, offline operations, <command moreinfo=\"none\">update</command> vs. <command moreinfo=\"none\">status</command>, branches, tags, metadata, conflict resolution, and authentication."
msgstr "详细比较了Subversion与CVS的异同，并针对如何消除多年使用CVS养成的坏习惯提出建议。内容包括subversion版本号、目录的版本化、离线操作、<command moreinfo=\"none\">update</command>与<command moreinfo=\"none\">status</command>的对比、分支、标签、元数据、冲突处理和认证。"

#: build/en/book.xml:564(para)
msgid "Describes the details of WebDAV and DeltaV, and how you can configure your Subversion repository to be mounted read/write as a DAV share."
msgstr "描述了WebDAV与DeltaV的细节内容，并介绍了如何将Subversion版本库作为可读/写的DAV共享装载。"

#: build/en/book.xml:573(para)
msgid "Discusses tools that support or use Subversion, including alternative client programs, repository browser tools, and so on."
msgstr "讨论一些支持和使用Subversion的工具，包括其它客户端工具，版本库浏览工具等等。"

#: build/en/book.xml:588(title)
msgid "This Book is Free"
msgstr "本书是免费的"

#: build/en/book.xml:590(para)
#, fuzzy
msgid "This book started out as bits of documentation written by Subversion project developers, which were then coalesced into a single work and rewritten. As such, it has always been under a free license. (See <xref linkend=\"svn.copyright\"/>.) In fact, the book was written in the public eye, originally as a part of Subversion project itself. This means two things:"
msgstr "本书最初是作为Subversion项目的文档由Subversion的开发者开始撰写的，后来成为一个独立的项目并进行了重写。与Subversion相同，它始终按免费许可证（见<xref linkend=\"svn.copyright\"/>）发布。事实上，本书是在公众的关注中写作出来，并作为Subversion的一部分。这有两种含义："

#: build/en/book.xml:599(para)
msgid "You will always find the latest version of this book in the book's own Subversion repository."
msgstr "总可以在Subversion的版本库里找到本书的最新版本。"

#: build/en/book.xml:604(para)
#, fuzzy
msgid "You can make changes to this book and redistribute it however you wish—it's under a free license. Your only obligation is to maintain proper attribution to the original authors. Of course, rather than distribute your own private version of this book, we'd much rather you send feedback and patches to the Subversion developer community."
msgstr "可以任意分发或修改本书—它在免费许可证的控制之下。当然，与其独自发布私有版本，不如向Subversion开发社区提供反馈和修正信息。参见<xref linkend=\"svn.developer.contrib\"/>了解如何加入社区。"

#. O'REILLY SHOULD TWEAK THIS PARAGRAPH
#: build/en/book.xml:614(para)
msgid "The online home of this book's development and most of the volunteer-driven translation efforts around it is <ulink url=\"http://svnbook.red-bean.com\"/>. There, you can find links to the latest snapshots and tagged versions of the book in various formats, as well as instructions for accessing the book's Subversion repository (where lives its DocBook XML source code). Feedback is welcome—encouraged, even. Please submit all comments, complaints, and patches against the book sources to <email>svnbook-dev@red-bean.com</email>."
msgstr ""

#: build/en/book.xml:629(title)
msgid "Acknowledgments"
msgstr "致谢"

#: build/en/book.xml:637(para)
msgid "Oh, and thanks, Karl, for being too overworked to write this book yourself."
msgstr "噢，还要感谢Karl为了本书所付出的辛勤工作。"

#: build/en/book.xml:631(para)
#, fuzzy
msgid "This book would not be possible (nor very useful) if Subversion did not exist. For that, the authors would like to thank Brian Behlendorf and CollabNet for the vision to fund such a risky and ambitious new Open Source project; Jim Blandy for the original Subversion name and design—we love you, Jim; Karl Fogel for being such a good friend and a great community leader, in that order.<placeholder-1/>"
msgstr "没有Subversion就不可能有（即使有也没什么价值）这本书。所以作者衷心感谢Brian Behlendorf和CollabNet，他们独到的眼光开创了这个冒险但雄心勃勃的开源项目；Jim Blandy贡献了Subversion这个名字和最初的设计—我们爱你，Jim。还有Karl Fogel，一个好朋友和伟大的社区领袖。<footnote><placeholder-1/></footnote>"

#: build/en/book.xml:641(para)
msgid "Thanks to O'Reilly and our editors, Linda Mui and Tatiana Diaz for their patience and support."
msgstr "感谢O'Reilly和我们的编辑Linda Mui和Tatiana对我们的耐心和支持。"

#: build/en/book.xml:644(para)
#, fuzzy
msgid "Finally, we thank the countless people who contributed to this book with informal reviews, suggestions, and fixes: While this is undoubtedly not a complete list, this book would be incomplete and incorrect without the help of: David Anderson, Jani Averbach, Ryan Barrett, Francois Beausoleil, Jennifer Bevan, Matt Blais, Zack Brown, Martin Buchholz, Brane Cibej, John R. Daily, Peter Davis, Olivier Davy, Robert P. J. Day, Mo DeJong, Brian Denny, Joe Drew, Nick Duffek, Ben Elliston, Justin Erenkrantz, Shlomi Fish, Julian Foad, Chris Foote, Martin Furter, Dave Gilbert, Eric Gillespie, David Glasser, Matthew Gregan, Art Haas, Eric Hanchrow, Greg Hudson, Alexis Huxley, Jens B. Jorgensen, Tez Kamihira, David Kimdon, Mark Benedetto King, Andreas J. Koenig, Nuutti Kotivuori, Matt Kraai, Scott Lamb, Vincent Lefevre, Morten Ludvigsen, Paul Lussier, Bruce A. Mah, Philip Martin, Feliciano Matias, Patrick Mayweg, Gareth McCaughan, Jon Middleton, Tim Moloney, Christopher Ness, Mats Nilsson, Joe Orton, Amy Lyn Pilato, Kevin Pilch-Bisson, Dmitriy Popkov, Michael Price, Mark Proctor, Steffen Prohaska, Daniel Rall, Jack Repenning, Tobias Ringstrom, Garrett Rooney, Joel Rosdahl, Christian Sauer, Larry Shatzer, Russell Steicke, Sander Striker, Erik Sjoelund, Johan Sundstroem, John Szakmeister, Mason Thomas, Eric Wadsworth, Colin Watson, Alex Waugh, Chad Whitacre, Josef Wolf, Blair Zajac, and the entire Subversion community."
msgstr "最后，我们要感谢数不清的曾经为本书作出贡献的人们，他们进行了非正式的审阅，并给出了大量建议和修改意见。虽然无法列出一个完整的列表，但本书的完整和正确离不开：Jani Averbach, Ryan Barrett, Francois Beausoleil, Jennifer Bevan, Matt Blais, Zack Brown, Martin Buchholz, Brane Cibej, John R. Daily, Peter Davis, Olivier Davy, Robert P. J. Day, Mo DeJong, Brian Denny, Joe Drew, Nick Duffek, Ben Elliston, Justin Erenkrantz, Shlomi Fish, Julian Foad, Chris Foote, Martin Furter, Dave Gilbert, Eric Gillespie, Matthew Gregan, Art Haas, Greg Hudson, Alexis Huxley, Jens B. Jorgensen, Tez Kamihira, David Kimdon, Mark Benedetto King, Andreas J. Koenig, Nuutti Kotivuori, Matt Kraai, Scott Lamb, Vincent Lefevre, Morten Ludvigsen, Paul Lussier, Bruce A. Mah, Philip Martin, Feliciano Matias, Patrick Mayweg, Gareth McCaughan, Jon Middleton, Tim Moloney, Mats Nilsson, Joe Orton, Amy Lyn Pilato, Kevin Pilch-Bisson, Dmitriy Popkov, Michael Price, Mark Proctor, Steffen Prohaska, Daniel Rall, Tobias Ringstrom, Garrett Rooney, Joel Rosdahl, Christian Sauer, Larry Shatzer, Russell Steicke, Sander Striker, Erik Sjoelund, Johan Sundstroem, John Szakmeister, Mason Thomas, Eric Wadsworth, Colin Watson, Alex Waugh, Chad Whitacre, Josef Wolf, Blair Zajac, 以及整个Subversion社区。"

#: build/en/book.xml:671(title)
msgid "From Ben Collins-Sussman"
msgstr "来自 Ben Collins-Sussman"

#: build/en/book.xml:673(para)
msgid "Thanks to my wife Frances, who, for many months, got to hear, <quote>But honey, I'm still working on the book</quote>, rather than the usual, <quote>But honey, I'm still doing email.</quote> I don't know where she gets all that patience! She's my perfect counterbalance."
msgstr "感谢我的妻子Frances，在好几个月里，我一直在对你说：<quote>但是亲爱的，我还在为这本书工作</quote>，此外还有，<quote>但是亲爱的，我还在处理邮件</quote>。我不知道她为什么会如此耐心！她是我完美的平衡点。"

#: build/en/book.xml:679(para)
#, fuzzy
msgid "Thanks to my extended family and friends for their sincere encouragement, despite having no actual interest in the subject. (You know, the ones who say, <quote>Ooh, you wrote a book?</quote>, and then when you tell them it's a computer book, sort of glaze over.)"
msgstr "感谢我的家人对我的鼓励，无论他们是否真的对我的课题感兴趣。（你知道的，一个人说 <quote>哇，你正在写一本书？</quote>，然后当他知道你是写一本计算机书时，那种惊讶就变得没有那么多了。）"

#: build/en/book.xml:685(para)
msgid "Thanks to all my close friends, who make me a rich, rich man. Don't look at me that way—you know who you are."
msgstr "感谢我身边让我富有的朋友，不要那样看我—你们知道你们是谁。"

#: build/en/book.xml:688(para)
msgid "Thanks to my parents for the perfect low-level formatting, and being unbelievable role models. Thanks to my son for the opportunity to pass that on."
msgstr ""

#: build/en/book.xml:696(title)
msgid "From Brian W. Fitzpatrick"
msgstr "来自 Brian W. Fitzpatrick"

#. ### TODO(fitz):  update this?
#: build/en/book.xml:700(para)
msgid "Huge thanks to my wife Marie for being incredibly understanding, supportive, and most of all, patient. Thank you to my brother Eric who first introduced me to UNIX programming way back when. Thanks to my Mom and Grandmother for all their support, not to mention enduring a Christmas holiday where I came home and promptly buried my head in my laptop to work on the book."
msgstr "非常非常感谢我的妻子Marie的理解，支持和最重要的耐心。感谢引导我学会UNIX编程的兄弟Eric，感谢我的母亲和外祖母的支持，对我在圣诞夜里埋头工作的理解。"

#: build/en/book.xml:708(para)
msgid "To Mike and Ben: It was a pleasure working with you on the book. Heck, it's a pleasure working with you at work!"
msgstr "Mike和Ben：与你们一起工作非常快乐，Heck，我们在一起工作很愉快！"

#: build/en/book.xml:711(para)
msgid "To everyone in the Subversion community and the Apache Software Foundation, thanks for having me. Not a day goes by where I don't learn something from at least one of you."
msgstr "感谢所有在Subversion和Apache软件基金会的人们给我机会与你们在一起，没有一天我不从你们那里学到知识。"

#: build/en/book.xml:716(para)
msgid "Lastly, thanks to my Grandfather who always told me that <quote>freedom equals responsibility.</quote> I couldn't agree more."
msgstr "最后，感谢我的祖父，他一直跟我说<quote>自由等于责任</quote>，我深信不疑。"

#: build/en/book.xml:724(title)
msgid "From C. Michael Pilato"
msgstr "来自 C. Michael Pilato"

#: build/en/book.xml:726(para)
msgid "Special thanks to Amy, my best friend and wife of nine incredible years, for her love and patient support, for putting up with the late nights, and for graciously enduring the version control processes I've imposed on her. Don't worry, Sweetheart—you'll be a TortoiseSVN wizard in no time!"
msgstr ""

#: build/en/book.xml:733(para)
msgid "Gavin, there probably aren't many words in this book that you can successfully <quote>sound out</quote> at this stage, but when you've finally got a handle on the written form of this crazy language we speak, I hope you're as proud of your Daddy as he is of you."
msgstr ""

#: build/en/book.xml:742(para)
msgid "Translation: Daddy loves you and hopes you like computers as much as you like basketball, baseball, and football. (Wasn't that obvious?)"
msgstr ""

#: build/en/book.xml:739(para)
msgid "Aidan, Daddy luffoo et ope Aiduh yike contootoo as much as Aiduh yike batetball, base-ball, et bootball. <placeholder-1/>"
msgstr ""

#: build/en/book.xml:748(para)
msgid "Mom and Dad, thanks for your constant support and enthusiasm. Mom- and Dad-in-law, thanks for all of the same <emphasis>plus</emphasis> your fabulous daughter."
msgstr ""

#: build/en/book.xml:752(para)
msgid "Hats off to Shep Kendall, through whom the world of computers was first opened to me; Ben Collins-Sussman, my tour-guide through the open-source world; Karl Fogel—you <emphasis>are</emphasis> my <filename moreinfo=\"none\">.emacs</filename>; Greg Stein, for oozing practical programming know-how; Brian Fitzpatrick—for sharing this writing experience with me. To the many folks from whom I am constantly picking up new knowledge—keep dropping it!"
msgstr "向你们致敬，Shep Kendall，为我打开了通向计算机世界的大门；Ben Collins Sussman，我在开源世界的导师；Karl Fogel—你<emphasis>是</emphasis>我的<filename moreinfo=\"none\">.emacs</filename>；Greg Stain，让我在困境中知道怎样编程；Brain Fitzpatrick—同我分享他的写作经验。所有我曾经从你们那里获得知识的人—尽管又不断忘记。"

#: build/en/book.xml:761(para)
#, fuzzy
msgid "Finally, to the One who perfectly demonstrates creative excellence—thank You."
msgstr "最后，对所有为我展现完美卓越创造力的人们—感谢。"

#: build/en/book.xml:773(title)
msgid "What is Subversion?"
msgstr "Subversion 是什么？"

#: build/en/book.xml:775(para)
#, fuzzy
msgid "Subversion is a free/open-source version control system. That is, Subversion manages files and directories, and the changes made to them, over time. This allows you to recover older versions of your data, or examine the history of how your data changed. In this regard, many people think of a version control system as a sort of <quote>time machine</quote>."
msgstr "Subversion是一个自由/开源的版本控制系统。也就是说，在Subversion管理下，文件和目录可以超越时空。Subversion将文件存放在中心<firstterm>版本库</firstterm>里。这个版本库很像一个普通的文件服务器，不同的是，它可以记录每一次文件和目录的修改情况。于是我们就可以籍此将数据回复到以前的版本，并可以查看数据的更改细节。正因为如此，许多人将版本控制系统当作一种神奇的<quote>时间机器</quote>。"

#: build/en/book.xml:782(para)
#, fuzzy
msgid "Subversion can operate across networks, which allows it to be used by people on different computers. At some level, the ability for various people to modify and manage the same set of data from their respective locations fosters collaboration. Progress can occur more quickly without a single conduit through which all modifications must occur. And because the work is versioned, you need not fear that quality is the trade-off for losing that conduit—if some incorrect change is made to the data, just undo that change."
msgstr "Subversion的版本库可以通过网络访问，从而使用户可以在不同的电脑上进行操作。从某种程度上来说，允许用户在各自的空间里修改和管理同一组数据可以促进团队协作。因为修改不再是单线进行（单线进行也就是必须一个一个进行），开发进度会进展迅速。此外，由于所有的工作都已版本化，也就不必担心由于错误的更改而影响软件质量—如果出现不正确的更改，只要撤销那一次更改操作即可。"

#: build/en/book.xml:792(para)
msgid "Some version control systems are also software configuration management (SCM) systems. These systems are specifically tailored to manage trees of source code, and have many features that are specific to software development—such as natively understanding programming languages, or supplying tools for building software. Subversion, however, is not one of these systems. It is a general system that can be used to manage <emphasis>any</emphasis> collection of files. For you, those files might be source code—for others, anything from grocery shopping lists to digital video mixdowns and beyond."
msgstr "某些版本控制系统本身也是软件配置管理（SCM）系统，这种系统经过精巧的设计，专门用来管理源代码树，并且具备许多与软件开发有关的特性—比如，对编程语言的支持，或者提供程序构建工具。不过Subversion并不是这样的系统。它是一个通用系统，可以管理<emphasis>任何</emphasis>类型的文件集。对你来说，这些文件这可能是源程序—而对别人，则可能是一个货物清单或者是数字电影。"

#: build/en/book.xml:807(title)
msgid "Subversion's History"
msgstr "Subversion 的历史"

#: build/en/book.xml:809(para)
#, fuzzy
msgid "<indexterm significance=\"normal\"><primary>Subversion</primary><secondary>history of</secondary></indexterm> In early 2000, CollabNet, Inc. (<ulink url=\"http://www.collab.net\"/>) began seeking developers to write a replacement for CVS. CollabNet offers a collaboration software suite called CollabNet Enterprise Edition (CEE) of which one component is version control. Although CEE used CVS as its initial version control system, CVS's limitations were obvious from the beginning, and CollabNet knew it would eventually have to find something better. Unfortunately, CVS had become the de facto standard in the open source world largely because there <emphasis>wasn't</emphasis> anything better, at least not under a free license. So CollabNet determined to write a new version control system from scratch, retaining the basic ideas of CVS, but without the bugs and misfeatures."
msgstr "早在2000年，CollabNet, Inc. (<ulink url=\"http://www.collab.net\"/>)就开始寻找CVS替代产品的开发人员。CollabNet提供了一个名为CollabNet企业版（CEE） <footnote><placeholder-1/></footnote> 的协作软件套件。这个软件套件的一个组成部分就是版本控制系统。尽管CEE在最初采用了CVS作为其版本控制系统，但是CVS的局限性从一开始就很明显，CollabNet知道，迟早要找到一个更好的替代品。遗憾的是，CVS之所以成为开源世界<foreignphrase>事实上的</foreignphrase>标准，很大程度上是因为<emphasis>没有</emphasis>更好的替代品，至少是没有可以自由使用的替代品。所以CollabNet决定从头编写一个新的版本控制系统，这个系统保留CVS的基本思想，但是要修正其中的错误和不合理的特性。"

#: build/en/book.xml:829(para)
#, fuzzy
msgid "In February 2000, they contacted Karl Fogel, the author of <citetitle>Open Source Development with CVS</citetitle> (Coriolis, 1999), and asked if he'd like to work on this new project. Coincidentally, at the time Karl was already discussing a design for a new version control system with his friend Jim Blandy. In 1995, the two had started Cyclic Software, a company providing CVS support contracts, and although they later sold the business, they still used CVS every day at their jobs. Their frustration with CVS had led Jim to think carefully about better ways to manage versioned data, and he'd already come up with not only the name <quote>Subversion</quote>, but also with the basic design of the Subversion data store. When CollabNet called, Karl immediately agreed to work on the project, and Jim got his employer, Red Hat Software, to essentially donate him to the project for an indefinite period of time. CollabNet hired Karl and Ben Collins-Sussman, and detailed design work began in May. With the help of some well-placed prods from Brian Behlendorf and Jason Robbins of CollabNet, and Greg Stein (at the time an independent developer active in the WebDAV/DeltaV specification process), Subversion quickly attracted a community of active developers. It turned out that many people had had the same frustrating experiences with CVS, and welcomed the chance to finally do something about it."
msgstr "2000年2月，他们联系到<citetitle>Open Source Development with CVS</citetitle>(Coriolis, 1999)的作者Karl Fogel，并且询问他是否希望为这个新项目工作。巧合的是，当时Karl正在与朋友Jim Blandy讨论设计一个新的版本控制系统。1995年时，他们两人曾经开办了一个提供CVS支持的公司Cyclic Software，尽管他们最终卖掉了公司，但还是天天使用CVS进行日常工作。在使用CVS时的挫折促使Jim认真的思考如何管理版本化的数据，并且当时他不仅使用了<quote>Subversion</quote>这个名字，并且已经完成了Subversion版本库的最初设计。所以当CollabNet提出邀请的时候，Karl马上同意为这个项目工作，同时Jim也使他的雇主—Red Hat软件公司—允许他到这个项目工作，并且没有限定最终的期限。CollabNet雇佣了Karl和Ben Collins Sussman，详细设计工作从三月开始，在Behlendorf 、CollabNet、Jason Robbins和Greg Stein（当时是一个独立开发者，活跃在WebDAV/DeltaV系统规范制订工作中）恰到好处的激励下，Subversion很快吸引了许多活跃的开发者，结果使得许多具有CVS经验的人们很乐于为这个项目做些事情。"

#: build/en/book.xml:854(para)
msgid "The original design team settled on some simple goals. They didn't want to break new ground in version control methodology, they just wanted to fix CVS. They decided that Subversion would match CVS's features, and preserve the same development model, but not duplicate CVS's most obvious flaws. And although it did not need to be a drop-in replacement for CVS, it should be similar enough that any CVS user could make the switch with little effort."
msgstr "最初，设计小组设定了一些简单的开发目标。他们不想在版本控制方法学中开垦处女地，他们只是希望修正CVS。他们决定Subversion应符合CVS的特性，并保留相同的开发模型，但不再重复CVS的一些显著缺陷。尽管Subversion并不需要成为CVS的完全替代品，但它应该与CVS保持足够的相似性，以使CVS用户可以轻松的转移到Subversion上。"

#: build/en/book.xml:863(para)
msgid "After fourteen months of coding, Subversion became <quote>self-hosting</quote> on August 31, 2001. That is, Subversion developers stopped using CVS to manage Subversion's own source code, and started using Subversion instead."
msgstr "经过14个月的编码，2001年8月31日，Subversion能够<quote>自己管理自己</quote>了，开发者停止使用CVS保存Subversion的代码，而使用Subversion本身。"

#: build/en/book.xml:868(para)
msgid "While CollabNet started the project, and still funds a large chunk of the work (it pays the salaries of a few full-time Subversion developers), Subversion is run like most open-source projects, governed by a loose, transparent set of rules that encourage meritocracy. CollabNet's copyright license is fully compliant with the Debian Free Software Guidelines. In other words, anyone is free to download, modify, and redistribute Subversion as he pleases; no permission from CollabNet or anyone else is required."
msgstr "当CollabNet启动了这个项目，并且一直提供了大量的工作支持（它为一些全职的Subversion开发者提供薪水），Subversion像其它许多开源项目一样，被松散的、透明的规则管理着，这样的规则激励着知识界的精英们。CollabNet的版权许可证完全符合Debian的自由软件方针。也就是说，任何人都可以根据自己的意愿自由的下载、修改和重新发布Subversion，不需要CollabNet或其他人的授权。"

#: build/en/book.xml:883(title)
msgid "Subversion's Features"
msgstr "Subversion 的特性"

#: build/en/book.xml:885(para)
#, fuzzy
msgid "When discussing the features that Subversion brings to the version control table, it is often helpful to speak of them in terms of how they improve upon CVS's design. If you're not familiar with CVS, you may not understand all of these features. And if you're not familiar with version control at all, your eyes may glaze over unless you first read <xref linkend=\"svn.basic\"/>, in which we provide a gentle introduction to version control."
msgstr "Subversion将很多新特性引入版本控制领域。在讲解这些特性时，我们会经常性的与CVS进行对比，以说明Subversion比CVS高明在哪里。如果不熟悉CVS，了解所有Subversion的特性会有一定的困难。而如果根本就不熟悉版本控制，你就只有干瞪眼的份儿了。因此，最好首先阅读一下<xref linkend=\"svn.basic\"/>，这一章简单介绍了一些版本控制的基本思想和概念。"

#: build/en/book.xml:893(para)
msgid "Subversion provides:"
msgstr "Subversion支持："

#: build/en/book.xml:897(term)
msgid "Directory versioning"
msgstr "版本化的目录"

#: build/en/book.xml:899(para)
msgid "CVS only tracks the history of individual files, but Subversion implements a <quote>virtual</quote> versioned filesystem that tracks changes to whole directory trees over time. Files <emphasis>and</emphasis> directories are versioned."
msgstr "CVS只能跟踪单个文件的变更历史，但是Subversion实现的<quote>虚拟</quote>版本化文件系统则可以跟踪目录树的变更。在Subversion中，文件<emphasis>和</emphasis>目录都是版本化的。"

#: build/en/book.xml:908(term)
msgid "True version history"
msgstr "真实的版本历史"

#: build/en/book.xml:910(para)
msgid "Since CVS is limited to file versioning, operations such as copies and renames—which might happen to files, but which are really changes to the contents of some containing directory—aren't supported in CVS. Additionally, in CVS you cannot replace a versioned file with some new thing of the same name without the new item inheriting the history of the old—perhaps completely unrelated—file. With Subversion, you can add, delete, copy, and rename both files and directories. And every newly added file begins with a fresh, clean history all its own."
msgstr "由于只能跟踪单个文件的变更，CVS无法支持如文件拷贝和改名这些常见的操作—这些操作改变了目录的内容。同样，在CVS中，目录下的文件只要名字相同即拥有相同的历史，即使这些同名文件在历史上毫无关系。而在Subversion中，可以对文件或目录进行增加、拷贝和改名操作，也解决了同名而无关的文件之间的历史联系问题。"

#: build/en/book.xml:925(term)
msgid "Atomic commits"
msgstr "原子提交"

#: build/en/book.xml:927(para)
msgid "A collection of modifications either goes into the repository completely, or not at all. This allows developers to construct and commit changes as logical chunks, and prevents problems that can occur when only a portion of a set of changes is successfully sent to the repository."
msgstr "一系列相关的更改，要么全部提交到版本库，要么一个也不提交。这样用户就可以将相关的更改组成一个逻辑整体，防止出现部分修改而另一部分未修改的情况提交到版本库中。"

#: build/en/book.xml:937(term)
msgid "Versioned metadata"
msgstr "版本化的元数据"

#: build/en/book.xml:939(para)
msgid "Each file and directory has a set of properties—keys and their values—associated with it. You can create and store any arbitrary key/value pairs you wish. Properties are versioned over time, just like file contents."
msgstr "每一个文件和目录都有自己的一组属性—键和它们的值。可以根据需要建立并存储任何键/值对。和文件本身的内容一样，属性也在版本控制之下。"

#: build/en/book.xml:948(term)
msgid "Choice of network layers"
msgstr "可选的网络层"

#: build/en/book.xml:950(para)
msgid "Subversion has an abstracted notion of repository access, making it easy for people to implement new network mechanisms. Subversion can plug into the Apache HTTP Server as an extension module. This gives Subversion a big advantage in stability and interoperability, and instant access to existing features provided by that server—authentication, authorization, wire compression, and so on. A more lightweight, standalone Subversion server process is also available. This server speaks a custom protocol which can be easily tunneled over SSH."
msgstr "Subversion在版本库访问的实现上具有较高的抽象程度，利于人们实现新的网络访问机制。Subversion可以作为一个扩展模块嵌入到Apache之中。这种方式在稳定性和交互性方面有很大的优势，可以直接使用服务器的成熟技术—认证、授权和传输压缩等等。此外，Subversion自身也实现了一个轻型的，可独立运行的服务器软件。这个服务器使用了一个特定的协议，这个协议可以轻松的用SSH封装。"

#: build/en/book.xml:965(term)
msgid "Consistent data handling"
msgstr "一致的数据操作"

#: build/en/book.xml:967(para)
msgid "Subversion expresses file differences using a binary differencing algorithm, which works identically on both text (human-readable) and binary (human-unreadable) files. Both types of files are stored equally compressed in the repository, and differences are transmitted in both directions across the network."
msgstr "Subversion用一个二进制差异算法描述文件的变化，对于文本（可读）和二进制（不可读）文件其操作方式是一致的。这两种类型的文件压缩存储在版本库中，而差异信息则在网络上双向传递。"

#: build/en/book.xml:977(term)
msgid "Efficient branching and tagging"
msgstr "高效的分支和标签操作"

#: build/en/book.xml:979(para)
msgid "The cost of branching and tagging need not be proportional to the project size. Subversion creates branches and tags by simply copying the project, using a mechanism similar to a hard-link. Thus these operations take only a very small, constant amount of time."
msgstr "在Subversion中，分支与标签操作的开销与工程的大小无关。Subversion的分支和标签操作用只是一种类似于硬链接的机制拷贝整个工程。因而这些操作通常只会花费很少且相对固定的时间。"

#: build/en/book.xml:989(term)
msgid "Hackability"
msgstr "可修改性"

#: build/en/book.xml:991(para)
msgid "Subversion has no historical baggage; it is implemented as a collection of shared C libraries with well-defined APIs. This makes Subversion extremely maintainable and usable by other applications and languages."
msgstr "Subversion没有历史负担，它以一系列优质的共享C程序库的方式实现，具有定义良好的API。这使得Subversion非常容易维护，和其它语言的互操作性很强。"

#: build/en/book.xml:1006(title) build/en/book.xml:1013(title)
msgid "Subversion's Architecture"
msgstr "Subversion 的架构"

#: build/en/book.xml:1008(para)
#, fuzzy
msgid "<xref linkend=\"svn.intro.architecture.dia-1\"/> illustrates a <quote>mile-high</quote> view of Subversion's design."
msgstr "<xref linkend=\"svn.intro.architecture.dia-1\"/>给出了Subversion设计总体上的<quote>俯视图</quote>。"

#: build/en/book.xml:1017(para)
msgid "On one end is a Subversion repository that holds all of your versioned data. On the other end is your Subversion client program, which manages local reflections of portions of that versioned data (called <quote>working copies</quote>). Between these extremes are multiple routes through various Repository Access (RA) layers. Some of these routes go across computer networks and through network servers which then access the repository. Others bypass the network altogether and access the repository directly."
msgstr "图中的一端是保存所有在版本控制下数据的Subversion版本库，另一端是Subvesion的客户端程序，管理着所有在版本控制下数据的本地影射（称为<quote>工作拷贝</quote>），在这两极之间是各种各样的版本库访问（RA）层，某些使用电脑网络通过网络服务器访问版本库，某些则绕过网络服务器直接访问版本库。"

#: build/en/book.xml:1032(title)
msgid "Subversion's Components"
msgstr "Subversion 的组件"

#: build/en/book.xml:1034(para)
msgid "Subversion, once installed, has a number of different pieces. The following is a quick overview of what you get. Don't be alarmed if the brief descriptions leave you scratching your head—there are <emphasis>plenty</emphasis> more pages in this book devoted to alleviating that confusion."
msgstr "安装好的Subversion有几个几个部分组成，本节将简单的介绍一下这些组件。下文的描述或许过于简略，不易理解，不过不用担心，本书后面章节中会用<emphasis>更多的</emphasis>内容来详细阐述这些组件。"

#: build/en/book.xml:1042(term) build/en/book.xml:18153(primary)
#: build/en/book.xml:18259(primary) build/en/book.xml:18329(primary)
#: build/en/book.xml:18414(primary) build/en/book.xml:18551(primary)
#: build/en/book.xml:18629(primary) build/en/book.xml:18767(primary)
#: build/en/book.xml:18942(primary) build/en/book.xml:19055(primary)
#: build/en/book.xml:19307(primary) build/en/book.xml:19421(primary)
#: build/en/book.xml:19473(primary) build/en/book.xml:19575(primary)
#: build/en/book.xml:19736(primary) build/en/book.xml:19848(primary)
#: build/en/book.xml:19948(primary) build/en/book.xml:20192(primary)
#: build/en/book.xml:20313(primary) build/en/book.xml:20399(primary)
#: build/en/book.xml:20513(primary) build/en/book.xml:20591(primary)
#: build/en/book.xml:20667(primary) build/en/book.xml:20749(primary)
#: build/en/book.xml:20836(primary) build/en/book.xml:20971(primary)
#: build/en/book.xml:21060(primary) build/en/book.xml:21164(primary)
#: build/en/book.xml:21569(primary) build/en/book.xml:21729(primary)
#: build/en/book.xml:21822(primary)
msgid "svn"
msgstr "svn"

#: build/en/book.xml:1044(para)
msgid "The command-line client program."
msgstr "命令行客户端程序。"

#: build/en/book.xml:1049(term) build/en/book.xml:24030(command)
#: build/en/book.xml:24035(primary) build/en/book.xml:24039(refname)
msgid "svnversion"
msgstr "svnversion"

#: build/en/book.xml:1051(para)
msgid "A program for reporting the state (in terms of revisions of the items present) of a working copy."
msgstr "此工具用来显示工作副本的状态（用术语来说，就是当前项目的修订版本）。"

#: build/en/book.xml:1057(term) build/en/book.xml:10740(title)
#: build/en/book.xml:22914(command) build/en/book.xml:23004(primary)
#: build/en/book.xml:23050(primary) build/en/book.xml:23108(primary)
#: build/en/book.xml:23207(primary) build/en/book.xml:23253(primary)
#: build/en/book.xml:23324(primary) build/en/book.xml:23371(primary)
#: build/en/book.xml:23402(primary) build/en/book.xml:23467(primary)
#: build/en/book.xml:23518(primary) build/en/book.xml:23570(primary)
#: build/en/book.xml:23615(primary) build/en/book.xml:23670(primary)
#: build/en/book.xml:23736(primary) build/en/book.xml:23790(primary)
#: build/en/book.xml:23829(primary)
msgid "svnlook"
msgstr "svnlook"

#: build/en/book.xml:1059(para)
msgid "A tool for directly inspecting a Subversion repository."
msgstr "直接查看 Subversion 版本库的工具。"

#: build/en/book.xml:1064(term) build/en/book.xml:10707(title)
#: build/en/book.xml:21973(command) build/en/book.xml:22108(primary)
#: build/en/book.xml:22171(primary) build/en/book.xml:22211(primary)
#: build/en/book.xml:22321(primary) build/en/book.xml:22353(primary)
#: build/en/book.xml:22395(primary) build/en/book.xml:22427(primary)
#: build/en/book.xml:22475(primary) build/en/book.xml:22541(primary)
#: build/en/book.xml:22589(primary) build/en/book.xml:22629(primary)
#: build/en/book.xml:22711(primary) build/en/book.xml:22757(primary)
#: build/en/book.xml:22811(primary) build/en/book.xml:22871(primary)
msgid "svnadmin"
msgstr "svnadmin"

#: build/en/book.xml:1066(para)
msgid "A tool for creating, tweaking or repairing a Subversion repository."
msgstr "建立、调整和修复Subversion版本库的工具。"

#: build/en/book.xml:1072(term) build/en/book.xml:10865(title)
msgid "svndumpfilter"
msgstr "svndumpfilter"

#: build/en/book.xml:1074(para)
msgid "A program for filtering Subversion repository dump streams."
msgstr "过滤Subversion版本库转储数据流的工具。"

#: build/en/book.xml:1080(term) build/en/book.xml:16489(term)
#: build/en/book.xml:24184(command) build/en/book.xml:24189(literal)
msgid "mod_dav_svn"
msgstr "mod_dav_svn"

#: build/en/book.xml:1082(para)
msgid "A plug-in module for the Apache HTTP Server, used to make your repository available to others over a network."
msgstr "Apache HTTP服务器的一个插件，使版本库可以通过网络访问。"

#: build/en/book.xml:1089(term) build/en/book.xml:1623(literal)
#: build/en/book.xml:12678(entry) build/en/book.xml:23870(command)
msgid "svnserve"
msgstr "svnserve"

#: build/en/book.xml:1091(para)
msgid "A custom standalone server program, runnable as a daemon process or invokable by SSH; another way to make your repository available to others over a network."
msgstr "一个单独运行的服务器程序，可以作为守护进程或由SSH调用。这是另一种使版本库可以通过网络访问的方式。"

#: build/en/book.xml:1098(term) build/en/book.xml:10918(title)
msgid "svnsync"
msgstr "svnsync"

#: build/en/book.xml:1100(para)
msgid "A program for incrementally mirroring one repository to another over a network."
msgstr ""

#: build/en/book.xml:1107(para)
msgid "Assuming you have Subversion installed correctly, you should be ready to start. The next two chapters will walk you through the use of <command moreinfo=\"none\">svn</command>, Subversion's command-line client program."
msgstr "如果已经正确完成了Subversion的安装，我们就可以开始我们的学习之旅了。在后面的两章中，我们将讲解如何使用Subversion的客户端程序<command moreinfo=\"none\">svn</command>。"

#: build/en/book.xml:1125(title)
msgid "Fundamental Concepts"
msgstr "基本概念"

#: build/en/book.xml:1127(para)
msgid "This chapter is a short, casual introduction to Subversion. If you're new to version control, this chapter is definitely for you. We begin with a discussion of general version control concepts, work our way into the specific ideas behind Subversion, and show some simple examples of Subversion in use."
msgstr "本章主要为那些不熟悉版本控制技术的入门者提供一个简单扼要的、非系统的介绍。我们将从版本控制的基本概念开始，随后阐述Subversion的独特理念，并演示一些使用Subversion的例子。"

#: build/en/book.xml:1134(para)
msgid "Even though the examples in this chapter show people sharing collections of program source code, keep in mind that Subversion can manage any sort of file collection—it's not limited to helping computer programmers."
msgstr "虽然我们在本章中以分享程序源代码作为例子，但是记住Subversion可以管理任何类型的文件集—它并非是程序员专用的。"

#: build/en/book.xml:1144(title)
msgid "The Repository"
msgstr "版本库"

#: build/en/book.xml:1146(para)
msgid "Subversion is a centralized system for sharing information. At its core is a repository, which is a central store of data. The repository stores information in the form of a <firstterm>filesystem tree</firstterm>—a typical hierarchy of files and directories. Any number of <firstterm>clients</firstterm> connect to the repository, and then read or write to these files. By writing data, a client makes the information available to others; by reading data, the client receives information from others. <xref linkend=\"svn.basic.repository.dia-1\"/> illustrates this."
msgstr "Subversion是一个“中央集权式”的信息共享系统。版本库是Subversion的核心部分，是数据的中央仓库。版本库以文件和目录的典型结构形式—<firstterm>文件系统树</firstterm>来保存信息。此外，数个<firstterm>客户端</firstterm>（数量不限）连接到Subversion版本库，读取、修改这些文件。客户端之间通过修改数据实现与别人共享信息，通过读取数据实现获取别人共享的信息。<xref linkend=\"svn.basic.repository.dia-1\"/>展示了这种系统的概貌："

#: build/en/book.xml:1157(title)
msgid "A typical client/server system"
msgstr "一个典型的客户/服务器系统"

#: build/en/book.xml:1161(para)
msgid "So why is this interesting? So far, this sounds like the definition of a typical file server. And indeed, the repository <emphasis>is</emphasis> a kind of file server, but it's not your usual breed. What makes the Subversion repository special is that <emphasis>it remembers every change</emphasis> ever written to it: every change to every file, and even changes to the directory tree itself, such as the addition, deletion, and rearrangement of files and directories."
msgstr "这有什么意义吗？说了这么多，Subversion听起来和一般的文件服务器没什么不同。事实上，Subversion的版本库的确<emphasis>是</emphasis>一种文件服务器，但不是“一般”的文件服务器。Subversion版本库的特别之处在于，<emphasis>它会记录每一次改变</emphasis>，每一次文件和目录结构的改变，（比如增加、删除和重新布置文件和目录）它都不会放过。"

#: build/en/book.xml:1170(para)
msgid "When a client reads data from the repository, it normally sees only the latest version of the filesystem tree. But the client also has the ability to view <emphasis>previous</emphasis> states of the filesystem. For example, a client can ask historical questions like, <quote>What did this directory contain last Wednesday?</quote> or <quote>Who was the last person to change this file, and what changes did he make?</quote> These are the sorts of questions that are at the heart of any <firstterm>version control system</firstterm>: systems that are designed to record and track changes to data over time."
msgstr "一般情况下，客户端从版本库中获取的数据是文件系统树中的最新数据。但是客户端也具备查看文件系统树<emphasis>以前</emphasis>任何一个状态的能力。举个例子，客户端有时会对一些历史性问题感兴趣，比如<quote>上星期三时的目录结构是什么样的？</quote>或者<quote>谁最后一个修改了这个文件，都修改了什么？</quote>为了回答类似的问题，<firstterm>版本控制系统</firstterm>产生了。它的主要设计目的即是记录和跟踪数据的变化。"

#: build/en/book.xml:1188(title)
msgid "Versioning Models"
msgstr "版本模型"

#: build/en/book.xml:1190(para)
msgid "The core mission of a version control system is to enable collaborative editing and sharing of data. But different systems use different strategies to achieve this. It's important to understand these different strategies for a couple of reasons. First, it will help you compare and contrast existing version control systems, in case you encounter other systems similar to Subversion. Beyond that, it will also help you make more effective use of Subversion, since Subversion itself supports a couple of different ways of working."
msgstr ""

#: build/en/book.xml:1202(title)
msgid "The Problem of File-Sharing"
msgstr "文件共享的问题"

#: build/en/book.xml:1204(para)
msgid "All version control systems have to solve the same fundamental problem: how will the system allow users to share information, but prevent them from accidentally stepping on each other's feet? It's all too easy for users to accidentally overwrite each other's changes in the repository."
msgstr "所有的版本控制系统都需要解决这样一个基础问题：怎样让系统允许用户共享信息，而不会让他们因意外而互相干扰？版本库里意外覆盖别人的更改非常的容易。"

#: build/en/book.xml:1211(para)
msgid "Consider the scenario shown in <xref linkend=\"svn.basic.vsn-models.problem-sharing.dia-1\"/>. Suppose we have two co-workers, Harry and Sally. They each decide to edit the same repository file at the same time. If Harry saves his changes to the repository first, then it's possible that (a few moments later) Sally could accidentally overwrite them with her own new version of the file. While Harry's version of the file won't be lost forever (because the system remembers every change), any changes Harry made <emphasis>won't</emphasis> be present in Sally's newer version of the file, because she never saw Harry's changes to begin with. Harry's work is still effectively lost—or at least missing from the latest version of the file—and probably by accident. This is definitely a situation we want to avoid!"
msgstr "考虑<xref linkend=\"svn.basic.vsn-models.problem-sharing.dia-1\"/>的情景，我们有两个共同工作者，Harry和Sally，他们想同时编辑版本库里的同一个文件，如果首先Harry保存它的修改，过了一会，Sally可能凑巧用自己的版本覆盖了这些文件，Harry的更改不会永远消失（因为系统记录了每次修改），Harry所有的修改<emphasis>不会</emphasis>出现在Sally的文件中，所以Harry的工作还是丢失了—至少是从最新的版本中丢失了—而且是意外的，这就是我们要明确避免的情况！"

#: build/en/book.xml:1227(title)
msgid "The problem to avoid"
msgstr "需要避免的问题"

#: build/en/book.xml:1235(title)
msgid "The Lock-Modify-Unlock Solution"
msgstr "锁定-修改-解锁 方案"

#: build/en/book.xml:1237(para)
msgid "Many version control systems use a <firstterm>lock-modify-unlock</firstterm> model to address the problem of many authors clobbering each other's work. In this model, the repository allows only one person to change a file at a time. This exclusivity policy is managed using locks. Harry must <quote>lock</quote> a file before he can begin making changes to it. If Harry has locked a file, then Sally cannot also lock it, and therefore cannot make any changes to that file. All she can do is read the file, and wait for Harry to finish his changes and release his lock. After Harry unlocks the file, Sally can take her turn by locking and editing the file. <xref linkend=\"svn.basic.vsn-models.lock-unlock.dia-1\"/> demonstrates this simple solution."
msgstr "许多版本控制系统使用<firstterm>锁定-修改-解锁</firstterm>这种机制解决这种问题，在这样的模型里，在一个时间段里版本库的一个文件只允许被一个人修改。首先在修改之前，Harry要<quote>锁定</quote>住这个文件，锁定很像是从图书馆借一本书，如果Harry锁住这个文件，Sally不能做任何修改，如果Sally想请求得到一个锁，版本库会拒绝这个请求。在Harry结束编辑并且放开这个锁之前，她只可以阅读文件。Harry解锁后，就要换班了，Sally得到自己的轮换位置，锁定并且开始编辑这个文件。<xref linkend=\"svn.basic.vsn-models.lock-unlock.dia-1\"/>描述了这样的解决方案。"

#: build/en/book.xml:1252(title)
msgid "The lock-modify-unlock solution"
msgstr "锁定-修改-解锁 方案"

#: build/en/book.xml:1256(para)
msgid "The problem with the lock-modify-unlock model is that it's a bit restrictive, and often becomes a roadblock for users:"
msgstr "锁定-修改-解锁模型有一点问题就是限制太多，经常会成为用户的障碍："

#: build/en/book.xml:1262(para)
#, fuzzy
msgid "<emphasis>Locking may cause administrative problems.</emphasis> Sometimes Harry will lock a file and then forget about it. Meanwhile, because Sally is still waiting to edit the file, her hands are tied. And then Harry goes on vacation. Now Sally has to get an administrator to release Harry's lock. The situation ends up causing a lot of unnecessary delay and wasted time."
msgstr "<emphasis>锁定可能导致管理问题。</emphasis>有时候Harry会锁住文件然后忘了此事，这就是说Sally一直等待解锁来编辑这些文件，她在这里僵住了。然后Harry去旅行了，现在Sally只好去找管理员放开锁，这种情况会导致不必要的耽搁和时间浪费。"

#: build/en/book.xml:1274(para)
#, fuzzy
msgid "<emphasis>Locking may cause unnecessary serialization.</emphasis> What if Harry is editing the beginning of a text file, and Sally simply wants to edit the end of the same file? These changes don't overlap at all. They could easily edit the file simultaneously, and no great harm would come, assuming the changes were properly merged together. There's no need for them to take turns in this situation."
msgstr "<emphasis>锁定可能导致不必要的线性化开发。</emphasis>如果Harry编辑一个文件的开始，Sally想编辑同一个文件的结尾，这种修改不会冲突，设想修改可以正确的合并到一起，他们可以轻松的并行工作而没有太多的坏处，没有必要让他们轮流工作。"

#: build/en/book.xml:1287(para)
#, fuzzy
msgid "<emphasis>Locking may create a false sense of security.</emphasis> Suppose Harry locks and edits file A, while Sally simultaneously locks and edits file B. But what if A and B depend on one another, and the changes made to each are semantically incompatible? Suddenly A and B don't work together anymore. The locking system was powerless to prevent the problem—yet it somehow provided a false sense of security. It's easy for Harry and Sally to imagine that by locking files, each is beginning a safe, insulated task, and thus not bother discussing their incompatible changes early on. Locking often becomes a substitute for real communication."
msgstr "<emphasis>锁定可能导致错误的安全状态。</emphasis>假设Harry锁定和编辑一个文件A，同时Sally锁定并编辑文件B，如果A和B互相依赖，这种变化是必须同时作的，这样A和B不能正确的工作了，锁定机制对防止此类问题将无能为力—从而产生了一种处于安全状态的假相。很容易想象Harry和Sally都以为自己锁住了文件，而且从一个安全，孤立的情况开始工作，因而没有尽早发现他们不匹配的修改。"

#: build/en/book.xml:1308(title)
msgid "The Copy-Modify-Merge Solution"
msgstr "拷贝-修改-合并 方案"

#: build/en/book.xml:1310(para)
#, fuzzy
msgid "Subversion, CVS, and a number of other version control systems use a <firstterm>copy-modify-merge</firstterm> model as an alternative to locking. In this model, each user's client contacts the project repository and creates a personal <firstterm>working copy</firstterm>—a local reflection of the repository's files and directories. Users then work simultaneously and independently, modifying their private copies. Finally, the private copies are merged together into a new, final version. The version control system often assists with the merging, but ultimately a human being is responsible for making it happen correctly."
msgstr "Subversion，CVS和一些版本控制系统使用<firstterm>拷贝-修改-合并</firstterm>模型，在这种模型里，每一个客户联系项目版本库建立一个个人<firstterm>工作拷贝</firstterm>—版本库中文件和目录的本地映射。用户并行工作，修改各自的工作拷贝，最终，各个私有的拷贝合并在一起，成为最终的版本，这种系统通常可以辅助合并操作，但是最终要靠人工去确定正误。"

#: build/en/book.xml:1322(para)
msgid "Here's an example. Say that Harry and Sally each create working copies of the same project, copied from the repository. They work concurrently, and make changes to the same file A within their copies. Sally saves her changes to the repository first. When Harry attempts to save his changes later, the repository informs him that his file A is <firstterm>out-of-date</firstterm>. In other words, that file A in the repository has somehow changed since he last copied it. So Harry asks his client to <firstterm>merge</firstterm> any new changes from the repository into his working copy of file A. Chances are that Sally's changes don't overlap with his own; so once he has both sets of changes integrated, he saves his working copy back to the repository. <xref linkend=\"svn.basic.vsn-models.copy-merge.dia-1\"/> and <xref linkend=\"svn.basic.vsn-models.copy-merge.dia-2\"/> show this process."
msgstr "这是一个例子，Harry和Sally为同一个项目各自建立了一个工作拷贝，工作是并行的，修改了同一个文件A，Sally首先保存修改到版本库，当Harry想去提交修改的时候，版本库提示文件A已经<firstterm>过期</firstterm>，换句话说，A在他上次更新之后已经更改了，所以当他通过客户端请求<firstterm>合并</firstterm>版本库和他的工作拷贝之后，碰巧Sally的修改和他的不冲突，所以一旦他把所有的修改集成到一起，他可以将工作拷贝保存到版本库，<xref linkend=\"svn.basic.vsn-models.copy-merge.dia-1\"/>和<xref linkend=\"svn.basic.vsn-models.copy-merge.dia-2\"/>展示了这一过程。"

#: build/en/book.xml:1338(title)
msgid "The copy-modify-merge solution"
msgstr "拷贝-修改-合并 方案"

#: build/en/book.xml:1343(title)
msgid "The copy-modify-merge solution (continued)"
msgstr "拷贝-修改-合并 方案（续）"

#: build/en/book.xml:1347(para)
msgid "But what if Sally's changes <emphasis>do</emphasis> overlap with Harry's changes? What then? This situation is called a <firstterm>conflict</firstterm>, and it's usually not much of a problem. When Harry asks his client to merge the latest repository changes into his working copy, his copy of file A is somehow flagged as being in a state of conflict: he'll be able to see both sets of conflicting changes, and manually choose between them. Note that software can't automatically resolve conflicts; only humans are capable of understanding and making the necessary intelligent choices. Once Harry has manually resolved the overlapping changes—perhaps after a discussion with Sally—he can safely save the merged file back to the repository."
msgstr "但是如果Sally和Harry的修改<emphasis>交迭</emphasis>了该怎么办？这种情况叫做<firstterm>冲突</firstterm>，这通常不是个大问题，当Harry告诉他的客户端去合并版本库的最新修改到自己的工作拷贝时，他的文件A就会处于冲突状态：他可以看到一对冲突的修改集，并手工的选择保留一组修改。需要注意的是软件不能自动的解决冲突，只有人可以理解并作出智能的选择，一旦Harry手工的解决了冲突—也许需要与Sally讨论—它可以安全的把合并的文件保存到版本库。"

#: build/en/book.xml:1361(para)
#, fuzzy
msgid "The copy-modify-merge model may sound a bit chaotic, but in practice, it runs extremely smoothly. Users can work in parallel, never waiting for one another. When they work on the same files, it turns out that most of their concurrent changes don't overlap at all; conflicts are infrequent. And the amount of time it takes to resolve conflicts is usually far less than the time lost by a locking system."
msgstr "拷贝-修改-合并模型感觉是有一点混乱，但在实践中，通常运行的很平稳，用户可以并行的工作，不必等待别人，当工作在同一个文件上时，也很少会有交迭发生，冲突并不频繁，处理冲突的时间远比等待解锁花费的时间少。"

#: build/en/book.xml:1369(para)
msgid "In the end, it all comes down to one critical factor: user communication. When users communicate poorly, both syntactic and semantic conflicts increase. No system can force users to communicate perfectly, and no system can detect semantic conflicts. So there's no point in being lulled into a false promise that a locking system will somehow prevent conflicts; in practice, locking seems to inhibit productivity more than anything else."
msgstr "最后，一切都要归结到一条重要的因素：用户交流。当用户交流贫乏，语法和语义的冲突就会增加，没有系统可以强制用户完美的交流，没有系统可以检测语义上的冲突，所以没有任何证据能够承诺锁定系统可以防止冲突，实践中，锁定除了约束了生产力，并没有做什么事。"

#: build/en/book.xml:1379(title)
msgid "When Locking is Necessary"
msgstr "什么时候锁定是必需的"

#: build/en/book.xml:1381(para)
msgid "While the lock-modify-unlock model is considered generally harmful to collaboration, there are still times when locking is appropriate."
msgstr "锁定-修改-解锁模型被认为不利于协作，但有时候锁定会更好。"

#: build/en/book.xml:1385(para)
msgid "The copy-modify-merge model is based on the assumption that files are contextually mergeable: that is, that the majority of the files in the repository are line-based text files (such as program source code). But for files with binary formats, such as artwork or sound, it's often impossible to merge conflicting changes. In these situations, it really is necessary to users to take strict turns when changing the file. Without serialized access, somebody ends up wasting time on changes that are ultimately discarded."
msgstr "拷贝-修改-合并模型假定文件是可以根据上下文合并的：就是版本库的文件主要是以行为基础的文本文件（例如程序源代码）。但对于二进制格式，例如艺术品或声音，在这种情况下，十分有必要让用户轮流修改文件，如果没有线性的访问，有些人的许多工作就最终要被放弃。"

#: build/en/book.xml:1396(para)
#, fuzzy
msgid "While Subversion is still primarily a copy-modify-merge system, it still recognizes the need to lock an occasional file ands provide mechanisms for this. This feature is discussed later in this book, in <xref linkend=\"svn.advanced.locking\"/>."
msgstr "尽管CVS和Subversion一直主要是拷贝-修改-合并系统，它们都意识到了需要锁定一些文件，并且提供这种锁定机制。见<xref linkend=\"svn.advanced.locking\"/>。"

#: build/en/book.xml:1414(title)
msgid "Subversion in Action"
msgstr "Subversion 实践"

#: build/en/book.xml:1416(para)
msgid "It's time to move from the abstract to the concrete. In this section, we'll show real examples of Subversion being used."
msgstr "是时候从抽象转到具体了，在本小节，我们会展示一个Subversion真实使用的例子。"

#: build/en/book.xml:1422(title)
msgid "Subversion Repository URLs"
msgstr "Subversion 版本库 URL"

#: build/en/book.xml:1424(para)
#, fuzzy
msgid "Throughout this book, Subversion uses URLs to identify versioned files and directories in Subversion repositories. For the most part, these URLs use the standard syntax, allowing for server names and port numbers to be specified as part of the URL:"
msgstr "正如我们在整本书里描述的，Subversion使用URL来识别Subversion版本库中的版本化资源，通常情况下，这些URL使用标准的语法，允许服务器名称和端口作为URL的一部分："

#: build/en/book.xml:1430(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://svn.example.com:9834/repos\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout http://svn.example.com:9834/repos\n"
"…\n"

#: build/en/book.xml:1435(para)
#, fuzzy
msgid "But there are some nuances in Subversion's handling of URLs that are notable. For example, URLs containing the <literal moreinfo=\"none\">file://</literal> access method (used for local repositories) must, in accordance with convention, have either a server name of <literal moreinfo=\"none\">localhost</literal> or no server name at all:"
msgstr "但是Subversion处理URL的一些细微的不同之处需要注意，例如，使用<literal moreinfo=\"none\">file:</literal>访问方法的URL（用来访问本地版本库）必须与习惯一致，可以包括一个<literal moreinfo=\"none\">localhost</literal>服务器名或者没有服务器名："

#: build/en/book.xml:1442(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout file:///path/to/repos\n"
"…\n"
"$ svn checkout file://localhost/path/to/repos\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout file:///path/to/repos\n"
"…\n"
"$ svn checkout file://localhost/path/to/repos\n"
"…\n"

#: build/en/book.xml:1449(para)
#, fuzzy
msgid "Also, users of the <literal moreinfo=\"none\">file://</literal> scheme on Windows platforms will need to use an unofficially <quote>standard</quote> syntax for accessing repositories that are on the same machine, but on a different drive than the client's current working drive. Either of the two following URL path syntaxes will work where <literal moreinfo=\"none\">X</literal> is the drive on which the repository resides:"
msgstr "同样在Windows平台下使用<literal moreinfo=\"none\">file:</literal>模式时需要使用一个非正式的<quote>标准</quote>语法来访问本机上不在同一个磁盘分区中的版本库。下面的任意一个URL路径语法都可以工作，其中的<literal moreinfo=\"none\">X</literal>表示版本库所在的磁盘分区："

#: build/en/book.xml:1458(screen)
#, no-wrap
msgid ""
"\n"
"C:\\&gt; svn checkout file:///X:/path/to/repos\n"
"…\n"
"C:\\&gt; svn checkout \"file:///X|/path/to/repos\"\n"
"…\n"
msgstr ""
"\n"
"C:\\&gt; svn checkout file:///X:/path/to/repos\n"
"…\n"
"C:\\&gt; svn checkout \"file:///X|/path/to/repos\"\n"
"…\n"

#: build/en/book.xml:1465(para)
#, fuzzy
msgid "In the second syntax, you need to quote the URL so that the vertical bar character is not interpreted as a pipe. Also, note that a URL uses forward slashes even though the native (non-URL) form of a path on Windows uses backslashes."
msgstr "在第二个语法，你需要使用引号包含整个URL，这样竖线字符才不会被解释为管道。当然，注意URL使用普通的斜线而不是Windows本地（不是URL）的反斜线。"

#: build/en/book.xml:1471(para)
#, fuzzy
msgid "Subversion's <literal moreinfo=\"none\">file://</literal> URLs cannot be used in a regular web browser the way typical <literal moreinfo=\"none\">file://</literal> URLs can. When you attempt to view a <literal moreinfo=\"none\">file://</literal> URL in a regular web browser, it reads and displays the contents of the file at that location by examining the filesystem directly. However, Subversion's resources exist in a virtual filesystem (see <xref linkend=\"svn.developer.layerlib.repos\"/>), and your browser will not understand how to interact with that filesystem."
msgstr "也必须意识到Subversion的<literal moreinfo=\"none\">file:</literal> URL不能和在普通的web服务器中的<literal moreinfo=\"none\">file:</literal> URL一样工作。当你尝试在web服务器查看一个<literal moreinfo=\"none\">file:</literal>的URL，它会通过直接检测文件系统读取和显示那个位置的文件内容，但是Subversion的资源存在于虚拟文件系统（见<xref linkend=\"svn.developer.layerlib.repos\"/>）中，你的浏览器不会理解怎样读取这个文件系统。"

#: build/en/book.xml:1482(para)
msgid "Finally, it should be noted that the Subversion client will automatically encode URLs as necessary, just like a web browser does. For example, if a URL contains a space or upper-ASCII character:"
msgstr "最后，必须注意Subversion的客户端会根据需要自动编码URL，这一点和一般的web浏览器一样，举个例子，如果一个URL包含了空格或是一个字符编码大于128的ASCII字符："

#: build/en/book.xml:1487(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout \"http://host/path with space/project/españa\"\n"
msgstr ""
"\n"
"$ svn checkout \"http://host/path with space/project/españa\"\n"

#: build/en/book.xml:1491(para)
msgid "…then Subversion will escape the unsafe characters and behave as if you had typed:"
msgstr "…Subversion会回避这些不安全字符，并且会像你输入了这些字符一样工作："

#: build/en/book.xml:1494(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://host/path%20with%20space/project/espa%C3%B1a\n"
msgstr ""
"\n"
"$ svn checkout http://host/path%20with%20space/project/espa%C3%B1a\n"

#: build/en/book.xml:1498(para)
msgid "If the URL contains spaces, be sure to place it within quote marks, so that your shell treats the whole thing as a single argument to the <command moreinfo=\"none\">svn</command> program."
msgstr "如果URL包含空格，一定要使用引号，这样你的脚本才会把它做一个单独的<command moreinfo=\"none\">svn</command>参数。"

#: build/en/book.xml:1506(title)
msgid "Working Copies"
msgstr "工作拷贝"

#: build/en/book.xml:1508(para)
msgid "You've already read about working copies; now we'll demonstrate how the Subversion client creates and uses them."
msgstr "你已经阅读过了关于工作拷贝的内容，现在我们要讲一讲客户端怎样建立和使用它。"

#: build/en/book.xml:1512(para)
msgid "A Subversion working copy is an ordinary directory tree on your local system, containing a collection of files. You can edit these files however you wish, and if they're source code files, you can compile your program from them in the usual way. Your working copy is your own private work area: Subversion will never incorporate other people's changes, nor make your own changes available to others, until you explicitly tell it to do so. You can even have multiple working copies of the same project."
msgstr "一个Subversion工作拷贝是你本地机器一个普通的目录，保存着一些文件，你可以任意的编辑文件，而且如果是源代码文件，你可以像平常一样编译，你的工作拷贝是你的私有工作区，在你明确的做了特定操作之前，Subversion不会把你的修改与其他人的合并，也不会把你的修改展示给别人，你甚至可以拥有同一个项目的多个工作拷贝。"

#: build/en/book.xml:1522(para)
msgid "After you've made some changes to the files in your working copy and verified that they work properly, Subversion provides you with commands to <quote>publish</quote> your changes to the other people working with you on your project (by writing to the repository). If other people publish their own changes, Subversion provides you with commands to merge those changes into your working directory (by reading from the repository)."
msgstr "当你在工作拷贝作了一些修改并且确认它们工作正常之后，Subversion提供了一个命令可以<quote>发布</quote>你的修改给项目中的其他人（通过写到版本库），如果别人发布了各自的修改，Subversion提供了手段可以把这些修改与你的工作目录进行合并（通过读取版本库）。"

#: build/en/book.xml:1531(para)
msgid "A working copy also contains some extra files, created and maintained by Subversion, to help it carry out these commands. In particular, each directory in your working copy contains a subdirectory named <filename moreinfo=\"none\">.svn</filename>, also known as the working copy <firstterm>administrative directory</firstterm>. The files in each administrative directory help Subversion recognize which files contain unpublished changes, and which files are out-of-date with respect to others' work."
msgstr "一个工作拷贝也包括一些由Subversion创建并维护的额外文件，用来协助执行这些命令。通常情况下，你的工作拷贝每一个文件夹有一个以<filename moreinfo=\"none\">.svn</filename>为名的文件夹，也被叫做工作拷贝<firstterm>管理目录</firstterm>，这个目录里的文件能够帮助Subversion识别哪一个文件做过修改，哪一个文件相对于别人的工作已经过期了。"

#: build/en/book.xml:1541(para)
msgid "A typical Subversion repository often holds the files (or source code) for several projects; usually, each project is a subdirectory in the repository's filesystem tree. In this arrangement, a user's working copy will usually correspond to a particular subtree of the repository."
msgstr "一个典型的Subversion的版本库经常包含许多项目的文件（或者说源代码），通常每一个项目都是版本库的子目录，在这种安排下，一个用户的工作拷贝往往对应版本库的的一个子目录。"

#: build/en/book.xml:1547(para)
msgid "For example, suppose you have a repository that contains two software projects, <literal moreinfo=\"none\">paint</literal> and <literal moreinfo=\"none\">calc</literal>. Each project lives in its own top-level subdirectory, as shown in <xref linkend=\"svn.basic.in-action.wc.dia-1\"/>."
msgstr "举一个例子，你的版本库包含两个软件项目，<literal moreinfo=\"none\">paint</literal>和<literal moreinfo=\"none\">calc</literal>。每个项目在它们各自的顶级子目录下，见<xref linkend=\"svn.basic.in-action.wc.dia-1\"/>。"

#: build/en/book.xml:1553(title)
msgid "The repository's filesystem"
msgstr "版本库的文件系统"

#: build/en/book.xml:1557(para)
msgid "To get a working copy, you must <firstterm>check out</firstterm> some subtree of the repository. (The term <quote>check out</quote> may sound like it has something to do with locking or reserving resources, but it doesn't; it simply creates a private copy of the project for you.) For example, if you check out <filename moreinfo=\"none\">/calc</filename>, you will get a working copy like this:"
msgstr "为了得到一个工作拷贝，你必须<firstterm>检出</firstterm>（<firstterm>check out</firstterm>）版本库的一个子树，（术语<quote>check out</quote>听起来像是锁定或者保存资源，实际上不是，只是简单的得到一个项目的私有拷贝），举个例子，你检出 <filename moreinfo=\"none\">/calc</filename>，你可以得到这样的工作拷贝："

#: build/en/book.xml:1565(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://svn.example.com/repos/calc\n"
"A    calc/Makefile\n"
"A    calc/integer.c\n"
"A    calc/button.c\n"
"Checked out revision 56.\n"
"\n"
"$ ls -A calc\n"
"Makefile  integer.c  button.c  .svn/\n"
msgstr ""
"\n"
"$ svn checkout http://svn.example.com/repos/calc\n"
"A    calc/Makefile\n"
"A    calc/integer.c\n"
"A    calc/button.c\n"
"Checked out revision 56.\n"
"\n"
"$ ls -A calc\n"
"Makefile  integer.c  button.c  .svn/\n"

#: build/en/book.xml:1576(para)
msgid "The list of letter A's indicates that Subversion is adding a number of items to your working copy. You now have a personal copy of the repository's <filename moreinfo=\"none\">/calc</filename> directory, with one additional entry—<filename moreinfo=\"none\">.svn</filename>—which holds the extra information needed by Subversion, as mentioned earlier."
msgstr "列表中的A表示Subversion增加了一些条目到工作拷贝，你现在有了一个<filename moreinfo=\"none\">/calc</filename>的个人拷贝，有一个附加的目录—<filename moreinfo=\"none\">.svn</filename>—保存着前面提及的Subversion需要的额外信息。"

#: build/en/book.xml:1585(title)
msgid "Repository URLs"
msgstr "版本库的 URL"

#: build/en/book.xml:1587(para)
#, fuzzy
msgid "Subversion repositories can be accessed through many different methods—on local disk, or through various network protocols, depending on how your administrator has set things up for you. A repository location, however, is always a URL. <xref linkend=\"svn.basic.in-action.wc.tbl-1\"/> describes how different URL schemas map to the available access methods."
msgstr "Subversion可以通过多种方式访问—本地磁盘访问，或各种各样不同的网络协议，但一个版本库地址永远都是一个URL，<xref linkend=\"svn.basic.in-action.wc.tbl-1\"/>描述了不同的URL模式对应的访问方法。"

#: build/en/book.xml:1597(title)
msgid "Repository Access URLs"
msgstr "版本库访问 URL"

#: build/en/book.xml:1601(entry)
msgid "Schema"
msgstr "方案"

#: build/en/book.xml:1602(entry)
msgid "Access Method"
msgstr "访问方法"

#: build/en/book.xml:1607(literal)
msgid "file:///"
msgstr "file:///"

#: build/en/book.xml:1608(entry)
msgid "direct repository access (on local disk)"
msgstr "直接版本库访问（本地磁盘）。"

#: build/en/book.xml:1611(literal) build/en/book.xml:1617(literal)
msgid "http://"
msgstr "http://"

#: build/en/book.xml:1612(entry)
msgid "access via WebDAV protocol to Subversion-aware Apache server"
msgstr "通过配置Subversion的Apache服务器的WebDAV协议。"

#: build/en/book.xml:1616(literal)
msgid "https://"
msgstr "https://"

#: build/en/book.xml:1617(entry)
msgid "same as <placeholder-1/>, but with SSL encryption."
msgstr "与<placeholder-1/>相似，但是包括SSL加密。"

#: build/en/book.xml:1621(literal) build/en/book.xml:1627(literal)
msgid "svn://"
msgstr "svn://"

#: build/en/book.xml:1622(entry)
msgid "access via custom protocol to an <placeholder-1/> server"
msgstr "通过<placeholder-1/>服务自定义的协议。"

#: build/en/book.xml:1626(literal)
msgid "svn+ssh://"
msgstr "svn+ssh://"

#: build/en/book.xml:1627(entry)
msgid "same as <placeholder-1/>, but through an SSH tunnel."
msgstr "与<placeholder-1/>相似，但通过SSH封装。"

#: build/en/book.xml:1634(para)
#, fuzzy
msgid "For more information on how Subversion parses URLs, see <xref linkend=\"svn.advanced.reposurls\"/>. For more information on the different types of network servers available for Subversion, see <xref linkend=\"svn.serverconfig\"/>."
msgstr "关于Subversion解析URL的更多信息，见<xref linkend=\"svn.advanced.reposurls\"/>。"

#: build/en/book.xml:1642(para)
msgid "Suppose you make changes to <filename moreinfo=\"none\">button.c</filename>. Since the <filename moreinfo=\"none\">.svn</filename> directory remembers the file's modification date and original contents, Subversion can tell that you've changed the file. However, Subversion does not make your changes public until you explicitly tell it to. The act of publishing your changes is more commonly known as <firstterm>committing</firstterm> (or <firstterm>checking in</firstterm>) changes to the repository."
msgstr "假定你修改了<filename moreinfo=\"none\">button.c</filename>，因为<filename moreinfo=\"none\">.svn</filename>目录记录着文件的修改日期和原始内容，Subversion可以告诉你已经修改了文件，然而，在你明确告诉它之前，Subversion不会将你的改变公开。将改变公开的操作被叫做提交（<firstterm>committing</firstterm>，或者是<firstterm>checking in</firstterm>）修改到版本库。"

#: build/en/book.xml:1651(para)
#, fuzzy
msgid "To publish your changes to others, you can use Subversion's <command moreinfo=\"none\">commit</command> command."
msgstr "发布你的修改给别人，你可以使用Subversion的提交（<command moreinfo=\"none\">commit</command>）命令："

#: build/en/book.xml:1654(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit button.c -m \"Fixed a typo in button.c.\"\n"
"Sending        button.c\n"
"Transmitting file data .\n"
"Committed revision 57.\n"
msgstr ""
"\n"
"$ svn commit button.c -m \"Fixed a typo in button.c.\"\n"
"Sending        button.c\n"
"Transmitting file data .\n"
"Committed revision 57.\n"

#: build/en/book.xml:1661(para)
#, fuzzy
msgid "Now your changes to <filename moreinfo=\"none\">button.c</filename> have been committed to the repository, with a note describing your change (namely, that you fixed a typo). If another user checks out a working copy of <filename moreinfo=\"none\">/calc</filename>, they will see your changes in the latest version of the file."
msgstr "这时你对<filename moreinfo=\"none\">button.c</filename>的修改已经提交到了版本库，如果其他人取出了<filename moreinfo=\"none\">/calc</filename>的一个工作拷贝，他们会看到这个文件最新的版本。"

#: build/en/book.xml:1668(para)
msgid "Suppose you have a collaborator, Sally, who checked out a working copy of <filename moreinfo=\"none\">/calc</filename> at the same time you did. When you commit your change to <filename moreinfo=\"none\">button.c</filename>, Sally's working copy is left unchanged; Subversion only modifies working copies at the user's request."
msgstr "假设你有个合作者，Sally，她和你同时取出了<filename moreinfo=\"none\">/calc</filename>的一个工作拷贝，你提交了你对<filename moreinfo=\"none\">button.c</filename>的修改，Sally的工作拷贝并没有改变，Subversion只在用户要求的时候才改变工作拷贝。"

#: build/en/book.xml:1675(para)
msgid "To bring her project up to date, Sally can ask Subversion to <firstterm>update</firstterm> her working copy, by using the Subversion <command moreinfo=\"none\">update</command> command. This will incorporate your changes into her working copy, as well as any others that have been committed since she checked it out."
msgstr "要使项目最新，Sally可以要求Subversion<firstterm>更新</firstterm>她的工作备份，通过使用更新（<command moreinfo=\"none\">update</command>）命令，将结合你和所有其他人在她上次更新之后的改变到她的工作拷贝。"

#: build/en/book.xml:1682(screen)
#, no-wrap
msgid ""
"\n"
"$ pwd\n"
"/home/sally/calc\n"
"\n"
"$ ls -A \n"
".svn/ Makefile integer.c button.c\n"
"\n"
"$ svn update\n"
"U    button.c\n"
"Updated to revision 57.\n"
msgstr ""
"\n"
"$ pwd\n"
"/home/sally/calc\n"
"\n"
"$ ls -A \n"
".svn/ Makefile integer.c button.c\n"
"\n"
"$ svn update\n"
"U    button.c\n"
"Updated to revision 57.\n"

#: build/en/book.xml:1694(para)
msgid "The output from the <command moreinfo=\"none\">svn update</command> command indicates that Subversion updated the contents of <filename moreinfo=\"none\">button.c</filename>. Note that Sally didn't need to specify which files to update; Subversion uses the information in the <filename moreinfo=\"none\">.svn</filename> directory, and further information in the repository, to decide which files need to be brought up to date."
msgstr "<command moreinfo=\"none\">svn update</command>命令的输出表明Subversion更新了<filename moreinfo=\"none\">button.c</filename>的内容，注意，Sally不必指定要更新的文件，subversion利用<filename moreinfo=\"none\">.svn</filename>以及版本库的进一步信息决定哪些文件需要更新。"

#: build/en/book.xml:1707(title)
msgid "Revisions"
msgstr "修订版本"

#: build/en/book.xml:1709(para)
#, fuzzy
msgid "An <command moreinfo=\"none\">svn commit</command> operation publishes changes to any number of files and directories as a single atomic transaction. In your working copy, you can change files' contents, create, delete, rename and copy files and directories, and then commit a complete set of changes as an atomic transaction."
msgstr "一个<command moreinfo=\"none\">svn commit</command>操作可以作为一个原子事务操作发布任意数量文件和目录的修改，在你的工作拷贝里，你可以改变文件内容、删除、改名和拷贝文件和目录，然后作为一个整体提交。"

#: build/en/book.xml:1716(para)
#, fuzzy
msgid "By <quote>atomic transaction</quote>, we mean simply this: either all of the changes happen in the repository, or none of them happen. Subversion tries to retain this atomicity in the face of program crashes, system crashes, network problems, and other users' actions."
msgstr "在版本库中，每一次提交被当作一次原子事务操作：要么所有的改变发生，要么都不发生，Subversion努力保持原子性以应对程序错误、系统错误、网络问题和其他用户行为。"

#: build/en/book.xml:1722(para)
msgid "Each time the repository accepts a commit, this creates a new state of the filesystem tree, called a <firstterm>revision</firstterm>. Each revision is assigned a unique natural number, one greater than the number of the previous revision. The initial revision of a freshly created repository is numbered zero, and consists of nothing but an empty root directory."
msgstr "每当版本库接受了一个提交，文件系统进入了一个新的状态，叫做一次修订（<firstterm>revision</firstterm>），每一个修订版本被赋予一个独一无二的自然数，一个比一个大，初始修订号是0，只创建了一个空目录，没有任何内容。"

#: build/en/book.xml:1730(para)
msgid "<xref linkend=\"svn.basic.in-action.revs.dia-1\"/> illustrates a nice way to visualize the repository. Imagine an array of revision numbers, starting at 0, stretching from left to right. Each revision number has a filesystem tree hanging below it, and each tree is a <quote>snapshot</quote> of the way the repository looked after a commit."
msgstr "<xref linkend=\"svn.basic.in-action.revs.dia-1\"/>可以更形象的描述版本库，想象有一组修订号，从0开始，从左到右，每一个修订号有一个目录树挂在它下面，每一个树好像是一次提交后的版本库<quote>快照</quote>。"

#: build/en/book.xml:1738(title)
msgid "The repository"
msgstr "版本库"

#: build/en/book.xml:1743(title)
msgid "Global Revision Numbers"
msgstr "全局版本号"

#: build/en/book.xml:1745(para)
#, fuzzy
msgid "Unlike most version control systems, Subversion's revision numbers apply to <emphasis>entire trees</emphasis>, not individual files. Each revision number selects an entire tree, a particular state of the repository after some committed change. Another way to think about it is that revision N represents the state of the repository filesystem after the Nth commit. When Subversion users talk about <quote>revision 5 of <filename moreinfo=\"none\">foo.c</filename></quote>, they really mean <quote><filename moreinfo=\"none\">foo.c</filename> as it appears in revision 5.</quote> Notice that in general, revisions N and M of a file do <emphasis>not</emphasis> necessarily differ! Many other version control systems use per-file revision numbers, so this concept may seem unusual at first. (Former CVS users might want to see <xref linkend=\"svn.forcvs\"/> for more details.)"
msgstr "不像其他版本控制系统，Subversion的修订号是针对整个<emphasis>目录树</emphasis>的，而不是单个文件。每一个修订号代表了一次提交后版本库整个目录树的特定状态，另一种理解是修订号N代表版本库已经经过了N次提交。当Subversion用户讨论<quote><filename moreinfo=\"none\">foo.c</filename>的修订号5</quote>时，他们的实际意思是<quote>在修订号5时的<filename moreinfo=\"none\">foo.c</filename></quote>。需要注意的是，修订号N和M并<emphasis>不</emphasis>表示一个文件需要不同。因为CVS使用每一个文件一个修订号的策略，CVS用户可能希望察看<xref linkend=\"svn.forcvs\"/>来得到更多细节。"

#: build/en/book.xml:1763(para)
msgid "It's important to note that working copies do not always correspond to any single revision in the repository; they may contain files from several different revisions. For example, suppose you check out a working copy from a repository whose most recent revision is 4:"
msgstr "需要特别注意的是，工作拷贝并不一定对应版本库中的单个修订版本，他们可能包含多个修订版本的文件。举个例子，你从版本库检出一个工作拷贝，最近的修订号是4："

#: build/en/book.xml:1769(screen)
#, no-wrap
msgid ""
"\n"
"calc/Makefile:4\n"
"     integer.c:4\n"
"     button.c:4\n"
msgstr ""
"\n"
"calc/Makefile:4\n"
"     integer.c:4\n"
"     button.c:4\n"

#: build/en/book.xml:1775(para)
msgid "At the moment, this working directory corresponds exactly to revision 4 in the repository. However, suppose you make a change to <filename moreinfo=\"none\">button.c</filename>, and commit that change. Assuming no other commits have taken place, your commit will create revision 5 of the repository, and your working copy will now look like this:"
msgstr "此刻，工作目录与版本库的修订版本4完全对应，然而，你修改了<filename moreinfo=\"none\">button.c</filename>并且提交之后，假设没有别的提交出现，你的提交会在版本库建立修订版本5，你的工作拷贝会是这个样子的："

#: build/en/book.xml:1782(screen)
#, no-wrap
msgid ""
"\n"
"calc/Makefile:4\n"
"     integer.c:4\n"
"     button.c:5\n"
msgstr ""
"\n"
"calc/Makefile:4\n"
"     integer.c:4\n"
"     button.c:5\n"

#: build/en/book.xml:1788(para)
msgid "Suppose that, at this point, Sally commits a change to <filename moreinfo=\"none\">integer.c</filename>, creating revision 6. If you use <command moreinfo=\"none\">svn update</command> to bring your working copy up to date, then it will look like this:"
msgstr "假设此刻，Sally提交了对<filename moreinfo=\"none\">integer.c</filename>的修改，建立修订版本6，如果你使用<command moreinfo=\"none\">svn update</command>来更新你的工作拷贝，你会看到："

#: build/en/book.xml:1793(screen)
#, no-wrap
msgid ""
"\n"
"calc/Makefile:6\n"
"     integer.c:6\n"
"     button.c:6\n"
msgstr ""
"\n"
"calc/Makefile:6\n"
"     integer.c:6\n"
"     button.c:6\n"

#: build/en/book.xml:1799(para)
msgid "Sally's change to <filename moreinfo=\"none\">integer.c</filename> will appear in your working copy, and your change will still be present in <filename moreinfo=\"none\">button.c</filename>. In this example, the text of <filename moreinfo=\"none\">Makefile</filename> is identical in revisions 4, 5, and 6, but Subversion will mark your working copy of <filename moreinfo=\"none\">Makefile</filename> with revision 6 to indicate that it is still current. So, after you do a clean update at the top of your working copy, it will generally correspond to exactly one revision in the repository."
msgstr "Sally对<filename moreinfo=\"none\">integer.c</filename>的改变会出现在你的工作拷贝，你对<filename moreinfo=\"none\">button.c</filename>的改变还在，在这个例子里，<filename moreinfo=\"none\">Makefile</filename>在4、5、6修订版本都是一样的，但是Subversion会把他的<filename moreinfo=\"none\">Makefile</filename>的修订号设为6来表明它是最新的，所以你在工作拷贝顶级目录作一次干净的更新，会使得所有内容对应版本库的同一修订版本。"

#: build/en/book.xml:1814(title)
msgid "How Working Copies Track the Repository"
msgstr "工作拷贝怎样跟踪版本库"

#: build/en/book.xml:1816(para)
msgid "For each file in a working directory, Subversion records two essential pieces of information in the <filename moreinfo=\"none\">.svn/</filename> administrative area:"
msgstr "对于工作拷贝的每一个文件，Subversion在管理区域<filename moreinfo=\"none\">.svn/</filename>记录两项关键的信息："

#: build/en/book.xml:1823(para)
msgid "what revision your working file is based on (this is called the file's <firstterm>working revision</firstterm>), and"
msgstr "工作文件所作为基准的修订版本（叫做文件的<firstterm>工作修订版本</firstterm>）和"

#: build/en/book.xml:1829(para)
msgid "a timestamp recording when the local copy was last updated by the repository."
msgstr "一个本地拷贝最后更新的时间戳。"

#: build/en/book.xml:1834(para)
msgid "Given this information, by talking to the repository, Subversion can tell which of the following four states a working file is in:"
msgstr "给定这些信息，通过与版本库通讯，Subversion可以告诉我们工作文件是处与如下四种状态的那一种："

#: build/en/book.xml:1840(term)
msgid "Unchanged, and current"
msgstr "未修改且是当前的"

#: build/en/book.xml:1843(para)
msgid "The file is unchanged in the working directory, and no changes to that file have been committed to the repository since its working revision. An <command moreinfo=\"none\">svn commit</command> of the file will do nothing, and an <command moreinfo=\"none\">svn update</command> of the file will do nothing."
msgstr "文件在工作目录里没有修改，在工作修订版本之后没有修改提交到版本库。<command moreinfo=\"none\">svn commit</command>操作不做任何事情，<command moreinfo=\"none\">svn update</command>不做任何事情。"

#: build/en/book.xml:1853(term)
msgid "Locally changed, and current"
msgstr "本地已修改且是当前的"

#: build/en/book.xml:1856(para)
#, fuzzy
msgid "The file has been changed in the working directory, and no changes to that file have been committed to the repository since you last updated. There are local changes that have not been committed to the repository, thus an <command moreinfo=\"none\">svn commit</command> of the file will succeed in publishing your changes, and an <command moreinfo=\"none\">svn update</command> of the file will do nothing."
msgstr "在工作目录已经修改，从基本修订版本之后没有修改提交到版本库。本地修改没有提交，因此<command moreinfo=\"none\">svn commit</command>会成功的提交，<command moreinfo=\"none\">svn update</command>不做任何事情。"

#: build/en/book.xml:1867(term)
msgid "Unchanged, and out-of-date"
msgstr "未修改且不是当前的了"

#: build/en/book.xml:1870(para)
#, fuzzy
msgid "The file has not been changed in the working directory, but it has been changed in the repository. The file should eventually be updated, to make it current with the latest public revision. An <command moreinfo=\"none\">svn commit</command> of the file will do nothing, and an <command moreinfo=\"none\">svn update</command> of the file will fold the latest changes into your working copy."
msgstr "这个文件在工作目录没有修改，但在版本库中已经修改了。这个文件最终将更新到最新版本，成为当时的公共修订版本。<command moreinfo=\"none\">svn commit</command>不做任何事情，<command moreinfo=\"none\">svn update</command>将会取得最新的版本到工作拷贝。"

#: build/en/book.xml:1881(term)
msgid "Locally changed, and out-of-date"
msgstr "本地已修改且不是最新的"

#: build/en/book.xml:1884(para)
msgid "The file has been changed both in the working directory, and in the repository. An <command moreinfo=\"none\">svn commit</command> of the file will fail with an <quote>out-of-date</quote> error. The file should be updated first; an <command moreinfo=\"none\">svn update</command> command will attempt to merge the public changes with the local changes. If Subversion can't complete the merge in a plausible way automatically, it leaves it to the user to resolve the conflict."
msgstr "这个文件在工作目录和版本库都得到修改。一个<command moreinfo=\"none\">svn commit</command>将会失败，这个文件必须首先更新，<command moreinfo=\"none\">svn update</command>命令会合并公共和本地修改，如果Subversion不可以自动完成，将会让用户解决冲突。"

#: build/en/book.xml:1898(para)
msgid "This may sound like a lot to keep track of, but the <command moreinfo=\"none\">svn status</command> command will show you the state of any item in your working copy. For more information on that command, see <xref linkend=\"svn.tour.cycle.examine.status\"/>."
msgstr "这看起来需要记录很多事情，但是<command moreinfo=\"none\">svn status</command>命令可以告诉你工作拷贝中文件的状态，关于此命令更多的信息，请看<xref linkend=\"svn.tour.cycle.examine.status\"/>。"

#: build/en/book.xml:1908(title)
msgid "Mixed Revision Working Copies"
msgstr "混合版本的工作拷贝"

#: build/en/book.xml:1910(para)
msgid "As a general principle, Subversion tries to be as flexible as possible. One special kind of flexibility is the ability to have a working copy containing files and directories with a mix of different working revision numbers. Unfortunately, this flexibility tends to confuse a number of new users. If the earlier example showing mixed revisions perplexed you, here's a primer on both why the feature exists and how to make use of it."
msgstr "作为一个普遍原理，Subversion努力做到尽可能的灵活，一个特殊的灵活特性就是让工作拷贝包含不同工作修订版本号的文件和目录，不幸的是，这个灵活性会让许多新用户感到迷惑。如果上一个混合修订版本的例子让你感到困惑，这里是一个为何有这种特性和如何利用这个特性的基础介绍。"

#: build/en/book.xml:1921(title)
msgid "Updates and Commits are Separate"
msgstr "更新和提交是分开的"

#: build/en/book.xml:1923(para)
msgid "One of the fundamental rules of Subversion is that a <quote>push</quote> action does not cause a <quote>pull</quote>, nor the other way around. Just because you're ready to submit new changes to the repository doesn't mean you're ready to receive changes from other people. And if you have new changes still in progress, then <command moreinfo=\"none\">svn update</command> should gracefully merge repository changes into your own, rather than forcing you to publish them."
msgstr "Subversion有一个基本原则就是一个<quote>push</quote>动作不会导致<quote>pull</quote>，或者相反的过程，因为你准备好了提交你的修改并不意味着你已经准备好了从其他人那里接受修改。如果你的新的修改还在进行，<command moreinfo=\"none\">svn update</command>将会优雅的合并版本库的修改到你的工作拷贝，而不会强迫将修改发布。"

#: build/en/book.xml:1933(para)
msgid "The main side-effect of this rule is that it means a working copy has to do extra bookkeeping to track mixed revisions, and be tolerant of the mixture as well. It's made more complicated by the fact that directories themselves are versioned."
msgstr "这个规则的主要副作用就是工作拷贝需要记录额外的信息来追踪混合修订版本，并且也需要能容忍这种混合，当目录本身也是版本化的时候情况更加复杂。"

#: build/en/book.xml:1939(para)
msgid "For example, suppose you have a working copy entirely at revision 10. You edit the file <filename moreinfo=\"none\">foo.html</filename> and then perform an <command moreinfo=\"none\">svn commit</command>, which creates revision 15 in the repository. After the commit succeeds, many new users would expect the working copy to be entirely at revision 15, but that's not the case! Any number of changes might have happened in the repository between revisions 10 and 15. The client knows nothing of those changes in the repository, since you haven't yet run <command moreinfo=\"none\">svn update</command>, and <command moreinfo=\"none\">svn commit</command> doesn't pull down new changes. If, on the other hand, <command moreinfo=\"none\">svn commit</command><emphasis>were</emphasis> to automatically download the newest changes, then it would be possible to set the entire working copy to revision 15—but then we'd be breaking the fundamental rule of <quote>push</quote> and <quote>pull</quote> remaining separate actions. Therefore the only safe thing the Subversion client can do is mark the one file—<filename moreinfo=\"none\">foo.html</filename>—as being at revision 15. The rest of the working copy remains at revision 10. Only by running <command moreinfo=\"none\">svn update</command> can the latest changes be downloaded, and the whole working copy be marked as revision 15."
msgstr "举个例子，假定你有一个工作拷贝，修订版本号是10。你修改了<filename moreinfo=\"none\">foo.html</filename>，然后执行<command moreinfo=\"none\">svn commit</command>，在版本库里创建了修订版本15。当成功提交之后，许多用户希望工作拷贝完全变成修订版本15，但是事实并非如此。修订版本从10到15会发生任何修改，可是客户端在运行<command moreinfo=\"none\">svn update</command>之前不知道版本库发生了怎样的改变，<command moreinfo=\"none\">svn commit</command>不会拖出任何新的修改。另一方面，如果<command moreinfo=\"none\">svn commit</command>会自动下载最新的修改，可以使得整个工作拷贝成为修订版本15—但是，那样我们会打破<quote>push</quote>和<quote>pull</quote>完全分开的原则。因此，Subversion客户端最安全的方式是标记一个文件—<filename moreinfo=\"none\">foo.html</filename>—为修订版本15，工作拷贝余下的部分还是修订版本10。只有运行<command moreinfo=\"none\">svn update</command>才会下载最新的修改，整个工作拷贝被标记为修订版本15。"

#: build/en/book.xml:1968(title)
msgid "Mixed revisions are normal"
msgstr "混合版本很常见"

#: build/en/book.xml:1970(para)
msgid "The fact is, <emphasis>every time</emphasis> you run <command moreinfo=\"none\">svn commit</command>, your working copy ends up with some mixture of revisions. The things you just committed are marked as having larger working revisions than everything else. After several commits (with no updates in-between) your working copy will contain a whole mixture of revisions. Even if you're the only person using the repository, you will still see this phenomenon. To examine your mixture of working revisions, use the <command moreinfo=\"none\">svn status --verbose</command> command (see <xref linkend=\"svn.tour.cycle.examine.status\"/> for more information.)"
msgstr "事实上，<emphasis>每次</emphasis>运行<command moreinfo=\"none\">svn commit</command>，你的工作拷贝都会进入混合多个修订版本的状态，刚刚提交的文件会比其他文件有更高的修订版本号。经过多次提交（之间没有更新），你的工作拷贝会完全是混合的修订版本。即使只有你一个人使用版本库，你依然会见到这个现象。为了检验混合工作修订版本，可以使用<command moreinfo=\"none\">svn status --verbose</command>命令（详细信息见<xref linkend=\"svn.tour.cycle.examine.status\"/>）。"

#: build/en/book.xml:1982(para)
msgid "Often, new users are completely unaware that their working copy contains mixed revisions. This can be confusing, because many client commands are sensitive to the working revision of the item they're examining. For example, the <command moreinfo=\"none\">svn log</command> command is used to display the history of changes to a file or directory (see <xref linkend=\"svn.tour.history.log\"/>). When the user invokes this command on a working copy object, they expect to see the entire history of the object. But if the object's working revision is quite old (often because <command moreinfo=\"none\">svn update</command> hasn't been run in a long time), then the history of the <emphasis>older</emphasis> version of the object is shown."
msgstr "通常，新用户对于工作拷贝的混合修订版本一无所知，这会让人糊涂，因为许多客户端命令对于所检验条目的修订版本很敏感。例如<command moreinfo=\"none\">svn log</command>命令显示一个文件或目录的历史修改信息（见<xref linkend=\"svn.tour.history.log\"/>），当用户对一个工作拷贝对象调用这个命令，他们希望看到这个对象的整个历史信息。但是如果这个对象的修订版本已经相当老了（通常因为很长时间没有运行<command moreinfo=\"none\">svn update</command>），此时会显示比这个对象<emphasis>更老的</emphasis>历史。"

#: build/en/book.xml:2000(title)
msgid "Mixed revisions are useful"
msgstr "混合版本很有用"

#: build/en/book.xml:2002(para)
msgid "If your project is sufficiently complex, you'll discover that it's sometimes nice to forcibly <quote>backdate</quote> portions of your working copy to an earlier revision; you'll learn how to do that in <xref linkend=\"svn.tour\"/>. Perhaps you'd like to test an earlier version of a sub-module contained in a subdirectory, or perhaps you'd like to figure out when a bug first came into existence in a specific file. This is the <quote>time machine</quote> aspect of a version control system — the feature which allows you to move any portion of your working copy forward and backward in history."
msgstr "如果你的项目十分复杂，有时候你会发现强制工作拷贝的一部分<quote>回溯</quote>到过去非常有用，你将在第三章学习到如何这样做。或许你很希望测试某一子目录下某一子模块的早期版本，又或是要测试一个bug什么时候发生，这是版本控制系统像<quote>时间机器</quote>的一个方面—这个特性允许工作拷贝的任何一个部分在历史中前进或后退。"

#: build/en/book.xml:2018(title)
msgid "Mixed revisions have limitations"
msgstr "混合版本有限制"

#: build/en/book.xml:2020(para)
msgid "However you make use of mixed revisions in your working copy, there are limitations to this flexibility."
msgstr "无论你如何在工作拷贝中利用混合修订版本，这种灵活性还是有限制的。"

#: build/en/book.xml:2023(para)
msgid "First, you cannot commit the deletion of a file or directory which isn't fully up-to-date. If a newer version of the item exists in the repository, your attempt to delete will be rejected, to prevent you from accidentally destroying changes you've not yet seen."
msgstr "首先，你不可以提交一个不是完全最新的文件或目录，如果有个新的版本存在于版本库，你的删除操作会被拒绝，这防止你不小心破坏你没有见到的东西。"

#: build/en/book.xml:2029(para)
#, fuzzy
msgid "Second, you cannot commit a metadata change to a directory unless it's fully up-to-date. You'll learn about attaching <quote>properties</quote> to items in <xref linkend=\"svn.advanced\"/>. A directory's working revision defines a specific set of entries and properties, and thus committing a property change to an out-of-date directory may destroy properties you've not yet seen."
msgstr "第二，如果目录已经不是最新的了，你不能提交一个目录的元数据更改。你将会在第6章学习附加<quote>属性</quote>，一个目录的工作修订版本定义了许多条目和属性，因而对一个过期的版本提交属性会破坏一些你没有见到的属性。"

#: build/en/book.xml:2046(title) build/en/book.xml:3977(title)
#: build/en/book.xml:9645(title) build/en/book.xml:12575(title)
msgid "Summary"
msgstr "概要"

#: build/en/book.xml:2048(para)
msgid "We've covered a number of fundamental Subversion concepts in this chapter:"
msgstr "我们在这一章里学习了许多Subversion的基本概念："

#: build/en/book.xml:2053(para)
msgid "We've introduced the notions of the central repository, the client working copy, and the array of repository revision trees."
msgstr "我们介绍了中央版本库的概念、客户工作拷贝和版本修订树。"

#: build/en/book.xml:2059(para)
msgid "We've seen some simple examples of how two collaborators can use Subversion to publish and receive changes from one another, using the <quote>copy-modify-merge</quote> model."
msgstr "我们介绍了两个协作者如何使用Subversion发布和获得对方的修改，使用<quote>拷贝-修改-合并</quote>模型。"

#: build/en/book.xml:2066(para)
msgid "We've talked a bit about the way Subversion tracks and manages information in a working copy."
msgstr "我们讨论了一些Subversion跟踪和管理工作拷贝信息的方式。"

#: build/en/book.xml:2072(para)
#, fuzzy
msgid "At this point, you should have a good idea of how Subversion works in the most general sense. Armed with this knowledge, you should now be ready to move into the next chapter, which is a detailed tour of Subversion's commands and features."
msgstr "现在，你一定对Subversion在多数情形下的工作方式有了很好的认识，有了这些知识的武装，你一定已经准备好跳到下一章去了，一个关于Subversion命令与特性的详细教程。"

#: build/en/book.xml:2088(title)
msgid "Basic Usage"
msgstr "基本用法"

#: build/en/book.xml:2090(para)
#, fuzzy
msgid "Now we will go into the details of using Subversion. By the time you reach the end of this chapter, you will be able to perform all the tasks you need to use Subversion in a normal day's work. You'll start with getting your files into Subversion, followed by an initial checkout of your code. We'll then walk you through making changes and examining those changes. You'll also see how to bring changes made by others into your working copy, examine them, and work through any conflicts that might arise."
msgstr "现在，我们将要深入到Subversion到使用细节当中，完成本章，你将学会所有日常使用的Subversion命令，你将从一个初始化检出开始，做出修改并检查，你也将会学到如何将别人的修改取到工作拷贝，检查他们，并解决所有可能发生的冲突。"

#: build/en/book.xml:2100(para)
msgid "Note that this chapter is not meant to be an exhaustive list of all Subversion's commands—rather, it's a conversational introduction to the most common Subversion tasks you'll encounter. This chapter assumes that you've read and understood <xref linkend=\"svn.basic\"/> and are familiar with the general model of Subversion. For a complete reference of all commands, see <xref linkend=\"svn.ref\"/>."
msgstr "这一章并不是Subversion命令的完全列表—而是你将会遇到的最常用任务的介绍，这一章假定你已经读过并且理解了<xref linkend=\"svn.basic\"/>，而且熟悉Subversion的模型，如果想查看所有命令的参考，见<xref linkend=\"svn.ref\"/>。"

#: build/en/book.xml:2113(title) build/en/book.xml:19428(refpurpose)
#: build/en/book.xml:22327(refpurpose) build/en/book.xml:23377(refpurpose)
msgid "Help!"
msgstr "求助！"

#: build/en/book.xml:2115(para)
#, fuzzy
msgid "Before reading on, here is the most important command you'll ever need when using Subversion: <command moreinfo=\"none\">svn help</command>. The Subversion command-line client is self-documenting—at any time, a quick <command moreinfo=\"none\">svn help <replaceable>SUBCOMMAND</replaceable></command> will describe the syntax, switches, and behavior of the subcommand."
msgstr "在继续阅读之前，需要知道Subversion使用中最重要的命令：<command moreinfo=\"none\">svn help</command>，Subversion命令行工具是一个自文档的工具—在任何时候你可以运行<command moreinfo=\"none\">svn help &lt;subcommand&gt;</command>来查看子命令的语法、参数以及行为方式。"

#: build/en/book.xml:2122(screen)
#, no-wrap
msgid ""
"\n"
"$ svn help import\n"
"import: Commit an unversioned file or tree into the repository.\n"
"usage: import [PATH] URL\n"
"\n"
"  Recursively commit a copy of PATH to URL.\n"
"  If PATH is omitted '.' is assumed.\n"
"  Parent directories are created as necessary in the repository.\n"
"  If PATH is a directory, the contents of the directory are added\n"
"  directly under URL.\n"
"\n"
"Valid options:\n"
"  -q [--quiet]             : print as little as possible\n"
"  -N [--non-recursive]     : operate on single directory only\n"
"…\n"
msgstr ""
"\n"
"$ svn help import\n"
"import: Commit an unversioned file or tree into the repository.\n"
"usage: import [PATH] URL\n"
"\n"
"  Recursively commit a copy of PATH to URL.\n"
"  If PATH is omitted '.' is assumed.\n"
"  Parent directories are created as necessary in the repository.\n"
"  If PATH is a directory, the contents of the directory are added\n"
"  directly under URL.\n"
"\n"
"Valid options:\n"
"  -q [--quiet]             : print as little as possible\n"
"  -N [--non-recursive]     : operate on single directory only\n"
"…\n"

#: build/en/book.xml:2144(title)
#, fuzzy
msgid "Getting Data into your Repository"
msgstr "导入数据到你的版本库"

#: build/en/book.xml:2146(para)
#, fuzzy
msgid "There are two ways to get new files into your Subversion repository: <command moreinfo=\"none\">svn import</command> and <command moreinfo=\"none\">svn add</command>. We'll discuss <command moreinfo=\"none\">svn import</command> here and <command moreinfo=\"none\">svn add</command> later in this chapter when we review a typical day with Subversion."
msgstr "如果你看过树中目录和文件的布局，你可以使用<command moreinfo=\"none\">svnlook cat</command>，<command moreinfo=\"none\">svnlook propget</command>， 和<command moreinfo=\"none\">svnlook proplist</command>命令来查看这些目录和文件的细节。"

#: build/en/book.xml:2154(title) build/en/book.xml:19479(refname)
msgid "svn import"
msgstr "svn import"

#: build/en/book.xml:2156(para)
msgid "The <command moreinfo=\"none\">svn import</command> command is a quick way to copy an unversioned tree of files into a repository, creating intermediate directories as necessary. <command moreinfo=\"none\">svn import</command> doesn't require a working copy, and your files are immediately committed to the repository. This is typically used when you have an existing tree of files that you want to begin tracking in your Subversion repository. For example:"
msgstr ""

#: build/en/book.xml:2164(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create /usr/local/svn/newrepos\n"
"$ svn import mytree file:///usr/local/svn/newrepos/some/project \\\n"
"             -m \"Initial import\"\n"
"Adding         mytree/foo.c\n"
"Adding         mytree/bar.c\n"
"Adding         mytree/subdir\n"
"Adding         mytree/subdir/quux.h\n"
"\n"
"Committed revision 1.\n"
msgstr ""
"\n"
"$ svnadmin create /usr/local/svn/newrepos\n"
"$ svn import mytree file:///usr/local/svn/newrepos/some/project \\\n"
"             -m \"Initial import\"\n"
"Adding         mytree/foo.c\n"
"Adding         mytree/bar.c\n"
"Adding         mytree/subdir\n"
"Adding         mytree/subdir/quux.h\n"
"\n"
"Committed revision 1.\n"

#: build/en/book.xml:2176(para)
msgid "The previous example copied the contents of directory <filename moreinfo=\"none\">mytree</filename> under the directory <filename moreinfo=\"none\">some/project</filename> in the repository:"
msgstr "在上一个例子里，将会拷贝目录<filename moreinfo=\"none\">mytree</filename>到版本库的<filename moreinfo=\"none\">some/project</filename>下："

#: build/en/book.xml:2180(screen)
#, no-wrap
msgid ""
"\n"
"$ svn list file:///usr/local/svn/newrepos/some/project\n"
"bar.c\n"
"foo.c\n"
"subdir/\n"
msgstr ""
"\n"
"$ svn list file:///usr/local/svn/newrepos/some/project\n"
"bar.c\n"
"foo.c\n"
"subdir/\n"

#: build/en/book.xml:2187(para)
msgid "Note that after the import is finished, the original tree is <emphasis>not</emphasis> converted into a working copy. To start working, you still need to <command moreinfo=\"none\">svn checkout</command> a fresh working copy of the tree."
msgstr "注意，在导入之后，原来的目录树并<emphasis>没有</emphasis>转化成工作拷贝，为了开始工作，你还是需要运行<command moreinfo=\"none\">svn checkout</command>导出一个工作拷贝。"

#: build/en/book.xml:2196(title)
msgid "Recommended repository layout"
msgstr "推荐的版本库布局"

#: build/en/book.xml:2198(para)
#, fuzzy
msgid "While Subversion's flexibility allows you to layout your repository in any way that you choose, we recommend that you create a <filename moreinfo=\"none\">trunk</filename> directory to hold the <quote>main line</quote> of development, a <filename moreinfo=\"none\">branches</filename> directory to contain branch copies, and a <filename moreinfo=\"none\">tags</filename> directory to contain tag copies, for example:"
msgstr "有一些标准的，推荐的组织版本库的方式，许多人创建一个<filename moreinfo=\"none\">trunk</filename>目录来保存开发的<quote>主线</quote>，一个<filename moreinfo=\"none\">branches</filename>目录存放分支拷贝，一个目录保存标签拷贝，如果一个版本库只是存放一个项目，人们会在顶级目录创建这些目录："

#: build/en/book.xml:2206(screen)
#, no-wrap
msgid ""
"\n"
"$ svn list file:///usr/local/svn/repos\n"
"/trunk\n"
"/branches\n"
"/tags\n"
msgstr ""
"\n"
"$ svn list file:///usr/local/svn/repos\n"
"/trunk\n"
"/branches\n"
"/tags\n"

#: build/en/book.xml:2213(para)
#, fuzzy
msgid "You'll learn more about tags and branches in <xref linkend=\"svn.branchmerge\"/>. For details and how to setup multiple projects, see <xref linkend=\"svn.branchmerge.maint.layout\"/> and <xref linkend=\"svn.reposadmin.projects.chooselayout\"/> to read more about <quote>project roots</quote>."
msgstr "如果一个版本库保存了多个项目，管理员会通过项目来布局（见<xref linkend=\"svn.reposadmin.projects.chooselayout\"/>关于<quote>项目根目录</quote>）："

#: build/en/book.xml:2225(title)
msgid "Initial Checkout"
msgstr "初始化检出"

#: build/en/book.xml:2227(para)
#, fuzzy
msgid "Most of the time, you will start using a Subversion repository by doing a <firstterm>checkout</firstterm> of your project. Checking out a repository creates a <quote>working copy</quote> of it on your local machine. This copy contains the <literal moreinfo=\"none\">HEAD</literal> (latest revision) of the Subversion repository that you specify on the command line:"
msgstr "大多数时候，你会使用<firstterm>checkout</firstterm>从版本库取出一个新拷贝开始使用Subversion，这样会在本机创建一个项目的本地拷贝，这个拷贝包括版本库中的HEAD（最新的）版本："

#: build/en/book.xml:2235(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://svn.collab.net/repos/svn/trunk\n"
"A    trunk/Makefile.in\n"
"A    trunk/ac-helpers\n"
"A    trunk/ac-helpers/install.sh\n"
"A    trunk/ac-helpers/install-sh\n"
"A    trunk/build.conf\n"
"…\n"
"Checked out revision 8810.\n"
msgstr ""
"\n"
"$ svn checkout http://svn.collab.net/repos/svn/trunk\n"
"A    trunk/Makefile.in\n"
"A    trunk/ac-helpers\n"
"A    trunk/ac-helpers/install.sh\n"
"A    trunk/ac-helpers/install-sh\n"
"A    trunk/build.conf\n"
"…\n"
"Checked out revision 8810.\n"

#: build/en/book.xml:2247(title)
msgid "What's in a Name?"
msgstr "名称中有什么？"

#: build/en/book.xml:2249(para)
msgid "Subversion tries hard not to limit the type of data you can place under version control. The contents of files and property values are stored and transmitted as binary data, and <xref linkend=\"svn.advanced.props.special.mime-type\"/> tells you how to give Subversion a hint that <quote>textual</quote> operations don't make sense for a particular file. There are a few places, however, where Subversion places restrictions on information it stores."
msgstr "Subversion努力控制版本控制下数据的类型，文件的内容和属性值都是按照二进制数据存储和传递，并且<xref linkend=\"svn.advanced.props.special.mime-type\"/>给Subversion提示以说明对于特定文件<quote>文本化的</quote>操作是没有意义的，也有一些地方，Subversion对存放信息的有限制。"

#: build/en/book.xml:2259(para)
msgid "Subversion internally handles certain bits of data—for example, property names, path names, and log messages—as UTF-8 encoded Unicode. This is not to say that all your interactions with Subversion must involve UTF-8, though. As a general rule, Subversion clients will gracefully and transparently handle conversions between UTF-8 and the encoding system in use on your computer, if such a conversion can meaningfully be done (which is the case for most common encodings in use today)."
msgstr "Subversion内部使用二进制处理数据—例如，属性名称，路径名和日志信息—UTF-8编码的Unicode，这并不意味着与Subversion的交互必须完全使用UTF-8。作为一个惯例，Subversion的客户端能够透明的转化UTF-8和你所使用系统的编码，前提是可以进行有意义的转换（当然是大多数目前常见的编码）。"

#: build/en/book.xml:2269(para)
#, fuzzy
msgid "In addition, path names are used as XML attribute values in WebDAV exchanges, as well in as some of Subversion's housekeeping files. This means that path names can only contain legal XML (1.0) characters. Subversion also prohibits TAB, CR, and LF characters in path names to prevent paths from being broken up in diffs, or in the output of commands like <xref linkend=\"svn.ref.svn.c.log\"/> or <xref linkend=\"svn.ref.svn.c.status\"/>."
msgstr "此外，路径名称在WebDAV交换中会作为XML属性值，就像Subversion的管理文件。这意味着路径名称只能包含合法的XML（1.0）字符，Subversion也会禁止路径名称中出现TAB、CR或LF字符，所以它们才不会在区别程序或如<xref linkend=\"svn.ref.svn.c.log\"/>和<xref linkend=\"svn.ref.svn.c.status\"/>的输出命令中断掉。"

#: build/en/book.xml:2277(para)
#, fuzzy
msgid "While it may seem like a lot to remember, in practice these limitations are rarely a problem. As long as your locale settings are compatible with UTF-8, and you don't use control characters in path names, you should have no trouble communicating with Subversion. The command-line client adds an extra bit of help—it will automatically escape illegal path characters as needed in URLs you type to create <quote>legally correct</quote> versions for internal use."
msgstr "虽然看起来要记住很多事情，但在实践中这些限制很少会成为问题。只要你的本地设置兼容UTF-8，也不在路径名称中使用控制字符，与Subversion的通讯就不会有问题。命令行客户端会添加一些额外的帮助字节—自动将你输入的URL路径字符转化为<quote>合法正确的</quote>内部用版本。"

#: build/en/book.xml:2289(para)
msgid "Although the above example checks out the trunk directory, you can just as easily check out any deep subdirectory of a repository by specifying the subdirectory in the checkout URL:"
msgstr "尽管上面的例子取出了trunk目录，你也完全可以通过输入特定URL取出任意深度的子目录："

#: build/en/book.xml:2294(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout -r 8810 \\\n"
"      http://svn.collab.net/repos/svn/trunk/subversion/tests/cmdline/\n"
"A    cmdline/revert_tests.py\n"
"A    cmdline/diff_tests.py\n"
"A    cmdline/autoprop_tests.py\n"
"A    cmdline/xmltests\n"
"A    cmdline/xmltests/svn-test.sh\n"
"…\n"
"Checked out revision 8810.\n"
msgstr ""
"\n"
"$ svn checkout -r 8810 \\\n"
"      http://svn.collab.net/repos/svn/trunk/subversion/tests/cmdline/\n"
"A    cmdline/revert_tests.py\n"
"A    cmdline/diff_tests.py\n"
"A    cmdline/autoprop_tests.py\n"
"A    cmdline/xmltests\n"
"A    cmdline/xmltests/svn-test.sh\n"
"…\n"
"Checked out revision 8810.\n"

#: build/en/book.xml:2306(para)
#, fuzzy
msgid "Since Subversion uses a <quote>copy-modify-merge</quote> model instead of <quote>lock-modify-unlock</quote> (see <xref linkend=\"svn.basic.vsn-models\"/>), you're already able to start making changes to the files and directories in your working copy. Your working copy is just like any other collection of files and directories on your system. You can edit and change them, move them around, you can even delete the entire working copy and forget about it."
msgstr "因为Subversion使用<quote>拷贝-修改-合并</quote>模型而不是<quote>锁定-修改-解锁</quote>模型（见<xref linkend=\"svn.basic\"/>），你可以开始修改工作拷贝中的目录和文件，你的工作拷贝和你的系统中的其它文件和目录完全一样，你可以编辑并改变它，移动它，也可以完全的删掉它，把它忘了。"

#: build/en/book.xml:2316(para)
#, fuzzy
msgid "While your working copy is <quote>just like any other collection of files and directories on your system</quote>, you can edit files at will, but you must tell Subversion about <emphasis>everything else</emphasis> that you do. For example, if you want to copy or move an item in a working copy, you should use <command moreinfo=\"none\">svn copy</command> or <command moreinfo=\"none\">svn move</command> instead of the copy and move commands provided by your operating system. We'll talk more about them later in this chapter."
msgstr "因为你的工作拷贝<quote>同你的系统上的文件和目录没有什么区别</quote>，如果你希望重新规划工作拷贝，你必须要让Subversion知道，当你希望拷贝或者移动工作拷贝的一个项目时，你应该使用<command moreinfo=\"none\">svn copy</command>或者 <command moreinfo=\"none\">svn move</command>而不要使用操作系统的命令，我们会在以后的章节详细介绍。"

#: build/en/book.xml:2327(para)
msgid "Unless you're ready to commit a new file or directory, or changes to existing ones, there's no need to further notify the Subversion server that you've done anything."
msgstr "除非你准备好了提交一个新文件或目录，或改变了已存在的，否则没有必要通知Subversion你做了什么。"

#: build/en/book.xml:2332(title)
msgid "What's with the <filename moreinfo=\"none\">.svn</filename> directory?"
msgstr "<filename moreinfo=\"none\">.svn</filename>目录包含什么？"

#: build/en/book.xml:2334(para)
msgid "Every directory in a working copy contains an administrative area, a subdirectory named <filename moreinfo=\"none\">.svn</filename>. Usually, directory listing commands won't show this subdirectory, but it is nevertheless an important directory. Whatever you do, don't delete or change anything in the administrative area! Subversion depends on it to manage your working copy."
msgstr "工作拷贝中的任何一个目录包括一个名为<filename moreinfo=\"none\">.svn</filename>管理区域，通常列表操作不显示这个目录，但它仍然是一个非常重要的目录，无论你做什么？不要删除或是更改这个管理区域的任何东西，Subversion使用它来管理工作拷贝。"

#: build/en/book.xml:2344(para)
msgid "While you can certainly check out a working copy with the URL of the repository as the only argument, you can also specify a directory after your repository URL. This places your working copy in the new directory that you name. For example:"
msgstr "因为你可以使用版本库的URL作为唯一参数取出一个工作拷贝，你也可以在版本库URL之后指定一个目录，这样会将你的工作目录放到你的新目录，举个例子："

#: build/en/book.xml:2349(screen)
#, no-wrap
msgid ""
"\n"
"$  svn -r 8810  checkout http://svn.collab.net/repos/svn/trunk subv\n"
"A    subv/Makefile.in\n"
"A    subv/ac-helpers\n"
"A    subv/ac-helpers/install.sh\n"
"A    subv/ac-helpers/install-sh\n"
"A    subv/build.conf\n"
"…\n"
"Checked out revision 8810.\n"
msgstr ""
"\n"
"$  svn -r 8810  checkout http://svn.collab.net/repos/svn/trunk subv\n"
"A    subv/Makefile.in\n"
"A    subv/ac-helpers\n"
"A    subv/ac-helpers/install.sh\n"
"A    subv/ac-helpers/install-sh\n"
"A    subv/build.conf\n"
"…\n"
"Checked out revision 8810.\n"

#: build/en/book.xml:2360(para)
#, fuzzy
msgid "That will place your working copy in a directory named <literal moreinfo=\"none\">subv</literal> instead of a directory named <literal moreinfo=\"none\">trunk</literal> as we did previously. The directory <literal moreinfo=\"none\">subv</literal> will be created if it doesn't already exist."
msgstr "这样将把你的工作拷贝放到<literal moreinfo=\"none\">subv</literal>而不是和前面那样放到<literal moreinfo=\"none\">trunk</literal>。"

#: build/en/book.xml:2368(title)
msgid "Disabling Password Caching"
msgstr "禁用密码缓存"

#: build/en/book.xml:2373(para)
msgid "Of course, you're not terribly worried—first because you know that you can't <emphasis>really</emphasis> delete anything from Subversion and, secondly, because your Subversion password isn't the same as any of the other three million passwords you have, right? Right?"
msgstr ""

#: build/en/book.xml:2370(para)
msgid "When you perform a Subversion operation that requires you to authenticate, by default Subversion caches your authentication credentials on disk. If you're concerned about caching your Subversion passwords,<placeholder-1/> you can disable caching either permanently or on a case-by-case basis."
msgstr ""

#: build/en/book.xml:2381(para)
msgid "To disable password caching for a particular one-time command, pass the <option>--no-auth-cache</option> switch on the commandline. To permanently disable caching, you can add the line <literal moreinfo=\"none\">store-passwords = no</literal> to your local machine's Subversion configuration file. See <xref linkend=\"svn.serverconfig.netmodel.credcache\"/> for details."
msgstr ""

#: build/en/book.xml:2391(title)
msgid "Authenticating as a Different User"
msgstr "用其它身份认证"

#: build/en/book.xml:2393(para)
msgid "Since Subversion caches auth credentials by default (both username and password), it conveniently remembers who you were acting as the last time you modified you working copy. But sometimes that's not helpful—particularly if you're working in a shared working copy, like a system configuration directory or a webserver document root. In this case, just pass the <option>--username</option> option on the commandline and Subversion will attempt to authenticate as that user, prompting you for a password if necessary."
msgstr ""

#: build/en/book.xml:2411(title)
msgid "Basic Work Cycle"
msgstr "基本的工作循环"

#: build/en/book.xml:2413(para)
#, fuzzy
msgid "Subversion has numerous features, switches, bells and whistles, but on a day-to-day basis, odds are that you will only use a few of them. In this section we'll run through the most common things that you might find yourself doing with Subversion in the course of a day's work."
msgstr "Subversion有许多特性、选项和华而不实的高级功能，但日常的工作中你只使用其中的一小部分，有一些只在特殊情况才会使用，在这一节里，我们会介绍许多你在日常工作中常见的命令。"

#: build/en/book.xml:2419(para)
msgid "The typical work cycle looks like this:"
msgstr "典型的工作周期是这样的："

#: build/en/book.xml:2423(para)
msgid "Update your working copy"
msgstr "更新你的工作拷贝"

#: build/en/book.xml:2426(command) build/en/book.xml:2476(command)
#: build/en/book.xml:21828(refname)
msgid "svn update"
msgstr "svn update"

#: build/en/book.xml:2433(para)
msgid "Make changes"
msgstr "做出修改"

#: build/en/book.xml:2436(command) build/en/book.xml:18159(refname)
msgid "svn add"
msgstr "svn add"

#: build/en/book.xml:2439(command) build/en/book.xml:18948(refname)
msgid "svn delete"
msgstr "svn delete"

#: build/en/book.xml:2442(command) build/en/book.xml:18773(refname)
msgid "svn copy"
msgstr "svn copy"

#: build/en/book.xml:2445(command) build/en/book.xml:20405(refname)
msgid "svn move"
msgstr "svn move"

#: build/en/book.xml:2451(para)
msgid "Examine your changes"
msgstr "检验修改"

#: build/en/book.xml:2454(command) build/en/book.xml:21170(refname)
#: build/en/book.xml:25458(command)
msgid "svn status"
msgstr "svn status"

#: build/en/book.xml:2457(command) build/en/book.xml:3514(command)
#: build/en/book.xml:19061(refname) build/en/book.xml:25465(command)
msgid "svn diff"
msgstr "svn diff"

#: build/en/book.xml:2463(para)
msgid "Possibly undo some changes"
msgstr ""

#: build/en/book.xml:2466(command) build/en/book.xml:21066(refname)
#: build/en/book.xml:25472(command)
msgid "svn revert"
msgstr "svn revert"

#: build/en/book.xml:2473(para)
msgid "Resolve Conflicts (Merge Others' Changes)"
msgstr "解决冲突（合并别人的修改）"

#: build/en/book.xml:2479(command) build/en/book.xml:20977(refname)
msgid "svn resolved"
msgstr "svn resolved"

#: build/en/book.xml:2485(para)
msgid "Commit your changes"
msgstr "提交你的修改"

#: build/en/book.xml:2488(command) build/en/book.xml:18635(refname)
msgid "svn commit"
msgstr "svn commit"

#: build/en/book.xml:2496(title)
msgid "Update Your Working Copy"
msgstr "更新你的工作副本"

#: build/en/book.xml:2498(para)
msgid "When working on a project with a team, you'll want to update your working copy to receive any changes made since your last update by other developers on the project. Use <command moreinfo=\"none\">svn update</command> to bring your working copy into sync with the latest revision in the repository."
msgstr "当你在一个团队的项目里工作时，你希望更新你的工作拷贝得到所有其他人这段时间作出的修改，使用<command moreinfo=\"none\">svn update</command>让你的工作拷贝与最新的版本同步。"

#: build/en/book.xml:2504(screen)
#, no-wrap
msgid ""
"\n"
"$ svn update\n"
"U  foo.c\n"
"U  bar.c\n"
"Updated to revision 2.\n"
msgstr ""
"\n"
"$ svn update\n"
"U  foo.c\n"
"U  bar.c\n"
"Updated to revision 2.\n"

#: build/en/book.xml:2511(para)
msgid "In this case, someone else checked in modifications to both <filename moreinfo=\"none\">foo.c</filename> and <filename moreinfo=\"none\">bar.c</filename> since the last time you updated, and Subversion has updated your working copy to include those changes."
msgstr "这种情况下，其他人在你上次更新之后提交了对<filename moreinfo=\"none\">foo.c</filename>和<filename moreinfo=\"none\">bar.c</filename>的修改，因此Subversion更新你的工作拷贝来引入这些更改。"

#: build/en/book.xml:2516(para)
#, fuzzy
msgid "When the server sends changes to your working copy via <command moreinfo=\"none\">svn update</command>, a letter code is displayed next to each item to let you know what actions Subversion performed to bring your working copy up-to-date. To find out what these letters mean, see <xref linkend=\"svn.ref.svn.c.update\"/>"
msgstr "让我们认真检查<command moreinfo=\"none\">svn update</command>的输出，当服务器发送修改到你的工作拷贝，一个字母显示在每一个项目之前，来让你知道Subversion对你的工作拷贝做了什么操作："

#: build/en/book.xml:2526(title)
msgid "Make Changes to Your Working Copy"
msgstr "修改你的工作副本"

#: build/en/book.xml:2528(para)
#, fuzzy
msgid "Now you can get to work and make changes in your working copy. It's usually most convenient to decide on a discrete change (or set of changes) to make, such as writing a new feature, fixing a bug, etc. The Subversion commands that you will use here are <command moreinfo=\"none\">svn add</command>, <command moreinfo=\"none\">svn delete</command>, <command moreinfo=\"none\">svn copy</command>, <command moreinfo=\"none\">svn move</command>, and <command moreinfo=\"none\">svn mkdir</command>. However, if you are merely editing files that are already in Subversion, you may not need to use any of these commands until you commit."
msgstr "现在你可以开始工作并且修改你的工作拷贝了，你很容易决定作出一个修改（或者是一组），像写一个新的特性，修正一个错误等等。这时可以使用的Subversion命令包括<command moreinfo=\"none\">svn add</command>、 <command moreinfo=\"none\">svn delete</command>、<command moreinfo=\"none\">svn copy</command>和<command moreinfo=\"none\">svn move</command>。如果你只是修改版本库中已经存在的文件，在你提交之前，不必使用上面的任何一个命令。你可以对工作备份作的修改包括："

#: build/en/book.xml:2539(para)
msgid "There are two kinds of changes you can make to your working copy: file changes and tree changes. You don't need to tell Subversion that you intend to change a file; just make your changes using your text editor, word processor, graphics program, or whatever tool you would normally use. Subversion automatically detects which files have been changed, and in addition handles binary files just as easily as it handles text files—and just as efficiently too. For tree changes, you can ask Subversion to <quote>mark</quote> files and directories for scheduled removal, addition, copying, or moving. While these changes may take place immediately in your working copy, no additions or removals will happen in the repository until you commit them."
msgstr ""

#: build/en/book.xml:2553(para)
#, fuzzy
msgid "Here is an overview of the five Subversion subcommands that you'll use most often to make tree changes."
msgstr "这些是常用的可以修改目录树结构的子命令（我们会在后面包括<command moreinfo=\"none\">svn import</command>和<command moreinfo=\"none\">svn mkdir</command>）。"

#: build/en/book.xml:2557(title)
msgid "Versioning symbolic links"
msgstr "版本控制符号连接"

#: build/en/book.xml:2559(para)
msgid "On non-Windows platforms, Subversion is able to version files of the special type <firstterm>symbolic link</firstterm> (or, <quote>symlink</quote>). A symlink is a file which acts as a sort of transparent reference to some other object in the filesystem, allowing programs to read and write to those objects indirectly by way of performing operations on the symlink itself."
msgstr ""

#: build/en/book.xml:2567(para)
msgid "When a symlink is committed into a Subversion repository, Subversion remembers that the file was in fact a symlink, as well as to what object the symlink <quote>points</quote>. When that symlink is checked out to another working copy on a supporting system, Subversion reconstructs a real filesystem-level symbolic link from the versioned symlink. But that doesn't in any way limit the usability of working copies on systems such as Windows which do not support symlinks. On such systems, Subversion simply creates a regular text file whose contents are the path to which to the original symlink pointed. While that file can't be used as a symlink on a Windows system, it also won't prevent Windows users from performing their other Subversion-related activities."
msgstr ""

#: build/en/book.xml:2585(command)
msgid "svn add foo"
msgstr "svn add foo"

#: build/en/book.xml:2587(para)
#, fuzzy
msgid "Schedule file, directory, or symbolic link <filename moreinfo=\"none\">foo</filename> to be added to the repository. When you next commit, <filename moreinfo=\"none\">foo</filename> will become a child of its parent directory. Note that if <filename moreinfo=\"none\">foo</filename> is a directory, everything underneath <filename moreinfo=\"none\">foo</filename> will be scheduled for addition. If you only want to add <filename moreinfo=\"none\">foo</filename> itself, pass the <option>--non-recursive (-N)</option> option."
msgstr "预定将文件、目录或者符号链<filename moreinfo=\"none\">foo</filename>添加到版本库，当你下次提交后，<filename moreinfo=\"none\">foo</filename>会成为其父目录的一个子对象。注意，如果<filename moreinfo=\"none\">foo</filename>是目录，所有foo中的内容也会预定添加进去，如果你只想添加<filename moreinfo=\"none\">foo</filename>本身，使用<option>--non-recursive</option>（<option>-N</option>）参数。"

#: build/en/book.xml:2601(command)
msgid "svn delete foo"
msgstr "svn delete foo"

#: build/en/book.xml:2611(para)
#, fuzzy
msgid "Of course, nothing is ever totally deleted from the repository—just from the <literal moreinfo=\"none\">HEAD</literal> of the repository. You can get back anything you delete by checking out (or updating your working copy) a revision earlier than the one in which you deleted it. Also see <xref linkend=\"svn.branchmerge.commonuses.resurrect\"/>&gt;"
msgstr "当然没有任何东西是在版本库里被删除了—只是在版本库的<literal moreinfo=\"none\">HEAD</literal>里消失了，你可以通过检出（或者更新你的工作拷贝）你做出删除操作的前一个修订版本来找回所有的东西。"

#: build/en/book.xml:2603(para)
msgid "Schedule file, directory, or symbolic link <filename moreinfo=\"none\">foo</filename> to be deleted from the repository. If <filename moreinfo=\"none\">foo</filename> is a file or link, it is immediately deleted from your working copy. If <filename moreinfo=\"none\">foo</filename> is a directory, it is not deleted, but Subversion schedules it for deletion. When you commit your changes, <filename moreinfo=\"none\">foo</filename> will be removed from your working copy and the repository. <placeholder-1/>"
msgstr "预定将文件、目录或者符号链<filename moreinfo=\"none\">foo</filename>从版本库中删除掉，如果foo是文件，它马上从工作拷贝中删除，如果是目录，不会被删除，但是Subversion准备好删除了，当你提交你的修改，<filename moreinfo=\"none\">foo</filename>就会在你的工作拷贝和版本库中被删除。<placeholder-1/>"

#: build/en/book.xml:2621(command)
msgid "svn copy foo bar"
msgstr "svn copy foo bar"

#: build/en/book.xml:2623(para)
#, fuzzy
msgid "Create a new item <filename moreinfo=\"none\">bar</filename> as a duplicate of <filename moreinfo=\"none\">foo</filename> and automatically schedule <filename moreinfo=\"none\">bar</filename> for addition. When <filename moreinfo=\"none\">bar</filename> is added to the repository on the next commit, its copy history is recorded (as having originally come from <filename moreinfo=\"none\">foo</filename>). <command moreinfo=\"none\">svn copy</command> does not create intermediate directories."
msgstr "建立一个新的项目<filename moreinfo=\"none\">bar</filename>作为<filename moreinfo=\"none\">foo</filename>的复制品，当在下次提交时会将<filename moreinfo=\"none\">bar</filename>添加到版本库，这种拷贝历史会记录下来（按照来自<filename moreinfo=\"none\">foo</filename>的方式记录），<command moreinfo=\"none\">svn copy</command>并不建立中介目录。"

#: build/en/book.xml:2635(command)
msgid "svn move foo bar"
msgstr "svn move foo bar"

#: build/en/book.xml:2637(para)
msgid "This command is exactly the same as running <command moreinfo=\"none\">svn copy foo bar; svn delete foo</command>. That is, <filename moreinfo=\"none\">bar</filename> is scheduled for addition as a copy of <filename moreinfo=\"none\">foo</filename>, and <filename moreinfo=\"none\">foo</filename> is scheduled for removal. <command moreinfo=\"none\">svn move</command> does not create intermediate directories."
msgstr "这个命令与与运行<command moreinfo=\"none\">svn copy foo bar; svn delete foo</command>完全相同，<filename moreinfo=\"none\">bar</filename>作为<filename moreinfo=\"none\">foo</filename>的拷贝准备添加，<filename moreinfo=\"none\">foo</filename>已经预定要被删除，<command moreinfo=\"none\">svn move</command>不建立中介的目录。"

#: build/en/book.xml:2648(command)
msgid "svn mkdir blort"
msgstr "svn mkdir blort"

#: build/en/book.xml:2650(para)
msgid "This command is exactly the same as running <command moreinfo=\"none\">mkdir blort; svn add blort</command>. That is, a new directory named <filename moreinfo=\"none\">blort</filename> is created and scheduled for addition."
msgstr ""

#: build/en/book.xml:2660(title)
msgid "Changing the Repository Without a Working Copy"
msgstr "不通过工作副本修改版本库"

#: build/en/book.xml:2662(para)
#, fuzzy
msgid "There <emphasis>are</emphasis> some use cases that immediately commit tree changes to the repository. This only happens when a subcommand is operating directly on a URL, rather than on a working-copy path. In particular, specific uses of <command moreinfo=\"none\">svn mkdir</command>, <command moreinfo=\"none\">svn copy</command>, <command moreinfo=\"none\">svn move</command>, and <command moreinfo=\"none\">svn delete</command> can work with URLs (And don't forget that <command moreinfo=\"none\">svn import</command> always makes changes to a URL)."
msgstr "本章的前面曾经说过，为了使版本库反映你的改动，你应该提交所有改动。这并不完全正确—有一些方式<emphasis>是</emphasis>可以直接操作版本库的，当然只有子命令直接操作URL而不是本地拷贝路径时才可以实现，通常<command moreinfo=\"none\">svn mkdir</command>、<command moreinfo=\"none\">svn copy</command>、<command moreinfo=\"none\">svn move</command>、和 <command moreinfo=\"none\">svn delete</command>可以使用URL工作。"

#: build/en/book.xml:2672(para)
msgid "URL operations behave in this manner because commands that operate on a working copy can use the working copy as a sort of <quote>staging area</quote> to set up your changes before committing them to the repository. Commands that operate on URLs don't have this luxury, so when you operate directly on a URL, any of the above actions represent an immediate commit."
msgstr "指定URL的操作方式有一些区别，因为在使用工作拷贝的运作方式时，工作拷贝成为一个<quote>集结地</quote>，可以在提交之前整理组织所要做的修改，直接对URL操作就没有这种奢侈，所以当你直接操作URL的时候，所有以上的动作代表一个立即的提交。"

#: build/en/book.xml:2686(title)
msgid "Examine Your Changes"
msgstr "检查你的修改"

#: build/en/book.xml:2688(para)
#, fuzzy
msgid "Once you've finished making changes, you need to commit them to the repository, but before you do so, it's usually a good idea to take a look at exactly what you've changed. By examining your changes before you commit, you can make a more accurate log message. You may also discover that you've inadvertently changed a file, and this gives you a chance to revert those changes before committing. Additionally, this is a good opportunity to review and scrutinize changes before publishing them. You can see an overview of the changes you've made by using <command moreinfo=\"none\">svn status</command>, and dig into the details of those changes by using <command moreinfo=\"none\">svn diff</command>."
msgstr "当你完成修改，你需要提交他们到版本库，但是在此之前，检查一下做过什么修改是个好主意，通过提交前的检查，你可以整理一份精确的日志信息，你也可以发现你不小心修改的文件，给了你一次恢复修改的机会。此外，这是一个审查和仔细察看修改的好机会，你可通过命令<command moreinfo=\"none\">svn status</command>、<command moreinfo=\"none\">svn diff</command>和<command moreinfo=\"none\">svn revert</command>精确地察看所做的修改。你可以使用前两个命令察看工作拷贝中的修改，使用第三个来撤销部分（或全部)的修改。"

#: build/en/book.xml:2702(title)
msgid "Look Ma! No Network!"
msgstr "看！没有网络！"

#: build/en/book.xml:2711(para)
msgid "And also that you don't have a WAN card. Thought you got us, huh?"
msgstr ""

#: build/en/book.xml:2704(para)
#, fuzzy
msgid "The commands (<command moreinfo=\"none\">svn status</command>, <command moreinfo=\"none\">svn diff</command>, and <command moreinfo=\"none\">svn revert</command>) can be used without any network access (assuming, of course, that your repository is across the network and not local). This makes it easy to manage your changes-in-progress when you are somewhere without a network connection, such as travelling on an airplane, riding a commuter train or hacking on the beach.<placeholder-1/>"
msgstr "这三个命令（<command moreinfo=\"none\">svn status</command>、<command moreinfo=\"none\">svn diff</command>和 <command moreinfo=\"none\">svn revert</command>）都可以在没有网络的情况下工作，这让你在没有网络连接时的管理修改过程更加简单，像在飞机上旅行，乘坐火车往返或是在海滩上奋力工作时。"

#: build/en/book.xml:2715(para)
#, fuzzy
msgid "Subversion does this by keeping private caches of pristine versions of each versioned file inside of the <filename moreinfo=\"none\">.svn</filename> administrative areas. This allows Subversion to report—and revert—local modifications to those files <emphasis>without network access</emphasis>. This cache (called the <quote>text-base</quote>) also allows Subversion to send the user's local modifications during a commit to the server as a compressed <firstterm>delta</firstterm> (or <quote>difference</quote>) against the pristine version. Having this cache is a tremendous benefit—even if you have a fast net connection, it's much faster to send only a file's changes rather than the whole file to the server."
msgstr "Subversion通过在<filename moreinfo=\"none\">.svn</filename>管理区域使用原始的版本缓存来做到这一点，这使得恢复本地版本而<emphasis>不必访问网络</emphasis>，这个缓存（叫做<quote>text-base</quote>）也允许Subversion可以根据原始版本生成一个压缩的增量（<quote>区别</quote>） 提交—即使你有个非常快的网络，有这样一个缓存有极大的好处，非常的快，只向服务器提交修改的部分，这一点乍一看好像并不重要，但当你要提交一个400M大小的文件的修改时，你就会明白！"

#: build/en/book.xml:2732(para)
msgid "Subversion has been optimized to help you with this task, and is able to do many things without communicating with the repository. In particular, your working copy contains a secret cached <quote>pristine</quote> copy of each version controlled file within the <filename moreinfo=\"none\">.svn</filename> area. Because of this, Subversion can quickly show you how your working files have changed, or even allow you to undo your changes without contacting the repository."
msgstr "Subversion已经被优化来帮助你完成这个任务，可以在不与版本库通讯的情况下做许多事情，详细来说，对于每一个文件，你的的工作拷贝在<filename moreinfo=\"none\">.svn</filename>包含了一个<quote>原始的</quote>拷贝，所以Subversion可以快速的告诉你那些文件修改了，甚至允许你在不与版本库通讯的情况下恢复修改。"

#: build/en/book.xml:2743(title)
msgid "See an overview of your changes"
msgstr "查看你的修改概况"

#: build/en/book.xml:2745(para)
#, fuzzy
msgid "To get an overview of your changes, you'll use the <command moreinfo=\"none\">svn status</command> command. You'll probably use <command moreinfo=\"none\">svn status</command> more than any other Subversion command."
msgstr "相对于其他命令，你会更多地使用这个<command moreinfo=\"none\">svn status</command>命令。"

#: build/en/book.xml:2751(title)
msgid "CVS Users: Hold That Update!"
msgstr "CVS 用户：控制另类的更新！"

#: build/en/book.xml:2753(para)
msgid "You're probably used to using <command moreinfo=\"none\">cvs update</command> to see what changes you've made to your working copy. <command moreinfo=\"none\">svn status</command> will give you all the information you need regarding what has changed in your working copy—without accessing the repository or potentially incorporating new changes published by other users."
msgstr "你也许使用<command moreinfo=\"none\">cvs update</command>来看你做了哪些修改，<command moreinfo=\"none\">svn status</command>会给你所有你做的改变—而不需要访问版本库，并且不会在不知情的情况下与其他用户作的更改比较。"

#: build/en/book.xml:2761(para)
#, fuzzy
msgid "In Subversion, <command moreinfo=\"none\">update</command> does just that—it updates your working copy with any changes committed to the repository since the last time you've updated your working copy. You may have to break the habit of using the <command moreinfo=\"none\">update</command> command to see what local modifications you've made."
msgstr "在Subversion，<command moreinfo=\"none\">update</command>只是做这件事—将工作拷贝更新到版本库的最新版本，你可以消除使用<command moreinfo=\"none\">update</command>察看本地修改的习惯。"

#: build/en/book.xml:2770(para)
#, fuzzy
msgid "If you run <command moreinfo=\"none\">svn status</command> at the top of your working copy with no arguments, it will detect all file and tree changes you've made. Below are a few examples of the most common status codes that <command moreinfo=\"none\">svn status</command> can return. (Note that the text following <literal moreinfo=\"none\">#</literal> is not actually printed by <command moreinfo=\"none\">svn status</command>.)"
msgstr "如果你在工作拷贝的顶级目录运行不带参数的<command moreinfo=\"none\">svn status</command>命令，它会检测你做的所有的文件或目录的修改，以下的例子是来展示<command moreinfo=\"none\">svn status</command>可能返回的状态码（注意，<literal moreinfo=\"none\">#</literal>之后的不是<command moreinfo=\"none\">svn status</command>打印的）。"

#: build/en/book.xml:2778(screen)
#, no-wrap
msgid ""
"\n"
"A       stuff/loot/bloo.h   # file is scheduled for addition\n"
"C       stuff/loot/lump.c   # file has textual conflicts from an update\n"
"D       stuff/fish.c        # file is scheduled for deletion\n"
"M       bar.c               # the content in bar.c has local modifications\n"
msgstr ""
"\n"
"A       stuff/loot/bloo.h   # file is scheduled for addition\n"
"C       stuff/loot/lump.c   # file has textual conflicts from an update\n"
"D       stuff/fish.c        # file is scheduled for deletion\n"
"M       bar.c               # the content in bar.c has local modifications\n"

#: build/en/book.xml:2785(para)
#, fuzzy
msgid "In this output format <command moreinfo=\"none\">svn status</command> prints six columns of characters, followed by several whitespace characters, followed by a file or directory name. The first column tells the status of a file or directory and/or its contents. The codes we listed are:"
msgstr "在这种格式下，<command moreinfo=\"none\">svn status</command>打印五列字符，紧跟一些空格，接着是文件或者目录名。第一列告诉一个文件的状态或它的内容，返回代码解释如下："

#: build/en/book.xml:2794(computeroutput)
#, no-wrap
msgid "A      item"
msgstr "A      item"

#: build/en/book.xml:2796(para)
msgid "The file, directory, or symbolic link <filename moreinfo=\"none\">item</filename> has been scheduled for addition into the repository."
msgstr "文件、目录或是符号链<filename moreinfo=\"none\">item</filename>预定加入到版本库。"

#: build/en/book.xml:2803(computeroutput)
#, no-wrap
msgid "C      item"
msgstr "C      item"

#: build/en/book.xml:2805(para)
msgid "The file <filename moreinfo=\"none\">item</filename> is in a state of conflict. That is, changes received from the server during an update overlap with local changes that you have in your working copy. You must resolve this conflict before committing your changes to the repository."
msgstr "文件<filename moreinfo=\"none\">item</filename>发生冲突，在从服务器更新时与本地版本发生交迭，在你提交到版本库前，必须手工的解决冲突。"

#: build/en/book.xml:2815(computeroutput)
#, no-wrap
msgid "D      item"
msgstr "D      item"

#: build/en/book.xml:2817(para)
msgid "The file, directory, or symbolic link <filename moreinfo=\"none\">item</filename> has been scheduled for deletion from the repository."
msgstr "文件、目录或是符号链<filename moreinfo=\"none\">item</filename>预定从版本库中删除。"

#: build/en/book.xml:2824(computeroutput)
#, no-wrap
msgid "M      item"
msgstr "M      item"

#: build/en/book.xml:2826(para)
msgid "The contents of the file <filename moreinfo=\"none\">item</filename> have been modified."
msgstr "文件<filename moreinfo=\"none\">item</filename>的内容被修改了。"

#: build/en/book.xml:2833(para)
#, fuzzy
msgid "If you pass a specific path to <command moreinfo=\"none\">svn status</command>, you get information about that item alone:"
msgstr "如果你传递一个路径给<command moreinfo=\"none\">svn status</command>，它只给你这个项目的信息："

#: build/en/book.xml:2837(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status stuff/fish.c\n"
"D      stuff/fish.c\n"
msgstr ""
"\n"
"$ svn status stuff/fish.c\n"
"D      stuff/fish.c\n"

#: build/en/book.xml:2842(para)
#, fuzzy
msgid "<command moreinfo=\"none\">svn status</command> also has a <option>--verbose (-v)</option> switch, which will show you the status of <emphasis>every</emphasis> item in your working copy, even if it has not been changed:"
msgstr "<command moreinfo=\"none\">svn status</command>也有一个<option>--verbose</option>（<option>-v</option>）选项，它可以显示工作拷贝中的<emphasis>所有</emphasis>项目，即使没有改变过："

#: build/en/book.xml:2847(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status -v\n"
"M               44        23    sally     README\n"
"                44        30    sally     INSTALL\n"
"M               44        20    harry     bar.c\n"
"                44        18    ira       stuff\n"
"                44        35    harry     stuff/trout.c\n"
"D               44        19    ira       stuff/fish.c\n"
"                44        21    sally     stuff/things\n"
"A                0         ?     ?        stuff/things/bloo.h\n"
"                44        36    harry     stuff/things/gloo.c\n"
msgstr ""
"\n"
"$ svn status -v\n"
"M               44        23    sally     README\n"
"                44        30    sally     INSTALL\n"
"M               44        20    harry     bar.c\n"
"                44        18    ira       stuff\n"
"                44        35    harry     stuff/trout.c\n"
"D               44        19    ira       stuff/fish.c\n"
"                44        21    sally     stuff/things\n"
"A                0         ?     ?        stuff/things/bloo.h\n"
"                44        36    harry     stuff/things/gloo.c\n"

#: build/en/book.xml:2860(para)
#, fuzzy
msgid "This is the <quote>long form</quote> output of <command moreinfo=\"none\">svn status</command>. The first column remains the same, but the second column shows the working-revision of the item. The third and fourth columns show the revision in which the item last changed, and who changed it (these columns are not to be confused with the columns of characters that we just discussed)."
msgstr "这是<command moreinfo=\"none\">svn status</command>的<quote>加长形式</quote>，第一列保持相同，第二列显示一个工作版本号，第三和第四列显示最后一次修改的版本号和修改人。"

#: build/en/book.xml:2868(para)
#, fuzzy
msgid "None of the above invocations to <command moreinfo=\"none\">svn status</command> contact the repository, they work only locally by comparing the metadata in the <filename moreinfo=\"none\">.svn</filename> directory with the working copy. Finally, there is the <option>--show-updates (-u)</option> option, which contacts the repository and adds information about things that are out-of-date:"
msgstr "上面所有的<command moreinfo=\"none\">svn status</command>调用并没有联系版本库，只是与<filename moreinfo=\"none\">.svn</filename>中的元数据进行比较的结果，最后，是<option>--show-updates</option>（<option>-u</option>）参数，它将会联系版本库为已经过时的数据添加新信息："

#: build/en/book.xml:2876(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status -u -v\n"
"M      *        44        23    sally     README\n"
"M               44        20    harry     bar.c\n"
"       *        44        35    harry     stuff/trout.c\n"
"D               44        19    ira       stuff/fish.c\n"
"A                0         ?     ?        stuff/things/bloo.h\n"
"Status against revision:   46\n"
msgstr ""
"\n"
"$ svn status -u -v\n"
"M      *        44        23    sally     README\n"
"M               44        20    harry     bar.c\n"
"       *        44        35    harry     stuff/trout.c\n"
"D               44        19    ira       stuff/fish.c\n"
"A                0         ?     ?        stuff/things/bloo.h\n"
"Status against revision:   46\n"

#: build/en/book.xml:2886(para)
msgid "Notice the two asterisks: if you were to run <command moreinfo=\"none\">svn update</command> at this point, you would receive changes to <filename moreinfo=\"none\">README</filename> and <filename moreinfo=\"none\">trout.c</filename>. This tells you some very useful information—you'll need to update and get the server changes on <filename moreinfo=\"none\">README</filename> before you commit, or the repository will reject your commit for being out-of-date. (More on this subject later.)"
msgstr "注意这两个星号：如果你现在执行<command moreinfo=\"none\">svn update</command>，你的<filename moreinfo=\"none\">README</filename>和<filename moreinfo=\"none\">trout.c</filename>会被更新，这告诉你许多有用的信息—你可以在提交之前，需要使用更新操作得到文件<filename moreinfo=\"none\">README</filename>的更新，或者说文件已经过时，版本库会拒绝了你的提交。（后面还有更多关于此主题）。"

#: build/en/book.xml:2895(para)
msgid "<command moreinfo=\"none\">svn status</command> displays much more information about the files and directories in your working copy than we've shown here—for an exhaustive description of svn status and its output, see <xref linkend=\"svn.ref.svn.c.status\"/>."
msgstr ""

#: build/en/book.xml:2904(title)
msgid "Examine the details of your local modifications"
msgstr "检查你的本地修改的详情"

#: build/en/book.xml:2906(para)
#, fuzzy
msgid "Another way to examine your changes is with the <command moreinfo=\"none\">svn diff</command> command. You can find out <emphasis>exactly</emphasis> how you've modified things by running <command moreinfo=\"none\">svn diff</command> with no arguments, which prints out file changes in unified diff format:"
msgstr "另一种检查修改的方式是<command moreinfo=\"none\">svn diff</command>命令，你可以通过不带参数的<command moreinfo=\"none\">svn diff</command><emphasis>精确的</emphasis>找出你所做的修改，这会输出统一区别格式：<footnote><placeholder-1/></footnote>"

#: build/en/book.xml:2913(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff\n"
"Index: bar.c\n"
"===================================================================\n"
"--- bar.c\t(revision 3)\n"
"+++ bar.c\t(working copy)\n"
"@@ -1,7 +1,12 @@\n"
"+#include &lt;sys/types.h&gt;\n"
"+#include &lt;sys/stat.h&gt;\n"
"+#include &lt;unistd.h&gt;\n"
"+\n"
"+#include &lt;stdio.h&gt;\n"
"\n"
" int main(void) {\n"
"-  printf(\"Sixty-four slices of American Cheese...\\n\");\n"
"+  printf(\"Sixty-five slices of American Cheese...\\n\");\n"
" return 0;\n"
" }\n"
"\n"
"Index: README\n"
"===================================================================\n"
"--- README\t(revision 3)\n"
"+++ README\t(working copy)\n"
"@@ -193,3 +193,4 @@\n"
"+Note to self:  pick up laundry.\n"
"\n"
"Index: stuff/fish.c\n"
"===================================================================\n"
"--- stuff/fish.c\t(revision 1)\n"
"+++ stuff/fish.c\t(working copy)\n"
"-Welcome to the file known as 'fish'.\n"
"-Information on fish will be here soon.\n"
"\n"
"Index: stuff/things/bloo.h\n"
"===================================================================\n"
"--- stuff/things/bloo.h\t(revision 8)\n"
"+++ stuff/things/bloo.h\t(working copy)\n"
"+Here is a new file to describe\n"
"+things about bloo.\n"
msgstr ""
"\n"
"$ svn diff\n"
"Index: bar.c\n"
"===================================================================\n"
"--- bar.c\t(revision 3)\n"
"+++ bar.c\t(working copy)\n"
"@@ -1,7 +1,12 @@\n"
"+#include &lt;sys/types.h&gt;\n"
"+#include &lt;sys/stat.h&gt;\n"
"+#include &lt;unistd.h&gt;\n"
"+\n"
"+#include &lt;stdio.h&gt;\n"
"\n"
" int main(void) {\n"
"-  printf(\"Sixty-four slices of American Cheese...\\n\");\n"
"+  printf(\"Sixty-five slices of American Cheese...\\n\");\n"
" return 0;\n"
" }\n"
"\n"
"Index: README\n"
"===================================================================\n"
"--- README\t(revision 3)\n"
"+++ README\t(working copy)\n"
"@@ -193,3 +193,4 @@\n"
"+Note to self:  pick up laundry.\n"
"\n"
"Index: stuff/fish.c\n"
"===================================================================\n"
"--- stuff/fish.c\t(revision 1)\n"
"+++ stuff/fish.c\t(working copy)\n"
"-Welcome to the file known as 'fish'.\n"
"-Information on fish will be here soon.\n"
"\n"
"Index: stuff/things/bloo.h\n"
"===================================================================\n"
"--- stuff/things/bloo.h\t(revision 8)\n"
"+++ stuff/things/bloo.h\t(working copy)\n"
"+Here is a new file to describe\n"
"+things about bloo.\n"

#: build/en/book.xml:2954(para)
msgid "The <command moreinfo=\"none\">svn diff</command> command produces this output by comparing your working files against the cached <quote>pristine</quote> copies within the <filename moreinfo=\"none\">.svn</filename> area. Files scheduled for addition are displayed as all added-text, and files scheduled for deletion are displayed as all deleted text."
msgstr "<command moreinfo=\"none\">svn diff</command>命令通过比较你的文件和<filename moreinfo=\"none\">.svn</filename>的<quote>原始</quote>文件来输出信息，预定要增加的文件会显示所有增加的文本，要删除的文件会显示所有要删除的文本。"

#: build/en/book.xml:2962(para)
msgid "Output is displayed in <firstterm>unified diff format</firstterm>. That is, removed lines are prefaced with a <literal moreinfo=\"none\">-</literal> and added lines are prefaced with a <literal moreinfo=\"none\">+</literal>. <command moreinfo=\"none\">svn diff</command> also prints filename and offset information useful to the <command moreinfo=\"none\">patch</command> program, so you can generate <quote>patches</quote> by redirecting the diff output to a file:"
msgstr "输出的格式为<firstterm>统一区别格式</firstterm>（unified diff format），删除的行前面加一个<literal moreinfo=\"none\">-</literal>，添加的行前面有一个<literal moreinfo=\"none\">+</literal>，<command moreinfo=\"none\">svn diff</command>命令也打印文件名和<command moreinfo=\"none\">打补丁</command>需要的信息，所以你可以通过重定向一个区别文件来生成<quote>补丁</quote>："

#: build/en/book.xml:2971(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff &gt; patchfile\n"
msgstr ""
"\n"
"$ svn diff &gt; patchfile\n"

#: build/en/book.xml:2975(para)
msgid "You could, for example, email the patch file to another developer for review or testing prior to commit."
msgstr "举个例子，你可以把补丁文件发送邮件到其他开发者，在提交之前审核和测试。"

#: build/en/book.xml:2978(para)
#, fuzzy
msgid "Subversion uses its internal diff engine, which produces unified diff format, by default. If you want diff output in a different format, specify an external diff program using <option>--diff-cmd</option> and pass any flags you'd like to it using the <option>--extensions (-x)</option> switch. For example, to see local differences in file <filename moreinfo=\"none\">foo.c</filename> in context output format while ignoring case differences, you might run <command moreinfo=\"none\">svn diff --diff-cmd /usr/bin/diff --extensions '-i' foo.c</command>."
msgstr "Subversion使用内置区别引擎，缺省情况下输出为统一区别格式。如果你期望不同的输出格式，你可以使用<option>--diff-cmd</option>指定外置的区别程序，并且通过<option>--extensions</option>传递其他参数，举个例子，察看本地文件<filename moreinfo=\"none\">foo.c</filename>的区别，同时忽略空格修改，你可以运行<command moreinfo=\"none\">svn diff --diff-cmd /usr/bin/diff --extensions '-bc' foo.c</command>。"

#: build/en/book.xml:2996(title)
msgid "Undoing Working Changes"
msgstr "取消本地修改"

#: build/en/book.xml:2999(para)
msgid "Suppose while viewing the output of <command moreinfo=\"none\">svn diff</command> you determine that all the changes you made to a particular file are mistakes. Maybe you shouldn't have changed the file at all, or perhaps it would be easier to make different changes starting from scratch."
msgstr ""

#: build/en/book.xml:3005(para)
#, fuzzy
msgid "This is a perfect opportunity to use <command moreinfo=\"none\">svn revert</command>:"
msgstr "这是使用<command moreinfo=\"none\">svn revert</command>的好机会。"

#: build/en/book.xml:3008(screen)
#, no-wrap
msgid ""
"\n"
"$ svn revert README\n"
"Reverted 'README'\n"
msgstr ""
"\n"
"$ svn revert README\n"
"Reverted 'README'\n"

#: build/en/book.xml:3013(para)
msgid "Subversion reverts the file to its pre-modified state by overwriting it with the cached <quote>pristine</quote> copy from the <filename moreinfo=\"none\">.svn</filename> area. But also note that <command moreinfo=\"none\">svn revert</command> can undo <emphasis>any</emphasis> scheduled operations—for example, you might decide that you don't want to add a new file after all:"
msgstr "Subversion把文件恢复到未修改的状态，叫做<filename moreinfo=\"none\">.svn</filename>目录的<quote>原始</quote>拷贝，应该知道<command moreinfo=\"none\">svn revert</command>可以恢复任何预定要做的操作，举个例子，你不再想添加一个文件："

#: build/en/book.xml:3021(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status foo\n"
"?      foo\n"
"\n"
"$ svn add foo\n"
"A         foo\n"
"\n"
"$ svn revert foo\n"
"Reverted 'foo'\n"
"\n"
"$ svn status foo\n"
"?      foo\n"
msgstr ""
"\n"
"$ svn status foo\n"
"?      foo\n"
"\n"
"$ svn add foo\n"
"A         foo\n"
"\n"
"$ svn revert foo\n"
"Reverted 'foo'\n"
"\n"
"$ svn status foo\n"
"?      foo\n"

#: build/en/book.xml:3036(para)
msgid "<command moreinfo=\"none\">svn revert</command><replaceable>ITEM</replaceable> has exactly the same effect as deleting <replaceable>ITEM</replaceable> from your working copy and then running <command moreinfo=\"none\">svn update -r BASE</command><replaceable>ITEM</replaceable>. However, if you're reverting a file, <command moreinfo=\"none\">svn revert</command> has one very noticeable difference—it doesn't have to communicate with the repository to restore your file."
msgstr "<command moreinfo=\"none\">svn revert</command><replaceable>ITEM</replaceable>的效果与删除<replaceable>ITEM</replaceable>然后执行<command moreinfo=\"none\">svn update -r BASE</command><replaceable>ITEM</replaceable>完全一样，但是，如果你使用<command moreinfo=\"none\">svn revert</command>它不必通知版本库就可以恢复文件。"

#: build/en/book.xml:3047(para)
msgid "Or perhaps you mistakenly removed a file from version control:"
msgstr "或许你不小心删除了一个文件："

#: build/en/book.xml:3050(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status README\n"
"       README\n"
"\n"
"$ svn delete README\n"
"D         README\n"
"\n"
"$ svn revert README\n"
"Reverted 'README'\n"
"\n"
"$ svn status README\n"
"       README\n"
msgstr ""
"\n"
"$ svn status README\n"
"       README\n"
"\n"
"$ svn delete README\n"
"D         README\n"
"\n"
"$ svn revert README\n"
"Reverted 'README'\n"
"\n"
"$ svn status README\n"
"       README\n"

#: build/en/book.xml:3068(title)
msgid "Resolve Conflicts (Merging Others' Changes)"
msgstr "解决冲突（合并别人的修改）"

#: build/en/book.xml:3070(para)
msgid "We've already seen how <command moreinfo=\"none\">svn status -u</command> can predict conflicts. Suppose you run <command moreinfo=\"none\">svn update</command> and some interesting things occur:"
msgstr "我们可以使用<command moreinfo=\"none\">svn status -u</command>来预测冲突，当你运行<command moreinfo=\"none\">svn update</command>一些有趣的事情发生了："

#: build/en/book.xml:3074(screen)
#, no-wrap
msgid ""
"\n"
"$ svn update\n"
"U  INSTALL\n"
"G  README\n"
"C  bar.c\n"
"Updated to revision 46.\n"
msgstr ""
"\n"
"$ svn update\n"
"U  INSTALL\n"
"G  README\n"
"C  bar.c\n"
"Updated to revision 46.\n"

#: build/en/book.xml:3082(para)
msgid "The <computeroutput moreinfo=\"none\">U</computeroutput> and <computeroutput moreinfo=\"none\">G</computeroutput> codes are no cause for concern; those files cleanly absorbed changes from the repository. The files marked with <computeroutput moreinfo=\"none\">U</computeroutput> contained no local changes but were <computeroutput moreinfo=\"none\">U</computeroutput>pdated with changes from the repository. The <computeroutput moreinfo=\"none\">G</computeroutput> stands for mer<computeroutput moreinfo=\"none\">G</computeroutput>ed, which means that the file had local changes to begin with, but the changes coming from the repository didn't overlap with the local changes."
msgstr "<computeroutput moreinfo=\"none\">U</computeroutput>和<computeroutput moreinfo=\"none\">G</computeroutput>没必要关心，文件干净的接受了版本库的变化，文件标示为<computeroutput moreinfo=\"none\">U</computeroutput>表明本地没有修改，文件已经根据版本库更新。<computeroutput moreinfo=\"none\">G</computeroutput>标示合并，标示本地已经修改过，与版本库没有重迭的地方，已经合并。"

#: build/en/book.xml:3094(para)
msgid "But the <computeroutput moreinfo=\"none\">C</computeroutput> stands for conflict. This means that the changes from the server overlapped with your own, and now you have to manually choose between them."
msgstr "但是<computeroutput moreinfo=\"none\">C</computeroutput>表示冲突，说明服务器上的改动同你的改动冲突了，你需要自己手工去解决。"

#: build/en/book.xml:3099(para)
msgid "Whenever a conflict occurs, three things typically occur to assist you in noticing and resolving that conflict:"
msgstr "当冲突发生了，有三件事可以帮助你注意到这种情况和解决问题："

#: build/en/book.xml:3105(para)
msgid "Subversion prints a <computeroutput moreinfo=\"none\">C</computeroutput> during the update, and remembers that the file is in a state of conflict."
msgstr "Subversion打印<computeroutput moreinfo=\"none\">C</computeroutput>标记，并且标记这个文件已冲突。"

#: build/en/book.xml:3111(para)
#, fuzzy
msgid "If Subversion considers the file to be mergeable, it places <firstterm>conflict markers</firstterm>—special strings of text which delimit the <quote>sides</quote> of the conflict—into the file to visibly demonstrate the overlapping areas. (Subversion uses the <literal moreinfo=\"none\">svn:mime-type</literal> property to decide if a file is capable of contextual, line-based merging. See <xref linkend=\"svn.advanced.props.special.mime-type\"/> to learn more.)"
msgstr "如果Subversion认为这个文件是可合并的，它会置入<firstterm>冲突标记</firstterm>—特殊的横线分开冲突的<quote>两面</quote>—在文件里可视化的描述重叠的部分（Subversion使用<literal moreinfo=\"none\">svn:mime-type</literal>属性来决定一个文件是否可以使用上下文的，以行为基础合并，更多信息可以看<xref linkend=\"svn.advanced.props.special.mime-type\"/>）。"

#: build/en/book.xml:3123(para)
#, fuzzy
msgid "For every conflicted file, Subversion places three extra unversioned files in your working copy:"
msgstr "对于每一个冲突的文件，Subversion放置三个额外的未版本化文件到你的工作拷贝："

#: build/en/book.xml:3129(filename)
msgid "filename.mine"
msgstr "filename.mine"

#: build/en/book.xml:3131(para)
#, fuzzy
msgid "This is your file as it existed in your working copy before you updated your working copy—that is, without conflict markers. This file has only your latest changes in it. (If Subversion considers the file to be unmergeable, then the <filename moreinfo=\"none\">.mine</filename> file isn't created, since it would be identical to the working file.)"
msgstr "你更新前的文件，没有冲突标志，只是你最新更改的内容。（如果Subversion认为这个文件不可以合并，<filename moreinfo=\"none\">.mine</filename>文件不会创建，因为它和工作文件相同。）"

#: build/en/book.xml:3142(filename)
msgid "filename.rOLDREV"
msgstr "filename.rOLDREV"

#: build/en/book.xml:3144(para)
msgid "This is the file that was the <literal moreinfo=\"none\">BASE</literal> revision before you updated your working copy. That is, the file that you checked out before you made your latest edits."
msgstr "这是你的做更新操作以前的<literal moreinfo=\"none\">BASE</literal>版本文件，就是你在上次更新之后未作更改的版本。"

#: build/en/book.xml:3153(filename)
msgid "filename.rNEWREV"
msgstr "filename.rNEWREV"

#: build/en/book.xml:3155(para)
msgid "This is the file that your Subversion client just received from the server when you updated your working copy. This file corresponds to the <literal moreinfo=\"none\">HEAD</literal> revision of the repository."
msgstr "这是你的Subversion客户端从服务器刚刚收到的版本，这个文件对应版本库的<literal moreinfo=\"none\">HEAD</literal>版本。"

#: build/en/book.xml:3165(para)
msgid "Here <literal moreinfo=\"none\">OLDREV</literal> is the revision number of the file in your <filename moreinfo=\"none\">.svn</filename> directory and <literal moreinfo=\"none\">NEWREV</literal> is the revision number of the repository <literal moreinfo=\"none\">HEAD</literal>."
msgstr "这里<literal moreinfo=\"none\">OLDREV</literal>是你的<filename moreinfo=\"none\">.svn</filename>目录中的修订版本号，<literal moreinfo=\"none\">NEWREV</literal>是版本库中<literal moreinfo=\"none\">HEAD</literal>的版本号。"

#: build/en/book.xml:3173(para)
msgid "For example, Sally makes changes to the file <filename moreinfo=\"none\">sandwich.txt</filename> in the repository. Harry has just changed the file in his working copy and checked it in. Sally updates her working copy before checking in and she gets a conflict:"
msgstr "举一个例子，Sally修改了<filename moreinfo=\"none\">sandwich.txt</filename>，Harry刚刚改变了他的本地拷贝中的这个文件并且提交到服务器，Sally在提交之前更新它的工作拷贝得到了冲突："

#: build/en/book.xml:3179(screen)
#, no-wrap
msgid ""
"\n"
"$ svn update\n"
"C  sandwich.txt\n"
"Updated to revision 2.\n"
"$ ls -1\n"
"sandwich.txt\n"
"sandwich.txt.mine\n"
"sandwich.txt.r1\n"
"sandwich.txt.r2\n"
msgstr ""
"\n"
"$ svn update\n"
"C  sandwich.txt\n"
"Updated to revision 2.\n"
"$ ls -1\n"
"sandwich.txt\n"
"sandwich.txt.mine\n"
"sandwich.txt.r1\n"
"sandwich.txt.r2\n"

#: build/en/book.xml:3190(para)
msgid "At this point, Subversion will <emphasis>not</emphasis> allow you to commit the file <filename moreinfo=\"none\">sandwich.txt</filename> until the three temporary files are removed."
msgstr "在这种情况下，Subversion<emphasis>不</emphasis>会允许你提交<filename moreinfo=\"none\">sandwich.txt</filename>，直到你的三个临时文件被删掉。"

#: build/en/book.xml:3194(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit -m \"Add a few more things\"\n"
"svn: Commit failed (details follow):\n"
"svn: Aborting commit: '/home/sally/svn-work/sandwich.txt' remains in conflict\n"
msgstr ""
"\n"
"$ svn commit -m \"Add a few more things\"\n"
"svn: Commit failed (details follow):\n"
"svn: Aborting commit: '/home/sally/svn-work/sandwich.txt' remains in conflict\n"

#: build/en/book.xml:3200(para)
msgid "If you get a conflict, you need to do one of three things:"
msgstr "如果你遇到冲突，三件事你可以选择："

#: build/en/book.xml:3206(para)
msgid "Merge the conflicted text <quote>by hand</quote> (by examining and editing the conflict markers within the file)."
msgstr "<quote>手动</quote>合并冲突文本（检查和修改文件中的冲突标志）。"

#: build/en/book.xml:3212(para)
msgid "Copy one of the temporary files on top of your working file."
msgstr "用某一个临时文件覆盖你的工作文件。"

#: build/en/book.xml:3217(para)
msgid "Run <command moreinfo=\"none\">svn revert &lt;filename&gt;</command> to throw away all of your local changes."
msgstr "运行<command moreinfo=\"none\">svn revert &lt;filename&gt;</command>来放弃所有的修改。"

#: build/en/book.xml:3227(para)
msgid "You can always remove the temporary files yourself, but would you really want to do that when Subversion can do it for you? We didn't think so."
msgstr "你也可以手工的删除这三个临时文件，但是当Subversion会给你做时你会自己去做吗？我们是这样想的。"

#: build/en/book.xml:3223(para)
#, fuzzy
msgid "Once you've resolved the conflict, you need to let Subversion know by running <command moreinfo=\"none\">svn resolved</command>. This removes the three temporary files and Subversion no longer considers the file to be in a state of conflict.<placeholder-1/>"
msgstr "一旦你解决了冲突，你需要通过命令<command moreinfo=\"none\">svn resolved</command>让Subversion知道，这样就会删除三个临时文件，Subversion就不会认为这个文件是在冲突状态了。<footnote><placeholder-1/></footnote>"

#: build/en/book.xml:3232(screen)
#, no-wrap
msgid ""
"\n"
"$ svn resolved sandwich.txt\n"
"Resolved conflicted state of 'sandwich.txt'\n"
msgstr ""
"\n"
"$ svn resolved sandwich.txt\n"
"Resolved conflicted state of 'sandwich.txt'\n"

#: build/en/book.xml:3239(title)
msgid "Merging Conflicts by Hand"
msgstr "手工合并冲突"

#: build/en/book.xml:3241(para)
msgid "Merging conflicts by hand can be quite intimidating the first time you attempt it, but with a little practice, it can become as easy as falling off a bike."
msgstr "第一次尝试解决冲突让人感觉很害怕，但经过一点训练，它简单的像是骑着车子下坡。"

#: build/en/book.xml:3245(para)
#, fuzzy
msgid "Here's an example. Due to a miscommunication, you and Sally, your collaborator, both edit the file <filename moreinfo=\"none\">sandwich.txt</filename> at the same time. Sally commits her changes, and when you go to update your working copy, you get a conflict and you're going to have to edit <filename moreinfo=\"none\">sandwich.txt</filename> to resolve the conflicts. First, let's take a look at the file:"
msgstr "这里一个简单的例子，由于不良的交流，你和同事Sally，同时编辑了<filename moreinfo=\"none\">sandwich.txt</filename>。Sally提交了修改，当你准备更新你的版本，冲突发生了，我们不得不去修改<filename moreinfo=\"none\">sandwich.txt</filename>来解决这个问题。首先，看一下这个文件："

#: build/en/book.xml:3253(screen)
#, no-wrap
msgid ""
"\n"
"$ cat sandwich.txt\n"
"Top piece of bread\n"
"Mayonnaise\n"
"Lettuce\n"
"Tomato\n"
"Provolone\n"
"&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine\n"
"Salami\n"
"Mortadella\n"
"Prosciutto\n"
"=======\n"
"Sauerkraut\n"
"Grilled Chicken\n"
"&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2\n"
"Creole Mustard\n"
"Bottom piece of bread\n"
msgstr ""
"\n"
"$ cat sandwich.txt\n"
"Top piece of bread\n"
"Mayonnaise\n"
"Lettuce\n"
"Tomato\n"
"Provolone\n"
"&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine\n"
"Salami\n"
"Mortadella\n"
"Prosciutto\n"
"=======\n"
"Sauerkraut\n"
"Grilled Chicken\n"
"&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2\n"
"Creole Mustard\n"
"Bottom piece of bread\n"

#: build/en/book.xml:3272(para)
msgid "The strings of less-than signs, equal signs, and greater-than signs are conflict markers, and are not part of the actual data in conflict. You generally want to ensure that those are removed from the file before your next commit. The text between the first two sets of markers is composed of the changes you made in the conflicting area:"
msgstr "小于号、等于号和大于号串是冲突标记，并不是冲突的数据，你一定要确定这些内容在下次提交之前得到删除，前两组标志中间的内容是你在冲突区所做的修改："

#: build/en/book.xml:3280(screen)
#, no-wrap
msgid ""
"\n"
"&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine\n"
"Salami\n"
"Mortadella\n"
"Prosciutto\n"
"=======\n"
msgstr ""
"\n"
"&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine\n"
"Salami\n"
"Mortadella\n"
"Prosciutto\n"
"=======\n"

#: build/en/book.xml:3288(para)
msgid "The text between the second and third sets of conflict markers is the text from Sally's commit:"
msgstr "后两组之间的是Sally提交的修改冲突："

#: build/en/book.xml:3291(screen)
#, no-wrap
msgid ""
"\n"
"=======\n"
"Sauerkraut\n"
"Grilled Chicken\n"
"&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2\n"
msgstr ""
"\n"
"=======\n"
"Sauerkraut\n"
"Grilled Chicken\n"
"&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2\n"

#: build/en/book.xml:3303(para)
msgid "And if you ask them for it, they may very well ride you out of town on a rail."
msgstr "如果你向他们询问，他们非常有理由把你带到城外的铁轨上。"

#: build/en/book.xml:3298(para)
msgid "Usually you won't want to just delete the conflict markers and Sally's changes—she's going to be awfully surprised when the sandwich arrives and it's not what she wanted. So this is where you pick up the phone or walk across the office and explain to Sally that you can't get sauerkraut from an Italian deli.<placeholder-1/> Once you've agreed on the changes you will check in, edit your file and remove the conflict markers."
msgstr "通常你并不希望只是删除冲突标志和Sally的修改—当她收到三明治时，会非常的吃惊。所以你应该走到她的办公室或是拿起电话告诉Sally，你没办法从从意大利熟食店得到想要的泡菜。<placeholder-1/>一旦你们确认了提交内容后，修改文件并且删除冲突标志。"

#: build/en/book.xml:3309(screen)
#, no-wrap
msgid ""
"\n"
"Top piece of bread\n"
"Mayonnaise\n"
"Lettuce\n"
"Tomato\n"
"Provolone\n"
"Salami\n"
"Mortadella\n"
"Prosciutto\n"
"Creole Mustard\n"
"Bottom piece of bread\n"
msgstr ""
"\n"
"Top piece of bread\n"
"Mayonnaise\n"
"Lettuce\n"
"Tomato\n"
"Provolone\n"
"Salami\n"
"Mortadella\n"
"Prosciutto\n"
"Creole Mustard\n"
"Bottom piece of bread\n"

#: build/en/book.xml:3322(para)
msgid "Now run <command moreinfo=\"none\">svn resolved</command>, and you're ready to commit your changes:"
msgstr "现在运行<command moreinfo=\"none\">svn resolved</command>，你已经准备好提交了："

#: build/en/book.xml:3325(screen)
#, no-wrap
msgid ""
"\n"
"$ svn resolved sandwich.txt\n"
"$ svn commit -m \"Go ahead and use my sandwich, discarding Sally's edits.\"\n"
msgstr ""
"\n"
"$ svn resolved sandwich.txt\n"
"$ svn commit -m \"Go ahead and use my sandwich, discarding Sally's edits.\"\n"

#: build/en/book.xml:3330(para)
#, fuzzy
msgid "Note that <command moreinfo=\"none\">svn resolved</command>, unlike most of the other commands we deal with in this chapter, requires an argument. In any case, you want to be careful and only run <command moreinfo=\"none\">svn resolved</command> when you're certain that you've fixed the conflict in your file—once the temporary files are removed, Subversion will let you commit the file even if it still contains conflict markers."
msgstr "现在我们准备好提交修改了，注意<command moreinfo=\"none\">svn resolved</command>不像我们本章学过的其他命令一样需要参数，在任何你认为解决了冲突的时候，只需要小心运行<command moreinfo=\"none\">svn resolved</command>，—一旦删除了临时文件，Subversion会让你提交这文件，即使文件中还存在冲突标记。"

#: build/en/book.xml:3338(para)
#, fuzzy
msgid "If you ever get confused while editing the conflicted file, you can always consult the three files that Subversion creates for you in your working copy—including your file as it was before you updated. You can even use a third-party interactive merging tool to examine those three files."
msgstr "记住，如果你修改冲突时感到混乱，你可以参考subversion生成的三个文件—包括你未作更新的文件。你也可以使用第三方的合并工具检验这三个文件。"

#: build/en/book.xml:3349(title)
msgid "Copying a File Onto Your Working File"
msgstr "复制文件到你的工作文件"

#: build/en/book.xml:3351(para)
msgid "If you get a conflict and decide that you want to throw out your changes, you can merely copy one of the temporary files created by Subversion over the file in your working copy:"
msgstr "如果你只是希望取消你的修改，你可以仅仅拷贝Subversion为你生成的文件替换你的工作拷贝："

#: build/en/book.xml:3356(screen)
#, no-wrap
msgid ""
"\n"
"$ svn update\n"
"C  sandwich.txt\n"
"Updated to revision 2.\n"
"$ ls sandwich.*\n"
"sandwich.txt  sandwich.txt.mine  sandwich.txt.r2  sandwich.txt.r1\n"
"$ cp sandwich.txt.r2 sandwich.txt\n"
"$ svn resolved sandwich.txt\n"
msgstr ""
"\n"
"$ svn update\n"
"C  sandwich.txt\n"
"Updated to revision 2.\n"
"$ ls sandwich.*\n"
"sandwich.txt  sandwich.txt.mine  sandwich.txt.r2  sandwich.txt.r1\n"
"$ cp sandwich.txt.r2 sandwich.txt\n"
"$ svn resolved sandwich.txt\n"

#: build/en/book.xml:3370(title)
msgid "Punting: Using <command moreinfo=\"none\">svn revert</command>"
msgstr "脚注：使用<command moreinfo=\"none\">svn revert</command>"

#: build/en/book.xml:3372(para)
msgid "If you get a conflict, and upon examination decide that you want to throw out your changes and start your edits again, just revert your changes:"
msgstr "如果你得到冲突，经过检查你决定取消自己的修改并且重新编辑，你可以恢复你的修改："

#: build/en/book.xml:3376(screen)
#, no-wrap
msgid ""
"\n"
"$ svn revert sandwich.txt\n"
"Reverted 'sandwich.txt'\n"
"$ ls sandwich.*\n"
"sandwich.txt\n"
msgstr ""
"\n"
"$ svn revert sandwich.txt\n"
"Reverted 'sandwich.txt'\n"
"$ ls sandwich.*\n"
"sandwich.txt\n"

#: build/en/book.xml:3383(para)
msgid "Note that when you revert a conflicted file, you don't have to run <command moreinfo=\"none\">svn resolved</command>."
msgstr "注意，当你恢复一个冲突的文件时，不需要再运行<command moreinfo=\"none\">svn resolved</command>。"

#: build/en/book.xml:3392(title)
msgid "Commit Your Changes"
msgstr "提交你的修改"

#: build/en/book.xml:3394(para)
msgid "Finally! Your edits are finished, you've merged all changes from the server, and you're ready to commit your changes to the repository."
msgstr "最后！你的修改结束了，你合并了服务器上所有的修改，你准备好提交修改到版本库。"

#: build/en/book.xml:3398(para)
#, fuzzy
msgid "The <command moreinfo=\"none\">svn commit</command> command sends all of your changes to the repository. When you commit a change, you need to supply a <firstterm>log message</firstterm>, describing your change. Your log message will be attached to the new revision you create. If your log message is brief, you may wish to supply it on the command line using the <option>--message</option> (or <option>-m</option>) switch:"
msgstr "<command moreinfo=\"none\">svn commit</command>命令发送所有的修改到版本库，当你提交修改时，你需要提供一些描述修改的<firstterm>日志信息</firstterm>，你的信息会附到这个修订版本上，如果信息很简短，你可以在命令行中使用<option>--message</option>（<option>-m</option>）选项："

#: build/en/book.xml:3407(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit -m \"Corrected number of cheese slices.\"\n"
"Sending        sandwich.txt\n"
"Transmitting file data .\n"
"Committed revision 3.\n"
msgstr ""
"\n"
"$ svn commit -m \"Corrected number of cheese slices.\"\n"
"Sending        sandwich.txt\n"
"Transmitting file data .\n"
"Committed revision 3.\n"

#: build/en/book.xml:3414(para)
#, fuzzy
msgid "However, if you've been composing your log message as you work, you may want to tell Subversion to get the message from a file by passing the filename with the <option>--file (-F)</option> option:"
msgstr "然而，如果你把写日志信息当作工作的一部分，你也许会希望通过告诉Subversion一个文件名得到日志信息，使用<option>--file</option>选项："

#: build/en/book.xml:3419(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit -F logmsg\n"
"Sending        sandwich.txt\n"
"Transmitting file data .\n"
"Committed revision 4.\n"
msgstr ""
"\n"
"$ svn commit -F logmsg\n"
"Sending        sandwich.txt\n"
"Transmitting file data .\n"
"Committed revision 4.\n"

#: build/en/book.xml:3426(para)
msgid "If you fail to specify either the <option>--message</option> or <option>--file</option> switch, then Subversion will automatically launch your favorite editor (see the <literal moreinfo=\"none\">editor-cmd</literal> section in <xref linkend=\"svn.advanced.confarea.opts.config\"/>) for composing a log message."
msgstr "如果你没有指定<option>--message</option>或者<option>--file</option>选项，Subversion会自动地启动你最喜欢的编辑器（见<xref linkend=\"svn.advanced.confarea.opts.config\"/>的<literal moreinfo=\"none\">editor-cmd</literal>部分）来编辑日志信息。"

#: build/en/book.xml:3435(para)
#, fuzzy
msgid "If you're in your editor writing a commit message and decide that you want to cancel your commit, you can just quit your editor without saving changes. If you've already saved your commit message, simply delete the text, save again, then quit."
msgstr "如果你使用编辑器撰写日志信息时希望取消提交，你可以直接关掉编辑器，不要保存，如果你已经做过保存，只要简单的删掉所有的文本并再次保存。"

#: build/en/book.xml:3441(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit\n"
"Waiting for Emacs...Done\n"
"\n"
"Log message unchanged or not specified\n"
"a)bort, c)ontinue, e)dit\n"
"a\n"
"$\n"
msgstr ""
"\n"
"$ svn commit\n"
"Waiting for Emacs...Done\n"
"\n"
"Log message unchanged or not specified\n"
"a)bort, c)ontinue, e)dit\n"
"a\n"
"$\n"

#: build/en/book.xml:3452(para)
msgid "The repository doesn't know or care if your changes make any sense as a whole; it only checks to make sure that nobody else has changed any of the same files that you did when you weren't looking. If somebody <emphasis>has</emphasis> done that, the entire commit will fail with a message informing you that one or more of your files is out-of-date:"
msgstr "版本库不知道也不关心你的修改作为一个整体是否有意义，它只检查是否有其他人修改了同一个文件，如果别人<emphasis>已经</emphasis>这样做了，你的整个提交会失败，并且提示你一个或多个文件已经过时了："

#: build/en/book.xml:3459(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit -m \"Add another rule\"\n"
"Sending        rules.txt\n"
"svn: Commit failed (details follow):\n"
"svn: Your file or directory 'sandwich.txt' is probably out-of-date\n"
"…\n"
msgstr ""
"\n"
"$ svn commit -m \"Add another rule\"\n"
"Sending        rules.txt\n"
"svn: Commit failed (details follow):\n"
"svn: Your file or directory 'sandwich.txt' is probably out-of-date\n"
"…\n"

#: build/en/book.xml:3467(para)
msgid "At this point, you need to run <command moreinfo=\"none\">svn update</command>, deal with any merges or conflicts that result, and attempt your commit again."
msgstr "此刻，你需要运行<command moreinfo=\"none\">svn update</command>来处理所有的合并和冲突，然后再尝试提交。"

#: build/en/book.xml:3471(para)
#, fuzzy
msgid "That covers the basic work cycle for using Subversion. There are many other features in Subversion that you can use to manage your repository and working copy, but most of your day-to-day use of Subversion will involve only the commands that we've discussed so far in this chapter. We will, however, cover a few more commands that you'll use just fairly often."
msgstr "我们已经覆盖了Subversion基本的工作周期，还有许多其它特性可以管理你得版本库和工作拷贝，但是只使用前面介绍的命令你就可以很轻松的工作了。"

#: build/en/book.xml:3487(title)
msgid "Examining History"
msgstr "检验历史"

#: build/en/book.xml:3489(para)
#, fuzzy
msgid "Your Subversion repository is like a time machine. It keeps a record of every change ever committed, and allows you to explore this history by examining previous versions of files and directories as well as the metadata that accompanies them. With a single Subversion command, you can check out the repository (or restore an existing working copy) exactly as it was at any date or revision number in the past. However, sometimes you just want to <emphasis>peer into</emphasis> the past instead of <emphasis>going into</emphasis> the past."
msgstr "我们曾经说过，版本库就像是一台时间机器，它记录了所有提交的修改，允许你检查文件或目录以及相关元数据的历史。通过一个Subversion命令你可以根据时间或修订号取出一个过去的版本（或者恢复现在的工作拷贝），然而，有时候我们只是想<emphasis>看看</emphasis>历史而不想<emphasis>回到</emphasis>历史。"

#: build/en/book.xml:3499(para)
msgid "There are several commands that can provide you with historical data from the repository:"
msgstr "有许多命令可以为你提供版本库历史："

#: build/en/book.xml:3505(command) build/en/book.xml:19954(refname)
msgid "svn log"
msgstr "svn log"

#: build/en/book.xml:3507(para)
msgid "Shows you broad information: log messages with date and author information attached to revisions, and which paths changed in each revision."
msgstr "展示给你主要信息：每个版本附加在版本上的作者与日期信息和所有路径修改。"

#: build/en/book.xml:3516(para)
msgid "Shows line-level details of a particular change."
msgstr ""

#: build/en/book.xml:3521(command) build/en/book.xml:3810(command)
#: build/en/book.xml:18335(refname)
msgid "svn cat"
msgstr "svn cat"

#: build/en/book.xml:3523(para)
msgid "This is used to retrieve any file as it existed in a particular revision number and display it on your screen."
msgstr "取得在特定版本的某一个文件显示在当前屏幕。"

#: build/en/book.xml:3530(command) build/en/book.xml:3838(command)
#: build/en/book.xml:19742(refname)
msgid "svn list"
msgstr "svn list"

#: build/en/book.xml:3532(para)
msgid "Displays the files in a directory for any given revision."
msgstr "显示一个目录在某一版本存在的文件。"

#: build/en/book.xml:3542(title)
msgid "Generating a list of historical changes"
msgstr "产生历史修改列表"

#: build/en/book.xml:3544(para)
msgid "To find information about the history of a file or directory, use the <command moreinfo=\"none\">svn log</command> command. <command moreinfo=\"none\">svn log</command> will provide you with a record of who made changes to a file or directory, at what revision it changed, the time and date of that revision, and, if it was provided, the log message that accompanied the commit."
msgstr "找出一个文件或目录的历史信息，使用<command moreinfo=\"none\">svn log</command>命令，<command moreinfo=\"none\">svn log</command>将会提供你一条记录，包括：谁对文件或目录作了修改、哪个修订版本作了修改、修订版本的日期和时间、还有如果你当时提供了日志信息，也会显示。"

#: build/en/book.xml:3552(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log\n"
"------------------------------------------------------------------------\n"
"r3 | sally | Mon, 15 Jul 2002 18:03:46 -0500 | 1 line\n"
"\n"
"Added include lines and corrected # of cheese slices.\n"
"------------------------------------------------------------------------\n"
"r2 | harry | Mon, 15 Jul 2002 17:47:57 -0500 | 1 line\n"
"\n"
"Added main() methods.\n"
"------------------------------------------------------------------------\n"
"r1 | sally | Mon, 15 Jul 2002 17:40:08 -0500 | 1 line\n"
"\n"
"Initial import\n"
"------------------------------------------------------------------------\n"
msgstr ""
"\n"
"$ svn log\n"
"------------------------------------------------------------------------\n"
"r3 | sally | Mon, 15 Jul 2002 18:03:46 -0500 | 1 line\n"
"\n"
"Added include lines and corrected # of cheese slices.\n"
"------------------------------------------------------------------------\n"
"r2 | harry | Mon, 15 Jul 2002 17:47:57 -0500 | 1 line\n"
"\n"
"Added main() methods.\n"
"------------------------------------------------------------------------\n"
"r1 | sally | Mon, 15 Jul 2002 17:40:08 -0500 | 1 line\n"
"\n"
"Initial import\n"
"------------------------------------------------------------------------\n"

#: build/en/book.xml:3569(para)
#, fuzzy
msgid "Note that the log messages are printed in <emphasis>reverse chronological order</emphasis> by default. If you wish to see a different range of revisions in a particular order, or just a single revision, pass the <option>--revision (-r)</option> option:"
msgstr "注意日志信息缺省根据<emphasis>时间逆序排列</emphasis>，如果希望察看特定顺序的一段修订版本或者单一版本，使用<option>--revision</option> （<option>-r</option>）选项："

#: build/en/book.xml:3575(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log -r 5:19    # shows logs 5 through 19 in chronological order\n"
"\n"
"$ svn log -r 19:5    # shows logs 5 through 19 in reverse order\n"
"\n"
"$ svn log -r 8       # shows log for revision 8\n"
msgstr ""
"\n"
"$ svn log -r 5:19    # shows logs 5 through 19 in chronological order\n"
"\n"
"$ svn log -r 19:5    # shows logs 5 through 19 in reverse order\n"
"\n"
"$ svn log -r 8       # shows log for revision 8\n"

#: build/en/book.xml:3583(para)
msgid "You can also examine the log history of a single file or directory. For example:"
msgstr "你也可以检查单个文件或目录的日志历史，举个例子："

#: build/en/book.xml:3586(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log foo.c\n"
"…\n"
"$ svn log http://foo.com/svn/trunk/code/foo.c\n"
"…\n"
msgstr ""
"\n"
"$ svn log foo.c\n"
"…\n"
"$ svn log http://foo.com/svn/trunk/code/foo.c\n"
"…\n"

#: build/en/book.xml:3593(para)
msgid "These will display log messages <emphasis>only</emphasis> for those revisions in which the working file (or URL) changed."
msgstr "这样<emphasis>只会</emphasis>显示这个工作文件（或者URL）做过修订的版本的日志信息。"

#: build/en/book.xml:3597(para)
#, fuzzy
msgid "If you want even more information about a file or directory, <command moreinfo=\"none\">svn log</command> also takes a <option>--verbose (-v)</option> option. Because Subversion allows you to move and copy files and directories, it is important to be able to track path changes in the filesystem, so in verbose mode, <command moreinfo=\"none\">svn log</command> will include a list of changed paths in a revision in its output:"
msgstr "如果你希望得到目录和文件更多的信息，你可以对<command moreinfo=\"none\">svn log</command>命令使用<option>--verbose</option> （<option>-v</option>）开关，因为Subversion允许移动和复制文件和目录，所以跟踪路径修改非常重要，在详细模式下，<command moreinfo=\"none\">svn log</command> 输出中会包括一个路径修改的历史："

#: build/en/book.xml:3605(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log -r 8 -v\n"
"------------------------------------------------------------------------\n"
"r8 | sally | 2002-07-14 08:15:29 -0500 | 1 line\n"
"Changed paths:\n"
"M /trunk/code/foo.c\n"
"M /trunk/code/bar.h\n"
"A /trunk/code/doc/README\n"
"\n"
"Frozzled the sub-space winch.\n"
"\n"
"------------------------------------------------------------------------\n"
msgstr ""
"\n"
"$ svn log -r 8 -v\n"
"------------------------------------------------------------------------\n"
"r8 | sally | 2002-07-14 08:15:29 -0500 | 1 line\n"
"Changed paths:\n"
"M /trunk/code/foo.c\n"
"M /trunk/code/bar.h\n"
"A /trunk/code/doc/README\n"
"\n"
"Frozzled the sub-space winch.\n"
"\n"
"------------------------------------------------------------------------\n"

#: build/en/book.xml:3619(para)
msgid "<command moreinfo=\"none\">svn log</command> also takes a <option>--quiet</option> (<option>-q</option>) switch, which suppresses the body of the log message. When combined with <option>--verbose</option>, it gives just the names of the changed files."
msgstr "<command moreinfo=\"none\">svn log</command>也有一个<option>--quiet</option> (<option>-q</option>)选项，会禁止日志信息的主要部分，当与<option>--verbose</option>结合使用，仅会显示修改的文件名。"

#: build/en/book.xml:3626(title)
msgid "Why Does <command moreinfo=\"none\">svn log</command> Give Me an Empty Response?"
msgstr "为什么<command moreinfo=\"none\">svn log</command>给我一个空的回应？"

#: build/en/book.xml:3629(para)
msgid "After working with Subversion for a bit, most users will come across something like this:"
msgstr "当使用Subversion一些时间后，许多用户会遇到这种情况："

#: build/en/book.xml:3632(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log -r 2\n"
"------------------------------------------------------------------------\n"
"$\n"
msgstr ""
"\n"
"$ svn log -r 2\n"
"------------------------------------------------------------------------\n"
"$\n"

#: build/en/book.xml:3638(para)
msgid "At first glance, this seems like an error. But recall that while revisions are repository-wide, <command moreinfo=\"none\">svn log</command> operates on a path in the repository. If you supply no path, Subversion uses the current working directory as the default target. As a result, if you're operating in a subdirectory of your working copy and attempt to see the log of a revision in which neither that directory nor any of its children was changed, Subversion will show you an empty log. If you want to see what changed in that revision, try pointing <command moreinfo=\"none\">svn log</command> directly at the top-most URL of your repository, as in <command moreinfo=\"none\">svn log -r 2 http://svn.collab.net/repos/svn</command>."
msgstr "乍一看，好像是一个错误，但是想一下修订版本号是作用在版本库整体之上的，如果你没有提供路径，<command moreinfo=\"none\">svn log</command>会使用当前目录作为默认的目标，所以，作为结果，如果你对一个本身和子目录在指定版本到现在没有做过修改的目录运行这个命令，你会得到空的日志。如果你希望察看某个版本做的修改的日志，只需要直接告诉<command moreinfo=\"none\">svn log</command>使用版本库顶级的目录作为参数，例如<command moreinfo=\"none\">svn log -r 2 http://svn.collab.net/repos/svn</command>。"

#: build/en/book.xml:3657(title)
msgid "Examining the details of historical changes"
msgstr "检查历史修改的详情"

#: build/en/book.xml:3659(para)
msgid "We've already seen <command moreinfo=\"none\">svn diff</command> before—it displays file differences in unified diff format; it was used to show the local modifications made to our working copy before committing to the repository."
msgstr "我们已经看过<command moreinfo=\"none\">svn diff</command>—使用标准区别文件格式显示区别，它在提交前用来显示本地工作拷贝与版本库的区别。"

#: build/en/book.xml:3664(para)
msgid "In fact, it turns out that there are <emphasis>three</emphasis> distinct uses of <command moreinfo=\"none\">svn diff</command>:"
msgstr "事实上，<command moreinfo=\"none\">svn diff</command>有<emphasis>三</emphasis>种不同的用法："

#: build/en/book.xml:3671(para)
msgid "Examine local changes"
msgstr "检查本地修改"

#: build/en/book.xml:3675(para)
msgid "Compare your working copy to the repository"
msgstr "比较工作拷贝与版本库"

#: build/en/book.xml:3679(para)
msgid "Compare repository to repository"
msgstr "比较版本库和版本库"

#: build/en/book.xml:3686(title)
msgid "Examining Local Changes"
msgstr "比较本地修改"

#: build/en/book.xml:3688(para)
msgid "As we've seen, invoking <command moreinfo=\"none\">svn diff</command> with no switches will compare your working files to the cached <quote>pristine</quote> copies in the <filename moreinfo=\"none\">.svn</filename> area:"
msgstr "像我们看到的，不使用任何参数调用时，<command moreinfo=\"none\">svn diff</command>将会比较你的工作文件与缓存在<filename moreinfo=\"none\">.svn</filename>的<quote>原始</quote>拷贝："

#: build/en/book.xml:3693(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff\n"
"Index: rules.txt\n"
"===================================================================\n"
"--- rules.txt\t(revision 3)\n"
"+++ rules.txt\t(working copy)\n"
"@@ -1,4 +1,5 @@\n"
" Be kind to others\n"
" Freedom = Responsibility\n"
" Everything in moderation\n"
"-Chew with your mouth open\n"
"+Chew with your mouth closed\n"
"+Listen when others are speaking\n"
"$\n"
msgstr ""
"\n"
"$ svn diff\n"
"Index: rules.txt\n"
"===================================================================\n"
"--- rules.txt\t(revision 3)\n"
"+++ rules.txt\t(working copy)\n"
"@@ -1,4 +1,5 @@\n"
" Be kind to others\n"
" Freedom = Responsibility\n"
" Everything in moderation\n"
"-Chew with your mouth open\n"
"+Chew with your mouth closed\n"
"+Listen when others are speaking\n"
"$\n"

#: build/en/book.xml:3713(title)
msgid "Comparing Working Copy to Repository"
msgstr "比较工作副本和版本库"

#: build/en/book.xml:3715(para)
msgid "If a single <option>--revision</option> (<option>-r</option>) number is passed, then your working copy is compared to the specified revision in the repository."
msgstr "如果传递一个<option>--revision</option>（<option>-r</option>）参数，你的工作拷贝会与指定的版本比较。"

#: build/en/book.xml:3720(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff -r 3 rules.txt\n"
"Index: rules.txt\n"
"===================================================================\n"
"--- rules.txt\t(revision 3)\n"
"+++ rules.txt\t(working copy)\n"
"@@ -1,4 +1,5 @@\n"
" Be kind to others\n"
" Freedom = Responsibility\n"
" Everything in moderation\n"
"-Chew with your mouth open\n"
"+Chew with your mouth closed\n"
"+Listen when others are speaking\n"
"$\n"
msgstr ""
"\n"
"$ svn diff -r 3 rules.txt\n"
"Index: rules.txt\n"
"===================================================================\n"
"--- rules.txt\t(revision 3)\n"
"+++ rules.txt\t(working copy)\n"
"@@ -1,4 +1,5 @@\n"
" Be kind to others\n"
" Freedom = Responsibility\n"
" Everything in moderation\n"
"-Chew with your mouth open\n"
"+Chew with your mouth closed\n"
"+Listen when others are speaking\n"
"$\n"

#: build/en/book.xml:3740(title)
msgid "Comparing Repository to Repository"
msgstr "比较版本库与版本库"

#: build/en/book.xml:3742(para)
#, fuzzy
msgid "If two revision numbers, separated by a colon, are passed via <option>--revision (-r)</option>, then the two revisions are directly compared."
msgstr "如果通过<option>--revision</option> （<option>-r</option>）传递两个版本号，通过冒号分开，这两个版本会进行比较。"

#: build/en/book.xml:3746(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff -r 2:3 rules.txt\n"
"Index: rules.txt\n"
"===================================================================\n"
"--- rules.txt\t(revision 2)\n"
"+++ rules.txt\t(revision 3)\n"
"@@ -1,4 +1,4 @@\n"
" Be kind to others\n"
"-Freedom = Chocolate Ice Cream\n"
"+Freedom = Responsibility\n"
" Everything in moderation\n"
" Chew with your mouth open\n"
"$\n"
msgstr ""
"\n"
"$ svn diff -r 2:3 rules.txt\n"
"Index: rules.txt\n"
"===================================================================\n"
"--- rules.txt\t(revision 2)\n"
"+++ rules.txt\t(revision 3)\n"
"@@ -1,4 +1,4 @@\n"
" Be kind to others\n"
"-Freedom = Chocolate Ice Cream\n"
"+Freedom = Responsibility\n"
" Everything in moderation\n"
" Chew with your mouth open\n"
"$\n"

#: build/en/book.xml:3761(para)
msgid "A more convenient way of comparing a revision to the previous revision is to use the <option>--change (-c)</option>:"
msgstr ""

#: build/en/book.xml:3765(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff -c 3 rules.txt\n"
"Index: rules.txt\n"
"===================================================================\n"
"--- rules.txt\t(revision 2)\n"
"+++ rules.txt\t(revision 3)\n"
"@@ -1,4 +1,4 @@\n"
" Be kind to others\n"
"-Freedom = Chocolate Ice Cream\n"
"+Freedom = Responsibility\n"
" Everything in moderation\n"
" Chew with your mouth open\n"
"$\n"
msgstr ""
"\n"
"$ svn diff -c 3 rules.txt\n"
"Index: rules.txt\n"
"===================================================================\n"
"--- rules.txt\t(revision 2)\n"
"+++ rules.txt\t(revision 3)\n"
"@@ -1,4 +1,4 @@\n"
" Be kind to others\n"
"-Freedom = Chocolate Ice Cream\n"
"+Freedom = Responsibility\n"
" Everything in moderation\n"
" Chew with your mouth open\n"
"$\n"

#: build/en/book.xml:3780(para)
msgid "Not only can you use <command moreinfo=\"none\">svn diff</command> to compare files in your working copy to the repository, but if you supply a URL argument, you can examine the differences between items in the repository without even having a working copy. This is especially useful if you wish to inspect changes in a file when you don't have a working copy on your local machine:"
msgstr "你不仅可以用<command moreinfo=\"none\">svn diff</command>比较你工作拷贝中的文件，你甚至可以通过提供一个URL参数来比较版本库中两个文件的的区别，通常在本地机器没有工作拷贝时非常有用："

#: build/en/book.xml:3788(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff -c 5 http://svn.example.com/repos/example/trunk/text/rules.txt\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svn diff -c 5 http://svn.example.com/repos/example/trunk/text/rules.txt\n"
"…\n"
"$\n"

#: build/en/book.xml:3800(title)
msgid "Browsing the repository"
msgstr "浏览版本库"

#: build/en/book.xml:3802(para)
msgid "Using <command moreinfo=\"none\">svn cat</command> and <command moreinfo=\"none\">svn list</command>, you can view various revisions of files and directories without changing the working revision of your working copy. In fact, you don't even need a working copy to use either one."
msgstr ""

#: build/en/book.xml:3813(para)
msgid "If you want to examine an earlier version of a file and not necessarily the differences between two files, you can use <command moreinfo=\"none\">svn cat</command>:"
msgstr "如果你只是希望检查一个过去的版本而不希望察看它们的区别，使用<command moreinfo=\"none\">svn cat</command>："

#: build/en/book.xml:3817(screen)
#, no-wrap
msgid ""
"\n"
"$ svn cat -r 2 rules.txt\n"
"Be kind to others\n"
"Freedom = Chocolate Ice Cream\n"
"Everything in moderation\n"
"Chew with your mouth open\n"
"$\n"
msgstr ""
"\n"
"$ svn cat -r 2 rules.txt\n"
"Be kind to others\n"
"Freedom = Chocolate Ice Cream\n"
"Everything in moderation\n"
"Chew with your mouth open\n"
"$\n"

#: build/en/book.xml:3826(para)
msgid "You can also redirect the output directly into a file:"
msgstr "你可以重定向输出到一个文件："

#: build/en/book.xml:3829(screen)
#, no-wrap
msgid ""
"\n"
"$ svn cat -r 2 rules.txt &gt; rules.txt.v2\n"
"$\n"
msgstr ""
"\n"
"$ svn cat -r 2 rules.txt &gt; rules.txt.v2\n"
"$\n"

#: build/en/book.xml:3840(para)
msgid "The <command moreinfo=\"none\">svn list</command> command shows you what files are in a repository directory without actually downloading the files to your local machine:"
msgstr "<command moreinfo=\"none\">svn list</command>可以在不下载文件到本地目录的情况下来察看目录中的文件："

#: build/en/book.xml:3844(screen)
#, no-wrap
msgid ""
"\n"
"$ svn list http://svn.collab.net/repos/svn\n"
"README\n"
"branches/\n"
"clients/\n"
"tags/\n"
"trunk/\n"
msgstr ""
"\n"
"$ svn list http://svn.collab.net/repos/svn\n"
"README\n"
"branches/\n"
"clients/\n"
"tags/\n"
"trunk/\n"

#: build/en/book.xml:3853(para)
#, fuzzy
msgid "If you want a more detailed listing, pass the <option>--verbose (-v)</option> flag to get output like this:"
msgstr "如果你希望察看详细信息，你可以使用<option>--verbose</option> （<option>-v</option>）参数："

#: build/en/book.xml:3857(screen)
#, no-wrap
msgid ""
"\n"
"$ svn list -v http://svn.collab.net/repos/svn\n"
"  20620 harry            1084 Jul 13  2006 README\n"
"  23339 harry                 Feb 04 01:40 branches/\n"
"  21282 sally                 Aug 27 09:41 developer-resources/\n"
"  23198 harry                 Jan 23 17:17 tags/\n"
"  23351 sally                 Feb 05 13:26 trunk/\n"
msgstr ""
"\n"
"$ svn list -v http://svn.collab.net/repos/svn\n"
"  20620 harry            1084 Jul 13  2006 README\n"
"  23339 harry                 Feb 04 01:40 branches/\n"
"  21282 sally                 Aug 27 09:41 developer-resources/\n"
"  23198 harry                 Jan 23 17:17 tags/\n"
"  23351 sally                 Feb 05 13:26 trunk/\n"

#: build/en/book.xml:3866(para)
msgid "The columns tell you the revision at which the file or directory was last modified, the user who modified it, the size if it is a file, the date it was last modified, and the item's name."
msgstr "这些列告诉你文件和目录最后修改的修订版本、做出修改的用户、如果是文件还会有文件的大小，最后是修改日期和项目的名字。"

#: build/en/book.xml:3877(title)
#, fuzzy
msgid "Fetching older repository snapshots"
msgstr "获得旧的版本库快照"

#: build/en/book.xml:3883(para)
msgid "See? We told you that Subversion was a time machine."
msgstr "看到了吧？我们说过Subversion是一个时间机器。"

#: build/en/book.xml:3879(para)
msgid "In addition to all of the above commands, you can use <command moreinfo=\"none\">svn update</command> and <command moreinfo=\"none\">svn checkout</command> with the <option>--revision</option> switch to take an entire working copy <quote>back in time</quote><placeholder-1/>:"
msgstr "除了以上的命令，你可以使用带参数<option>--revision</option>的<command moreinfo=\"none\">svn update</command>和<command moreinfo=\"none\">svn checkout</command>来使整个工作拷贝<quote>回到过去</quote><placeholder-1/>："

#: build/en/book.xml:3886(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout -r 1729 # Checks out a new working copy at r1729\n"
"…\n"
"$ svn update -r 1729 # Updates an existing working copy to r1729\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout -r 1729 # Checks out a new working copy at r1729\n"
"…\n"
"$ svn update -r 1729 # Updates an existing working copy to r1729\n"
"…\n"

#: build/en/book.xml:3894(para)
msgid "Many Subversion newcomers attempt to use the above <command moreinfo=\"none\">svn update</command> example to <quote>undo</quote> committed changes, but this won't work as you can't commit changes that you obtain from backdating a working copy if the changed files have newer revisions. See <xref linkend=\"svn.branchmerge.commonuses.resurrect\"/> for a description of how to <quote>undo</quote> a commit."
msgstr ""

#: build/en/book.xml:3902(para)
msgid "Lastly, if you're building a release and wish to bundle up your files from Subversion but don't want those pesky .svn directories in the way, then you can use svn export to create a local copy of all or part of your repository sans .svn directories. As with <command moreinfo=\"none\">svn update</command> and <command moreinfo=\"none\">svn checkout</command>, you can also pass the <option>--revision</option> switch to <command moreinfo=\"none\">svn export</command>:"
msgstr ""

#: build/en/book.xml:3911(screen)
#, no-wrap
msgid ""
"\n"
"$ svn export http://svn.example.com/svn/repos1 # Exports latest revision\n"
"…\n"
"$ svn export http://svn.example.com/svn/repos1 -r 1729\n"
"# Exports revision r1729\n"
"…\n"
msgstr ""
"\n"
"$ svn export http://svn.example.com/svn/repos1 # Exports latest revision\n"
"…\n"
"$ svn export http://svn.example.com/svn/repos1 -r 1729\n"
"# Exports revision r1729\n"
"…\n"

#: build/en/book.xml:3928(title)
msgid "Sometimes You Just Need to Cleanup"
msgstr "有时你只需要清理"

#: build/en/book.xml:3930(para)
msgid "When Subversion modifies your working copy (or any information within <filename moreinfo=\"none\">.svn</filename>), it tries to do so as safely as possible. Before changing the working copy, Subversion writes its intentions to a log file. Next it executes the commands in the log file to apply the requested change, holding a lock on the relevant part of the working copy while it works — to prevent other Subversion clients from accessing the working copy in mid-change. Finally, Subversion removes the log file. Architecturally, this is similar to a journaled filesystem. If a Subversion operation is interrupted (if the process is killed, or if the machine crashes, for example), the log files remain on disk. By re-executing the log files, Subversion can complete the previously started operation, and your working copy can get itself back into a consistent state."
msgstr "当Subversion改变你的工作拷贝（或是<filename moreinfo=\"none\">.svn</filename>中的任何信息），它会尽可能的小心，在修改任何事情之前，它把意图写到日志文件中去，然后执行log文件中的命令，并且执行过程中在工作拷贝的相关部分保存一个锁— 防止Subversion客户端在变更过程中访问工作拷贝。然后删掉日志文件，这与记帐试的文件系统架构类似。如果Subversion的操作中断了（举个例子：进程被杀死了，机器死掉了），日志文件会保存在硬盘上，通过重新执行日志文件，Subversion可以完成上一次开始的操作，你的工作拷贝可以回到一致的状态。"

#: build/en/book.xml:3946(para)
msgid "And this is exactly what <command moreinfo=\"none\">svn cleanup</command> does: it searches your working copy and runs any leftover logs, removing working copy locks in the process. If Subversion ever tells you that some part of your working copy is <quote>locked</quote>, then this is the command that you should run. Also, <command moreinfo=\"none\">svn status</command> will display an <literal moreinfo=\"none\">L</literal> next to locked items:"
msgstr "这就是<command moreinfo=\"none\">svn cleanup</command>所作的：它查找工作拷贝中的所有遗留的日志文件，删除进程中工作拷贝的锁。如果Subversion告诉你工作拷贝中的一部分已经<quote>锁定</quote>了，你就需要运行这个命令了。同样，<command moreinfo=\"none\">svn status</command>将会使用<literal moreinfo=\"none\">L</literal> 显示锁定的项目："

#: build/en/book.xml:3954(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status\n"
"  L    somedir\n"
"M      somedir/foo.c\n"
"\n"
"$ svn cleanup\n"
"$ svn status\n"
"M      somedir/foo.c\n"
msgstr ""
"\n"
"$ svn status\n"
"  L    somedir\n"
"M      somedir/foo.c\n"
"\n"
"$ svn cleanup\n"
"$ svn status\n"
"M      somedir/foo.c\n"

#: build/en/book.xml:3964(para)
msgid "Don't confuse these working copy locks with the ordinary locks that Subversion users create when using the <quote>lock-modify-unlock</quote> model of concurrent version control; see <xref linkend=\"svn.advanced.locking.meanings\"/> for clarification."
msgstr "Don't confuse these working copy locks with the ordinary locks that Subversion users create when using the <quote>lock-modify-unlock</quote> model of concurrent version control; see <xref linkend=\"svn.advanced.locking.meanings\"/> for clarification."

#: build/en/book.xml:3979(para)
msgid "Now we've covered most of the Subversion client commands. Notable exceptions are those dealing with branching and merging (see <xref linkend=\"svn.branchmerge\"/>) and properties (see <xref linkend=\"svn.advanced.props\"/>). However, you may want to take a moment to skim through <xref linkend=\"svn.ref\"/> to get an idea of all the many different commands that Subversion has—and how you can use them to make your work easier."
msgstr "我们已经覆盖了大多数Subversion的客户端命令，引人注目的例外是处理分支与合并（见<xref linkend=\"svn.branchmerge\"/>）以及属性（见<xref linkend=\"svn.advanced.props\"/>）的命令，然而你也许会希望跳到<xref linkend=\"svn.ref\"/>来察看所有不同的命令—怎样利用它们使你的工作更容易。"

#: build/en/book.xml:3999(title)
msgid "Advanced Topics"
msgstr "高级主题"

#: build/en/book.xml:4001(para)
msgid "If you've been reading this book chapter by chapter, from start to finish, you should by now have acquired enough knowledge to use the Subversion client to perform the most common version control operations. You understand how to checkout a working copy from a Subversion repository. You are comfortable with submitting and receiving changes using the <command moreinfo=\"none\">svn commit</command> and <command moreinfo=\"none\">svn update</command> functions. You've probably even developed a reflex which causes you to run the <command moreinfo=\"none\">svn status</command> command almost unconsciously. For all intents and purposes, you are ready to use Subversion in a typical environment."
msgstr "如果你是从头到尾按章节阅读本书，你一定已经具备了使用Subversion客户端执行大多数不同的版本控制操作足够的知识，你理解了怎样从Subversion版本库取出一个工作拷贝，你已经熟悉了通过<command moreinfo=\"none\">svn commit</command>和<command moreinfo=\"none\">svn update</command>来提交和接收修改，你甚至也经常下意识的使用<command moreinfo=\"none\">svn status</command>，无论目的是什么，你已经可以正常使用Subversion了。"

#: build/en/book.xml:4013(para)
msgid "But the Subversion feature set doesn't stop at <quote>common version control operations</quote>. It has other bits of functionality that extend beyond just communicating file and directory changes to and from a central repository."
msgstr ""

#: build/en/book.xml:4018(para)
#, fuzzy
msgid "This chapter highlights some of Subversion's features that, while important, aren't part of the typical user's daily routine. It assumes that you are familiar with Subversion's basic file and directory versioning capabilities. If you aren't, you'll want to first read <xref linkend=\"svn.basic\"/> and <xref linkend=\"svn.tour\"/>. Once you've mastered those basics and consumed this chapter, you'll be a Subversion power-user!"
msgstr "在阅读本章之前，你一定要熟悉Subversion对文件和目录的基本版本操作能力，如果你还没有阅读这些内容，或者是需要一个复习，我们建议你重读<xref linkend=\"svn.basic\"/>和<xref linkend=\"svn.tour\"/>，一旦你已经掌握了基础知识和本章的内容，你会变成Subversion的超级用户！"

#: build/en/book.xml:4030(title)
msgid "Revision Specifiers"
msgstr "版本清单"

#: build/en/book.xml:4032(para)
msgid "As you saw in <xref linkend=\"svn.basic.in-action.revs\"/>, revision numbers in Subversion are pretty straightforward—integers that keep getting larger as you commit more changes to your versioned data. Still, it doesn't take long before you can no longer remember exactly what happened in each and every revision. Fortunately, the typical Subversion workflow doesn't often demand that you supply arbitrary revisions to the Subversion operations you perform. For operations that <emphasis>do</emphasis> require a revision specifier, you generally supply a revision number that you saw in a commit email, in the output of some other Subversion operation, or in some other context that would yield meaning to that particular number."
msgstr ""

#: build/en/book.xml:4046(para)
msgid "But occasionally, you need to pinpoint a moment in time for which you don't already have a revision number memorized or handy. So besides the integer revision numbers, <command moreinfo=\"none\">svn</command> allows as input some additional forms of revision specifiers—revision keywords, and revision dates."
msgstr ""

#: build/en/book.xml:4054(para)
msgid "The various forms of Subversion revision specifiers can be mixed and matched when used to specify revision ranges. For example, you can use <option>-r <replaceable>REV1</replaceable>:<replaceable>REV2</replaceable></option> where <replaceable>REV1</replaceable> is a revision keyword and <replaceable>REV2</replaceable> is a revision number, or where <replaceable>REV1</replaceable> is a date and <replaceable>REV2</replaceable> is a revision keyword, and so on. The individual revision specifiers are independently evaluated, so you can put whatever you want on the opposite sides of that colon."
msgstr ""

#: build/en/book.xml:4069(title)
msgid "Revision Keywords"
msgstr "修订版本关键字"

#: build/en/book.xml:4072(primary) build/en/book.xml:4179(primary)
msgid "revisions"
msgstr "版本"

#: build/en/book.xml:4073(secondary)
msgid "revision keywords"
msgstr "版本关键字"

#: build/en/book.xml:4076(primary) build/en/book.xml:4097(term)
msgid "HEAD"
msgstr "HEAD"

#: build/en/book.xml:4079(primary) build/en/book.xml:4105(term)
msgid "BASE"
msgstr "BASE"

#: build/en/book.xml:4082(primary) build/en/book.xml:4115(term)
msgid "COMMITTED"
msgstr "COMMITTED"

#: build/en/book.xml:4085(primary) build/en/book.xml:4123(term)
msgid "PREV"
msgstr "PREV"

#: build/en/book.xml:4088(para)
#, fuzzy
msgid "The Subversion client understands a number of <firstterm>revision keywords</firstterm>. These keywords can be used instead of integer arguments to the <option>--revision (-r)</option> switch, and are resolved into specific revision numbers by Subversion:"
msgstr "Subversion客户端可以理解一些<firstterm>修订版本关键字</firstterm>，这些关键字可以用来代替<option>--revision</option>的数字参数，这会被Subversion解释到特定版本："

#: build/en/book.xml:4099(para)
msgid "The latest (or <quote>youngest</quote>) revision in the repository."
msgstr "版本库中最新的（或者是<quote>最年轻的</quote>）版本。"

#: build/en/book.xml:4107(para)
msgid "The revision number of an item in a working copy. If the item has been locally modified, the <quote>BASE version</quote> refers to the way the item appears without those local modifications."
msgstr "工作拷贝中一个条目的修订版本号，如果这个版本在本地修改了，则<quote>BASE版本</quote>就是这个条目在本地未修改的版本。"

#: build/en/book.xml:4117(para)
msgid "The most recent revision prior to, or equal to, <literal moreinfo=\"none\">BASE</literal>, in which an item changed."
msgstr "在<literal moreinfo=\"none\">BASE</literal>版本之前（或在Base）一个项目最后修改的版本。"

#: build/en/book.xml:4125(para)
#, fuzzy
msgid "The revision immediately <emphasis>before</emphasis> the last revision in which an item changed. Technically, this boils down to <literal moreinfo=\"none\">COMMITTED</literal>-1."
msgstr "一个项目最后修改版本<emphasis>之前</emphasis>的那个版本（技术上为COMMITTED -1）。"

#: build/en/book.xml:4134(para)
#, fuzzy
msgid "As can be derived from their descriptions, the <literal moreinfo=\"none\">PREV</literal>, <literal moreinfo=\"none\">BASE</literal>, and <literal moreinfo=\"none\">COMMITTED</literal> revision keywords are used only when referring to a working copy path—they don't apply to repository URLs. <literal moreinfo=\"none\">HEAD</literal>, on the other hand, can be used in conjunction with both of these path types."
msgstr "Subversion将CVS的<literal moreinfo=\"none\">P</literal>和<literal moreinfo=\"none\">U</literal>合并为<literal moreinfo=\"none\">U</literal>，当合并或冲突发生时，Subversion会简单的打印<literal moreinfo=\"none\">G</literal>或<literal moreinfo=\"none\">C</literal>，而不是大段相关内容。"

#: build/en/book.xml:4142(para)
msgid "Here are some examples of revision keywords in action:"
msgstr ""

#: build/en/book.xml:4145(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff -r PREV:COMMITTED foo.c\n"
"# shows the last change committed to foo.c\n"
"\n"
"$ svn log -r HEAD\n"
"# shows log message for the latest repository commit\n"
"\n"
"$ svn diff -r HEAD\n"
"# compares your working copy (with all of its local changes) to the\n"
"# latest version of that tree in the repository\n"
"\n"
"$ svn diff -r BASE:HEAD foo.c\n"
"# compares the unmodified version of foo.c with the latest version of\n"
"# foo.c in the repository\n"
"\n"
"$ svn log -r BASE:HEAD\n"
"# shows all commit logs for the current versioned directory since you\n"
"# last updated\n"
"\n"
"$ svn update -r PREV foo.c\n"
"# rewinds the last change on foo.c, decreasing foo.c's working revision\n"
"\n"
"$ svn diff -r BASE:14 foo.c\n"
"# compares the unmodified version of foo.c with the way foo.c looked\n"
"# in revision 14\n"
msgstr ""
"\n"
"$ svn diff -r PREV:COMMITTED foo.c\n"
"# shows the last change committed to foo.c\n"
"\n"
"$ svn log -r HEAD\n"
"# shows log message for the latest repository commit\n"
"\n"
"$ svn diff -r HEAD\n"
"# compares your working copy (with all of its local changes) to the\n"
"# latest version of that tree in the repository\n"
"\n"
"$ svn diff -r BASE:HEAD foo.c\n"
"# compares the unmodified version of foo.c with the latest version of\n"
"# foo.c in the repository\n"
"\n"
"$ svn log -r BASE:HEAD\n"
"# shows all commit logs for the current versioned directory since you\n"
"# last updated\n"
"\n"
"$ svn update -r PREV foo.c\n"
"# rewinds the last change on foo.c, decreasing foo.c's working revision\n"
"\n"
"$ svn diff -r BASE:14 foo.c\n"
"# compares the unmodified version of foo.c with the way foo.c looked\n"
"# in revision 14\n"

#: build/en/book.xml:4176(title)
msgid "Revision Dates"
msgstr "版本日期"

#: build/en/book.xml:4180(secondary)
msgid "specified as dates"
msgstr ""

#: build/en/book.xml:4183(para)
msgid "Revision numbers reveal nothing about the world outside the version control system, but sometimes you need to correlate a moment in real time with a moment in version history. To facilitate this, the <option>--revision (-r)</option> option can also accept as input date specifiers wrapped in curly braces (<literal moreinfo=\"none\">{</literal> and <literal moreinfo=\"none\">}</literal>). Subversion accepts the standard ISO-8601 date and time formats, plus a few others. Here are some examples. (Remember to use quotes around any date that contains spaces.)"
msgstr ""

#: build/en/book.xml:4194(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout -r {2006-02-17}\n"
"$ svn checkout -r {15:30}\n"
"$ svn checkout -r {15:30:00.200000}\n"
"$ svn checkout -r {\"2006-02-17 15:30\"}\n"
"$ svn checkout -r {\"2006-02-17 15:30 +0230\"}\n"
"$ svn checkout -r {2006-02-17T15:30}\n"
"$ svn checkout -r {2006-02-17T15:30Z}\n"
"$ svn checkout -r {2006-02-17T15:30-04:00}\n"
"$ svn checkout -r {20060217T1530}\n"
"$ svn checkout -r {20060217T1530Z}\n"
"$ svn checkout -r {20060217T1530-0500}\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout -r {2006-02-17}\n"
"$ svn checkout -r {15:30}\n"
"$ svn checkout -r {15:30:00.200000}\n"
"$ svn checkout -r {\"2006-02-17 15:30\"}\n"
"$ svn checkout -r {\"2006-02-17 15:30 +0230\"}\n"
"$ svn checkout -r {2006-02-17T15:30}\n"
"$ svn checkout -r {2006-02-17T15:30Z}\n"
"$ svn checkout -r {2006-02-17T15:30-04:00}\n"
"$ svn checkout -r {20060217T1530}\n"
"$ svn checkout -r {20060217T1530Z}\n"
"$ svn checkout -r {20060217T1530-0500}\n"
"…\n"

#: build/en/book.xml:4209(para)
#, fuzzy
msgid "When you specify a date, Subversion resolves that date to the most recent revision of the repository as of that date, and then continues to operate against that resolved revision number:"
msgstr "当你指定一个日期，Subversion会在版本库找到接近这个日期的最新版本："

#: build/en/book.xml:4214(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log -r {2006-11-28}\n"
"------------------------------------------------------------------------\n"
"r12 | ira | 2006-11-27 12:31:51 -0600 (Mon, 27 Nov 2006) | 6 lines\n"
"…\n"
msgstr ""
"\n"
"$ svn log -r {2006-11-28}\n"
"------------------------------------------------------------------------\n"
"r12 | ira | 2006-11-27 12:31:51 -0600 (Mon, 27 Nov 2006) | 6 lines\n"
"…\n"

#: build/en/book.xml:4222(title)
msgid "Is Subversion a Day Early?"
msgstr "Subversion 会早一天吗？"

#: build/en/book.xml:4224(para)
#, fuzzy
msgid "If you specify a single date as a revision without specifying a time of day (for example <literal moreinfo=\"none\">2006-11-27</literal>), you may think that Subversion should give you the last revision that took place on the 27th of November. Instead, you'll get back a revision from the 26th, or even earlier. Remember that Subversion will find the <emphasis>most recent revision of the repository</emphasis> as of the date you give. If you give a date without a timestamp, like <literal moreinfo=\"none\">2006-11-27</literal>, Subversion assumes a time of 00:00:00, so looking for the most recent revision won't return anything on the day of the 27th."
msgstr "如果你只是指定了日期而没有时间（举个例子<literal moreinfo=\"none\">2002-11-27</literal>），你也许会以为Subversion会给你11-27号最后的版本，相反，你会得到一个26号版本，甚至更早。记住Subversion会根据你的日期找到<emphasis>最新的</emphasis>版本，如果你给一个日期，而没有给时间，像<literal moreinfo=\"none\">2002-11-27</literal>，Subversion会假定时间是00:00:00，所以在27号找不到任何版本。"

#: build/en/book.xml:4237(para)
#, fuzzy
msgid "If you want to include the 27th in your search, you can either specify the 27th with the time (<literal moreinfo=\"none\">{\"2006-11-27 23:59\"}</literal>), or just specify the next day (<literal moreinfo=\"none\">{2006-11-28}</literal>)."
msgstr "如果你希望查询包括27号，你既可以使用（<literal moreinfo=\"none\">{\"2002-11-27 23:59\"}</literal>），或是直接使用（<literal moreinfo=\"none\">{2002-11-28}</literal>）。"

#: build/en/book.xml:4244(para)
msgid "You can also use a range of dates. Subversion will find all revisions between both dates, inclusive:"
msgstr "你可以使用时间段，Subversion会找到这段时间的所有版本："

#: build/en/book.xml:4247(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log -r {2006-11-20}:{2006-11-29}\n"
"…\n"
msgstr ""
"\n"
"$ svn log -r {2006-11-20}:{2006-11-29}\n"
"…\n"

#: build/en/book.xml:4253(para)
#, fuzzy
msgid "Since the timestamp of a revision is stored as an unversioned, modifiable property of the revision (see <xref linkend=\"svn.advanced.props\"/>, revision timestamps can be changed to represent complete falsifications of true chronology, or even removed altogether. This will wreak havoc on the internal date-to-revision conversion that Subversion performs."
msgstr "用户一定要认识到这种精巧会成为处理日期的绊脚石，因为一个版本的时间戳是作为一个属性存储的—不是版本化的，而是可以编辑的属性—版本号的时间戳可以被修改，从而建立一个虚假的年代表，也可以被完全删除。这将大大破坏Subversion的这种时间—版本转化功能的表现。"

#: build/en/book.xml:4269(title)
msgid "Properties"
msgstr "属性"

#: build/en/book.xml:4271(primary)
msgid "properties"
msgstr "属性"

#: build/en/book.xml:4274(para)
#, fuzzy
msgid "We've already covered in detail how Subversion stores and retrieves various versions of files and directories in its repository. Whole chapters have been devoted to this most fundamental piece of functionality provided by the tool. And if the versioning support stopped there, Subversion would still be complete from a version control perspective."
msgstr "我们已经详细讲述了Subversion存储和检索版本库中不同版本的文件和目录的细节，并且用了好几个章节来论述这个工具的基本功能。到此为止，Subversion还仅仅表现出一个普通的版本控制理念。但是Subversion并没有就此止步。"

#: build/en/book.xml:4281(para)
msgid "But it doesn't stop there."
msgstr ""

#: build/en/book.xml:4283(para)
#, fuzzy
msgid "In addition to versioning your directories and files, Subversion provides interfaces for adding, modifying, and removing versioned metadata on each of your versioned directories and files. We refer to this metadata as <firstterm>properties</firstterm>, and they can be thought of as two-column tables that map property names to arbitrary values attached to each item in your working copy. Generally speaking, the names and values of the properties can be whatever you want them to be, with the constraint that the names must be human-readable text. And the best part about these properties is that they, too, are versioned, just like the textual contents of your files. You can modify, commit, and revert property changes as easily as you can file content changes. And the sending and receiving of property changes occurs as part of your typical commit and update operations—you don't have to change your basic processes to accommodate them."
msgstr "作为目录和文件版本化的补充，Subversion提供了对每一个版本化的目录和文件添加、修改和删除版本化的元数据的接口，我们用<firstterm>属性</firstterm>来表示这些元数据。我们可以认为它们是一个两列的表，附加到你的工作拷贝的每个条目上，映射属性名到任意的值。一般来说，属性的名称和值可以是你希望的任何值，限制就是名称必须是可读的文本，并且最好的一点是这些属性也是版本化的，就像你的文本内容文件，你可以像提交文本修改一样修改、提交和恢复属性修改，当你更新时也会接收到别人的属性修改。"

#: build/en/book.xml:4300(para)
#, fuzzy
msgid "Properties show up elsewhere in Subversion, too. Just as files and directories may have arbitrary property names and values attached to them, each revision as a whole may have arbitrary properties attached to it. The same constraints apply—human-readable names and anything-you-want binary values. The main difference is that revision properties are not versioned. In other words, if you change the value of, or delete, a revision property, there's no way within the scope of Subversion's functionality to recover the previous value."
msgstr "Subversion的属性也可以在别的地方出现，就像文件和目录可能附加有任意的属性名和值，每个修订版本作为一个整体也可以附加任意的属性，也有同样的限制—可读的文本名称和任何你希望的，二进制值—除了修订版本不是版本化的，参见<xref linkend=\"svn.reposadmin.basics.revprops\"/>获得版本化的属性信息。"

#: build/en/book.xml:4310(para)
msgid "Subversion has no particular policy regarding the use of properties. It asks only that you not use property names that begin with the prefix <literal moreinfo=\"none\">svn:</literal>. That's the namespace that it sets aside for its own use. And Subversion does, in fact, use properties, both the versioned and unversioned variety. Certain versioned properties have special meaning or effects when found on files and directories, or house a particular bit of information about the revisions on which they are found. Certain revision properties are automatically attached to revisions by Subversion's commit process, and carry information about the revision. Most of these properties are mentioned elsewhere in this or other chapters as part of the more general topics to which they are related. For an exhaustive list of Subversion's pre-defined properties, see <xref linkend=\"svn.ref.properties\"/>."
msgstr ""

#: build/en/book.xml:4326(para)
msgid "In this section, we will examine the utility—both to users of Subversion, and to Subversion itself—of property support. You'll learn about the property-related <command moreinfo=\"none\">svn</command> subcommands, and how property modifications affect your normal Subversion workflow. Hopefully, you'll be convinced that Subversion properties can enhance your version control experience."
msgstr "在本小节，我们将会检验这个工具—不仅是对Subversion的用户，也对Subversion本身—对于属性的支持。你会学到与属性相关的<command moreinfo=\"none\">svn</command>子命令，和属性怎样影响你的普通Subversion工作流，希望你会感到Subversion的属性可以提高你的版本控制体验。"

#: build/en/book.xml:4336(title)
msgid "Why Properties?"
msgstr "为什么需要属性？"

#: build/en/book.xml:4338(para)
msgid "Just as Subversion uses properties to store extra information about the files, directories, and revisions that it contains, you might also find properties to be of similar use. Some part of the processes around Subversion's usage to which you adhere, or maybe some additional tooling around Subversion that you use, might find utility in having a place close to your versioned data to hang custom metadata about that data."
msgstr ""

#: build/en/book.xml:4347(para)
msgid "Say you wish to design a website that houses many digital photos, and displays them with captions and a datestamp. Now, your set of photos is constantly changing, so you'd like to have as much of this site automated as possible. These photos can be quite large, so as is common with sites of this nature, you want to provide smaller thumbnail images to your site visitors."
msgstr ""

#: build/en/book.xml:4355(para)
#, fuzzy
msgid "Now, you can get this functionality using traditional files. That is, you can have your <filename moreinfo=\"none\">image123.jpg</filename> and an <filename moreinfo=\"none\">image123-thumbnail.jpg</filename> side-by-side in a directory. Or if you want to keep the filenames the same, you might have your thumbnails in a different directory, like <filename moreinfo=\"none\">thumbnails/image123.jpg</filename>. You can also store your captions and datestamps in a similar fashion, again separated from the original image file. But the problem here is that your collection of files grows in multiples with each new photo added to the site."
msgstr "假定你希望设计一个网站存放许多数码图片，并且显示他们的标题和时间戳，现在你的图片集经常修改，所以你希望你的网站能够尽量的自动化，这些图片可能非常大，所以根据这个网站的特性，你希望在网站给用户提供图标图像。你可以用传统的文件做这件事，你可以有一个<filename moreinfo=\"none\">image123.jpg</filename>和一个<filename moreinfo=\"none\">image123-thumbnail.jpg</filename>对应在同一个目录，有时候你希望保持文件名相同，你可以使用不同的目录，如<filename moreinfo=\"none\">thumbnails/image123.jpg</filename>。你可以用一种相似的样式来保存你的标题和时间戳同原始图像文件分开。很快你的目录树会是一团糟，每个新图片的添加都会成倍的增加混乱。"

#: build/en/book.xml:4367(para)
#, fuzzy
msgid "Now consider the same website deployed in a way that makes use of Subversion's file properties. Imagine having a single image file, <filename moreinfo=\"none\">image123.jpg</filename>, and then properties set on that file named <literal moreinfo=\"none\">caption</literal>, <literal moreinfo=\"none\">datestamp</literal>, and even <literal moreinfo=\"none\">thumbnail</literal>. Now your working copy directory looks much more manageable—in fact, it looks to the casual browser like there are nothing but image files in it. But your automation scripts know better. They know that they can use <command moreinfo=\"none\">svn</command> (or better yet, they can use the Subversion language bindings—see <xref linkend=\"svn.developer.usingapi.otherlangs\"/>) to dig out the extra information that your site needs to display without having to read an index file or play path manipulation games."
msgstr "现在考虑使用Subversion文件的属性来做相同的设置，想象我们有一个单独的图像文件<filename moreinfo=\"none\">image123.jpg</filename>，然后这个文件的属性集包括<literal moreinfo=\"none\">caption</literal>、<literal moreinfo=\"none\">datestamp</literal>甚至<literal moreinfo=\"none\">thumbnail</literal>。现在你的工作拷贝目录看起来更容易管理—实际上，它看起来只有图像文件，但是你的自动化脚本知道得更多，它们知道可以用<command moreinfo=\"none\">svn</command>（更好的选择是使用Subversion的语言绑定—见<xref linkend=\"svn.developer.usingapi.otherlangs\"/>）来挖掘更多的站点显示需要的额外信息，而不必去阅读一个索引文件或者是玩一个路径处理的游戏。"

#: build/en/book.xml:4382(para)
msgid "Custom revision properties are also frequently used. One common such use is a property whose value contains an issue tracker ID with which the revision is associated, perhaps because the change made in that revision fixes a bug filed in the tracker issue with that ID. Other uses include hanging more friendly names on the revision—it might be hard to remember that revision 1935 was a fully tested revision. But if there's, say, a <literal moreinfo=\"none\">test-results</literal> property on that revision with a value <literal moreinfo=\"none\">all passing</literal>, that's meaningful information to have."
msgstr ""

#: build/en/book.xml:4394(title)
msgid "Searchability (or, Why <emphasis>Not</emphasis> Properties)"
msgstr "可搜索性(或者，为什么<emphasis>不</emphasis>使用属性)"

#: build/en/book.xml:4397(para)
msgid "For all their utility, Subversion properties—or, more accurately, the available interfaces to them—have a major shortcoming which diminishes their practicality. While it is a simple matter to set a custom property, <emphasis>finding</emphasis> that property later is whole different ball of wax."
msgstr ""

#: build/en/book.xml:4404(para)
msgid "Trying to locate a custom revision property generally involves performing a linear walk across all the revisions of the repository, asking of each revision, \"Do you have the property I'm looking for?\" Trying to find a custom versioned property is painful, too, and often involves a recursive <command moreinfo=\"none\">svn propget</command> across an entire working copy. In your situation, that might not be as bad as a linear walk across all revisions. But it certainly leaves much to be desired in terms of both performance and likelihood of success, especially if the scope of your search would require a working copy from the root of your repository."
msgstr ""

#: build/en/book.xml:4417(para)
msgid "For this reason, you might choose—especially in the revision property use-case—to simply add your metadata to the revision's log message, using some policy-driven (and perhaps programmatically-enforced) formatting that is designed to be quickly parsed from the output of <command moreinfo=\"none\">svn log</command>. It is quite common to see in Subversion log messages the likes of:"
msgstr ""

#: build/en/book.xml:4425(programlisting)
#, no-wrap
msgid ""
"\n"
"Issue(s): IZ2376, IZ1919\n"
"Reviewed by:  sally\n"
"\n"
"This fixes a nasty segfault in the wort frabbing process\n"
"…\n"
msgstr ""
"\n"
"Issue(s): IZ2376, IZ1919\n"
"Reviewed by:  sally\n"
"\n"
"This fixes a nasty segfault in the wort frabbing process\n"
"…\n"

#: build/en/book.xml:4433(para)
msgid "But here again lies some misfortune. Subversion doesn't yet provide a log message templating mechanism, which would go a long way toward helping users be consistent with the formatting of their log-embedded revision metadata."
msgstr ""

#: build/en/book.xml:4444(title)
msgid "Manipulating Properties"
msgstr "操作属性"

#: build/en/book.xml:4446(para)
msgid "The <command moreinfo=\"none\">svn</command> command affords a few ways to add or modify file and directory properties. For properties with short, human-readable values, perhaps the simplest way to add a new property is to specify the property name and value on the command-line of the <command moreinfo=\"none\">propset</command> subcommand."
msgstr "<command moreinfo=\"none\">svn</command>命令提供一些方法来添加和修改文件或目录的属性，对于短的，可读的属性，最简单的添加方法是在<command moreinfo=\"none\">propset</command>子命令里指定正确的名称和值。"

#: build/en/book.xml:4453(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propset copyright '(c) 2006 Red-Bean Software' calc/button.c\n"
"property 'copyright' set on 'calc/button.c'\n"
"$\n"
msgstr ""
"\n"
"$ svn propset copyright '(c) 2006 Red-Bean Software' calc/button.c\n"
"property 'copyright' set on 'calc/button.c'\n"
"$\n"

#: build/en/book.xml:4459(para)
#, fuzzy
msgid "But we've been touting the flexibility that Subversion offers for your property values. And if you are planning to have a multi-line textual, or even binary, property value, you probably do not want to supply that value on the command-line. So the <command moreinfo=\"none\">propset</command> subcommand takes a <option>--file (-F)</option> option for specifying the name of a file which contains the new property value."
msgstr "But we've been touting the flexibility that Subversion offers for your property values. And if you are planning to have a multi-line textual, or even binary, property value, you probably do not want to supply that value on the command-line. So the <command moreinfo=\"none\">propset</command> subcommand takes a <option>--file</option> (<option>-F</option>) option for specifying the name of a file which contains the new property value."

#: build/en/book.xml:4467(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propset license -F /path/to/LICENSE calc/button.c\n"
"property 'license' set on 'calc/button.c'\n"
"$\n"
msgstr ""
"\n"
"$ svn propset license -F /path/to/LICENSE calc/button.c\n"
"property 'license' set on 'calc/button.c'\n"
"$\n"

#: build/en/book.xml:4480(para)
msgid "If you're familiar with XML, this is pretty much the ASCII subset of the syntax for XML \"Name\"."
msgstr "如果你熟悉XML，其实这就是XML的\"Name\"语法的ASCII子集。"

#: build/en/book.xml:4473(para)
#, fuzzy
msgid "There are some restrictions on the names you can use for properties. A property name must start with a letter, a colon (<literal moreinfo=\"none\">:</literal>), or an underscore (<literal moreinfo=\"none\">_</literal>); after that, you can also use digits, hyphens (<literal moreinfo=\"none\">-</literal>), and periods (<literal moreinfo=\"none\">.</literal>). <placeholder-1/>"
msgstr "对于属性名称也有一些限制，属性名必须以一个字符、一个冒号(<literal moreinfo=\"none\">:</literal>)或下划线(<literal moreinfo=\"none\">_</literal>)开始，之后你可以使用数字，横线(<literal moreinfo=\"none\">-</literal>)和句号(<literal moreinfo=\"none\">.</literal>)。 <footnote><placeholder-1/></footnote>"

#: build/en/book.xml:4485(para)
msgid "In addition to the <command moreinfo=\"none\">propset</command> command, the <command moreinfo=\"none\">svn</command> program supplies the <command moreinfo=\"none\">propedit</command> command. This command uses the configured editor program (see <xref linkend=\"svn.advanced.confarea.opts.config\"/>) to add or modify properties. When you run the command, <command moreinfo=\"none\">svn</command> invokes your editor program on a temporary file that contains the current value of the property (or which is empty, if you are adding a new property). Then, you just modify that value in your editor program until it represents the new value you wish to store for the property, save the temporary file, and then exit the editor program. If Subversion detects that you've actually changed the existing value of the property, it will accept that as the new property value. If you exit your editor without making any changes, no property modification will occur."
msgstr "作为<command moreinfo=\"none\">propset</command>命令的补充，<command moreinfo=\"none\">svn</command>提供了一个<command moreinfo=\"none\">propedit</command>命令，这个命令使用定制的编辑器程序（见<xref linkend=\"svn.advanced.confarea.opts.config\"/>）来添加和修改属性。当你运行这个命令，<command moreinfo=\"none\">svn</command>调用你的编辑器程序打开一个临时文件，文件中保存当前的属性值（或者是空文件，如果你正在添加新的属性）。然后你只需要修改为你想要的值，保存临时文件，然后离开编辑器程序。如果Subversion发现你已经修改了属性值，就会接受新值，如果你未作任何修改而离开，不会产生属性修改操作。"

#: build/en/book.xml:4501(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propedit copyright calc/button.c  ### exit the editor without changes\n"
"No changes to property 'copyright' on 'calc/button.c'\n"
"$\n"
msgstr ""
"\n"
"$ svn propedit copyright calc/button.c  ### exit the editor without changes\n"
"No changes to property 'copyright' on 'calc/button.c'\n"
"$\n"

#: build/en/book.xml:4507(para)
msgid "We should note that, as with other <command moreinfo=\"none\">svn</command> subcommands, those related to properties can act on multiple paths at once. This enables you to modify properties on whole sets of files with a single command. For example, we could have done:"
msgstr "我们也应该注意导，像其它<command moreinfo=\"none\">svn</command>子命令一样，这些关联的属性可以一次添加到多个路径上，这样就可以通过一个命令修改一组文件的属性。举个例子，我们可以："

#: build/en/book.xml:4513(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propset copyright '(c) 2006 Red-Bean Software' calc/*\n"
"property 'copyright' set on 'calc/Makefile'\n"
"property 'copyright' set on 'calc/button.c'\n"
"property 'copyright' set on 'calc/integer.c'\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svn propset copyright '(c) 2006 Red-Bean Software' calc/*\n"
"property 'copyright' set on 'calc/Makefile'\n"
"property 'copyright' set on 'calc/button.c'\n"
"property 'copyright' set on 'calc/integer.c'\n"
"…\n"
"$\n"

#: build/en/book.xml:4522(para)
msgid "All of this property adding and editing isn't really very useful if you can't easily get the stored property value. So the <command moreinfo=\"none\">svn</command> program supplies two subcommands for displaying the names and values of properties stored on files and directories. The <command moreinfo=\"none\">svn proplist</command> command will list the names of properties that exist on a path. Once you know the names of the properties on the node, you can request their values individually using <command moreinfo=\"none\">svn propget</command>. This command will, given a path (or set of paths) and a property name, print the value of the property to the standard output stream."
msgstr "如果不能方便的得到存储的属性值，那么属性的添加和编辑操作也不会很容易，所以<command moreinfo=\"none\">svn</command>提供了两个子命令来显示文件和目录存储的属性名和值。<command moreinfo=\"none\">svn proplist</command>命令会列出路径上存在的所有属性名称，一旦你知道了某个节点的属性名称，你可以用<command moreinfo=\"none\">svn propget</command>获取它的值，这个命令获取给定的路径（或者是一组路径）和属性名称，打印这个属性的值到标准输出。"

#: build/en/book.xml:4534(screen)
#, no-wrap
msgid ""
"\n"
"$ svn proplist calc/button.c\n"
"Properties on 'calc/button.c':\n"
"  copyright\n"
"  license\n"
"$ svn propget copyright calc/button.c\n"
"(c) 2006 Red-Bean Software\n"
msgstr ""
"\n"
"$ svn proplist calc/button.c\n"
"Properties on 'calc/button.c':\n"
"  copyright\n"
"  license\n"
"$ svn propget copyright calc/button.c\n"
"(c) 2006 Red-Bean Software\n"

#: build/en/book.xml:4543(para)
msgid "There's even a variation of the <command moreinfo=\"none\">proplist</command> command that will list both the name and value of all of the properties. Simply supply the <option>--verbose</option> (<option>-v</option>) option."
msgstr "还有一个<command moreinfo=\"none\">proplist</command>变种命令会列出所有属性的名称和值，只需要设置<option>--verbose</option>（<option>-v</option>）选项。"

#: build/en/book.xml:4548(screen)
#, no-wrap
msgid ""
"\n"
"$ svn proplist -v calc/button.c\n"
"Properties on 'calc/button.c':\n"
"  copyright : (c) 2006 Red-Bean Software\n"
"  license : ================================================================\n"
"Copyright (c) 2006 Red-Bean Software.  All rights reserved.\n"
"\n"
"Redistribution and use in source and binary forms, with or without\n"
"modification, are permitted provided that the following conditions \n"
"are met:\n"
"\n"
"1. Redistributions of source code must retain the above copyright\n"
"notice, this list of conditions, and the recipe for Fitz's famous\n"
"red-beans-and-rice.\n"
"…\n"
msgstr ""
"\n"
"$ svn proplist -v calc/button.c\n"
"Properties on 'calc/button.c':\n"
"  copyright : (c) 2006 Red-Bean Software\n"
"  license : ================================================================\n"
"Copyright (c) 2006 Red-Bean Software.  All rights reserved.\n"
"\n"
"Redistribution and use in source and binary forms, with or without\n"
"modification, are permitted provided that the following conditions \n"
"are met:\n"
"\n"
"1. Redistributions of source code must retain the above copyright\n"
"notice, this list of conditions, and the recipe for Fitz's famous\n"
"red-beans-and-rice.\n"
"…\n"

#: build/en/book.xml:4565(para)
msgid "The last property-related subcommand is <command moreinfo=\"none\">propdel</command>. Since Subversion allows you to store properties with empty values, you can't remove a property altogether using <command moreinfo=\"none\">propedit</command> or <command moreinfo=\"none\">propset</command>. For example, this command will <emphasis>not</emphasis> yield the desired effect:"
msgstr "最后一个与属性相关的子命令是<command moreinfo=\"none\">propdel</command>，因为Subversion允许属性值为空，所有不能用<command moreinfo=\"none\">propedit</command>或者<command moreinfo=\"none\">propset</command>命令删除一个属性。举个例子，这个命令<emphasis>不会</emphasis>产生预期的效果："

#: build/en/book.xml:4572(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propset license '' calc/button.c\n"
"property 'license' set on 'calc/button.c'\n"
"$ svn proplist -v calc/button.c\n"
"Properties on 'calc/button.c':\n"
"  copyright : (c) 2006 Red-Bean Software\n"
"  license : \n"
"$\n"
msgstr ""
"\n"
"$ svn propset license '' calc/button.c\n"
"property 'license' set on 'calc/button.c'\n"
"$ svn proplist -v calc/button.c\n"
"Properties on 'calc/button.c':\n"
"  copyright : (c) 2006 Red-Bean Software\n"
"  license : \n"
"$\n"

#: build/en/book.xml:4582(para)
#, fuzzy
msgid "You need to use the <command moreinfo=\"none\">propdel</command> subcommand to delete properties altogether. The syntax is similar to the other property commands:"
msgstr "你需要用<command moreinfo=\"none\">propdel</command>来删除属性，语法与其它与属性相关命令相似："

#: build/en/book.xml:4586(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propdel license calc/button.c\n"
"property 'license' deleted from 'calc/button.c'.\n"
"$ svn proplist -v calc/button.c\n"
"Properties on 'calc/button.c':\n"
"  copyright : (c) 2006 Red-Bean Software\n"
"$\n"
msgstr ""
"\n"
"$ svn propdel license calc/button.c\n"
"property 'license' deleted from 'calc/button.c'.\n"
"$ svn proplist -v calc/button.c\n"
"Properties on 'calc/button.c':\n"
"  copyright : (c) 2006 Red-Bean Software\n"
"$\n"

#: build/en/book.xml:4609(para)
msgid "Fixing spelling errors, grammatical gotchas, and <quote>just-plain-wrongness</quote> in commit log messages is perhaps the most common use case for the <option>--revprop</option> option."
msgstr "修正提交日志信息的拼写错误，文法错误和<quote>简单的错误</quote>是<option>--revprop</option>选项最常见用例。"

#: build/en/book.xml:4595(para)
#, fuzzy
msgid "Remember those unversioned revision properties? You can modify those, too, using the same <command moreinfo=\"none\">svn</command> subcommands that we just described. Simply add the <option>--revprop</option> command-line parameter, and specify the revision whose property you wish to modify. Since revisions are global, you don't need to specify a target path to these property-related commands so long as you are positioned in a working copy of the repository whose revision property you wish to modify. Otherwise, you can simply provide the URL of any path in the repository of interest (including the repository's root URL). For example, you might want to replace the commit log message of an existing revision. <placeholder-1/> If your current working directory is part of a working copy of your repository, you can simply run the <command moreinfo=\"none\">svn propset</command> command with no target path:"
msgstr "还记的这些未版本化的属性？你也可以使用<command moreinfo=\"none\">svn</command>命令修改这些属性。只需要添加<option>--revprop</option>命令参数，并且说明希望修改属性的修订版本。因为修订版本是全局的，你不需要指定一个路径，只要你已经位于你希望修改属性的工作拷贝路径，举个例子，你希望修改一个存在版本的提交日志信息。 <footnote><placeholder-1/></footnote>"

#: build/en/book.xml:4618(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop\n"
"property 'svn:log' set on repository revision '11'\n"
"$\n"
msgstr ""
"\n"
"$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop\n"
"property 'svn:log' set on repository revision '11'\n"
"$\n"

#: build/en/book.xml:4624(para)
msgid "But even if you haven't checked out a working copy from that repository, you can still affect the property change by providing the repository's root URL:"
msgstr ""

#: build/en/book.xml:4628(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop \\\n"
"              http://svn.example.com/repos/project\n"
"property 'svn:log' set on repository revision '11'\n"
"$\n"
msgstr ""
"\n"
"$ svn propset svn:log '* button.c: Fix a compiler warning.' -r11 --revprop \\\n"
"              http://svn.example.com/repos/project\n"
"property 'svn:log' set on repository revision '11'\n"
"$\n"

#: build/en/book.xml:4635(para)
msgid "Note that the ability to modify these unversioned properties must be explicitly added by the repository administrator (see <xref linkend=\"svn.reposadmin.create.hooks\"/>). Since the properties aren't versioned, you run the risk of losing information if you aren't careful with your edits. The repository administrator can setup methods to protect against this loss, and by default, modification of unversioned properties is disabled."
msgstr "注意，修改这些未版本化的属性的能力一定要明确的添加给版本库管理员（见<xref linkend=\"svn.reposadmin.create.hooks\"/>）。因为属性没有版本化，如果编辑的时候不小心，就会冒丢失信息的风险，版本库管理员可以设置方法来防范这种意外，缺省情况下，修改未版本化的属性是禁止的。"

#: build/en/book.xml:4645(para)
msgid "Users should, where possible, use <command moreinfo=\"none\">svn propedit</command> instead of <command moreinfo=\"none\">svn propset</command>. While the end result of the commands is identical, the former will allow them to see the current value of the property they are about to change, which helps them to verify that they are, in fact, making the change they think they are making. This is especially true when modifying unversioned revision properties. Also, it is significantly easier to modify multiline property values in a text editor than at the command line."
msgstr ""

#: build/en/book.xml:4661(title)
msgid "Properties and the Subversion Workflow"
msgstr "属性和 Subversion 工作流程"

#: build/en/book.xml:4663(para)
msgid "Now that you are familiar with all of the property-related <command moreinfo=\"none\">svn</command> subcommands, let's see how property modifications affect the usual Subversion workflow. As we mentioned earlier, file and directory properties are versioned, just like your file contents. As a result, Subversion provides the same opportunities for merging—in cleanly or conflicting fashions—someone else's modifications into your own."
msgstr "现在你已经熟悉了所有与属性相关的<command moreinfo=\"none\">svn</command>子命令，让我们看看属性修改如何影响Subversion的工作流。我们前面提到过，文件和目录的属性是版本化的，这一点类似于版本化的文件内容。后果之一，就是Subversion具有了同样的机制来合并—用干净或者冲突的方式—其他人的修改应用到你的修改。"

#: build/en/book.xml:4672(para)
msgid "And as with file contents, your property changes are local modifications, only made permanent when you commit them to the repository with <command moreinfo=\"none\">svn commit</command>. Your property changes can be easily unmade, too—the <command moreinfo=\"none\">svn revert</command> command will restore your files and directories to their un-edited states, contents, properties, and all. Also, you can receive interesting information about the state of your file and directory properties by using the <command moreinfo=\"none\">svn status</command> and <command moreinfo=\"none\">svn diff</command> commands."
msgstr "就像文件内容，你的属性修改是本地修改，只有使用<command moreinfo=\"none\">svn commit</command>命令提交后才会保存到版本库中，属性修改也可以很容易的取消—<command moreinfo=\"none\">svn revert</command>命令会恢复你的文件和目录为编辑前状态，包括内容、属性和其它的信息。另外，你可以使用<command moreinfo=\"none\">svn status</command>和<command moreinfo=\"none\">svn diff</command>接受感兴趣的文件和目录属性的状态信息。"

#: build/en/book.xml:4683(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status calc/button.c\n"
" M     calc/button.c\n"
"$ svn diff calc/button.c\n"
"Property changes on: calc/button.c\n"
"___________________________________________________________________\n"
"Name: copyright\n"
"   + (c) 2006 Red-Bean Software\n"
"\n"
"$\n"
msgstr ""
"\n"
"$ svn status calc/button.c\n"
" M     calc/button.c\n"
"$ svn diff calc/button.c\n"
"Property changes on: calc/button.c\n"
"___________________________________________________________________\n"
"Name: copyright\n"
"   + (c) 2006 Red-Bean Software\n"
"\n"
"$\n"

#: build/en/book.xml:4695(para)
msgid "Notice how the <command moreinfo=\"none\">status</command> subcommand displays <literal moreinfo=\"none\">M</literal> in the second column instead of the first. That is because we have modified the properties on <filename moreinfo=\"none\">calc/button.c</filename>, but not modified its textual contents. Had we changed both, we would have seen <literal moreinfo=\"none\">M</literal> in the first column, too (see <xref linkend=\"svn.tour.cycle.examine.status\"/>)."
msgstr "注意<command moreinfo=\"none\">status</command>子命令显示的<literal moreinfo=\"none\">M</literal>在第二列而不是在第一列，这是因为我们修改了<filename moreinfo=\"none\">calc/button.c</filename>的属性，而不是它的文本内容，如果我们都修改了，我们也会看到<literal moreinfo=\"none\">M</literal>出现在第一列（见<xref linkend=\"svn.tour.cycle.examine.status\"/>）。"

#: build/en/book.xml:4703(title)
msgid "Property Conflicts"
msgstr "属性冲突"

#: build/en/book.xml:4705(para)
#, fuzzy
msgid "As with file contents, local property modifications can conflict with changes committed by someone else. If you update your working copy directory and receive property changes on a versioned object that clash with your own, Subversion will report that the object is in a conflicted state."
msgstr "与文件内容一样，本地的属性修改也会同别人的提交冲突，如果你更新你的工作拷贝目录并且接收到有资源属性修改与你的修改冲突，Subversion会报告资源处于冲突状态。"

#: build/en/book.xml:4712(screen)
#, no-wrap
msgid ""
"\n"
"% svn update calc\n"
"M  calc/Makefile.in\n"
" C calc/button.c\n"
"Updated to revision 143.\n"
"$ \n"
msgstr ""
"\n"
"% svn update calc\n"
"M  calc/Makefile.in\n"
" C calc/button.c\n"
"Updated to revision 143.\n"
"$ \n"

#: build/en/book.xml:4720(para)
#, fuzzy
msgid "Subversion will also create, in the same directory as the conflicted object, a file with a <filename moreinfo=\"none\">.prej</filename> extension which contains the details of the conflict. You should examine the contents of this file so you can decide how to resolve the conflict. Until the conflict is resolved, you will see a <literal moreinfo=\"none\">C</literal> in the second column of <command moreinfo=\"none\">svn status</command> output for that object, and attempts to commit your local modifications will fail."
msgstr "Subversion也会在冲突资源的同一个目录创建一个<filename moreinfo=\"none\">.prej</filename>扩展名的文件，保存冲突的细节。你一定要检查这个文件的内容来决定如何解决冲突，在你解决冲突之前，你会在使用<command moreinfo=\"none\">svn status</command>时看到这个资源的输出的第二列是一个<literal moreinfo=\"none\">C</literal>，提交本地修改的尝试会失败。"

#: build/en/book.xml:4730(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status calc\n"
" C     calc/button.c\n"
"?      calc/button.c.prej\n"
"$ cat calc/button.c.prej \n"
"prop 'linecount': user set to '1256', but update set to '1301'.\n"
"$\n"
msgstr ""
"\n"
"$ svn status calc\n"
" C     calc/button.c\n"
"?      calc/button.c.prej\n"
"$ cat calc/button.c.prej \n"
"prop 'linecount': user set to '1256', but update set to '1301'.\n"
"$\n"

#: build/en/book.xml:4739(para)
msgid "To resolve property conflicts, simply ensure that the conflicting properties contain the values that they should, and then use the <command moreinfo=\"none\">svn resolved</command> command to alert Subversion that you have manually resolved the problem."
msgstr "为了解决属性冲突，只需要确定冲突的属性保存了它们应该的值，然后使用<command moreinfo=\"none\">svn resolved</command>命令告诉Subversion你已经手工解决了问题。"

#: build/en/book.xml:4747(para)
msgid "You might also have noticed the non-standard way that Subversion currently displays property differences. You can still run <command moreinfo=\"none\">svn diff</command> and redirect the output to create a usable patch file. The <command moreinfo=\"none\">patch</command> program will ignore property patches—as a rule, it ignores any noise it can't understand. This does unfortunately mean that to fully apply a patch generated by <command moreinfo=\"none\">svn diff</command>, any property modifications will need to be applied by hand."
msgstr "你也许已经注意到了Subversion在显示属性时的非标准方式。你还可以运行<command moreinfo=\"none\">svn diff</command>并且重定向输出来产生一个有用的补丁文件，<command moreinfo=\"none\">patch</command>程序会忽略属性补丁—作为规则，它会忽略任何不理解的噪音。很遗憾，这意味着完全应用<command moreinfo=\"none\">svn diff</command>产生的补丁时，任何属性修改必须手工实施。"

#: build/en/book.xml:4761(title)
msgid "Automatic Property Setting"
msgstr "自动设置属性"

#: build/en/book.xml:4763(para)
msgid "Properties are a powerful feature of Subversion, acting as key components of many Subversion features discussed elsewhere in this and other chapters—textual diff and merge support, keyword substitution, newline translation, etc. But to get the full benefit of properties, they must be set on the right files and directories. Unfortunately, that can be a step easily forgotten in the routine of things, especially since failing to set a property doesn't usually result in an obvious error condition (at least compared to, say, failing to add a file to version control). To help your properties get applied to the places that need them, Subversion provides a couple of simple but useful features."
msgstr "属性是Subversion一个强大的特性，成为本章和其它章讨论的许多Subversion特性的关键组成部分—文本区别和合并支持、关键字替换、新行的自动转换等等。但是为了从属性得到完全的利益，他们必须设置到正确的文件和目录。不幸的是，在日常工作中很容易忘记这一步工作，特别是当没有设置属性不会引起明显的错误时（至少相对与未能添加一个文件到版本控制这种操作），为了帮助你在需要添加属性的文件上添加属性，Subversion提供了一些简单但是有用的特性。"

#: build/en/book.xml:4776(para)
#, fuzzy
msgid "Whenever you introduce a file to version control using the <command moreinfo=\"none\">svn add</command> or <command moreinfo=\"none\">svn import</command> commands, Subversion tries to assist by setting some common file properties automatically. First, on operating systems whose filesystems support an execute permission bit, Subversion will automatically set the <literal moreinfo=\"none\">svn:executable</literal> property on newly added or imported files whose execute bit is enabled. (See <xref linkend=\"svn.advanced.props.special.executable\"/> for more about this property.) Secondly, it runs a very basic heuristic to determine if that file contains human-readable content. If not, Subversion will automatically set the <literal moreinfo=\"none\">svn:mime-type</literal> property on that file to <literal moreinfo=\"none\">application/octet-stream</literal> (the generic <quote>this is a collection of bytes</quote> MIME type). Of course, if Subversion guesses incorrectly, or if you wish to set the <literal moreinfo=\"none\">svn:mime-type</literal> property to something more precise—perhaps <literal moreinfo=\"none\">image/png</literal> or <literal moreinfo=\"none\">application/x-shockwave-flash</literal>—you can always remove or edit that property. (For more on Subversion's use of MIME types, see <xref linkend=\"svn.advanced.props.special.mime-type\"/>.)"
msgstr "当你使用<command moreinfo=\"none\">svn add</command>或是<command moreinfo=\"none\">svn import</command>准备加入一个版本控制的文件时，Subversion会运行一个基本探测来检查文件是包括了可读还是不可读的内容，如果Subversion猜测错误，或者是你希望使用<literal moreinfo=\"none\">svn:mime-type</literal>属性更精确的设置—或许是<literal moreinfo=\"none\">image/png</literal>或者<literal moreinfo=\"none\">application/x-shockwave-flash</literal>—你可以一直删除或编辑那个属性。"

#: build/en/book.xml:4797(para)
#, fuzzy
msgid "Subversion also provides, via its runtime configuration system (see <xref linkend=\"svn.advanced.confarea\"/>), a more flexible automatic property setting feature which allows you to create mappings of filename patterns to property names and values. Once again, these mappings affect adds and imports, and not only can override the default MIME type decision made by Subversion during those operations, but can also set additional Subversion or custom properties, too. For example, you might create a mapping that says that any time you add JPEG files—ones that match the pattern <literal moreinfo=\"none\">*.jpg</literal>—Subversion should automatically set the <literal moreinfo=\"none\">svn:mime-type</literal> property on those files to <literal moreinfo=\"none\">image/jpeg</literal>. Or perhaps any files that match <literal moreinfo=\"none\">*.cpp</literal> should have <literal moreinfo=\"none\">svn:eol-style</literal> set to <literal moreinfo=\"none\">native</literal>, and <literal moreinfo=\"none\">svn:keywords</literal> set to <literal moreinfo=\"none\">Id</literal>. Automatic property support is perhaps the handiest property related tool in the Subversion toolbox. See <xref linkend=\"svn.advanced.confarea.opts.config\"/> for more about configuring that support."
msgstr "Subversion也提供了自动属性特性，允许你创建文件名到属性名称与值影射，这个影射在你的运行配置区域设置，它们会影响添加和导入操作，而且不仅仅会覆盖Subversion所有缺省的MIME类型判断操作，也会设置额外的Subversion或者自定义的属性。举个例子，你会创建一个影射文件说在任何时候你添加了一个JPEG文件—一些符合<literal moreinfo=\"none\">*.jpg</literal>的文件—Subversion一定会自动设置它们的<literal moreinfo=\"none\">svn:mime-type</literal>属性为<literal moreinfo=\"none\">image/jpeg</literal>。或者是任何匹配<literal moreinfo=\"none\">*.cpp</literal>的文件，必须把<literal moreinfo=\"none\">svn:eol-style</literal>设置为<literal moreinfo=\"none\">native</literal>，并且<literal moreinfo=\"none\">svn:keywords</literal>设置为<literal moreinfo=\"none\">Id</literal>。自动属性支持是Subversion工具箱中属性相关最垂手可得的工具，见<xref linkend=\"svn.advanced.confarea.opts.config\"/>来查看更多的配置支持。"

#: build/en/book.xml:4825(title)
msgid "File Portability"
msgstr "文件移植性"

#: build/en/book.xml:4827(para)
msgid "Fortunately for Subversion users who routinely find themselves on different computers with different operating systems, Subversion's command-line program behaves almost identically on all those systems. If you know how to wield <command moreinfo=\"none\">svn</command> on one platform, you know how to wield it everywhere."
msgstr ""

#: build/en/book.xml:4834(para)
msgid "However, the same is not always true of other general classes of software, or of the actual files you keep in Subversion. For example, on a Windows machine, the definition of a <quote>text file</quote> would be similar to that used on a Linux box, but with a key difference—the character sequences used to mark the ends of the lines of those files. There are other differences, too. Unix platforms have (and Subversion supports) symbolic links; Windows does not. Unix platforms use filesystem permission to determine executability; Windows uses filename extensions."
msgstr ""

#: build/en/book.xml:4845(para)
msgid "Because Subversion is in no position to unite the whole world in common definitions and implementations of all of these things, the best it can do is to try to help make your life simpler when you need to work with your versioned files and directories on multiple computers and operating systems. This section describes some of the ways Subversion does this."
msgstr ""

#: build/en/book.xml:4854(title)
msgid "File Content Type"
msgstr "文件内容类型"

#: build/en/book.xml:4856(para)
#, fuzzy
msgid "Subversion joins the ranks of the many applications which recognize and make use of Multipurpose Internet Mail Extensions (MIME) content types. Besides being a general-purpose storage location for a file's content type, the value of the <literal moreinfo=\"none\">svn:mime-type</literal> file property determines some behavioral characteristics of Subversion itself."
msgstr "<literal moreinfo=\"none\">svn:mime-type</literal>属性为Subversion的许多目的服务，除了保存一个文件的多用途网际邮件扩展（MIME）分类以外，这个属性值也描述了一些Subversion自己使用的行为特性。"

#: build/en/book.xml:4865(title)
msgid "Identifying File Types"
msgstr "识别文件类型"

#: build/en/book.xml:4867(para)
msgid "Software programs on most modern operating systems make assumptions about the type and format of the contents of a file by the file's name, specifically its file extension. For example, files whose names end in <filename moreinfo=\"none\">.txt</filename> are generally assumed to be human-readable, able to be understood by simple perusal rather than requiring complex processing to decipher. Files whose names end in <filename moreinfo=\"none\">.png</filename>, on the other hand, are assumed to be of the Portable Network Graphics type—not human-readable at all, and sensible only when interpreted by software which understands the PNG format and can render the information in that format as a raster image."
msgstr ""

#: build/en/book.xml:4894(para)
msgid "You think that was rough? During that same era, WordPerfect also used <filename moreinfo=\"none\">.DOC</filename> for their proprietary file format's preferred extension!"
msgstr ""

#: build/en/book.xml:4881(para)
msgid "Unfortunately, some of those extensions have changed meanings over time. When personal computers first appeared, a file named <filename moreinfo=\"none\">README.DOC</filename> would have almost certainly been a plaintext file, just like today's <filename moreinfo=\"none\">.txt</filename> files. But by the mid-1990's, you could almost bet that a file of that name would not be a plaintext file at all, but instead a Microsoft Word document with a proprietary, non-human-readable format. But this change didn't occur overnight—there was certainly a period of confusion for computer users over what exactly they had in hand when they saw a <filename moreinfo=\"none\">.DOC</filename> file. <placeholder-1/>"
msgstr ""

#: build/en/book.xml:4900(para)
msgid "The popularity of computer networking cast still more doubt on the mapping between a file's name and its content. With information being served across networks and generated dynamically by server-side scripts, there was often no real file per se to speak of, and therefore no file name. Web servers, for example, needed some other way to tell browsers what they were downloading so the browser could do something intelligent with that information, whether that was to display the data using a program registered to handle that data type, or to prompt the user for where on the client machine to store the downloaded data."
msgstr ""

#: build/en/book.xml:4912(para)
msgid "Eventually, a standard emerged for, among other things, describing the contents of a data stream. In 1996, RFC2045 was published, the first of five RFCs describing MIME. In it, this RFC describes the concept of media types and subtypes, and recommends a syntax for the representation of those types. Today, MIME media types—or, MIME types— are used almost universally across e-mail applications, Web servers, and other software as the de facto mechanism for clearing up the file content confusion."
msgstr ""

#: build/en/book.xml:4925(para)
#, fuzzy
msgid "For example, one of the benefits that Subversion typically provides is contextual, line-based merging of changes received from the server during an update into your working file. But for files containing non-textual data, there is often no concept of a <quote>line</quote>. So, for versioned files whose <literal moreinfo=\"none\">svn:mime-type</literal> property is set to a non-textual MIME type (generally, something that doesn't begin with <literal moreinfo=\"none\">text/</literal>, though there are exceptions), Subversion does not attempt to perform contextual merges during updates. Instead, any time you have locally modified a binary working copy file that is also being updated, your file is renamed with a <filename moreinfo=\"none\">.orig</filename> extension, and then Subversion stores a new working copy file that contains the changes received during the update, but not your own local modifications, at the original filename. This behavior is really for the protection of the user against failed attempts at performing contextual merges on files that simply cannot be contextually merged."
msgstr "举个例子，如果一个文件<literal moreinfo=\"none\">svn:mime-type</literal>属性设置为非文本的MIME类型（通常是那些不是<literal moreinfo=\"none\">text/</literal>开头的类型，但也有例外），Subversion会假定这个文件保存了二进制内容—也就是不可读的—数据。一个好处就是Subversion通常在更新到工作拷贝时提供了一个前后相关的以行为基础的修改合并，但是对于保存二进制数据的文件，没有<quote>行</quote>的概念，所以对这些文件，Subversion不会在更新时尝试执行合并操作，相反，任何时候你在本地修改的一个二进制文件有了更新，你的文件会被重命名为<filename moreinfo=\"none\">.orig</filename>为扩展名，然后Subversion保存一个新的工作拷贝文件，保存更新时得到的修改，但原来的文件名已经不是你自己的本地修改。这个行为模式是用来保护用户在对不可文本合并的文件尝试执行文本的合并时失败的情形。"

#: build/en/book.xml:4944(para)
#, fuzzy
msgid "Also, if the <literal moreinfo=\"none\">svn:mime-type</literal> property is set, then the Subversion Apache module will use its value to populate the <literal moreinfo=\"none\">Content-type:</literal> HTTP header when responding to GET requests. This gives your web browser a crucial clue about how to display a file when using it to peruse your Subversion repository's contents."
msgstr "另外，如果<literal moreinfo=\"none\">svn:mime-type</literal>属性被设置，Subversion的Apache模块会使用这个值来在HTTP头里输入<literal moreinfo=\"none\">Content-type:</literal>，这给了web浏览器如何显示一个文件提供了至关重要的线索。"

#: build/en/book.xml:4955(title)
msgid "File Executability"
msgstr "文件可执行性"

#: build/en/book.xml:4957(para)
#, fuzzy
msgid "On many operating systems, the ability to execute a file as a command is governed by the presence of an execute permission bit. This bit usually defaults to being disabled, and must be explicitly enabled by the user for each file that needs it. But it would be a monumental hassle to have to remember exactly which files in freshly checked-out working copy were supposed to have their executable bits toggled on, and then to have to do that toggling. So, Subversion provides the <literal moreinfo=\"none\">svn:executable</literal> property as a way to specify that the executable bit for the file on which that property is set should be enabled, and Subversion honors that request when populating working copies with such files."
msgstr "在多数操作系统，执行一个文件或命令的能力是由执行位管理的，这些位通常是关闭的，必须由用户显式的指定，这意味着你必须改变文件的执行位，然后更新你的工作拷贝，燃火如果你的文件成为更新的一部分，它的执行位会被关闭，所以Subversion提供了<literal moreinfo=\"none\">svn:executable</literal>这个属性来保持打开执行位。"

#: build/en/book.xml:4974(para)
msgid "The Windows filesystems use file extensions (such as <literal moreinfo=\"none\">.EXE</literal>, <literal moreinfo=\"none\">.BAT</literal>, and <literal moreinfo=\"none\">.COM</literal>) to denote executable files."
msgstr "Windows文件系统使用文件扩展名（如<literal moreinfo=\"none\">.EXE</literal>、<literal moreinfo=\"none\">.BAT</literal>和<literal moreinfo=\"none\">.COM</literal>）来标示可执行文件。"

#: build/en/book.xml:4970(para)
#, fuzzy
msgid "This property has no effect on filesystems that have no concept of an executable permission bit, such as FAT32 and NTFS. <placeholder-1/> Also, although it has no defined values, Subversion will force its value to <literal moreinfo=\"none\">*</literal> when setting this property. Finally, this property is valid only on files, not on directories."
msgstr "这个属性对于没有可执行权限位的文件系统无效，如FAT32和NTFS。 <footnote><placeholder-1/></footnote> 也就是说，尽管它没有定义的值，在设置这个属性时，Subversion会强制它的值为<literal moreinfo=\"none\">*</literal>，最后，这个属性只对文件有效，目录无效。"

#: build/en/book.xml:4988(title)
msgid "End-of-Line Character Sequences"
msgstr "行结束字符序列"

#: build/en/book.xml:4990(para)
msgid "Unless otherwise noted using a versioned file's <literal moreinfo=\"none\">svn:mime-type</literal> property, Subversion assumes the file contains human-readable data. Generally speaking, Subversion only uses this knowledge to determine if contextual difference reports for that file are possible. Otherwise, to Subversion, bytes are bytes."
msgstr "不像我们说过的版本化文件的<literal moreinfo=\"none\">svn:mime-type</literal>属性，Subversion假定这个文件保存了可读的数据，一般来讲，Subversion因为这个属性来判断一个文件是否可以用上下文区别报告，否则，对Subversion来说只是字节。"

#: build/en/book.xml:4997(para)
#, fuzzy
msgid "This means that by default, Subversion doesn't pay any attention to the type of <firstterm>end-of-line (EOL) markers</firstterm> used in your files. Unfortunately, different operating systems have different conventions about which character sequences represent the end of a line of text in a file. For example, the usual line ending token used by software on the Windows platform is a pair of ASCII control characters—a carriage return (<literal moreinfo=\"none\">CR</literal>) followed by a line feed (<literal moreinfo=\"none\">LF</literal>). Unix software, however, just uses the <literal moreinfo=\"none\">LF</literal> character to denote the end of a line."
msgstr "这意味着缺省情况下，Subversion不会关注任何<firstterm>行结束标记（end-of-line，EOL）</firstterm>，不幸的是不同的操作系统在文本文件使用不同的行结束标志，举个例子，Windows平台下的A编辑工具使用一对SCII控制字符—回车（<literal moreinfo=\"none\">CR</literal>）和一个移行（<literal moreinfo=\"none\">LF</literal>）。Unix软件，只使用一个<literal moreinfo=\"none\">LF</literal>来表示一个行的结束。"

#: build/en/book.xml:5009(para)
msgid "Not all of the various tools on these operating systems are prepared to understand files that contain line endings in a format that differs from the <firstterm>native line ending style</firstterm> of the operating system on which they are running. Common results are that Unix programs treat the <literal moreinfo=\"none\">CR</literal> character present in Windows files as a regular character (usually rendered as <literal moreinfo=\"none\">^M</literal>), and that Windows programs combine all of the lines of a Unix file into one giant line because no carriage return-linefeed (or <literal moreinfo=\"none\">CRLF</literal>) character combination was found to denote the end of line."
msgstr "并不是所有操作系统的工具准备好了理解与<firstterm>本地行结束样式</firstterm>不一样的行结束格式，一个常见的结果是Unix程序会把Windows文件中的<literal moreinfo=\"none\">CR</literal>当作一个不同的字符（通常表现为<literal moreinfo=\"none\">^M</literal>），而Windows程序会把Unix文件合并为一个非常大的行，因为没有发现标志行结束的回车加换行（或者是<literal moreinfo=\"none\">CRLF</literal>）字符。"

#: build/en/book.xml:5022(para)
msgid "This sensitivity to foreign EOL markers can become frustrating for folks who share a file across different operating systems. For example, consider a source code file, and developers that edit this file on both Windows and Unix systems. If all the developers always use tools which preserve the line ending style of the file, no problems occur."
msgstr "对外来EOL标志的敏感会让在各个操作系统分享文件的人们感到沮丧，例如，考虑有一个源代码文件，开发者会在Windows和Unix系统上编辑这个文件，如果所有的用户使用的工具可以展示文件的行结束，那就没有问题。"

#: build/en/book.xml:5030(para)
msgid "But in practice, many common tools either fail to properly read a file with foreign EOL markers, or they convert the file's line endings to the native style when the file is saved. If the former is true for a developer, he has to use an external conversion utility (such as <command moreinfo=\"none\">dos2unix</command> or its companion, <command moreinfo=\"none\">unix2dos</command>) to prepare the file for editing. The latter case requires no extra preparation. But both cases result in a file that differs from the original quite literally on every line! Prior to committing his changes, the user has two choices. Either he can use a conversion utility to restore the modified file to the same line ending style that it was in before his edits were made. Or, he can simply commit the file—new EOL markers and all."
msgstr "但实践中，许多常用的工具不会正确的读取外来的EOL标志，或者是将文件的行结束转化为本地的样式，如果是前者，他需要一个外部的转化工具（如<command moreinfo=\"none\">dos2unix</command>或是他的伴侣，<command moreinfo=\"none\">unix2dos</command>）来准备需要编辑的文件。后一种情况不需要额外的准备工作，两种方法都会造成文件会与原来的文件在每一行上都不一样！在提交之前，用户有两个选择，或者选择用一个转化工具恢复文件的行结束样式，或者是简单的提交文件—包含新的EOL标志。"

#: build/en/book.xml:5046(para)
msgid "The result of scenarios like these include wasted time and unnecessary modifications to committed files. Wasted time is painful enough. But when commits change every line in a file, this complicates the job of determining which of those lines were changed in a non-trivial way. Where was that bug really fixed? On what line was a syntax error introduced?"
msgstr "这个情景的结局看起来像是要浪费时间对提交的文件作不必要的修改，浪费时间是痛苦的，但是如果提交修改了文件的每一行，判断那个文件是通过正常的方式修改的会是一件复杂的工作，bug在那一行修正的？那一行引入了语法错误？"

#: build/en/book.xml:5054(para)
msgid "The solution to this problem is the <literal moreinfo=\"none\">svn:eol-style</literal> property. When this property is set to a valid value, Subversion uses it to determine what special processing to perform on the file so that the file's line ending style isn't flip-flopping with every commit that comes from a different operating system. The valid values are:"
msgstr "这个问题的解决方案是<literal moreinfo=\"none\">svn:eol-style</literal>属性，当这个属性设置为一个正确的值，Subversion使用它来判断针对行结束样式执行何种特殊的操作，而不会因为多种操作系统的每次提交发生震荡。正确的值有："

#: build/en/book.xml:5064(literal)
msgid "native"
msgstr "native"

#: build/en/book.xml:5066(para)
msgid "This causes the file to contain the EOL markers that are native to the operating system on which Subversion was run. In other words, if a user on a Windows machine checks out a working copy that contains a file with an <literal moreinfo=\"none\">svn:eol-style</literal> property set to <literal moreinfo=\"none\">native</literal>, that file will contain <literal moreinfo=\"none\">CRLF</literal> EOL markers. A Unix user checking out a working copy which contains the same file will see <literal moreinfo=\"none\">LF</literal> EOL markers in his copy of the file."
msgstr "这会导致保存EOL标志的文件使用Subversion运行的操作系统的本地编码，换句话说，如果一个Windows用户取出一个工作拷贝包含的一个文件有<literal moreinfo=\"none\">svn:eol-style</literal>的属性设置为<literal moreinfo=\"none\">native</literal>，这个文件会使用<literal moreinfo=\"none\">CRLF</literal>的EOL标志，一个Unix用户取出相同的文件会看到他的文件使用<literal moreinfo=\"none\">LF</literal>的EOL标志。"

#: build/en/book.xml:5078(para)
msgid "Note that Subversion will actually store the file in the repository using normalized <literal moreinfo=\"none\">LF</literal> EOL markers regardless of the operating system. This is basically transparent to the user, though."
msgstr "注意Subversion实际上使用<literal moreinfo=\"none\">LF</literal>的EOL标志，而不会考略操作系统，尽管这对用户来说是透明的。"

#: build/en/book.xml:5086(literal)
msgid "CRLF"
msgstr "CRLF"

#: build/en/book.xml:5088(para)
msgid "This causes the file to contain <literal moreinfo=\"none\">CRLF</literal> sequences for EOL markers, regardless of the operating system in use."
msgstr "这会导致这个文件使用<literal moreinfo=\"none\">CRLF</literal>序列作为EOL标志，不管使用何种操作系统。"

#: build/en/book.xml:5094(literal)
msgid "LF"
msgstr "LF"

#: build/en/book.xml:5096(para)
msgid "This causes the file to contain <literal moreinfo=\"none\">LF</literal> characters for EOL markers, regardless of the operating system in use."
msgstr "这会导致文件使用<literal moreinfo=\"none\">LF</literal>字符作为EOL标志，不管使用何种操作系统。"

#: build/en/book.xml:5102(literal)
msgid "CR"
msgstr "CR"

#: build/en/book.xml:5104(para)
msgid "This causes the file to contain <literal moreinfo=\"none\">CR</literal> characters for EOL markers, regardless of the operating system in use. This line ending style is not very common. It was used on older Macintosh platforms (on which Subversion doesn't even run)."
msgstr "这会导致文件使用<literal moreinfo=\"none\">CR</literal>字符作为EOL标志，不管使用何种操作系统。这种行结束样式不是很常见，它用在一些老的苹果机（Subversion不会运行的机器上）。"

#: build/en/book.xml:5121(title)
msgid "Ignoring Unversioned Items"
msgstr "忽略未版本控制的项目"

#: build/en/book.xml:5123(para)
msgid "In any given working copy there is a good chance that alongside all those versioned files and directories are other files and directories which are neither versioned nor intended to be. Text editors litter directories with backup files. Code compilation processes generate intermediate—or even final—files which you typically wouldn't bother to version. And users themselves drop various other files and directories wherever they see fit, often in version control working copies."
msgstr ""

#: build/en/book.xml:5133(para)
msgid "It's ludicrous to expect Subversion working copies to be somehow impervious to this kind of clutter and impurity. In fact, Subversion counts it as a <emphasis>feature</emphasis> that its working copies are just typical directories, just like unversioned trees. But these not-to-be-versioned files and directories can cause some annoyance for Subversion users. For example, because the <command moreinfo=\"none\">svn add</command> and <command moreinfo=\"none\">svn import</command> commands act recursively by default, and don't know which files in a given tree you do and don't wish to version, it's easy to accidentally add stuff to version control that you didn't mean to. And because <command moreinfo=\"none\">svn status</command> reports, by default, every item of interest in a working copy—including unversioned files and directories—its output can get quite noisy where many of these things exist."
msgstr ""

#: build/en/book.xml:5149(para)
msgid "So Subversion provides two ways for telling it which files you would prefer that it simply disregard. One of the ways involves the use of Subversion's runtime configuration system (see <xref linkend=\"svn.advanced.confarea\"/>), and therefore applies to all the Subversion operations which make use of that runtime configuration, generally those performed on a particular computer, or by a particular user of a computer. The other way makes use of Subversion's directory property support, is more tightly bound to the versioned tree itself, and therefore affects everyone who has a working copy of that tree. Both of the mechanisms use file patterns."
msgstr ""

#: build/en/book.xml:5161(para)
msgid "The Subversion runtime configuration system provides an option, <literal moreinfo=\"none\">global-ignores</literal>, whose value is a whitespace-delimited collection of file patterns (or globs). These patterns are applied to files which are candidates for addition to version control, as well as to unversioned files which the <command moreinfo=\"none\">svn status</command> command notices. If the filenames match one of the patterns, Subversion will basically act as if the file didn't exist at all. This is really useful for file patterns which are nearly universally of the variety that you don't want to version, such as editor backup files like Emacs' <literal moreinfo=\"none\">*~</literal> and <literal moreinfo=\"none\">.*~</literal> files."
msgstr ""

#: build/en/book.xml:5174(para)
msgid "When found on a versioned directory, the <literal moreinfo=\"none\">svn:ignore</literal> property is expected to contain a list of newline-delimited file patterns which Subversion should use to determine ignorable objects in that same directory. These patterns do not override those found in the <literal moreinfo=\"none\">global-ignores</literal> runtime configuration option, but are instead appended to that list. And it's worth noting again that, unlike the <literal moreinfo=\"none\">global-ignores</literal> option, the patterns found in the <literal moreinfo=\"none\">svn:eol-ignore</literal> property apply only to the directory on which that property is set, and not to any of its subdirectories. The <literal moreinfo=\"none\">svn:ignore</literal> property is a good way to tell Subversion to ignore files that are likely to be present in every user's working copy of that directory, such as compiler output or—to use an example more appropriate to this book—the HTML, PDF, or PostScript files generated as the result of a conversion of some source DocBook XML files to a more legible output format."
msgstr ""

#: build/en/book.xml:5194(para)
msgid "Subversion's support for ignorable file patterns extends only to the one-time process of adding unversioned files and directories to version control. Once an object is under Subversion's control, the ignore pattern mechanisms no longer apply to it. In other words, don't expect Subversion to avoid committing changes you've made to a versioned file simply because that file's name matches an ignore pattern—Subversion <emphasis>always</emphasis> notices all of its versioned objects."
msgstr ""

#: build/en/book.xml:5206(title)
msgid "Ignore Patterns for CVS Users"
msgstr "CVS 用户的忽略模式"

#: build/en/book.xml:5208(para)
msgid "The Subversion <literal moreinfo=\"none\">svn:ignore</literal> property is very similar in syntax and function to the CVS <filename moreinfo=\"none\">.cvsignore</filename> file. In fact, if you are migrating a CVS working copy to Subversion, you can directly migrate the ignore patterns by using the <filename moreinfo=\"none\">.cvsignore</filename> file as input file to the <command moreinfo=\"none\">svn propset</command> command:"
msgstr "Subversion的<literal moreinfo=\"none\">svn:ignore</literal>属性与CVS的<filename moreinfo=\"none\">.cvsignore</filename>文件的语法和功能非常类似，实际上，如果你移植一个CVS的工作拷贝到Subversion，你可以直接使用<filename moreinfo=\"none\">.cvsignore</filename>作为<command moreinfo=\"none\">svn propset</command>输入文件参数："

#: build/en/book.xml:5216(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propset svn:ignore -F .cvsignore .\n"
"property 'svn:ignore' set on '.'\n"
"$\n"
msgstr ""
"\n"
"$ svn propset svn:ignore -F .cvsignore .\n"
"property 'svn:ignore' set on '.'\n"
"$\n"

#: build/en/book.xml:5222(para)
msgid "There are, however, some differences in the ways that CVS and Subversion handle ignore patterns. The two systems use the ignore patterns at some different times, and there are slight discrepancies in what the ignore patterns apply to. Also, Subversion does not recognize the use of the <literal moreinfo=\"none\">!</literal> pattern as a reset back to having no ignore patterns at all."
msgstr "但是CVS和Subversion处理忽略模式的方式有一些不同，这两个系统在不同的时候使用忽略模式，忽略模式应用的对象也由微小的不同，但是Subversion不会识别重置回到没有忽略模式的<literal moreinfo=\"none\">!</literal>模式的使用。"

#: build/en/book.xml:5232(para)
msgid "The global list of ignore patterns tends to be more a matter of personal taste, and tied more closely to a user's particular tool chain than to the details of any particular working copy's needs. So, the rest of this section will focus on the <literal moreinfo=\"none\">svn:ignore</literal> property and its uses."
msgstr ""

#: build/en/book.xml:5239(para)
#, fuzzy
msgid "Say you have the following output from <command moreinfo=\"none\">svn status</command>:"
msgstr "下注：使用<command moreinfo=\"none\">svn revert</command>"

#: build/en/book.xml:5242(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status calc\n"
" M     calc/button.c\n"
"?      calc/calculator\n"
"?      calc/data.c\n"
"?      calc/debug_log\n"
"?      calc/debug_log.1\n"
"?      calc/debug_log.2.gz\n"
"?      calc/debug_log.3.gz\n"
msgstr ""
"\n"
"$ svn status calc\n"
" M     calc/button.c\n"
"?      calc/calculator\n"
"?      calc/data.c\n"
"?      calc/debug_log\n"
"?      calc/debug_log.1\n"
"?      calc/debug_log.2.gz\n"
"?      calc/debug_log.3.gz\n"

#: build/en/book.xml:5262(para)
msgid "Isn't that the whole point of a build system?"
msgstr "这不是编译系统的基本功能吗？"

#: build/en/book.xml:5253(para)
#, fuzzy
msgid "In this example, you have made some property modifications to <filename moreinfo=\"none\">button.c</filename>, but in your working copy you also have some unversioned files: the latest <filename moreinfo=\"none\">calculator</filename> program that you've compiled from your source code, a source file named <filename moreinfo=\"none\">data.c</filename>, and a set of debugging output log files. Now, you know that your build system always results in the <filename moreinfo=\"none\">calculator</filename> program being generated. <placeholder-1/> And you know that your test suite always leaves those debugging log files lying around. These facts are true for all working copies of this project, not just your own. And you know that you aren't interested in seeing those things every time you run <command moreinfo=\"none\">svn status</command>, and pretty sure that nobody else is interested in them either. So you use <command moreinfo=\"none\">svn propedit svn:ignore calc</command> to add some ignore patterns to the <filename moreinfo=\"none\">calc</filename> directory. For example, you might add this as the new value of the <literal moreinfo=\"none\">svn:ignore</literal> property:"
msgstr "在这个例子里，你对<filename moreinfo=\"none\">button.c</filename>文件作了一些属性修改，但是你的工作拷贝也有一些未版本化的文件：你从源代码编译的最新的<filename moreinfo=\"none\">计算器</filename>程序是<filename moreinfo=\"none\">data.c</filename>，一系列调试输出日志文件，现在你知道你的编译系统会编译生成<filename moreinfo=\"none\">计算器</filename>程序。 <footnote><placeholder-1/></footnote> 就像你知道的，你的测试组件总是会留下这些调试日志，这对所有的工作拷贝都是一样的，不仅仅使你的。你也知道你不会有兴趣在<command moreinfo=\"none\">svn status</command>命令中显示这些信息，所以使用<command moreinfo=\"none\">svn propedit svn:ignore calc</command>来为<filename moreinfo=\"none\">calc</filename>目录增加一些忽略模式，举个例子，你或许会添加如下的值作为<literal moreinfo=\"none\">svn:ignore</literal>属性："

#: build/en/book.xml:5275(programlisting)
#, no-wrap
msgid ""
"\n"
"calculator\n"
"debug_log*\n"
msgstr ""
"\n"
"calculator\n"
"debug_log*\n"

#: build/en/book.xml:5280(para)
msgid "After you've added this property, you will now have a local property modification on the <filename moreinfo=\"none\">calc</filename> directory. But notice what else is different about your <command moreinfo=\"none\">svn status</command> output:"
msgstr "当你添加完这些属性，你会在<filename moreinfo=\"none\">calc</filename>目录有一个本地修改，但是注意你的<command moreinfo=\"none\">svn status</command>输出有什么其他的不同："

#: build/en/book.xml:5285(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status\n"
" M     calc\n"
" M     calc/button.c\n"
"?      calc/data.c\n"
msgstr ""
"\n"
"$ svn status\n"
" M     calc\n"
" M     calc/button.c\n"
"?      calc/data.c\n"

#: build/en/book.xml:5292(para)
#, fuzzy
msgid "Now, all that cruft is missing from the output! Of course, your <filename moreinfo=\"none\">calculator</filename> compiled program and all those logfiles are still in your working copy. Subversion is simply not reminding you that they are present and unversioned. And now with all the uninteresting noise removed from the display, you are left with more interesting items—such as that source code file <filename moreinfo=\"none\">data.c</filename> that you probably forgot to add to version control."
msgstr "现在，所有多余的输出不见了！当然，这些文件还在工作拷贝中，Subversion仅仅是不再提醒你它们的存在和未版本化。现在所有讨厌的噪音都已经删除了，你留下了更加感兴趣的项目—如你忘记添加到版本控制的源代码文件。"

#: build/en/book.xml:5301(para)
#, fuzzy
msgid "Of course, this less-verbose report of your working copy status isn't the only one available. If you actually want to see the ignored files as part of the status report, you can pass the <option>--no-ignore</option> option to Subversion:"
msgstr "如果想查看被忽略的文件，可以设置Subversion的<option>--no-ignore</option>选项："

#: build/en/book.xml:5306(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status --no-ignore\n"
" M     calc\n"
" M     calc/button.c\n"
"I      calc/calculator\n"
"?      calc/data.c\n"
"I      calc/debug_log\n"
"I      calc/debug_log.1\n"
"I      calc/debug_log.2.gz\n"
"I      calc/debug_log.3.gz\n"
msgstr ""
"\n"
"$ svn status --no-ignore\n"
" M     calc\n"
" M     calc/button.c\n"
"I      calc/calculator\n"
"?      calc/data.c\n"
"I      calc/debug_log\n"
"I      calc/debug_log.1\n"
"I      calc/debug_log.2.gz\n"
"I      calc/debug_log.3.gz\n"

#: build/en/book.xml:5318(para)
#, fuzzy
msgid "As mentioned earlier, the list of file patterns to ignore is also used by <command moreinfo=\"none\">svn add</command> and <command moreinfo=\"none\">svn import</command>. Both of these operations involve asking Subversion to begin managing some set of files and directories. Rather than force the user to pick and choose which files in a tree she wishes to start versioning, Subversion uses the ignore patterns—both the global and the per-directory lists—to determine which files should not be swept into the version control system as part of a larger recursive addition or import operation. And here again, you can use the <option>--no-ignore</option> option to tell Subversion ignore its ignores list and operate on all the files and directories present."
msgstr "<command moreinfo=\"none\">svn add</command>和<command moreinfo=\"none\">svn import</command>也会使用这个忽略模式列表，这两个操作都包括了询问Subversion来开始管理一组文件和目录。比强制用户挑拣目录树中那个文件要纳入版本控制的方式更好，Subversion使用忽略模式来检测那个文件不应该在大的迭代添加和导入操作中进入版本控制系统。"

#: build/en/book.xml:5338(title)
msgid "Keyword Substitution"
msgstr "关键字置换"

#: build/en/book.xml:5340(para)
msgid "Subversion has the ability to substitute <firstterm>keywords</firstterm>—pieces of useful, dynamic information about a versioned file—into the contents of the file itself. Keywords generally describe information about the last time the file was known to be modified. Because this information changes each time the file changes, and more importantly, just <emphasis>after</emphasis> the file changes, it is a hassle for any process except the version control system to keep the data completely up-to-date. Left to human authors, the information would inevitably grow stale."
msgstr "Subversion具备有添加<firstterm>关键字</firstterm>的能力—一些有用的，关于版本化的文件动态信息的片断—不必直接添加到文件本身。关键字通常会用来描述文件最后一次修改的一些信息，因为这些信息每次都有改变，更重要的一点，这是在文件修改<emphasis>之后</emphasis>，除了版本控制系统，对于任何处理完全保持最新的数据都是一场争论，作为人类作者，信息变得陈旧是不可避免的。"

#: build/en/book.xml:5352(para)
msgid "For example, say you have a document in which you would like to display the last date on which it was modified. You could burden every author of that document to, just before committing their changes, also tweak the part of the document that describes when it was last changed. But sooner or later, someone would forget to do that. Instead simply ask Subversion to perform keyword substitution on the <literal moreinfo=\"none\">LastChangedDate</literal> keyword. You control where the keyword is inserted into your document by placing a <firstterm>keyword anchor</firstterm> at the desired location in the file. This anchor is just a string of text formatted as <literal moreinfo=\"none\">$</literal><replaceable>KeywordName</replaceable><literal moreinfo=\"none\">$</literal>."
msgstr "举个例子，你有一个文档希望显示最后修改的日期，你需要麻烦每个作者提交之前做这件事情，同时会改变描述这部分细细的部分，但是迟早会有人忘记做这件事，不选择简单的告诉Subversion来执行替换<literal moreinfo=\"none\">LastChangedDate</literal>关键字的操作，在你的文档需要放置这个关键字的地方放置一个<firstterm>keyword anchor</firstterm>，这个anchor只是一个格式为<literal moreinfo=\"none\">$</literal><replaceable>KeywordName</replaceable><literal moreinfo=\"none\">$</literal>字符串。"

#: build/en/book.xml:5366(para)
msgid "All keywords are case-sensitive where they appear as anchors in files: you must use the correct capitalization in order for the keyword to be expanded. You should consider the value of the <literal moreinfo=\"none\">svn:keywords</literal> property to be case-sensitive too—certain keyword names will be recognized regardless of case, but this behavior is deprecated."
msgstr "所有作为anchor出现在文件里的关键字是大小写敏感的：为了关键字的扩展，你必须使用正确的按顺序大写。你必须考虑<literal moreinfo=\"none\">svn:keywords</literal>的属性值也是大小写敏感—特定的关键字名会忽略大小写，但是这个特性已经被废弃了。"

#: build/en/book.xml:5373(para)
msgid "Subversion defines the list of keywords available for substitution. That list contains the following five keywords, some of which have aliases that you can also use:"
msgstr "Subversion定义了用来替换的关键字列表，这个列表保存了如下五个关键字，有一些也包括了可用的别名："

#: build/en/book.xml:5379(literal)
msgid "Date"
msgstr "Date"

#: build/en/book.xml:5381(para)
#, fuzzy
msgid "This keyword describes the last time the file was known to have been changed in the repository, and looks something like <literal moreinfo=\"none\">$Date: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $</literal>. It may also be specified as <literal moreinfo=\"none\">LastChangedDate</literal>."
msgstr "这个关键字保存了文件最后一次在版本库修改的日期，看起来类似于<literal moreinfo=\"none\">$Date: 2002-07-22 21:42:37 -0700 (Mon, 22 Jul 2002) $</literal>，它也可以用<literal moreinfo=\"none\">LastChangedDate</literal>来指定。"

#: build/en/book.xml:5390(literal) build/en/book.xml:19602(para)
msgid "Revision"
msgstr "版本"

#: build/en/book.xml:5392(para)
msgid "This keyword describes the last known revision in which this file changed in the repository, and looks something like <literal moreinfo=\"none\">$Revision: 144 $</literal>. It may also be specified as <literal moreinfo=\"none\">LastChangedRevision</literal> or <literal moreinfo=\"none\">Rev</literal>."
msgstr "这个关键字描述了这个文件最后一次修改的修订版本，看起来像<literal moreinfo=\"none\">$Revision: 144 $</literal>，也可以通过<literal moreinfo=\"none\">LastChangedRevision</literal>或者<literal moreinfo=\"none\">Rev</literal>引用。"

#: build/en/book.xml:5401(literal)
msgid "Author"
msgstr "Author"

#: build/en/book.xml:5403(para)
msgid "This keyword describes the last known user to change this file in the repository, and looks something like <literal moreinfo=\"none\">$Author: harry $</literal>. It may also be specified as <literal moreinfo=\"none\">LastChangedBy</literal>."
msgstr "这个关键字描述了最后一个修改这个文件的用户，看起来类似<literal moreinfo=\"none\">$Author: harry $</literal>，也可以用<literal moreinfo=\"none\">LastChangedBy</literal>来指定。"

#: build/en/book.xml:5411(literal)
msgid "HeadURL"
msgstr "HeadURL"

#: build/en/book.xml:5413(para)
msgid "This keyword describes the full URL to the latest version of the file in the repository, and looks something like <literal moreinfo=\"none\">$HeadURL: http://svn.collab.net/repos/trunk/README $</literal>. It may be abbreviated as <literal moreinfo=\"none\">URL</literal>."
msgstr "这个关键字描述了这个文件在版本库最新的版本的完全URL，看起来类似<literal moreinfo=\"none\">$HeadURL: http://svn.collab.net/repos/trunk/README $</literal>，可以缩写为<literal moreinfo=\"none\">URL</literal>。"

#: build/en/book.xml:5422(literal)
msgid "Id"
msgstr "Id"

#: build/en/book.xml:5424(para)
#, fuzzy
msgid "This keyword is a compressed combination of the other keywords. Its substitution looks something like <literal moreinfo=\"none\">$Id: calc.c 148 2006-07-28 21:30:43Z sally $</literal>, and is interpreted to mean that the file <filename moreinfo=\"none\">calc.c</filename> was last changed in revision 148 on the evening of July 28, 2006 by the user <literal moreinfo=\"none\">sally</literal>."
msgstr "这个关键字是其他关键字一个压缩组合，它看起来就像<literal moreinfo=\"none\">$Id: calc.c 148 2002-07-28 21:30:43Z sally $</literal>，可以解释为文件<filename moreinfo=\"none\">calc.c</filename>上一次修改的修订版本号是148，时间是2002年7月28日，作者是<literal moreinfo=\"none\">sally</literal>。"

#: build/en/book.xml:5441(para)
msgid "… or maybe even a section of a book …"
msgstr "… 或者可能是一本书的一个小节 …"

#: build/en/book.xml:5435(para)
#, fuzzy
msgid "Simply adding keyword anchor text to your file does nothing special. Subversion will never attempt to perform textual substitutions on your file contents unless explicitly asked to do so. After all, you might be writing a document <placeholder-1/> about how to use keywords, and you don't want Subversion to substitute your beautiful examples of un-substituted keyword anchors!"
msgstr "只在你的文件增加关键字anchor不会做什么特别的事情，Subversion不会尝试对你的文件内容执行文本替换，除非明确的被告知这样做，毕竟，你可以撰写一个文档 <footnote><placeholder-1/></footnote> 关于如何使用关键字，你希望Subversion不会替代你漂亮的关于不需要替换的关键字anchor实例！"

#: build/en/book.xml:5447(para)
msgid "To tell Subversion whether or not to substitute keywords on a particular file, we again turn to the property-related subcommands. The <literal moreinfo=\"none\">svn:keywords</literal> property, when set on a versioned file, controls which keywords will be substituted on that file. The value is a space-delimited list of the keyword names or aliases found in the previous table."
msgstr "为了告诉Subversion是否替代某个文件的关键字，我们要再次求助于属性相关的子命令，当<literal moreinfo=\"none\">svn:keywords</literal>属性设置到一个版本化的文件，这些属性控制了那些关键字将会替换到那个文件。这个值是空格分隔的前面列表的名称或是别名列表。"

#: build/en/book.xml:5455(para)
msgid "For example, say you have a versioned file named <filename moreinfo=\"none\">weather.txt</filename> that looks like this:"
msgstr "举个例子，假定你有一个版本化的文件<filename moreinfo=\"none\">weather.txt</filename>，内容如下："

#: build/en/book.xml:5459(programlisting)
#, no-wrap
msgid ""
"\n"
"Here is the latest report from the front lines.\n"
"$LastChangedDate$\n"
"$Rev$\n"
"Cumulus clouds are appearing more frequently as summer approaches.\n"
msgstr ""
"\n"
"Here is the latest report from the front lines.\n"
"$LastChangedDate$\n"
"$Rev$\n"
"Cumulus clouds are appearing more frequently as summer approaches.\n"

#: build/en/book.xml:5466(para)
msgid "With no <literal moreinfo=\"none\">svn:keywords</literal> property set on that file, Subversion will do nothing special. Now, let's enable substitution of the <literal moreinfo=\"none\">LastChangedDate</literal> keyword."
msgstr "当没有<literal moreinfo=\"none\">svn:keywords</literal>属性设置到这个文件，Subversion不会有任何特别操作，现在让我们允许<literal moreinfo=\"none\">LastChangedDate</literal>关键字的替换。"

#: build/en/book.xml:5471(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propset svn:keywords \"Date Author\" weather.txt\n"
"property 'svn:keywords' set on 'weather.txt'\n"
"$\n"
msgstr ""
"\n"
"$ svn propset svn:keywords \"Date Author\" weather.txt\n"
"property 'svn:keywords' set on 'weather.txt'\n"
"$\n"

#: build/en/book.xml:5477(para)
msgid "Now you have made a local property modification on the <filename moreinfo=\"none\">weather.txt</filename> file. You will see no changes to the file's contents (unless you made some of your own prior to setting the property). Notice that the file contained a keyword anchor for the <literal moreinfo=\"none\">Rev</literal> keyword, yet we did not include that keyword in the property value we set. Subversion will happily ignore requests to substitute keywords that are not present in the file, and will not substitute keywords that are not present in the <literal moreinfo=\"none\">svn:keywords</literal> property value."
msgstr "现在你已经对<filename moreinfo=\"none\">weather.txt</filename>的属性作了修改，你会看到文件的内容没有改变（除非你之前做了一些属性设置），注意这个文件包含了<literal moreinfo=\"none\">Rev</literal>的关键字anchor，但我们没有在属性值中包括这个关键字，Subversion会高兴的忽略替换这个文件中的关键字，也不会替换<literal moreinfo=\"none\">svn:keywords</literal>属性中没有出现的关键字。"

#: build/en/book.xml:5488(para)
msgid "Immediately after you commit this property change, Subversion will update your working file with the new substitute text. Instead of seeing your keyword anchor <literal moreinfo=\"none\">$LastChangedDate$</literal>, you'll see its substituted result. That result also contains the name of the keyword, and continues to be bounded by the dollar sign (<literal moreinfo=\"none\">$</literal>) characters. And as we predicted, the <literal moreinfo=\"none\">Rev</literal> keyword was not substituted because we didn't ask for it to be."
msgstr "在你提交了属性修改后，Subversion会立刻更新你的工作文件为新的替代文本，你将无法找到<literal moreinfo=\"none\">$LastChangedDate$</literal>的关键字anchor，你会看到替换的结果，这个结果也保存了关键字的名字，与美元符号（<literal moreinfo=\"none\">$</literal>）绑定在一起，而且我们预测的，<literal moreinfo=\"none\">Rev</literal>关键字不会被替换，因为我们没有要求这样做。"

#: build/en/book.xml:5498(para)
msgid "Note also that we set the <literal moreinfo=\"none\">svn:keywords</literal> property to <quote>Date Author</quote> yet the keyword anchor used the alias <literal moreinfo=\"none\">$LastChangedDate$</literal> and still expanded correctly."
msgstr "注意我们设置<literal moreinfo=\"none\">svn:keywords</literal>属性为<quote>Date Author</quote>，关键字anchor使用别名<literal moreinfo=\"none\">$LastChangedDate$</literal>并且正确的扩展。"

#: build/en/book.xml:5503(screen)
#, no-wrap
msgid ""
"\n"
"Here is the latest report from the front lines.\n"
"$LastChangedDate: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $\n"
"$Rev$\n"
"Cumulus clouds are appearing more frequently as summer approaches.\n"
msgstr ""
"\n"
"Here is the latest report from the front lines.\n"
"$LastChangedDate: 2006-07-22 21:42:37 -0700 (Sat, 22 Jul 2006) $\n"
"$Rev$\n"
"Cumulus clouds are appearing more frequently as summer approaches.\n"

#: build/en/book.xml:5510(para)
msgid "If someone else now commits a change to <filename moreinfo=\"none\">weather.txt</filename>, your copy of that file will continue to display the same substituted keyword value as before—until you update your working copy. At that time the keywords in your <filename moreinfo=\"none\">weather.txt</filename> file will be re-substituted with information that reflects the most recent known commit to that file."
msgstr "如果有其他人提交了<filename moreinfo=\"none\">weather.txt</filename>的修改，你的此文件的拷贝还会显示同样的替换关键字值—直到你更新你的工作拷贝，此时你的<filename moreinfo=\"none\">weather.txt</filename>重的关键字将会被替换来反映最新的提交信息。"

#: build/en/book.xml:5519(title)
msgid "Where's $GlobalRev$?"
msgstr "$GlobalRev$? 在哪里？"

#: build/en/book.xml:5521(para)
msgid "New users are often confused by how the <literal moreinfo=\"none\">$Rev$</literal> keyword works. Since the repository has a single, globally increasing revision number, many people assume that it is this number which is reflected by the <literal moreinfo=\"none\">$Rev$</literal> keyword's value. But <literal moreinfo=\"none\">$Rev$</literal> expands to show the last revision in which the file <emphasis>changed</emphasis>, not the last revision to which it was updated. Understanding this clears the confusion, but frustration often remains—without the support of a Subversion keyword to do so, how can you automatically get the global revision number into your files?"
msgstr ""

#: build/en/book.xml:5534(para)
msgid "To do this, you need external processing. Subversion ships with a tool called <command moreinfo=\"none\">svnversion</command> which was designed for just this purpose. <command moreinfo=\"none\">svnversion</command> crawls your working copy and generates as output the revision(s) it finds. You can use this program, plus some additionally tooling, to embed that revision information into your files. For more information on <command moreinfo=\"none\">svnversion</command>, see <xref linkend=\"svn.ref.svnversion\"/>."
msgstr ""

#: build/en/book.xml:5545(para)
msgid "Subversion 1.2 introduced a new variant of the keyword syntax which brought additional, useful—though perhaps atypical—functionality. You can now tell Subversion to maintain a fixed length (in terms of the number of bytes consumed) for the substituted keyword. By using a double-colon (<literal moreinfo=\"none\">::</literal>) after the keyword name, followed by a number of space characters, you define that fixed width. When Subversion goes to substitute your keyword for the keyword and its value, it will essentially replace only those space characters, leaving the overall width of the keyword field unchanged. If the substituted value is shorter than the defined field width, there will be extra padding characters (spaces) at the end of the substituted field; if it is too long, it is truncated with a special hash (<literal moreinfo=\"none\">#</literal>) character just before the final dollar sign terminator."
msgstr "Subversion 1.2引入了另一种关键字的语法，提供了额外和有用的，尽管是非典型的功能。你现在可以告诉Subversion为替代的关键字维护一个固定长度（从消耗字节的观点），通过在关键字名后使用双冒号（<literal moreinfo=\"none\">::</literal>），然后紧跟一组空格，你就定义了固定宽度。当Subversion使用替代值代替你的关键字，只会替换这些空白字符，保持关键字字段长度保持不变，如果替代值比定义的字段短，会有替代字段后保留空格；如果替代值太长，就会在最后的美元符号终止符前用井号（<literal moreinfo=\"none\">#</literal>）截断。"

#: build/en/book.xml:5562(para)
msgid "For example, say you have a document in which you have some section of tabular data reflecting the document's Subversion keywords. Using the original Subversion keyword substitution syntax, your file might look something like:"
msgstr "例如，你有一篇文档，其中一段是一些反映Subversion关键字的表格数据，使用原始的Subversion关键字替换语法，你的文件或许像这样："

#: build/en/book.xml:5568(screen)
#, no-wrap
msgid ""
"\n"
"$Rev$:     Revision of last commit\n"
"$Author$:  Author of last commit\n"
"$Date$:    Date of last commit\n"
msgstr ""
"\n"
"$Rev$:     Revision of last commit\n"
"$Author$:  Author of last commit\n"
"$Date$:    Date of last commit\n"

#: build/en/book.xml:5574(para)
msgid "Now, that looks nice and tabular at the start of things. But when you then commit that file (with keyword substitution enabled, of course), you see:"
msgstr "现在，表格看起来佷漂亮，但是当你提交文件（当然，关键字替换功能已打开），你会看到："

#: build/en/book.xml:5578(screen)
#, no-wrap
msgid ""
"\n"
"$Rev: 12 $:     Revision of last commit\n"
"$Author: harry $:  Author of last commit\n"
"$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Date of last commit\n"
msgstr ""
"\n"
"$Rev: 12 $:     Revision of last commit\n"
"$Author: harry $:  Author of last commit\n"
"$Date: 2006-03-15 02:33:03 -0500 (Wed, 15 Mar 2006) $:    Date of last commit\n"

#: build/en/book.xml:5584(para)
msgid "The result is not so beautiful. And you might be tempted to then adjust the file after the substitution so that it again looks tabular. But that only holds as long as the keyword values are the same width. If the last committed revision rolls into a new place value (say, from 99 to 100), or if another person with a longer username commits the file, stuff gets all crooked again. However, if you are using Subversion 1.2 or better, you can use the new fixed-length keyword syntax, define some field widths that seem sane, and now your file might look like this:"
msgstr "结果并不漂亮，你可能会尝试重新调整文件使之更像一个列表。只有关键字的长度是相同的时候才能保证保持样式，如果进入另一个修订版本（如从99到100），或者是另一个有较长用户名的人提交了文件，表格又会变形。然而，如果你使用Subversion 1.2，你可以使用新的固定长度的关键字语法，定义合适的字段宽度，然后你的文件可能如此："

#: build/en/book.xml:5595(screen)
#, no-wrap
msgid ""
"\n"
"$Rev::               $:  Revision of last commit\n"
"$Author::            $:  Author of last commit\n"
"$Date::              $:  Date of last commit\n"
msgstr ""
"\n"
"$Rev::               $:  Revision of last commit\n"
"$Author::            $:  Author of last commit\n"
"$Date::              $:  Date of last commit\n"

#: build/en/book.xml:5601(para)
msgid "You commit this change to your file. This time, Subversion notices the new fixed-length keyword syntax, and maintains the width of the fields as defined by the padding you placed between the double-colon and the trailing dollar sign. After substitution, the width of the fields is completely unchanged—the short values for <literal moreinfo=\"none\">Rev</literal> and <literal moreinfo=\"none\">Author</literal> are padded with spaces, and the long <literal moreinfo=\"none\">Date</literal> field is truncated by a hash character:"
msgstr "你提交这个文件的修改，这一次Subversion注意到了新的固定长度的关键字语法，根据你在双冒号之间指定的空格长度调整格式，并且紧跟一个美元符号。经过替换，字段的长度没有发生变化—<literal moreinfo=\"none\">Rev</literal>和<literal moreinfo=\"none\">Author</literal>多了一些空格，而较长的<literal moreinfo=\"none\">Date</literal>字段被一个井号截断："

#: build/en/book.xml:5611(screen)
#, no-wrap
msgid ""
"\n"
"$Rev:: 13            $:  Revision of last commit\n"
"$Author:: harry      $:  Author of last commit\n"
"$Date:: 2006-03-15 0#$:  Date of last commit\n"
msgstr ""
"\n"
"$Rev:: 13            $:  Revision of last commit\n"
"$Author:: harry      $:  Author of last commit\n"
"$Date:: 2006-03-15 0#$:  Date of last commit\n"

#: build/en/book.xml:5617(para)
msgid "The use of fixed-length keywords is especially handy when performing substitutions into complex file formats that themselves use fixed-length fields for data, or for which the stored size of a given data field is overbearingly difficult to modify from outside the format's native application (such as for Microsoft Office documents)."
msgstr "固定长度关键字在执行复杂文件格式的替换中非常易用，也可以处理那些很难通过其他程序（例如Microsoft Office文档）进行修改的文件。"

#: build/en/book.xml:5625(para)
msgid "Be aware that because the width of a keyword field is measured in bytes, the potential for corruption of multi-byte values exists. For example, a username which contains some multi-byte UTF-8 characters might suffer truncation in the middle of the string of bytes which make up one of those characters. The result will be a mere truncation when viewed at the byte level, but will likely appear as a string with an incorrect or garbled final character when viewed as UTF-8 text. It is conceivable that certain applications, when asked to load the file, would notice the broken UTF-8 text and deem the entire file corrupt, refusing to operate on the file altogether."
msgstr "需要意识到，因为关键字字段的长度是以字节为单位，可能会破坏多字节值，例如一个用户名包含多字节的UTF-8字符，可能会遭遇从某个字符中间截断的情况，从字节角度看仅仅是一种截断，但是从UTF-8字符串角度看可能是错误和曲解的，当载入文件时，破坏的UTF-8文本可能导致整个文件的破坏，整个文件无法操作。"

#: build/en/book.xml:5646(title)
msgid "Locking"
msgstr "锁定"

#: build/en/book.xml:5648(para)
msgid "Subversion's copy-modify-merge version control model lives and dies on its data merging algorithms, specifically on how well those algorithms perform when trying to resolve conflicts caused by multiple users modifying the same file concurrently. Subversion itself provides only one such algorithm, a three-way differencing algorithm which is smart enough to handle data at a granularity of a single line of text. Subversion also allows you to supplement its content merge processing with external differencing utilities (as described in <xref linkend=\"svn.advanced.externaldifftools.diff3\"/>), some of which may do an even better job, perhaps providing granularity of a word or a single character of text. But common among those algorithms is that they generally work only on text files. The landscape starts to look pretty grim when you start talking about content merges of non-textual file formats. And when you can't find a tool that can handle that type of merging, you begin to run into problems with the copy-modify-merge model."
msgstr ""

#: build/en/book.xml:5666(para)
msgid "Let's look at a real-life example of where this model runs aground. Harry and Sally are both graphic designers working on the same project, a bit of marketing collateral for an automobile mechanic. Central to the design of a particular poster is an image of a car in need of some body work, stored in a file using the PNG image format. The poster's layout is almost finished, and both Harry and Sally are pleased with the particular photo they chose for their damaged car—a baby blue 1967 Ford Mustang with an unfortunate bit of crumpling on the left front fender."
msgstr ""

#: build/en/book.xml:5677(para)
msgid "Now, as is common in graphic design work, there's a change in plans which causes the car's color to be a concern. So Sally updates her working copy to <literal moreinfo=\"none\">HEAD</literal>, fires up her photo editing software, and sets about tweaking the image so that the car is now cherry red. Meanwhile, Harry, feeling particularly inspired that day, decides that the image would have greater impact if the car also appears to have suffered greater impact. He, too, updates to <literal moreinfo=\"none\">HEAD</literal>, and then draws some cracks on the vehicle's windshield. He manages to finish his work before Sally finishes hers, and after admiring the fruits of his undeniable talent, commits the modified image. Shortly thereafter, Sally is finished with the car's new finish, and tries to commit her changes. But, as expected, Subversion fails the commit, informing Sally that now her version of the image is out of date."
msgstr ""

#: build/en/book.xml:5693(para)
msgid "Here's where the difficulty sets in. Were Harry and Sally making changes to a text file, Sally would simply update her working copy, receiving Harry's changes in the process. In the worst possible case, they would have modified the same region of the file, and Sally would have to work out by hand the proper resolution to the conflict. But these aren't text files—they are binary images. And while it's a simple matter to describe what one would expect the results of this content merge to be, there is precious little chance that any software exists which is smart enough to examine the common baseline image that each of these graphic artists worked against, the changes that Harry made, and the changes that Sally made, and spit out an image of a busted-up red Mustang with a cracked windshield!"
msgstr ""

#: build/en/book.xml:5716(para)
msgid "Communication wouldn't have been such bad medicine for Harry and Sally's Hollywood namesakes, either, for that matter."
msgstr ""

#: build/en/book.xml:5708(para)
msgid "Clearly, things would have gone more smoothly if Harry and Sally had serialized their modifications to the image. If, say, Harry had waited to draw his windshield cracks on Sally's now-red car, or if Sally had tweaked the color of a car whose windshield was already cracked. As is discussed in <xref linkend=\"svn.basic.vsn-models.copy-merge\"/>, much of these types problems go away entirely where perfect communication between Harry and Sally exists. <placeholder-1/> But as one's version control system is, in fact, one form of communication, it follows that having that software facilitate the serialization of non-parallelizable energies is no bad thing. And this where Subversion's implementation of the lock-modify-unlock model steps into the spotlight. This is where we talk about Subversion's <firstterm>locking</firstterm> feature, which is similar to the <quote>reserved checkouts</quote> mechanisms of other version control systems."
msgstr ""

#: build/en/book.xml:5730(para)
msgid "Subversion's locking feature serves two main purposes:"
msgstr "Subversion 的锁定特性为两个主要目的服务："

#: build/en/book.xml:5735(para)
#, fuzzy
msgid "<emphasis>Serializing access to a versioned object</emphasis>. By allowing a user to programmatically claim the exclusive right to change to a file in the repository, that user can be reasonably confident that energy invested on unmergeable changes won't be wasted—his commit of those changes will succeed."
msgstr "<emphasis>顺序访问资源</emphasis>。允许用户得到一个排他的修改文件权，如果Harry保留了修改<filename moreinfo=\"none\">foo.jpg</filename>的权利，Sally将不可以提交这个文件的修改。"

#: build/en/book.xml:5743(para)
msgid "<emphasis>Aiding communication</emphasis>. By alerting other users that serialization is in effect for particular versioned object, those other users can reasonably expect that the object is about to be changed by someone else, and they, too, can avoid wasting their time and energy on unmergeable changes that won't be committable due to eventual out-of-dateness."
msgstr ""

#: build/en/book.xml:5757(para)
msgid "Subversion does not currently allow locks on directories."
msgstr ""

#: build/en/book.xml:5753(para)
msgid "When referring to Subversion's locking feature, one is actually talking about a fairly diverse collection of behaviors which include the ability to lock a versioned file <placeholder-1/> (claiming the exclusive right to modify the file), to unlock that file (yielding that exclusive right to modify), to see reports about which files are locked and by whom, to annotate files for which locking before editing is strongly advised, and so on. In this section, we'll cover all of these facets of the larger locking feature."
msgstr ""

#: build/en/book.xml:5767(title)
msgid "The three meanings of <quote>lock</quote>"
msgstr "<quote>锁定</quote>的三种含义"

#: build/en/book.xml:5769(para)
msgid "In this section, and almost everywhere in this book, the words <quote>lock</quote> and <quote>locking</quote> describe a mechanism for mutual exclusion between users to avoid clashing commits. Unfortunately, there are two other sorts of <quote>lock</quote> with which Subversion, and therefore this book, sometimes needs to be concerned."
msgstr "在本小节，和几乎本书的每一个地方<quote>lock</quote>和<quote>locking</quote>描述了一种避免用户之间冲突提交的排他机制，但是佷不幸，Subversion中还有另外两种锁，因此需要在本书格外关心。"

#: build/en/book.xml:5776(para)
#, fuzzy
msgid "The first is <firstterm>working copy locks</firstterm>, used internally by Subversion to prevent clashes between multiple Subversion clients operating on the same working copy. This is the sort of lock indicated by an <computeroutput moreinfo=\"none\">L</computeroutput> in the third column of <command moreinfo=\"none\">svn status</command> output, and removed by the <command moreinfo=\"none\">svn cleanup</command> command, as described in <xref linkend=\"svn.tour.cleanup\"/>."
msgstr "<firstterm>工作拷贝锁</firstterm>，Subversion内部用来防止不同客户端同时操作同一份工作拷贝的锁，这种锁使用<command moreinfo=\"none\">svn status</command>输出中第三列出现的<computeroutput moreinfo=\"none\">L</computeroutput>表示，可以使用<command moreinfo=\"none\">svn cleanup</command>删除（<xref linkend=\"svn.tour.other.cleanup\"/>有介绍）。"

#: build/en/book.xml:5784(para)
#, fuzzy
msgid "Secondly, there are <firstterm>database locks</firstterm>, used internally by the Berkeley DB backend to prevent clashes between multiple programs trying to access the database. This is the sort of lock whose unwanted persistence after an error can cause a repository to be <quote>wedged</quote>, as described in <xref linkend=\"svn.reposadmin.maint.recovery\"/>."
msgstr "<firstterm>数据库锁</firstterm>，在Berkeley DB后端内部使用，防止多个程序访问数据库发生冲突，一个导致版本库<quote>楔住</quote>的错误发生后产生（<xref linkend=\"svn.reposadmin.maint.recovery\"/>有描述）。"

#: build/en/book.xml:5791(para)
#, fuzzy
msgid "You can generally forget about these other kinds of locks until something goes wrong that requires you to care about them. In this book, <quote>lock</quote> means the first sort unless the contrary is either clear from context or explicitly stated."
msgstr "在发生问题之前你可以忘记上面两种锁，在本书，<quote>锁定</quote>意味着第一种锁，除非是清除不合理的上下文或明确的状态。"

#: build/en/book.xml:5801(title)
msgid "Creating locks"
msgstr "创建锁定"

#: build/en/book.xml:5803(para)
#, fuzzy
msgid "In the Subversion repository, a <firstterm>lock</firstterm> is a piece of metadata which grants exclusive access to one user to change a file. This user is said to be the <firstterm>lock owner</firstterm>. Each lock also has a unique identifier, typically a long string of characters, known as the <firstterm>lock token</firstterm>. The repository manages locks, ultimately handling their creation, enforcement, and removal. If any commit transaction attempts to modify or delete a locked file (or delete one of the parent directories of the file), the repository will demand two pieces of information—that the client performing the commit be authenticated as the lock owner, and that the lock token has been provided as part of the commit process as a sort of proof that client knows which lock it is using."
msgstr "在Subversion的版本库，一个<firstterm>锁</firstterm>是一份元数据，可以排它赋予某个用户修改权，这个用户被称作<firstterm>锁的拥有者</firstterm>。每个锁都有一个唯一标识，通常是一长串字符，叫做<firstterm>锁令牌</firstterm>。版本库在一个单独的表里管理锁，提交时强制锁定检查，如果操作会修改或删除文件（或者是删除文件父目录），版本库会要求两份信息："

#: build/en/book.xml:5819(para)
#, fuzzy
msgid "To demonstrate lock creation, let's refer back to our example of multiple graphic designers working with on the same binary image files. Harry has decided to change a JPEG image. To prevent other people from committing changes to the file while he is modifying it (as well as alerting them that he is about to change it), he locks the file in the repository using the <command moreinfo=\"none\">svn lock</command> command."
msgstr "一个例子是按照顺序。为了描述方便，假定Harry决定修改一个JPEG图像，为了防止其他用户提交这个文件的修改，他使用<command moreinfo=\"none\">svn lock</command>命令锁定了版本库的这个文件："

#: build/en/book.xml:5827(screen)
#, no-wrap
msgid ""
"\n"
"$ svn lock banana.jpg -m \"Editing file for tomorrow's release.\"\n"
"'banana.jpg' locked by user 'harry'.\n"
"$\n"
msgstr ""
"\n"
"$ svn lock banana.jpg -m \"Editing file for tomorrow's release.\"\n"
"'banana.jpg' locked by user 'harry'.\n"
"$\n"

#: build/en/book.xml:5833(para)
#, fuzzy
msgid "There are a number of new things demonstrated in the previous example. First, notice that Harry passed the <option>--message (-m)</option> option to <command moreinfo=\"none\">svn lock</command>. Similar to <command moreinfo=\"none\">svn commit</command>, the <command moreinfo=\"none\">svn lock</command> command can take comments (either via <option>--message (-m)</option> or <option>--file (-F)</option>) to describe the reason for locking the file. Unlike <command moreinfo=\"none\">svn commit</command>, however, <command moreinfo=\"none\">svn lock</command> will not demand a message by launching your preferred text editor. Lock comments are optional, but still recommended to aid communication."
msgstr "前一个例子描述了许多新事物，第一，注意Harry在<command moreinfo=\"none\">svn lock</command>中使用了<option>--message</option>选项，类似于<command moreinfo=\"none\">svn commit</command>，<command moreinfo=\"none\">svn lock</command>命令可以有描述锁定原因的注释（通过<option>--message (-m)</option>或<option>--file (-F)</option>）。然而不像<command moreinfo=\"none\">svn commit</command>，<command moreinfo=\"none\">svn lock</command>不会自动强制启动你喜欢的编辑器，锁定注释是可选的，但是为了方便交流我们还是推荐使用。"

#: build/en/book.xml:5845(para)
#, fuzzy
msgid "Secondly, the lock attempt succeeded. This means that the file wasn't already locked, and that Harry had the latest version of the file. If Harry's working copy of the file had been out-of-date, the repository would have rejected the request, forcing Harry to <command moreinfo=\"none\">svn update</command> and reattempt the locking command. The locking command would also have failed if the file already been locked by someone else."
msgstr "第二，锁定成功了。这意味着文件已经锁定了，Harry有了文件最新的版本，如果Harry的工作拷贝文件不是最新的，版本库会拒绝请求，强制Harry执行<command moreinfo=\"none\">svn update</command>并重新运行锁定命令。"

#: build/en/book.xml:5854(para)
msgid "As you can see, the <command moreinfo=\"none\">svn lock</command> command prints confirmation of the successful lock. At this point, the fact that the file is locked becomes apparent in the output of the <command moreinfo=\"none\">svn status</command> and <command moreinfo=\"none\">svn info</command> reporting subcommands."
msgstr ""

#: build/en/book.xml:5860(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status\n"
"     K banana.jpg\n"
"\n"
"$ svn info banana.jpg\n"
"Path: banana.jpg\n"
"Name: banana.jpg\n"
"URL: http://svn.example.com/repos/project/banana.jpg\n"
"Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec\n"
"Revision: 2198\n"
"Node Kind: file\n"
"Schedule: normal\n"
"Last Changed Author: frank\n"
"Last Changed Rev: 1950\n"
"Last Changed Date: 2006-03-15 12:43:04 -0600 (Wed, 15 Mar 2006)\n"
"Text Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)\n"
"Properties Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)\n"
"Checksum: 3b110d3b10638f5d1f4fe0f436a5a2a5\n"
"Lock Token: opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e\n"
"Lock Owner: harry\n"
"Lock Created: 2006-06-14 17:20:31 -0500 (Wed, 14 Jun 2006)\n"
"Lock Comment (1 line):\n"
"Editing file for tomorrow's release.\n"
"\n"
"$\n"
msgstr ""
"\n"
"$ svn status\n"
"     K banana.jpg\n"
"\n"
"$ svn info banana.jpg\n"
"Path: banana.jpg\n"
"Name: banana.jpg\n"
"URL: http://svn.example.com/repos/project/banana.jpg\n"
"Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec\n"
"Revision: 2198\n"
"Node Kind: file\n"
"Schedule: normal\n"
"Last Changed Author: frank\n"
"Last Changed Rev: 1950\n"
"Last Changed Date: 2006-03-15 12:43:04 -0600 (Wed, 15 Mar 2006)\n"
"Text Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)\n"
"Properties Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006)\n"
"Checksum: 3b110d3b10638f5d1f4fe0f436a5a2a5\n"
"Lock Token: opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e\n"
"Lock Owner: harry\n"
"Lock Created: 2006-06-14 17:20:31 -0500 (Wed, 14 Jun 2006)\n"
"Lock Comment (1 line):\n"
"Editing file for tomorrow's release.\n"
"\n"
"$\n"

#: build/en/book.xml:5887(para)
#, fuzzy
msgid "That the <command moreinfo=\"none\">svn info</command> command, which does not contact the repository when run against working copy paths, can display the lock token reveals an important fact about lock tokens—that they are cached in the working copy. The presence of the lock token is critical. It gives the working copy authorization to make use of the lock later on. Also, the <command moreinfo=\"none\">svn status</command> command shows a <literal moreinfo=\"none\">K</literal> next to the file (short for locKed), indicating that the lock token is present."
msgstr "也要注意到在创建版本库的锁定之后，工作拷贝也缓存了锁定的信息—最重要的是锁定令牌。有锁定令牌是非常重要的，这给了工作拷贝权利利用这个锁的能力。<command moreinfo=\"none\">svn status</command>会在文件后面显示一个<literal moreinfo=\"none\">K</literal>（locKed的缩写），表明了拥有锁定令牌。"

#: build/en/book.xml:5898(title)
msgid "Regarding lock tokens"
msgstr "关于锁定令牌"

#: build/en/book.xml:5900(para)
#, fuzzy
msgid "A lock token isn't an authentication token, so much as an <emphasis>authorization</emphasis> token. The token isn't a protected secret. In fact, a lock's unique token is discoverable by anyone who runs <command moreinfo=\"none\">svn info URL</command>. A lock token is special only when it lives inside a working copy. It's proof that the lock was created in that particular working copy, and not somewhere else by some other client. Merely authenticating as the lock owner isn't enough to prevent accidents."
msgstr "一个锁定令牌只有在工作拷贝中才有特别的意义，它是锁定建立在这个工作拷贝的证据，而不是其它用户在其他地方。仅仅检验锁定拥有者还不能防止事故。"

#: build/en/book.xml:5910(para)
#, fuzzy
msgid "For example, suppose you lock a file using a computer at your office, but leave work for the day before you finish your changes to that file. It should not be possible to accidentally commit changes to that same file from your home computer later that evening simply because you've authenticated as the lock's owner. In other words, the lock token prevents one piece of Subversion-related software from undermining the work of another. (In our example, if you really need to change the file from an alternate working copy, you would need to break the lock and re-lock the file.)"
msgstr "例如：你在办公室电脑上锁定了一个文件，或许修改正在进行中。很有可能在你的家用计算机上的一个工作拷贝（或别的Subversion客户端）里你又不小心修改了同一个文件，仅仅因为检验了你就是锁定的拥有者。换句话说，锁定令牌防止你通过一个Subversion相关软件的工作破坏另一个。（在我们的例子里，如果你真的需要在另一个工作拷贝修改这个文件，你必须打破锁定再重新锁定文件。）"

#: build/en/book.xml:5924(para)
msgid "Now that Harry has locked <filename moreinfo=\"none\">banana.jpg</filename>, Sally is unable to change or delete that file:"
msgstr "现在Harry已经锁定了<filename moreinfo=\"none\">banana.jpg</filename>，Sally不能修改或删除这个文件："

#: build/en/book.xml:5927(screen)
#, no-wrap
msgid ""
"\n"
"$ svn delete banana.jpg\n"
"D         banana.jpg\n"
"$ svn commit -m \"Delete useless file.\"\n"
"Deleting       banana.jpg\n"
"svn: Commit failed (details follow):\n"
"svn: DELETE of\n"
"'/repos/project/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc35d/banana.jpg':\n"
"423 Locked (http://svn.example.com)\n"
"$\n"
msgstr ""
"\n"
"$ svn delete banana.jpg\n"
"D         banana.jpg\n"
"$ svn commit -m \"Delete useless file.\"\n"
"Deleting       banana.jpg\n"
"svn: Commit failed (details follow):\n"
"svn: DELETE of\n"
"'/repos/project/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc35d/banana.jpg':\n"
"423 Locked (http://svn.example.com)\n"
"$\n"

#: build/en/book.xml:5939(para)
msgid "But Harry, after touching up the banana's shade of yellow, is able to commit his changes to the file. That's because he authenticates as the lock owner, and also because his working copy holds the correct lock token:"
msgstr "但是，当完成了香蕉的黄色渐变，就可以提交文件的修改，因为认证为锁定的拥有者，也因为他的工作拷贝有正确的锁定令牌："

#: build/en/book.xml:5944(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status\n"
"M    K banana.jpg\n"
"$ svn commit -m \"Make banana more yellow\"\n"
"Sending        banana.jpg\n"
"Transmitting file data .\n"
"Committed revision 2201.\n"
"$ svn status\n"
"$\n"
msgstr ""
"\n"
"$ svn status\n"
"M    K banana.jpg\n"
"$ svn commit -m \"Make banana more yellow\"\n"
"Sending        banana.jpg\n"
"Transmitting file data .\n"
"Committed revision 2201.\n"
"$ svn status\n"
"$\n"

#: build/en/book.xml:5955(para)
#, fuzzy
msgid "Notice that after the commit is finished, <command moreinfo=\"none\">svn status</command> shows that the lock token is no longer present in working copy. This is the standard behavior of <command moreinfo=\"none\">svn commit</command>—it searches the working copy (or list of targets, if you provide such a list) for local modifications, and sends all the lock tokens it encounters during this walk to the server as part of the commit transaction. After the commit completes successfully, all of the repository locks that were mentioned are released—<emphasis>even on files that weren't committed</emphasis>. This is meant to discourage users from being sloppy about locking, or from holding locks for too long. If Harry haphazardly locks thirty files in a directory named <filename moreinfo=\"none\">images</filename> because he's unsure of which files he needs to change, yet only only changes four of those file, when he runs <command moreinfo=\"none\">svn commit images</command>, the process will still release all thirty locks."
msgstr "需要注意到提交之后，<command moreinfo=\"none\">svn status</command>显示工作拷贝已经没有锁定令牌了，这是<command moreinfo=\"none\">svn commit</command>的标准行为方式：它会遍历工作拷贝（或者从目标列表，如果有列表的话），并且作为提交的一部分发送所有遇到的锁定令牌到服务器。当提交完全成功，前面用到的所有版本库锁定都会被释放—<emphasis>即使是没有提交的文件。</emphasis>这样的原因是不鼓励用户滥用锁定，或者是长时间的保持锁定。例如，假定Harry不小心锁定了<filename moreinfo=\"none\">images</filename>目录的30个文件，因为他不确定要修改什么文件，他最后只修改了四个文件，当他运行<command moreinfo=\"none\">svn commit images</command>，会释放所有的30个锁定。"

#: build/en/book.xml:5973(para)
#, fuzzy
msgid "This behavior of automatically releasing locks can be overridden with the <option>--no-unlock</option> option to <command moreinfo=\"none\">svn commit</command>. This is best used for those times when you want to commit changes, but still plan to make more changes and thus need to retain existing locks. You can also make this your default behavior by setting the <literal moreinfo=\"none\">no-unlock</literal> runtime configuration option (see <xref linkend=\"svn.advanced.confarea\"/>)."
msgstr "自动释放锁定的特性可以通过<command moreinfo=\"none\">svn commit</command>的<option>--no-unlock</option>选项关闭，当你要提交文件，同时期望继续修改而必须保留锁定时非常有用。这个特性也可以半永久性的设定，方法是设置运行中<filename moreinfo=\"none\">config</filename>文件（见<xref linkend=\"svn.advanced.confarea\"/>）的<literal moreinfo=\"none\">no-unlock = yes</literal>。"

#: build/en/book.xml:5982(para)
msgid "Of course, locking a file doesn't oblige one to commit a change to it. The lock can be released at any time with a simple <command moreinfo=\"none\">svn unlock</command> command:"
msgstr "当然，锁定一个文件不会强制一个人要提交修改，任何时候都可以通过运行<command moreinfo=\"none\">svn unlock</command>命令释放锁定："

#: build/en/book.xml:5986(screen)
#, no-wrap
msgid ""
"\n"
"$ svn unlock banana.c\n"
"'banana.c' unlocked.\n"
msgstr ""
"\n"
"$ svn unlock banana.c\n"
"'banana.c' unlocked.\n"

#: build/en/book.xml:5995(title)
msgid "Discovering locks"
msgstr "发现锁定"

#: build/en/book.xml:5997(para)
msgid "When a commit fails due to someone else's locks, it's fairly easy to learn about them. The easiest of these is <command moreinfo=\"none\">svn status --show-updates</command>:"
msgstr "最明显的方式就是因为锁定而不能提交一个文件，最简单的方式是<command moreinfo=\"none\">svn status --show-updates</command>："

#: build/en/book.xml:6001(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status -u\n"
"M              23   bar.c\n"
"M    O         32   raisin.jpg\n"
"       *       72   foo.h\n"
"Status against revision:     105\n"
"$\n"
msgstr ""
"\n"
"$ svn status -u\n"
"M              23   bar.c\n"
"M    O         32   raisin.jpg\n"
"       *       72   foo.h\n"
"Status against revision:     105\n"
"$\n"

#: build/en/book.xml:6010(para)
msgid "In this example, Sally can see not only that her copy of <filename moreinfo=\"none\">foo.h</filename> is out-of-date, but that one of the two modified files she plans to commit is locked in the repository. The <literal moreinfo=\"none\">O</literal> symbol stands for <quote>Other</quote>, meaning that a lock exists on the file, and was created by somebody else. If she were to attempt a commit, the lock on <filename moreinfo=\"none\">raisin.jpg</filename> would prevent it. Sally is left wondering who made the lock, when, and why. Once again, <command moreinfo=\"none\">svn info</command> has the answers:"
msgstr "在这个例子里，Sally可以见到不仅她的<filename moreinfo=\"none\">foo.h</filename>是过期的，而且发现两个计划要提交的文件被锁定了。<literal moreinfo=\"none\">O</literal>符号表示其他人所订了文件。如果她尝试提交，<filename moreinfo=\"none\">raisin.jpg</filename>的锁定会阻止她，Sally会纳闷谁锁定了文件，什么时候，为什么。再一次，<command moreinfo=\"none\">svn info</command>拥有答案："

#: build/en/book.xml:6021(screen)
#, no-wrap
msgid ""
"\n"
"$ svn info http://svn.example.com/repos/project/raisin.jpg\n"
"Path: raisin.jpg\n"
"Name: raisin.jpg\n"
"URL: http://svn.example.com/repos/project/raisin.jpg\n"
"Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec\n"
"Revision: 105\n"
"Node Kind: file\n"
"Last Changed Author: sally\n"
"Last Changed Rev: 32\n"
"Last Changed Date: 2006-01-25 12:43:04 -0600 (Sun, 25 Jan 2006)\n"
"Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b\n"
"Lock Owner: harry\n"
"Lock Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)\n"
"Lock Comment (1 line):\n"
"Need to make a quick tweak to this image.\n"
"$\n"
msgstr ""
"\n"
"$ svn info http://svn.example.com/repos/project/raisin.jpg\n"
"Path: raisin.jpg\n"
"Name: raisin.jpg\n"
"URL: http://svn.example.com/repos/project/raisin.jpg\n"
"Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec\n"
"Revision: 105\n"
"Node Kind: file\n"
"Last Changed Author: sally\n"
"Last Changed Rev: 32\n"
"Last Changed Date: 2006-01-25 12:43:04 -0600 (Sun, 25 Jan 2006)\n"
"Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b\n"
"Lock Owner: harry\n"
"Lock Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)\n"
"Lock Comment (1 line):\n"
"Need to make a quick tweak to this image.\n"
"$\n"

#: build/en/book.xml:6040(para)
#, fuzzy
msgid "Just as <command moreinfo=\"none\">svn info</command> can be used to examine objects in the working copy, it can also be used to examine objects in the repository. If the main argument to <command moreinfo=\"none\">svn info</command> is a working copy path, then all of the working copy's cached information is displayed; any mention of a lock means that the working copy is holding a lock token (if a file is locked by another user or in another working copy, <command moreinfo=\"none\">svn info</command> on a working copy path will show no lock information at all). If the main argument to <command moreinfo=\"none\">svn info</command> is a URL, then the information reflects the latest version of an object in the repository, and any mention of a lock describes the current lock on the object."
msgstr "就像<command moreinfo=\"none\">svn info</command>可以检验工作拷贝的对象，它也可以检验版本库的对象，如果<command moreinfo=\"none\">svn info</command>的主要参数工作拷贝路径，所有工作拷贝的缓存信息都会显示，发现了锁定就意味着工作拷贝拥有锁定令牌（如果一个文件被另一个用户在另一个工作拷贝锁定，工作拷贝路径上运行<command moreinfo=\"none\">svn info</command>不会显示锁定信息）。如果<command moreinfo=\"none\">svn info</command>的主参数是URL，就会反映版本库中最新版本的对象信息，任何对锁定的提及描述了当前对象的锁定。"

#: build/en/book.xml:6054(para)
msgid "So in this particular example, Sally can see that Harry locked the file on February 16th to <quote>make a quick tweak</quote>. It being June, she suspects that he probably forgot all about the lock. She might phone Harry to complain and ask him to release the lock. If he's unavailable, she might try to forcibly break the lock herself or ask an administrator to do so."
msgstr "所以在这个特定的例子里，Sally可以看到Harry在二月十六日为了<quote>做修改</quote>而锁定了这个文件，现在已经六月了，她怀疑他可能是忘记了这个锁定，她会打电话给Harry去询问他应该释放这个锁定，如果他不再，她就要自己强制解除这个锁定或者是找管理员去做。"

#: build/en/book.xml:6066(title)
msgid "Breaking and stealing locks"
msgstr "解除和偷窃锁定"

#: build/en/book.xml:6068(para)
#, fuzzy
msgid "A repository lock isn't sacred—in Subversion's default configuration state, locks can be released not only by the person who created them, but by anyone at all. When somebody other than the original lock creator destroys a lock, we refer to this as <firstterm>breaking</firstterm> the lock."
msgstr "版本库锁定并不是神圣不可侵犯的，不只是创建者可以释放锁定，任何人都可以。当有其他人期望消灭锁定时，我们称之为<firstterm>打破</firstterm>锁定。"

#: build/en/book.xml:6075(para)
msgid "From the administrator's chair, it's simple to break locks. The <command moreinfo=\"none\">svnlook</command> and <command moreinfo=\"none\">svnadmin</command> programs have the ability to display and remove locks directly from the repository. (For more information about these tools, see <xref linkend=\"svn.reposadmin.maint.tk\"/>.)"
msgstr "从管理员的位子上很容易打破锁定，<command moreinfo=\"none\">svnlook</command>和<command moreinfo=\"none\">svnadmin</command>程序都有能力从版本库直接显示和删除锁定。（关于这些工具的信息可以看<xref linkend=\"svn.reposadmin.maint.tk\"/>。）"

#: build/en/book.xml:6082(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin lslocks /usr/local/svn/repos\n"
"Path: /project2/images/banana.jpg\n"
"UUID Token: opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923\n"
"Owner: frank\n"
"Created: 2006-06-15 13:29:18 -0500 (Thu, 15 Jun 2006)\n"
"Expires: \n"
"Comment (1 line):\n"
"Still improving the yellow color.\n"
"\n"
"Path: /project/raisin.jpg\n"
"UUID Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b\n"
"Owner: harry\n"
"Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)\n"
"Expires: \n"
"Comment (1 line):\n"
"Need to make a quick tweak to this image.\n"
"\n"
"$ svnadmin rmlocks /usr/local/svn/repos /project/raisin.jpg\n"
"Removed lock on '/project/raisin.jpg'.\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin lslocks /usr/local/svn/repos\n"
"Path: /project2/images/banana.jpg\n"
"UUID Token: opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923\n"
"Owner: frank\n"
"Created: 2006-06-15 13:29:18 -0500 (Thu, 15 Jun 2006)\n"
"Expires: \n"
"Comment (1 line):\n"
"Still improving the yellow color.\n"
"\n"
"Path: /project/raisin.jpg\n"
"UUID Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b\n"
"Owner: harry\n"
"Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006)\n"
"Expires: \n"
"Comment (1 line):\n"
"Need to make a quick tweak to this image.\n"
"\n"
"$ svnadmin rmlocks /usr/local/svn/repos /project/raisin.jpg\n"
"Removed lock on '/project/raisin.jpg'.\n"
"$\n"

#: build/en/book.xml:6105(para)
#, fuzzy
msgid "The more interesting option is allowing users to break each other's locks over the network. To do this, Sally simply needs to pass the <option>--force</option> to the unlock command:"
msgstr "更有趣的选项是允许用户互相打破锁定，为此只需要使用unlock命令的<option>--force</option>选项："

#: build/en/book.xml:6110(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status -u\n"
"M              23   bar.c\n"
"M    O         32   raisin.jpg\n"
"       *       72   foo.h\n"
"Status against revision:     105\n"
"$ svn unlock raisin.jpg\n"
"svn: 'raisin.jpg' is not locked in this working copy\n"
"$ svn info raisin.jpg | grep URL\n"
"URL: http://svn.example.com/repos/project/raisin.jpg\n"
"$ svn unlock http://svn.example.com/repos/project/raisin.jpg\n"
"svn: Unlock request failed: 403 Forbidden (http://svn.example.com)\n"
"$ svn unlock --force http://svn.example.com/repos/project/raisin.jpg\n"
"'raisin.jpg' unlocked.\n"
"$\n"
msgstr ""
"\n"
"$ svn status -u\n"
"M              23   bar.c\n"
"M    O         32   raisin.jpg\n"
"       *       72   foo.h\n"
"Status against revision:     105\n"
"$ svn unlock raisin.jpg\n"
"svn: 'raisin.jpg' is not locked in this working copy\n"
"$ svn info raisin.jpg | grep URL\n"
"URL: http://svn.example.com/repos/project/raisin.jpg\n"
"$ svn unlock http://svn.example.com/repos/project/raisin.jpg\n"
"svn: Unlock request failed: 403 Forbidden (http://svn.example.com)\n"
"$ svn unlock --force http://svn.example.com/repos/project/raisin.jpg\n"
"'raisin.jpg' unlocked.\n"
"$\n"

#: build/en/book.xml:6127(para)
#, fuzzy
msgid "Now, Sally's initial attempt to unlock failed because she ran <command moreinfo=\"none\">svn unlock</command> directly on her working copy of the file, and no lock token was present. To remove the lock directly from the repository, she needs to pass a URL to <command moreinfo=\"none\">svn unlock</command>. Her first attempt to unlock the URL fails, because she can't authenticate as the lock owner (nor does she have the lock token). But when she passes <option>--force</option>, the authentication and authorization requirements are ignored, and the remote lock is broken."
msgstr "Sally初始的unlock命令失败了，因为她直接在自己的工作拷贝上运行了<command moreinfo=\"none\">svn unlock</command>，而这里没有锁定令牌。为了直接从版本库删除锁定，她需要给<command moreinfo=\"none\">svn unlock</command>传递URL参数，她的这一次尝试又失败了，因为她不是锁定的拥有者（也没有锁定令牌）。当她使用了<option>--force</option>选项后，认证和授权的要求被忽略了，远程的锁定被打破了。"

#: build/en/book.xml:6138(para)
#, fuzzy
msgid "Of course, simply breaking a lock may not be enough. In the running example, Sally may not only want to break Harry's long-forgotten lock, but re-lock the file for her own use. She can accomplish this by running <command moreinfo=\"none\">svn unlock --force</command> and then <command moreinfo=\"none\">svn lock</command> back-to-back, but there's a small chance that somebody else might lock the file between the two commands. The simpler thing to is <firstterm>steal</firstterm> the lock, which involves breaking and re-locking the file all in one atomic step. To do this, Sally passes the <option>--force</option> option to <command moreinfo=\"none\">svn lock</command>:"
msgstr "当然，简单的打破锁定也许还不够，在这个例子里，Sally不仅想要打破Harry遗忘的锁定，她也希望自己重新锁定。她可以通过运行<command moreinfo=\"none\">svn unlock --force</command>紧接着<command moreinfo=\"none\">svn lock</command>，但是有可能有人在这两次命令之间锁定了文件，最简单的方式是<firstterm>窃取</firstterm>这个锁定，将打破和重新锁定变成一种原子操作，为此需要运行<command moreinfo=\"none\">svn lock</command>加<option>--force</option>选项："

#: build/en/book.xml:6150(screen)
#, no-wrap
msgid ""
"\n"
"$ svn lock raisin.jpg\n"
"svn: Lock request failed: 423 Locked (http://svn.example.com)\n"
"$ svn lock --force raisin.jpg\n"
"'raisin.jpg' locked by user 'sally'.\n"
"$\n"
msgstr ""
"\n"
"$ svn lock raisin.jpg\n"
"svn: Lock request failed: 423 Locked (http://svn.example.com)\n"
"$ svn lock --force raisin.jpg\n"
"'raisin.jpg' locked by user 'sally'.\n"
"$\n"

#: build/en/book.xml:6158(para)
msgid "In any case, whether the lock is broken or stolen, Harry may be in for a surprise. Harry's working copy still contains the original lock token, but that lock no longer exists. The lock token is said to be <firstterm>defunct</firstterm>. The lock represented by the lock-token has either been broken (no longer in the repository), or stolen (replaced with a different lock). Either way, Harry can see this by asking <command moreinfo=\"none\">svn status</command> to contact the repository:"
msgstr "在任何情况下，无论锁定被打破还是窃取，Harry都会感到惊讶。Harry的工作拷贝还保留有原来的锁定令牌，但是锁定已经不存在了，锁定令牌可以说已经<firstterm>死掉了</firstterm>。锁定令牌指代的锁定被打破（版本库中不再存在）或者是窃取了（被另一个锁定代替了），任何一种情况下，Harry都可以使用<command moreinfo=\"none\">svn status</command>询问版本库："

#: build/en/book.xml:6168(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status\n"
"     K raisin.jpg\n"
"$ svn status -u\n"
"     B         32   raisin.jpg\n"
"$ svn update\n"
"  B  raisin.jpg\n"
"$ svn status\n"
"$\n"
msgstr ""
"\n"
"$ svn status\n"
"     K raisin.jpg\n"
"$ svn status -u\n"
"     B         32   raisin.jpg\n"
"$ svn update\n"
"  B  raisin.jpg\n"
"$ svn status\n"
"$\n"

#: build/en/book.xml:6179(para)
msgid "If the repository lock was broken, then <command moreinfo=\"none\">svn status --show-updates</command> displays a <literal moreinfo=\"none\">B</literal> (Broken) symbol next to the file. If a new lock exists in place of the old one, then a <literal moreinfo=\"none\">T</literal> (sTolen) symbol is shown. Finally, <command moreinfo=\"none\">svn update</command> notices any defunct lock tokens and removes them from the working copy."
msgstr "如果版本库锁定被打破了，<command moreinfo=\"none\">svn status --show-updates</command>会在文件旁边显示一个<literal moreinfo=\"none\">B</literal> (Broken)。如果有一个新的锁，就会显示一个<literal moreinfo=\"none\">T</literal> (sTolen)符号。最终，<command moreinfo=\"none\">svn update</command>会注意到所有死掉的锁定并且把它们从工作拷贝中删除掉。"

#: build/en/book.xml:6188(title)
msgid "Locking Policies"
msgstr "锁定策略"

#: build/en/book.xml:6190(para)
#, fuzzy
msgid "Different systems have different notions of how strict a lock should be. Some folks argue that locks must be strictly enforced at all costs, releasable only by the original creator or administrator. They argue that if anyone can break a lock, then chaos runs rampant and the whole point of locking is defeated. The other side argues that locks are first and foremost a communication tool. If users are constantly breaking each others' locks, then it represents a cultural failure within the team and the problem falls outside the scope of software enforcement."
msgstr "不同的系统有不同的锁定限制程度的观念。有些人认为锁定必须不顾任何代价的严格执行，只有原始的创建者和管理员可以释放。他们认为如果有人打破了锁定，混乱就会放任，锁定就完全失去了意义。这些人认为锁定是第一个和最首要的交流工具，如果用户经常的打破别人的锁定，代表了团队的文化失败和软件之外的问题。"

#: build/en/book.xml:6201(para)
#, fuzzy
msgid "Subversion defaults to the <quote>softer</quote> approach, but still allows administrators to create stricter enforcement policies through the use of hook scripts. In particular, the <filename moreinfo=\"none\">pre-lock</filename> and <filename moreinfo=\"none\">pre-unlock</filename> hooks allow administrators to decide when lock creation and lock releases are allowed to happen. Depending on whether or not a lock already exists, these two hooks can decide whether or not to allow a certain user to break or steal a lock. The <filename moreinfo=\"none\">post-lock</filename> and <filename moreinfo=\"none\">post-unlock</filename> hooks are also available, and can be used to send email after locking actions. To learn more about repository hooks, see <xref linkend=\"svn.reposadmin.create.hooks\"/>."
msgstr "Subversion缺省是比较<quote>宽松的</quote>方式，但也允许管理员创建钩子脚本来建立严格的控制策略。具体来说，<filename moreinfo=\"none\">pre-lock</filename>和<filename moreinfo=\"none\">pre-unlock</filename>钩子允许管理员决定什么时候创建和释放锁定。根据锁定是否已经存在，这两个钩子脚本可以决定是否允许特定用户打破或窃取锁定。也有<filename moreinfo=\"none\">post-lock</filename>和<filename moreinfo=\"none\">post-unlock</filename>钩子，可以用来发送锁定动作的通知邮件。"

#: build/en/book.xml:6221(title)
msgid "Lock Communication"
msgstr "锁定交流"

#: build/en/book.xml:6223(para)
msgid "We've seen how <command moreinfo=\"none\">svn lock</command> and <command moreinfo=\"none\">svn unlock</command> can be used to create, release, break, and steal locks. This satisfies the goal of serializing commit access to a file. But what about the larger problem of preventing wasted time?"
msgstr "我们已经见到了如何利用<command moreinfo=\"none\">svn lock</command>和<command moreinfo=\"none\">svn unlock</command>来创建、释放、打破和窃取锁定，这就满足了顺序访问文件的要求，但是浪费时间这个大问题该如何呢？"

#: build/en/book.xml:6229(para)
msgid "For example, suppose Harry locks an image file and then begins editing it. Meanwhile, miles away, Sally wants to do the same thing. She doesn't think to run <command moreinfo=\"none\">svn status --show-updates</command>, so she has no idea that Harry has already locked the file. She spends hours editing the file, and when she tries to commit her change, she discovers that either the file is locked or that she's out-of-date. Regardless, her changes aren't mergeable with Harry's. One of these two people has to throw away their work, and a lot of time has been wasted."
msgstr "例如，假定Harry锁定了一个图片，并开始编辑。同时，几英里之外的Sally希望做同样的工作，她没想到运行<command moreinfo=\"none\">svn status --show-updates</command>，她不知道Harry已经锁定了文件。她花费了数小时来修改文件，当她真被提交时发现文件已经被锁定或者是她的文件已经过期了。她的修改不能和Harry的合并，他们中的一人需要抛弃自己的工作，许多时间被浪费了。"

#: build/en/book.xml:6240(para)
#, fuzzy
msgid "Subversion's solution to this problem is to provide a mechanism to remind users that a file ought to be locked <emphasis>before</emphasis> the editing begins. The mechanism is a special property, <literal moreinfo=\"none\">svn:needs-lock</literal>. If that property is attached to a file (regardless of its value, which is irrelevant), then Subversion will try to use filesystem-level permissions to make the file read-only, unless, of course, the user has explicitly locked the file. When a lock-token is present (as a result of running <command moreinfo=\"none\">svn lock</command>), the file becomes read-write. When the lock is released, the file becomes read-only again."
msgstr "这个属性用来标示这个文件在编辑之前需要锁定，属性值无所谓，Subversion会规格化为<literal moreinfo=\"none\">*</literal>。当有这个值时，<emphasis>除非</emphasis>用户锁定这个文件，否则文件一直是只读的。当得到一个锁定令牌（运行<command moreinfo=\"none\">svn lock</command>的结果），文件变成可读写，当释放这个锁后，文件又变成只读。"

#: build/en/book.xml:6253(para)
#, fuzzy
msgid "The theory, then, is that if the image file has this property attached, then Sally would immediately notice something is strange when she opens the file for editing. Many applications alert users immediately when a read-only file is opened for editing. And nearly all applications would at least prevent her from saving changes to the file. This reminds her to lock the file before editing, whereby she discovers the pre-existing lock:"
msgstr "根据这个原理，如果一个图像文件有这个属性，Sally就会立刻注意到打开的文件有些特别，她的程序将不能保存修改，或者（更好的情况）是告诉她文件只读，这提醒了她编辑之前需要锁定文件，这样她就发现了原来存在的锁定："

#: build/en/book.xml:6262(screen)
#, no-wrap
msgid ""
"\n"
"$ /usr/local/bin/gimp raisin.jpg\n"
"gimp: error: file is read-only!\n"
"$ ls -l raisin.jpg\n"
"-r--r--r--   1 sally   sally   215589 Jun  8 19:23 raisin.jpg\n"
"$ svn lock raisin.jpg\n"
"svn: Lock request failed: 423 Locked (http://svn.example.com)\n"
"$ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock\n"
"Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b\n"
"Lock Owner: harry\n"
"Lock Created: 2006-06-08 07:29:18 -0500 (Thu, 08 June 2006)\n"
"Lock Comment (1 line):\n"
"Making some tweaks.  Locking for the next two hours.\n"
"$\n"
msgstr ""
"\n"
"$ /usr/local/bin/gimp raisin.jpg\n"
"gimp: error: file is read-only!\n"
"$ ls -l raisin.jpg\n"
"-r--r--r--   1 sally   sally   215589 Jun  8 19:23 raisin.jpg\n"
"$ svn lock raisin.jpg\n"
"svn: Lock request failed: 423 Locked (http://svn.example.com)\n"
"$ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock\n"
"Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b\n"
"Lock Owner: harry\n"
"Lock Created: 2006-06-08 07:29:18 -0500 (Thu, 08 June 2006)\n"
"Lock Comment (1 line):\n"
"Making some tweaks.  Locking for the next two hours.\n"
"$\n"

#: build/en/book.xml:6279(para)
#, fuzzy
msgid "Users and administrators alike are encouraged to attach the <literal moreinfo=\"none\">svn:needs-lock</literal> property to any file which cannot be contextually merged. This is the primary technique for encouraging good locking habits and preventing wasted effort."
msgstr "作为一个<quote>最佳实践</quote>，用户和管理员都应该给不能根据上下文的文件添加<literal moreinfo=\"none\">svn:needs-lock</literal>属性，这是鼓励好的锁定习惯和防止浪费的主要技术手段。"

#: build/en/book.xml:6286(para)
msgid "Note that this property is a communication tool which works independently from the locking system. In other words, any file can be locked, whether or not this property is present. And conversely, the presence of this property doesn't make the repository require a lock when committing."
msgstr "需要注意到这个属性是依赖于锁定系统的交流工具，不管是否有这个属性，文件都可以锁定。相反的，无论有没有这个属性，并不会要求提交需要首先锁定文件。"

#: build/en/book.xml:6302(para)
msgid "Except, perhaps, a classic Vulcan mind-meld."
msgstr ""

#: build/en/book.xml:6293(para)
#, fuzzy
msgid "Unfortunately, the system isn't flawless. It's possible that even when a file has the property, the read-only reminder won't always work. Sometimes applications misbehave and <quote>hijack</quote> the read-only file, silently allowing users to edit and save the file anyway. There's not much that Subversion can do in this situation—at the end of the day, there's simply no substitution for good interpersonal communication. <placeholder-1/>"
msgstr "这个系统并不是毫无瑕疵，即使有这个属性，只读提醒也有可能失效。有些程序<quote>偷偷的篡改了</quote>文件的只读属性，悄无声息的允许用户编辑和保存文件，不幸的是，Subversion对此无能为力。"

#: build/en/book.xml:6314(title)
msgid "Externals Definitions"
msgstr "外部定义"

#: build/en/book.xml:6316(para)
msgid "Sometimes it is useful to construct a working copy that is made out of a number of different checkouts. For example, you may want different subdirectories to come from different locations in a repository, or perhaps from different repositories altogether. You could certainly setup such a scenario by hand—using <command moreinfo=\"none\">svn checkout</command> to create the sort of nested working copy structure you are trying to achieve. But if this layout is important for everyone who uses your repository, every other user will need to perform the same checkout operations that you did."
msgstr "有时候创建一个由多个不同检出得到的工作拷贝是非常有用的，举个例子，你或许希望不同的子目录来自不同的版本库位置，或者是不同的版本库。你可以手工设置这样一个工作拷贝—使用<command moreinfo=\"none\">svn checkout</command>来创建这种你需要的嵌套的工作拷贝结构。但是如果这个结构对所有的用户是很重要的，每个用户需要执行同样的检出操作。"

#: build/en/book.xml:6327(para)
#, fuzzy
msgid "Fortunately, Subversion provides support for <firstterm>externals definitions</firstterm>. An externals definition is a mapping of a local directory to the URL—and possibly a particular revision—of a versioned directory. In Subversion, you declare externals definitions in groups using the <literal moreinfo=\"none\">svn:externals</literal> property. You can create or modify this property using <command moreinfo=\"none\">svn propset</command> or <command moreinfo=\"none\">svn propedit</command> (see <xref linkend=\"svn.advanced.props.manip\"/>). It can be set on any versioned directory, and its value is a multi-line table of subdirectories (relative to the versioned directory on which the property is set), optional revision flags, and a fully qualified, absolute Subversion repository URLs."
msgstr "很幸运，Subversion提供了<firstterm>外部定义</firstterm>的支持，一个外部定义是一个本地路经到URL的影射—也有可能一个特定的修订版本—一些版本化的资源。在Subversion你可以使用<literal moreinfo=\"none\">svn:externals</literal>属性来定义外部定义，你可以用<command moreinfo=\"none\">svn propset</command>或<command moreinfo=\"none\">svn propedit</command>（见<xref linkend=\"svn.advanced.props.why\"/>）创建和修改这个属性。它可以设置到任何版本化的路经，它的值是一个多行的子目录和完全有效的Subversion版本库URL的列表（相对于设置属性的版本化目录）。"

#: build/en/book.xml:6341(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propget svn:externals calc\n"
"third-party/sounds             http://sounds.red-bean.com/repos\n"
"third-party/skins              http://skins.red-bean.com/repositories/skinproj\n"
"third-party/skins/toolkit -r21 http://svn.red-bean.com/repos/skin-maker\n"
msgstr ""
"\n"
"$ svn propget svn:externals calc\n"
"third-party/sounds             http://sounds.red-bean.com/repos\n"
"third-party/skins              http://skins.red-bean.com/repositories/skinproj\n"
"third-party/skins/toolkit -r21 http://svn.red-bean.com/repos/skin-maker\n"

#: build/en/book.xml:6348(para)
msgid "The convenience of the <literal moreinfo=\"none\">svn:externals</literal> property is that once it is set on a versioned directory, everyone who checks out a working copy with that directory also gets the benefit of the externals definition. In other words, once one person has made the effort to define those nested working copy checkouts, no one else has to bother—Subversion will, upon checkout of the original working copy, also checkout the external working copies."
msgstr "<literal moreinfo=\"none\">svn:externals</literal>的方便之处是这个属性设置到版本化的路径后，任何人可以从那个目录取出一个工作拷贝，同样得到外部定义的好处。换句话说，一旦一个人努力来定义这些嵌套的工作拷贝检出，其他任何人不需要再麻烦了—Subversion会在原先的工作拷贝检出之后，也会检出外部工作拷贝。"

#: build/en/book.xml:6358(para)
msgid "The relative target subdirectories of externals definitions needn't already exist on your or other users' systems—Subversion will create them when it checks out the external working copy. In fact, you should <emphasis>not</emphasis> try to use externals definitions to populate directories that are already under version control."
msgstr ""

#: build/en/book.xml:6367(para)
msgid "Note the previous externals definition example. When someone checks out a working copy of the <filename moreinfo=\"none\">calc</filename> directory, Subversion also continues to checkout the items found in its externals definition."
msgstr "注意前一个外部定义实例，当有人取出了一个<filename moreinfo=\"none\">calc</filename>目录的工作拷贝，Subversion会继续来取出外部定义的项目。"

#: build/en/book.xml:6372(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://svn.example.com/repos/calc\n"
"A  calc\n"
"A  calc/Makefile\n"
"A  calc/integer.c\n"
"A  calc/button.c\n"
"Checked out revision 148.\n"
"\n"
"Fetching external item into calc/third-party/sounds\n"
"A  calc/third-party/sounds/ding.ogg\n"
"A  calc/third-party/sounds/dong.ogg\n"
"A  calc/third-party/sounds/clang.ogg\n"
"…\n"
"A  calc/third-party/sounds/bang.ogg\n"
"A  calc/third-party/sounds/twang.ogg\n"
"Checked out revision 14.\n"
"\n"
"Fetching external item into calc/third-party/skins\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout http://svn.example.com/repos/calc\n"
"A  calc\n"
"A  calc/Makefile\n"
"A  calc/integer.c\n"
"A  calc/button.c\n"
"Checked out revision 148.\n"
"\n"
"Fetching external item into calc/third-party/sounds\n"
"A  calc/third-party/sounds/ding.ogg\n"
"A  calc/third-party/sounds/dong.ogg\n"
"A  calc/third-party/sounds/clang.ogg\n"
"…\n"
"A  calc/third-party/sounds/bang.ogg\n"
"A  calc/third-party/sounds/twang.ogg\n"
"Checked out revision 14.\n"
"\n"
"Fetching external item into calc/third-party/skins\n"
"…\n"

#: build/en/book.xml:6393(para)
msgid "If you need to change the externals definition, you can do so using the regular property modification subcommands. When you commit a change to the <literal moreinfo=\"none\">svn:externals</literal> property, Subversion will synchronize the checked-out items against the changed externals definition when you next run <command moreinfo=\"none\">svn update</command>. The same thing will happen when others update their working copies and receive your changes to the externals definition."
msgstr "如果你希望修改外部定义，你可以使用普通的属性修改子命令，当你提交一个<literal moreinfo=\"none\">svn:externals</literal>属性修改后，当你运行<command moreinfo=\"none\">svn update</command>时，Subversion会根据修改的外部定义同步检出的项目，同样的事情也会发生在别人更新他们的工作拷贝接受你的外部定义修改时。"

#: build/en/book.xml:6403(para)
#, fuzzy
msgid "Because the <literal moreinfo=\"none\">svn:externals</literal> property has a multiline value, we strongly recommend that you use <command moreinfo=\"none\">svn propedit</command> instead of <command moreinfo=\"none\">svn propset</command>."
msgstr "为了设置或得到一个属性名称，使用<command moreinfo=\"none\">svn propset</command>和<command moreinfo=\"none\">svn propget</command>子命令，列出对象所有的属性，使用<command moreinfo=\"none\">svn proplist</command>。"

#: build/en/book.xml:6410(para)
#, fuzzy
msgid "You should strongly consider using explicit revision numbers in all of your externals definitions. Doing so means that you get to decide when to pull down a different snapshot of external information, and exactly which snapshot to pull. Besides avoiding the surprise of getting changes to third-party repositories that you might not have any control over, using explicit revision numbers also means that as you backdate your working copy to a previous revision, your externals definitions will also revert to the way they looked in that previous revision, which in turn means that the external working copies will be updated to match they way <emphasis>they</emphasis> looked back when your repository was at that previous revision. For software projects, this could be the difference between a successful and a failed build of an older snapshot of your complex codebase."
msgstr "你一定要要考虑在所有的外部定义中使用明确的修订版本，这样做意味着你已经决定了何时拖出外部信息不同的快照，和精确的拖出哪个快照。除了不会受到第三方版本库的意外修改的影响以外，当你的工作拷贝回溯到以前的版本库时，使用明确的修订版本号会让外部定义回到以前的那个修订版本，也意味着外部定义的工作拷贝更新会匹配以前修订版本的样子。对于软件项目，这可能是编译复杂代码基的老快照成功和失败的区别。"

#: build/en/book.xml:6427(para)
msgid "The <command moreinfo=\"none\">svn status</command> command also recognizes externals definitions, displaying a status code of <literal moreinfo=\"none\">X</literal> for the disjoint subdirectories into which externals are checked out, and then recursing into those subdirectories to display the status of the external items themselves."
msgstr "<command moreinfo=\"none\">svn status</command>命令也认识外部定义，会为外部定义的子目录显示<literal moreinfo=\"none\">X</literal>状态码，然后迭代这些子目录来显示外部项目的子目录状态信息。"

#: build/en/book.xml:6434(para)
msgid "The support that exists for externals definitions in Subversion today can be a little misleading, though. First, an externals definition can only point to directories, not files. Second, the externals definition cannot point to relative paths (paths like <filename moreinfo=\"none\">../../skins/myskin</filename>). Third, the working copies created via the externals definition support are still disconnected from the primary working copy (on whose versioned directories the <literal moreinfo=\"none\">svn:externals</literal> property was actually set). And Subversion still only truly operates on non-disjoint working copies. So, for example, if you want to commit changes that you've made in one or more of those external working copies, you must run <command moreinfo=\"none\">svn commit</command> explicitly on those working copies—committing on the primary working copy will not recurse into any external ones."
msgstr "Subversion目前对外部定义的支持可能会引起误导，首先，一个外部定义只可以指向目录，而不是文件。第二，外部定义不可以指向相对路径（如<filename moreinfo=\"none\">../../skins/myskin</filename>）。第三，通过外部定义创建的工作拷贝与主工作拷贝没有连接，所以举个例子，如果你希望提交一个或多个外部定义的拷贝，你必须在这些工作拷贝显示的运行<command moreinfo=\"none\">svn commit</command>—对主工作拷贝的提交不会迭代到外部定义的部分。"

#: build/en/book.xml:6450(para)
#, fuzzy
msgid "Also, since the definitions themselves use absolute URLs, moving or copying a directory to which they are attached will not affect what gets checked out as an external (though the relative local target subdirectory will, of course, move with renamed directory). This can be confusing—even frustrating—in certain situations. For example, say you have a top-level directory named <filename moreinfo=\"none\">my-project</filename>, and you've created an externals definition on one of its subdirectories (<filename moreinfo=\"none\">my-project/some-dir</filename>) which tracks the latest revision of another of its subdirectories (<filename moreinfo=\"none\">my-project/external-dir</filename>)."
msgstr "另外，因为定义本身使用绝对路径，移动和拷贝路径他们附着的路径不会影响他们作为外部的检出（尽管相对的本地目标子目录会这样，当然，根据重命名的目录）。这看起来有些迷惑—甚至让人沮丧—在特定情形。举个例子，如果你在<filename moreinfo=\"none\">/trunk</filename>开发线对一个目录使用外部定义，指向同一条线上的其他区域，然后使用<command moreinfo=\"none\">svn copy</command>把分支开发线拷贝到<filename moreinfo=\"none\">/branches/my-branch</filename>这个新位置，这个项目新分支的外部定义仍然指向<filename moreinfo=\"none\">/trunk</filename>版本化资源。另外，需要意识到如果你需要一个重新规划你的工作拷贝的父目录（使用<command moreinfo=\"none\">svn switch --relocate</command>），外部定义<emphasis>不</emphasis>会重新选择父目录。"

#: build/en/book.xml:6463(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://svn.example.com/projects .\n"
"A    my-project\n"
"A    my-project/some-dir\n"
"A    my-project/external-dir\n"
"…\n"
"Fetching external item into 'my-project/some-dir/subdir'\n"
"Checked out external at revision 11.\n"
"\n"
"Checked out revision 11.\n"
"$ svn propget svn:externals my-project/some-dir\n"
"subdir http://svn.example.com/projects/my-project/external-dir\n"
"\n"
"$\n"
msgstr ""
"\n"
"$ svn checkout http://svn.example.com/projects .\n"
"A    my-project\n"
"A    my-project/some-dir\n"
"A    my-project/external-dir\n"
"…\n"
"Fetching external item into 'my-project/some-dir/subdir'\n"
"Checked out external at revision 11.\n"
"\n"
"Checked out revision 11.\n"
"$ svn propget svn:externals my-project/some-dir\n"
"subdir http://svn.example.com/projects/my-project/external-dir\n"
"\n"
"$\n"

#: build/en/book.xml:6479(para)
msgid "Now you use <command moreinfo=\"none\">svn move</command> to rename the <filename moreinfo=\"none\">my-project</filename> directory. At this point, your externals definition will still refer to a path under the <filename moreinfo=\"none\">my-project</filename> directory, even though that directory no longer exists."
msgstr ""

#: build/en/book.xml:6485(screen)
#, no-wrap
msgid ""
"\n"
"$ svn move -q my-project renamed-project\n"
"$ svn commit -m \"Rename my-project to renamed-project.\"\n"
"Deleting       my-project\n"
"Adding         my-renamed-project\n"
"\n"
"Committed revision 12.\n"
"$ svn update\n"
"\n"
"Fetching external item into 'renamed-project/some-dir/subdir'\n"
"svn: Target path does not exist\n"
"$\n"
msgstr ""
"\n"
"$ svn move -q my-project renamed-project\n"
"$ svn commit -m \"Rename my-project to renamed-project.\"\n"
"Deleting       my-project\n"
"Adding         my-renamed-project\n"
"\n"
"Committed revision 12.\n"
"$ svn update\n"
"\n"
"Fetching external item into 'renamed-project/some-dir/subdir'\n"
"svn: Target path does not exist\n"
"$\n"

#: build/en/book.xml:6499(para)
msgid "Also, the fact that externals definitions use absolute URLs can cause problems with repositories that are available via multiple URL schemes. For example, if your Subversion server is configured to allow everyone to checkout the repository over <literal moreinfo=\"none\">http://</literal> or <literal moreinfo=\"none\">https://</literal>, but only allow commits to come in via <literal moreinfo=\"none\">https://</literal>, you have an interesting problem on your hands. If your externals definitions use the <literal moreinfo=\"none\">http://</literal> form of the repository URLs, you won't be able to commit anything from the working copies created by those externals. On the other hand, if they use the <literal moreinfo=\"none\">https://</literal> form of the URLs, anyone who might be checking out via <literal moreinfo=\"none\">http://</literal> because their client doesn't support <literal moreinfo=\"none\">https://</literal> will be unable to fetch the external items. Be aware, too, that if you need to re-parent your working copy (using <command moreinfo=\"none\">svn switch --relocate</command>), externals definitions will <emphasis>not</emphasis> also be re-parented."
msgstr ""

#: build/en/book.xml:6518(para)
msgid "Finally, there might be times when you would prefer that <command moreinfo=\"none\">svn</command> subcommands would not recognize or otherwise operate on the external working copies created as the result of externals definition handling. In those instances, you can pass the <option>--ignore-externals</option> option to the subcommand."
msgstr "最后，你或许经常希望<command moreinfo=\"none\">svn</command>子命令不会识别或其它作为外部定义处理的结果的外部工作拷贝上的操作，在这种情况下，你可以对子命令使用<option>--ignore-externals</option>选项。"

#: build/en/book.xml:6530(title)
msgid "Peg and Operative Revisions"
msgstr "Peg 算法和版本"

#: build/en/book.xml:6532(para)
#, fuzzy
msgid "We make use of the ability to copy, move, rename, and completely replace files and directories on our computers all the time. And your version control system shouldn't get in the way of your doing these things with your version-controlled files and directories, either. Subversion's file management support is quite liberating, affording almost as much flexibility for versioned files as you'd expect when manipulating your unversioned ones. But that flexibility means that across the lifetime of your repository, a given versioned object might have many paths, and a given path might represent several entirely different versioned objects. And this introduces a certain level of complexity to your interactions with those paths and objects."
msgstr "文件和目录的拷贝、改名和移动能力使你可以创建一个项目，然后删除它，然后在同一个位置添加一个新的—这是在我们的计算机中经常发生的操作，我们认为这些功能都是必然有的，Subversion很高兴你也是这么认为的，Subversion的文件管理操作是这样的开放，提供了几乎和普通文件一样的操作版本化文件的灵活性，但是灵活意味着在整个版本库的生命周期中，一个给定的版本化的资源可能会出现在许多不同的路径，一个给定的路径会展示给我们许多完全不同的版本化资源。当然这些功能也增加了你与这些路径和资源交互的难度。"

#: build/en/book.xml:6546(para)
#, fuzzy
msgid "Subversion is pretty smart about noticing when an object's version history includes such <quote>changes of address</quote>. For example, if you ask for the revision history log of a particular file that was renamed last week, Subversion happily provides all those logs—the revision in which the rename itself happened, plus the logs of relevant revisions both before and after that rename. So, most of the time, you don't even have to think about such things. But occasionally, Subversion needs your help to clear up ambiguities."
msgstr "Subversion可以非常聪明的注意到一个对象的版本历史变化包括一个<quote>地址改变</quote>，举个例子，如果你询问一个曾经上周改过名的文件的所有的日志信息，Subversion会很高兴提供所有的日志—重命名发生的修订版本，外加相关版本之前和之后的修订版本日志，所以大多数时间里，你不需要考虑这些事情，但是偶尔，Subversion会需要你的帮助来清除混淆。"

#: build/en/book.xml:6556(para)
#, fuzzy
msgid "The simplest example of this occurs when a directory or file is deleted from version control, and then a new directory or file is created with the same name and added to version control. Clearly the thing you deleted and the thing you later added aren't the same thing. They merely happen to have had the same path, <filename moreinfo=\"none\">/trunk/object</filename> for example. What, then, does it mean to ask Subversion about the history of <filename moreinfo=\"none\">/trunk/object</filename>? Are you asking about the thing currently at that location, or the old thing you deleted from that location? Are you asking about the operations that have happened to <emphasis>all</emphasis> the objects that have ever lived at that path? Clearly, Subversion needs a hint about what you really want."
msgstr "这个最简单的例子发生在当一个目录或者文件从版本控制中删除时，然后一个新的同样名字目录或者文件添加到版本控制，清除了你删除的东西，然后你添加的不是同样的东西，它们仅仅是有同样的路径，我们会把它叫做<filename moreinfo=\"none\">/trunk/object</filename>。什么，这意味着询问Subversion来查看<filename moreinfo=\"none\">/trunk/object</filename>的历史？你是询问当前这个位置的东西还是你在这个位置删除的那个对象？你是希望询问对这个对象的所有操作还是这个路径的所有对象？很明显，Subversion需要线索知道你真实的想法。"

#: build/en/book.xml:6578(para)
msgid "<quote>You're not supposed to name it. Once you name it, you start getting attached to it.</quote> — Mike Wazowski"
msgstr "<quote>你不是被期望去命名它，一旦你取了名字，你开始与之联系在一起。</quote> — Mike Wazowski"

#: build/en/book.xml:6570(para)
#, fuzzy
msgid "And thanks to moves, versioned object history can get far more twisted than that, even. For example, you might have a directory named <filename moreinfo=\"none\">concept</filename>, containing some nascent software project you've been toying with. Eventually, though, that project matures to the point that the idea seems to actually have some wings, so you do the unthinkable and decide to give the project a name. <placeholder-1/> Let's say you called your software Frabnaggilywort. At this point, it makes sense to rename the directory to reflect the project's new name, so <filename moreinfo=\"none\">concept</filename> is renamed to <filename moreinfo=\"none\">frabnaggilywort</filename>. Life goes on, Frabnaggilywort releases a 1.0 version, and is downloaded and used daily by hordes of people aiming to improve their lives."
msgstr "由于移动，版本化资源历史会变得非常扭曲。举个例子，你会有一个目录叫做<filename moreinfo=\"none\">concept</filename>，保存了一些你用来试验的初生的软件项目，最终，这个项目变得足够成熟，说明这个注意确实需要一些翅膀了，所以你决定给这个项目一个名字。 <footnote><placeholder-1/></footnote> 假定你叫你的软件为Frabnaggilywort，此刻，有必要把你的目录命名为反映项目名称的名字，所以<filename moreinfo=\"none\">concept</filename>改名为<filename moreinfo=\"none\">frabnaggilywort</filename>。生活还在继续，Frabnaggilywort发布了1.0版本，并且被许多希望改进他们生活的分散用户天天使用。"

#: build/en/book.xml:6590(para)
msgid "It's a nice story, really, but it doesn't end there. Entrepreneur that you are, you've already got another think in the tank. So you make a new directory, <filename moreinfo=\"none\">concept</filename>, and the cycle begins again. In fact, the cycle begins again many times over the years, each time starting with that old <filename moreinfo=\"none\">concept</filename> directory, then sometimes seeing that directory renamed as the idea cures, sometimes seeing it deleted when you scrap the idea. Or, to get really sick, maybe you rename <filename moreinfo=\"none\">concept</filename> to something else for a while, but later rename the thing back to <filename moreinfo=\"none\">concept</filename> for some reason."
msgstr "这是一个美好的故事，但是没有在这里结束，作为主办人，你一定想到了另一件事，所以你创建了一个目录叫做<filename moreinfo=\"none\">concept</filename>，周期重新开始。实际上，这个循环在几年里开始了多次，每一个想法从使用旧的<filename moreinfo=\"none\">concept</filename>目录开始，然后有时在想法成熟之后重新命名，有时你放弃了这个注意而删除了这个目录。或者更加变态一点，或许你把<filename moreinfo=\"none\">concept</filename>改成其他名字之后又因为一些原因重新改回<filename moreinfo=\"none\">concept</filename>。"

#: build/en/book.xml:6603(para)
msgid "When scenarios like these occur, attempting to instruct Subversion to work with these re-used paths can be a little like instructing a motorist in Chicago's West Suburbs to drive east down Roosevelt Road and turn left onto Main Street. In a mere twenty minutes, you can cross <quote>Main Street</quote> in Wheaton, Glen Ellyn, and Lombard. And no, they aren't the same street. Our motorist—and our Subversion—need a little more detail in order to do the right thing."
msgstr "当这样的情景发生时，指导Subversion工作在重新使用的路径上的尝试就像指导一个芝加哥西郊的乘客驾车到东面的罗斯福路并且左转到主大道。仅仅20分钟，你可以穿过惠顿、格伦埃林何朗伯德的<quote>主大道</quote>，但是它们不是一样的街道，我们的乘客—和我们的Subversion—需要更多的细节来做正确的事情。"

#: build/en/book.xml:6612(para)
#, fuzzy
msgid "In version 1.1, Subversion introduced a way for you to tell it exactly which Main Street you meant. It's called the <firstterm>peg revision</firstterm>, and it is a revision provided to Subversion for the sole purpose of identifying a unique line of history. Because at most one versioned object may occupy a path at any given time—or, more precisely, in any one revision—the combination of a path and a peg revision is all that is needed to refer to a specific line of history. Peg revisions are specified to the Subversion command-line client using <firstterm>at syntax</firstterm>, so called because the syntax involves appending an <quote>at sign</quote> (<literal moreinfo=\"none\">@</literal>) and the peg revision to the end of the path with which the revision is associated."
msgstr "在1.1版本，Subversion提供了一种方法来说明你所指是哪一个街道，叫做<firstterm>peg修订版本</firstterm>，这是一个提供给Subversion的一个区别一个独立历史线路的单独目的修订版本，因为一个版本化的文件会在任何时间占用某个路径—路径和peg修订版本的合并是可以指定一个历史的特定线路。Peg修订版本可以在Subversion命令行客户端中用<firstterm>at语法</firstterm>指定，之所以使用这个名称是因为会在关联的修订版本的路径后面追加一个<quote>at符号</quote>（<literal moreinfo=\"none\">@</literal>）。"

#: build/en/book.xml:6636(para)
msgid "606 N. Main Street, Wheaton, Illinois, is the home of the Wheaton History Center. Get it—<quote>History Center</quote>? It seemed appropriate…."
msgstr "伊利诺伊州惠顿主大道606号市惠顿离市中心，让它作为—<quote>历史中心</quote>？看起来是恰当的…。"

#: build/en/book.xml:6626(para)
#, fuzzy
msgid "But what of the <option>--revision (-r)</option> of which we've spoken so much in this book? That revision (or set of revisions) is called the <firstterm>operative revision</firstterm> (or <firstterm>operative revision range</firstterm>). Once a particular line of history has been identified using a path and peg revision, Subversion performs the requested operation using the operative revision(s). To map this to our Chicagoland streets analogy, if we are told to go to 606 N. Main Street in Wheaton, <placeholder-1/> we can think of <quote>Main Street</quote> as our path and <quote>Wheaton</quote> as our peg revision. These two pieces of information identify a unique path which can travelled (north or south on Main Street), and will keep us from travelling up and down the wrong Main Street in search of our destination. Now we throw in <quote>606 N.</quote> as our operative revision, of sorts, and we know <emphasis>exactly</emphasis> where to go."
msgstr "但是我们在本书多次提到的<option>--revision (-r)</option>到底是什么？修订版本（或者是修订版本集）叫做<firstterm>实施的修订版本</firstterm>（或者叫做<firstterm>实施的修订版本范围</firstterm>），一旦一个特定历史线路通过一个路径和peg修订版本指定，Subversion会使用实施的修订版本执行要求的操作。类似的，为了指出这个到我们芝加哥的道路，如果我们被告知到惠顿主大道606号， <footnote><placeholder-1/></footnote> 我们可以把<quote>主大道</quote>看作路径，把<quote>惠顿</quote>当作我们的peg修订版本。这两段信息确认了我们可以旅行（主大道的北方或南方）的唯一路径，也会保持我们不会在前前后后寻找目标时走到错误的主大道。现在我们把<quote>606 N.</quote>作为我们实施的修订版本，我们<emphasis>精确的</emphasis>知道到哪里。"

#: build/en/book.xml:6650(title)
msgid "The peg revision algorithm"
msgstr "Peg 版本算法"

#: build/en/book.xml:6652(para)
msgid "The Subversion command-line performs the peg revision algorithm any time it needs to resolve possible ambiguities in the paths and revisions provided to it. Here's an example of such an invocation for the purposes of illustrating that algorithm."
msgstr ""

#: build/en/book.xml:6659(replaceable)
msgid "command"
msgstr "command"

#: build/en/book.xml:6659(replaceable)
msgid "OPERATIVE-REV"
msgstr "OPERATIVE-REV"

#: build/en/book.xml:6659(replaceable)
msgid "PEG-REV"
msgstr "PEG-REV"

#: build/en/book.xml:6658(screen)
#, no-wrap
msgid ""
"\n"
"$ svn <placeholder-1/> -r <placeholder-2/> item@<placeholder-3/>\n"
msgstr ""
"\n"
"$ svn <placeholder-1/> -r <placeholder-2/> item@<placeholder-3/>\n"

#: build/en/book.xml:6662(para)
msgid "The algorithm has three simple steps:"
msgstr "此算法有三个简单步骤："

#: build/en/book.xml:6667(para)
#, fuzzy
msgid "Locate <replaceable>item</replaceable> in the revision identified by <replaceable>PEG-REV</replaceable>. There can be only one such object."
msgstr "来到修订版本<replaceable>PEG-REV</replaceable>，找到<replaceable>item</replaceable>，在版本库定位到一个唯一的对象。"

#: build/en/book.xml:6673(para)
#, fuzzy
msgid "Trace the object's history backwards (through any possible renames) to its ancestor in the revision <replaceable>OPERATIVE-REV</replaceable>."
msgstr "追踪对象的历史背景（通过任何可能的改名）来到修订版本<replaceable>OPERATIVE-REV</replaceable>的祖先。"

#: build/en/book.xml:6679(para)
#, fuzzy
msgid "Perform the requested action on that ancestor, wherever it is located, or whatever its name might be or have been at that time."
msgstr "对那个祖先执行请求的动作，无论它的位置，无论它是什么名字。"

#: build/en/book.xml:6686(para)
msgid "Note that even when you don't explicitly supply a peg revision or operative revision, they are still present. For your convenience, the default peg revision is <literal moreinfo=\"none\">BASE</literal> for working copy items and <literal moreinfo=\"none\">HEAD</literal> for repository URLs. And when no operative revision is provided, it defaults to being the same revision as the peg revision."
msgstr ""

#: build/en/book.xml:6696(para)
msgid "Say that long ago we created our repository, and in revision 1 added our first <filename moreinfo=\"none\">concept</filename> directory, plus an <filename moreinfo=\"none\">IDEA</filename> file in that directory talking about the concept. After several revisions in which real code was added and tweaked, we, in revision 20, renamed this directory to <filename moreinfo=\"none\">frabnaggilywort</filename>. By revision 27, we had a new concept, a new <filename moreinfo=\"none\">concept</filename> directory to hold it, and a new <filename moreinfo=\"none\">IDEA</filename> file to describe it. And then five years and twenty thousand revisions flew by, just like they would in any good romance story."
msgstr "也就是说很久以前我们创建了我们的版本库，在修订版本1添加我们第一个<filename moreinfo=\"none\">concept</filename>目录，并且在这个目录增加一个<filename moreinfo=\"none\">IDEA</filename>文件与concept相关，在几个修订版本之后，真实的代码被添加和修改，我们在修订版本20，修改这个目录为<filename moreinfo=\"none\">frabnaggilywort</filename>。通过修订版本27，我们有了一个新的概念，所以一个新的<filename moreinfo=\"none\">concept</filename>目录用来保存这些东西，一个新的<filename moreinfo=\"none\">IDEA</filename>文件来描述这个概念，然后经过5年20000个修订版本，就像他们都有一个非常浪漫的历史。"

#: build/en/book.xml:6707(para)
msgid "Now, years later, we wonder what the <filename moreinfo=\"none\">IDEA</filename> file looked like back in revision 1. But Subversion needs to know if we are asking about how the <emphasis>current</emphasis> file looked back in revision 1, or are we asking for the contents of whatever file lived at <filename moreinfo=\"none\">concepts/IDEA</filename> in revision 1? Certainly those questions have different answers, and because of peg revisions, you can ask either of them. To find out how the current <filename moreinfo=\"none\">IDEA</filename> file looked in that old revision, you run:"
msgstr "现在，一年之后，我们想知道<filename moreinfo=\"none\">IDEA</filename>在修订版本1时是什么样子，但是Subversion需要知道我们是想询问<emphasis>当前</emphasis>文件在修订版本1时的样子，还是希望知道<filename moreinfo=\"none\">concepts/IDEA</filename>在修订版本1时的那个文件？确定这些问题有不同的答案，并且因为peg修订版本，你可以用两种方式询问。为了知道当前的<filename moreinfo=\"none\">IDEA</filename>文件在旧版本1的样子，我们可以运行："

#: build/en/book.xml:6718(screen)
#, no-wrap
msgid ""
"\n"
"$ svn cat -r 1 concept/IDEA \n"
"svn: Unable to find repository location for 'concept/IDEA' in revision 1\n"
msgstr ""
"\n"
"$ svn cat -r 1 concept/IDEA \n"
"svn: Unable to find repository location for 'concept/IDEA' in revision 1\n"

#: build/en/book.xml:6723(para)
msgid "Of course, in this example, the current <filename moreinfo=\"none\">IDEA</filename> file didn't exist yet in revision 1, so Subversion gives an error. The command above is shorthand for a longer notation which explicitly lists a peg revision. The expanded notation is:"
msgstr "当然，在这个例子里，当前的<filename moreinfo=\"none\">IDEA</filename>文件在修订版本1中并不存在，所以Subversion给出一个错误，这个上面的命令是长的peg修订版本命令一个缩写，扩展的写法是："

#: build/en/book.xml:6729(screen)
#, no-wrap
msgid ""
"\n"
"$ svn cat -r 1 concept/IDEA@BASE\n"
"svn: Unable to find repository location for 'concept/IDEA' in revision 1\n"
msgstr ""
"\n"
"$ svn cat -r 1 concept/IDEA@BASE\n"
"svn: Unable to find repository location for 'concept/IDEA' in revision 1\n"

#: build/en/book.xml:6734(para)
msgid "And when executed, it has the expected results. Peg revisions generally default to a value of <literal moreinfo=\"none\">BASE</literal> (the revision currently present in the working copy) when applied to working copy paths, and of <literal moreinfo=\"none\">HEAD</literal> when applied to URLs."
msgstr "当执行时会有预料中的结果，当应用到工作拷贝路径时，Peg修订版本通常缺省值是<literal moreinfo=\"none\">BASE</literal>（在当前工作拷贝现在的修订版本），当应用到URL时，缺省值是<literal moreinfo=\"none\">HEAD</literal>。"

#: build/en/book.xml:6740(para)
msgid "The perceptive reader is probably wondering at this point if the peg revision syntax causes problems for working copy paths or URLs that actually have at signs in them. After all, how does <command moreinfo=\"none\">svn</command> know whether <literal moreinfo=\"none\">news@11</literal> is the name of a directory in my tree, or just a syntax for <quote>revision 11 of <filename moreinfo=\"none\">news</filename></quote>? Thankfully, while <command moreinfo=\"none\">svn</command> will always assume the latter, there is a trivial workaround. You need only append an at sign to the end of the path, such as <literal moreinfo=\"none\">news@11@</literal>. <command moreinfo=\"none\">svn</command> only cares about the last at sign in the argument, and it is not considered illegal to omit a literal peg revision specifier after that at sign. This workaround even applies to paths that end in an at sign—you would use <literal moreinfo=\"none\">filename@@</literal> to talk about a file named <filename moreinfo=\"none\">filename@</filename>."
msgstr ""

#: build/en/book.xml:6757(para)
msgid "Let's ask the other question, then—in revision 1, what were the contents of whatever file occupied the address <filename moreinfo=\"none\">concepts/IDEA</filename> at the time? We'll use an explicit peg revision to help us out."
msgstr "然后让我们询问另一个问题—在修订版本1 ，占据<filename moreinfo=\"none\">concepts/IDEA</filename>路径的文件的内容到底是什么？我们会使用一个明确的peg修订版本来帮助我们完成。"

#: build/en/book.xml:6762(screen)
#, no-wrap
msgid ""
"\n"
"$ svn cat concept/IDEA@1\n"
"The idea behind this project is to come up with a piece of software\n"
"that can frab a naggily wort.  Frabbing naggily worts is tricky\n"
"business, and doing it incorrectly can have serious ramifications, so\n"
"we need to employ over-the-top input validation and data verification\n"
"mechanisms.\n"
msgstr ""
"\n"
"$ svn cat concept/IDEA@1\n"
"The idea behind this project is to come up with a piece of software\n"
"that can frab a naggily wort.  Frabbing naggily worts is tricky\n"
"business, and doing it incorrectly can have serious ramifications, so\n"
"we need to employ over-the-top input validation and data verification\n"
"mechanisms.\n"

#: build/en/book.xml:6771(para)
msgid "Notice that we didn't provide an operative revision this time. That's because when no operative revision is specified, Subversion assumes a default operative revision that's the same as the peg revision."
msgstr ""

#: build/en/book.xml:6776(para)
#, fuzzy
msgid "As you can see, the output from our operation appears to be correct. The text even mentions frabbing naggily worts, so this is almost certainly the file which describes the software now called Frabnaggilywort. In fact, we can verify this using the combination of an explicit peg revision and explicit operative revision. We know that in <literal moreinfo=\"none\">HEAD</literal>, the Frabnaggilywort project is located in the <filename moreinfo=\"none\">frabnaggilywort</filename> directory. So we specify that we want to see how the line of history identified in <literal moreinfo=\"none\">HEAD</literal> as the path <filename moreinfo=\"none\">frabnaggilywort/IDEA</filename> looked in revision 1."
msgstr "这看起来是正确的输出，这些文本甚至提到“frabbing naggily worts”，所以这就是现在叫做Frabnaggilywort项目的那个文件，实际上，我们可以使用显示的peg修订版本和实施修订版本的组合核实这一点。我们知道在<literal moreinfo=\"none\">HEAD</literal>，Frabnaggilywort项目坐落在<filename moreinfo=\"none\">frabnaggilywort</filename>目录，所以我们指定我们希望看到<literal moreinfo=\"none\">HEAD</literal>的<filename moreinfo=\"none\">frabnaggilywort/IDEA</filename>路经在历史上的修订版本1的内容。"

#: build/en/book.xml:6789(screen)
#, no-wrap
msgid ""
"\n"
"$ svn cat -r 1 frabnaggilywort/IDEA@HEAD\n"
"The idea behind this project is to come up with a piece of software\n"
"that can frab a naggily wort.  Frabbing naggily worts is tricky\n"
"business, and doing it incorrectly can have serious ramifications, so\n"
"we need to employ over-the-top input validation and data verification\n"
"mechanisms.\n"
msgstr ""
"\n"
"$ svn cat -r 1 frabnaggilywort/IDEA@HEAD\n"
"The idea behind this project is to come up with a piece of software\n"
"that can frab a naggily wort.  Frabbing naggily worts is tricky\n"
"business, and doing it incorrectly can have serious ramifications, so\n"
"we need to employ over-the-top input validation and data verification\n"
"mechanisms.\n"

#: build/en/book.xml:6798(para)
msgid "And the peg and operative revisions need not be so trivial, either. For example, say <filename moreinfo=\"none\">frabnaggilywort</filename> had been deleted from <literal moreinfo=\"none\">HEAD</literal>, but we know it existed in revision 20, and we want to see the diffs for its <filename moreinfo=\"none\">IDEA</filename> file between revisions 4 and 10. We can use the peg revision 20 in conjunction with the URL that would have held Frabnaggilywort's <filename moreinfo=\"none\">IDEA</filename> file in revision 20, and then use 4 and 10 as our operative revision range."
msgstr "而且peg修订版本和实施修订版本也不需要这样琐碎，举个例子，我们的<filename moreinfo=\"none\">frabnaggilywort</filename>已经在<literal moreinfo=\"none\">HEAD</literal>删除，但我们知道在修订版本20它是存在的，我们希望知道<filename moreinfo=\"none\">IDEA</filename>从修订版本4到10的区别，我们可以使用peg修订版本20和<filename moreinfo=\"none\">IDEA</filename>文件的修订版本20的URL的组合，然后使用4到10作为我们的实施修订版本范围。"

#: build/en/book.xml:6808(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff -r 4:10 http://svn.red-bean.com/projects/frabnaggilywort/IDEA@20\n"
"Index: frabnaggilywort/IDEA\n"
"===================================================================\n"
"--- frabnaggilywort/IDEA\t(revision 4)\n"
"+++ frabnaggilywort/IDEA\t(revision 10)\n"
"@@ -1,5 +1,5 @@\n"
"-The idea behind this project is to come up with a piece of software\n"
"-that can frab a naggily wort.  Frabbing naggily worts is tricky\n"
"-business, and doing it incorrectly can have serious ramifications, so\n"
"-we need to employ over-the-top input validation and data verification\n"
"-mechanisms.\n"
"+The idea behind this project is to come up with a piece of\n"
"+client-server software that can remotely frab a naggily wort.\n"
"+Frabbing naggily worts is tricky business, and doing it incorrectly\n"
"+can have serious ramifications, so we need to employ over-the-top\n"
"+input validation and data verification mechanisms.\n"
msgstr ""
"\n"
"$ svn diff -r 4:10 http://svn.red-bean.com/projects/frabnaggilywort/IDEA@20\n"
"Index: frabnaggilywort/IDEA\n"
"===================================================================\n"
"--- frabnaggilywort/IDEA\t(revision 4)\n"
"+++ frabnaggilywort/IDEA\t(revision 10)\n"
"@@ -1,5 +1,5 @@\n"
"-The idea behind this project is to come up with a piece of software\n"
"-that can frab a naggily wort.  Frabbing naggily worts is tricky\n"
"-business, and doing it incorrectly can have serious ramifications, so\n"
"-we need to employ over-the-top input validation and data verification\n"
"-mechanisms.\n"
"+The idea behind this project is to come up with a piece of\n"
"+client-server software that can remotely frab a naggily wort.\n"
"+Frabbing naggily worts is tricky business, and doing it incorrectly\n"
"+can have serious ramifications, so we need to employ over-the-top\n"
"+input validation and data verification mechanisms.\n"

#: build/en/book.xml:6827(para)
msgid "Fortunately, most folks aren't faced with such complex situations. But when you are, remember that peg revisions are that extra hint Subversion needs to clear up ambiguity."
msgstr "幸运的是，几乎所有的人不会面临如此复杂的情形，但是如果是，记住peg修订版本是帮助Subversion清除混淆的额外提示。"

#: build/en/book.xml:6838(title)
msgid "Network Model"
msgstr "网络模型"

#: build/en/book.xml:6840(para)
msgid "At some point, you're going to need to understand how your Subversion client communicates with its server. Subversion's networking layer is abstracted, meaning that Subversion clients exhibit the same general behaviors no matter what sort of server they are operating against. Whether speaking the HTTP protocol (<literal moreinfo=\"none\">http://</literal>) with the Apache HTTP Server or speaking the custom Subversion protocol (<literal moreinfo=\"none\">svn://</literal>) with <command moreinfo=\"none\">svnserve</command>, the basic network model is the same. In this section, we'll explain the basics of that network model, including how Subversion manages authentication and authorization matters."
msgstr ""

#: build/en/book.xml:6855(title)
msgid "Requests and Responses"
msgstr "请求和响应"

#: build/en/book.xml:6857(para)
#, fuzzy
msgid "The Subversion client spends most of its time managing working copies. When it needs information from a remote repository, however, it makes a network request, and the server responds with an appropriate answer. The details of the network protocol are hidden from the user—the client attempts to access a URL, and depending on the URL schema, a particular protocol is used to contact the server (see <xref linkend=\"svn.basic.in-action.wc.sb-1\"/>)."
msgstr "Subversion客户端花费大量的时间来管理工作拷贝，当它需要版本库信息，它会做一个网络请求，然后服务器给一个恰当的回答，具体的网络协议细节对用户不可见，客户端尝试去访问一个URL，根据URL模式的不同，会使用特定的协议与服务器联系（见<xref linkend=\"svn.basic.in-action.wc.sb-1\"/>），用户可以运行<command moreinfo=\"none\">svn --version</command>来查看客户端可以使用的URL模式和协议。"

#: build/en/book.xml:6865(para)
#, fuzzy
msgid "Users can run <command moreinfo=\"none\">svn --version</command> to see which URL schemas and protocols the client knows how to use."
msgstr "打印<command moreinfo=\"none\">svnversion</command>，如果没有错误退出。"

#: build/en/book.xml:6870(para)
#, fuzzy
msgid "When the server process receives a client request, it often demands that the client identify itself. It issues an authentication challenge to the client, and the client responds by providing <firstterm>credentials</firstterm> back to the server. Once authentication is complete, the server responds with the original information the client asked for. Notice that this system is different from systems like CVS, where the client pre-emptively offers credentials (<quote>logs in</quote>) to the server before ever making a request. In Subversion, the server <quote>pulls</quote> credentials by challenging the client at the appropriate moment, rather than the client <quote>pushing</quote> them. This makes certain operations more elegant. For example, if a server is configured to allow anyone in the world to read a repository, then the server will never issue an authentication challenge when a client attempts to <command moreinfo=\"none\">svn checkout</command>."
msgstr "当服务器处理一个客户端请求，它通常会要求客户端确定它自己的身份，它会发出一个认证请求给客户端，而客户端通过提供<firstterm>凭证</firstterm>给服务器作为响应，一旦认证结束，服务器会响应客户端最初请求的信息。注意这个系统与CVS之类的系统不一样，它们会在请求之前，预先提供凭证（<quote>logs in</quote>）给服务器，在Subversion里，服务器通过请求客户端适时地<quote>拖入</quote>凭证，而不是客户端<quote>推</quote>出。这使得这种操作更加的优雅，例如，如果一个服务器配置为世界上的任何人都可以读取版本库，在客户使用<command moreinfo=\"none\">svn checkout</command>时，服务器永远不会发起一个认证请求。"

#: build/en/book.xml:6899(para)
msgid "This problem is actually a FAQ, resulting from a misconfigured server setup."
msgstr "这个问题实际上是一个FAQ，源自错误的服务器配置。"

#: build/en/book.xml:6887(para)
#, fuzzy
msgid "If the particular network requests issued by the client result in a new revision being created in the repository, (e.g. <command moreinfo=\"none\">svn commit</command>), then Subversion uses the authenticated username associated with those requests as the author of the revision. That is, the authenticated user's name is stored as the value of the <literal moreinfo=\"none\">svn:author</literal> property on the new revision (see <xref linkend=\"svn.ref.properties\"/>). If the client was not authenticated (in other words, the server never issued an authentication challenge), then the revision's <literal moreinfo=\"none\">svn:author</literal> property is empty. <placeholder-1/>"
msgstr "如果客户端请求往版本库写入新的数据（例如<command moreinfo=\"none\">svn commit</command>），这会建立新的修订版本树，如果客户端的请求是经过认证的，认证过的用户的用户名就会作为<literal moreinfo=\"none\">svn:author</literal>属性的值保存到新的修订本里（见<xref linkend=\"svn.reposadmin.basics.revprops\"/>）。如果客户端没有经过认证（换句话说，服务器没有发起过认证请求），这时修订本的<literal moreinfo=\"none\">svn:author</literal>的值是空的。<placeholder-1/>"

#: build/en/book.xml:6908(title)
msgid "Client Credentials Caching"
msgstr "客户端凭证缓存"

#: build/en/book.xml:6910(para)
#, fuzzy
msgid "Many servers are configured to require authentication on every request. This can become a big annoyance to users, who are forced to type their passwords over and over again. Fortunately, the Subversion client has a remedy for this—a built-in system for caching authentication credentials on disk. By default, whenever the command-line client successfully responds to a server's authentication challenge, it saves the credentials in the user's private runtime configuration area (<filename moreinfo=\"none\">~/.subversion/auth/</filename> on Unix-like systems or <filename moreinfo=\"none\">%APPDATA%/Subversion/auth/</filename> on Windows; see <xref linkend=\"svn.advanced.confarea\"/> for more details about the runtime configuration system). Successful credentials are cached on disk, keyed on a combination of the server's hostname, port, and authentication realm."
msgstr "令人高兴的是，Subversion客户端对此有一个修补：存在一个在磁盘上保存认证凭证缓存的系统，缺省情况下，当一个命令行客户端成功的响应了服务器的认证请求，它会保存一个认证文件到用户的私有运行配置区—类Unix系统下会在<filename moreinfo=\"none\">~/.subversion/auth/</filename>，Windows下在<filename moreinfo=\"none\">%APPDATA%/Subversion/auth/</filename>（运行区在<xref linkend=\"svn.advanced.confarea\"/>会有更多细节描述）。成功的凭证会缓存在磁盘，以主机名、端口和认证域的组合作为唯一性区别。"

#: build/en/book.xml:6926(para)
#, fuzzy
msgid "When the client receives an authentication challenge, it first looks for the appropriate credentials in the user's disk cache. If seemingly suitable credentials are not present, or if the cached credentials ultimately fail to authenticate, then the client will, by default, fall back to prompting the user for the necessary information."
msgstr "当客户端接收到一个认证请求，它会首先查找用户磁盘中的认证凭证缓存，如果没有发现，或者是缓存的凭证认证失败，客户端会提示用户需要这些信息。"

#: build/en/book.xml:6933(para)
#, fuzzy
msgid "The security-conscious reader will suspect immediately that there is reason for concern here. <quote>Caching passwords on disk? That's terrible! You should never do that!</quote>"
msgstr "十分关心安全的人们一定会想<quote>把密码缓存在磁盘？太可怕了，永远不要这样做！</quote>但是请保持冷静，并没有你想象得那么可怕。"

#: build/en/book.xml:6938(para)
msgid "The Subversion developers recognize the legitimacy of such concerns, and so Subversion works with available mechanisms provided by the operating system and environment to try to minimize the risk of leaking this information. Here's a breakdown of what this means on for users on the most common platforms:"
msgstr ""

#: build/en/book.xml:6948(para)
#, fuzzy
msgid "On Windows 2000 and later, the Subversion client uses standard Windows cryptography services to encrypt the password on disk. Because the encryption key is managed by Windows and is tied to the user's own login credentials, only the user can decrypt the cached password. (Note that if the user's Windows account password is reset by an administrator, all of the cached passwords become undecipherable. The Subversion client will behave as if they don't exist, prompting for passwords when required.)"
msgstr "在Windows 2000或更新的系统上，Subversion客户端使用标准Windows加密服务来加密磁盘上的密码。因为加密密钥是Windows管理的，与用户的登陆凭证相关，只有用户可以解密密码。（注意：如果用户的Windows账户密码被管理员重置，所有的缓存密码就不可以解密了，此时Subversion客户端就会当它们根本不存在，在需要时继续询问密码。）"

#: build/en/book.xml:6961(para)
msgid "Similarly, on Mac OS X, the Subversion client stores all repository passwords in the login keyring (managed by the Keychain service), which is protected by the user's account password. User preference settings can impose additional policies, such as requiring the user's account password be entered each time the Subversion password is used."
msgstr ""

#: build/en/book.xml:6971(para)
#, fuzzy
msgid "For other Unix-like operating systems, no standard <quote>keychain</quote> services exist. However, the <filename moreinfo=\"none\">auth/</filename> caching area is still permission-protected so that only the user (owner) can read data from it, not the world at large. The operating system's own file permissions protect the passwords."
msgstr "<filename moreinfo=\"none\">auth/</filename>缓存区只有用户（拥有者）可以访问，而不是全世界都可以，操作系统的访问许可可以保护密码文件。"

#: build/en/book.xml:6981(para)
msgid "Of course, for the truly paranoid, none of these mechanisms meets the test of perfection. So for those folks willing to sacrifice convenience for the ultimate security, Subversion provides various ways of disabling its credentials caching system altogether."
msgstr ""

#: build/en/book.xml:6987(para)
msgid "To disable caching for a single command, pass the <option>--no-auth-cache</option> option:"
msgstr "你可以关闭凭证缓存，只需要一个简单的命令，使用参数<option>--no-auth-cache</option>："

#: build/en/book.xml:6990(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit -F log_msg.txt --no-auth-cache\n"
"Authentication realm: &lt;svn://host.example.com:3690&gt; example realm\n"
"Username:  joe\n"
"Password for 'joe':\n"
"\n"
"Adding         newfile\n"
"Transmitting file data .\n"
"Committed revision 2324.\n"
"\n"
"# password was not cached, so a second commit still prompts us\n"
"\n"
"$ svn delete newfile\n"
"$ svn commit -F new_msg.txt\n"
"Authentication realm: &lt;svn://host.example.com:3690&gt; example realm\n"
"Username:  joe\n"
"…\n"
msgstr ""
"\n"
"$ svn commit -F log_msg.txt --no-auth-cache\n"
"Authentication realm: &lt;svn://host.example.com:3690&gt; example realm\n"
"Username:  joe\n"
"Password for 'joe':\n"
"\n"
"Adding         newfile\n"
"Transmitting file data .\n"
"Committed revision 2324.\n"
"\n"
"# password was not cached, so a second commit still prompts us\n"
"\n"
"$ svn delete newfile\n"
"$ svn commit -F new_msg.txt\n"
"Authentication realm: &lt;svn://host.example.com:3690&gt; example realm\n"
"Username:  joe\n"
"…\n"

#: build/en/book.xml:7009(para)
#, fuzzy
msgid "Or, if you want to disable credential caching permanently, you can edit the <filename moreinfo=\"none\">config</filename> file in your runtime configuration area, and set the <option>store-auth-creds</option> option to <literal moreinfo=\"none\">no</literal>. This will prevent the storing of credentials used in any Subversion interactions you perform on the affected computer. This can be extended to cover all users on the computer, too, by modifying the system-wide runtime configuration area."
msgstr "或许，你希望永远关闭凭证缓存，你可以编辑你的运行<filename moreinfo=\"none\">配置</filename>文件（坐落在<filename moreinfo=\"none\">auth/</filename>目录），只需要把<literal moreinfo=\"none\">store-auth-creds</literal>设置为<literal moreinfo=\"none\">no</literal>，这样就不会有凭证缓存在磁盘。"

#: build/en/book.xml:7019(screen)
#, no-wrap
msgid ""
"\n"
"[auth]\n"
"store-auth-creds = no\n"
msgstr ""
"\n"
"[auth]\n"
"store-auth-creds = no\n"

#: build/en/book.xml:7024(para)
msgid "Sometimes users will want to remove specific credentials from the disk cache. To do this, you need to navigate into the <filename moreinfo=\"none\">auth/</filename> area and manually delete the appropriate cache file. Credentials are cached in individual files; if you look inside each file, you will see keys and values. The <literal moreinfo=\"none\">svn:realmstring</literal> key describes the particular server realm that the file is associated with:"
msgstr "有时候，用户希望从磁盘缓存删除特定的凭证，为此你可以浏览到<filename moreinfo=\"none\">auth/</filename>区域，删除特定的缓存文件，凭证都是作为一个单独的文件缓存，如果你打开每一个文件，你会看到键和值，<literal moreinfo=\"none\">svn:realmstring</literal>描述了这个文件关联的特定服务器的域："

#: build/en/book.xml:7033(screen)
#, no-wrap
msgid ""
"\n"
"$ ls ~/.subversion/auth/svn.simple/\n"
"5671adf2865e267db74f09ba6f872c28\n"
"3893ed123b39500bca8a0b382839198e\n"
"5c3c22968347b390f349ff340196ed39\n"
"\n"
"$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28\n"
"\n"
"K 8\n"
"username\n"
"V 3\n"
"joe\n"
"K 8\n"
"password\n"
"V 4\n"
"blah\n"
"K 15\n"
"svn:realmstring\n"
"V 45\n"
"&lt;https://svn.domain.com:443&gt; Joe's repository\n"
"END\n"
msgstr ""
"\n"
"$ ls ~/.subversion/auth/svn.simple/\n"
"5671adf2865e267db74f09ba6f872c28\n"
"3893ed123b39500bca8a0b382839198e\n"
"5c3c22968347b390f349ff340196ed39\n"
"\n"
"$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28\n"
"\n"
"K 8\n"
"username\n"
"V 3\n"
"joe\n"
"K 8\n"
"password\n"
"V 4\n"
"blah\n"
"K 15\n"
"svn:realmstring\n"
"V 45\n"
"&lt;https://svn.domain.com:443&gt; Joe's repository\n"
"END\n"

#: build/en/book.xml:7056(para)
msgid "Once you have located the proper cache file, just delete it."
msgstr "一旦你定位了正确的缓存文件，只需要删除它。"

#: build/en/book.xml:7071(para)
msgid "Again, a common mistake is to misconfigure a server so that it never issues an authentication challenge. When users pass <option>--username</option> and <option>--password</option> options to the client, they're surprised to see that they're never used, i.e. new revisions still appear to have been committed anonymously!"
msgstr "再次重申，一个常见的错误是把服务器配置为从不会请求认证，当用户传递<option>--username</option>和<option>--password</option>给客户端时，他们惊奇的发现它们没有被使用，如新的修订版本看起来始终是由匿名用户提交的！"

#: build/en/book.xml:7059(para)
#, fuzzy
msgid "One last word about <command moreinfo=\"none\">svn</command>'s authentication behavior, specifically regarding the <option>--username</option> and <option>--password</option> options. Many client subcommands accept these options, but it is important to understand using these options does <emphasis>not</emphasis> automatically send credentials to the server. As discussed earlier, the server <quote>pulls</quote> credentials from the client when it deems necessary; the client cannot <quote>push</quote> them at will. If a username and/or password are passed as options, they will only be presented to the server if the server requests them. <placeholder-1/> These options are typically used to authenticate as a different user than Subversion would have chosen by default (such as your system login name), or when trying to avoid interactive prompting (such as when calling <command moreinfo=\"none\">svn</command> from a script)."
msgstr "客户端认证的行为的最后一点：对使用<option>--username</option>和<option>--password</option>选项的一点说明，许多客户端和子命令接受这个选项，但是要明白使用这个选项<emphasis>不会</emphasis>主动地发送凭证信息到服务器，就像前面讨论过的，服务器会在需要的时候才会从客户端<quote>拖</quote>入凭证，客户端不会随意<quote>推</quote>出。如果一个用户名和/或者密码作为选项传入，它们<emphasis>只会</emphasis>在服务器需要时展现给服务器。<placeholder-1/>通常，只有在如下情况下才会使用这些选项："

#: build/en/book.xml:7086(para)
#, fuzzy
msgid "Here is a final summary that describes how a Subversion client behaves when it receives an authentication challenge."
msgstr "这里是Subversion客户端在收到认证请求的时候的行为方式："

#: build/en/book.xml:7092(para)
#, fuzzy
msgid "First, the client checks whether the user specified any credentials as command-line options (<option>--username</option> and/or <option>--password</option>). If not, or if these options fail to authenticate successfully, then"
msgstr "检查用户是否通过<option>--username</option>和/或<option>--password</option>命令选项指定了任何凭证信息，如果没有，或者这些选项没有认证成功，然后"

#: build/en/book.xml:7100(para)
#, fuzzy
msgid "the client looks up the server's hostname, port, and realm in the runtime <filename moreinfo=\"none\">auth/</filename> area, to see if the user already has the appropriate credentials cached. If not, or if the cached credentials fail to authenticate, then"
msgstr "查找运行中的<filename moreinfo=\"none\">auth/</filename>区域保存的服务器域信息，来确定用户是否已经有了恰当的认证缓存，如果没有，或者缓存凭证认证失败，然后"

#: build/en/book.xml:7108(para)
msgid "finally, the client resorts to prompting the user (unless instructed not to do so via the <option>--non-interactive</option> option or its client-specific equivalents)."
msgstr ""

#: build/en/book.xml:7116(para)
msgid "If the client successfully authenticates by any of the methods listed above, it will attempt to cache the credentials on disk (unless the user has disabled this behavior, as mentioned earlier)."
msgstr "如果客户端通过以上的任何一种方式成功认证，它会尝试在磁盘缓存凭证（除非用户已经关闭了这种行为方式，在前面提到过。）"

#: build/en/book.xml:7134(title)
msgid "Branching and Merging"
msgstr "分支与合并"

#: build/en/book.xml:7137(attribution)
msgid "Confucius"
msgstr "孔子"

#: build/en/book.xml:7138(quote)
msgid "君子务本 (It is upon the Trunk that a gentleman works.)"
msgstr "君子务本"

#: build/en/book.xml:7143(para)
msgid "Branching, tagging, and merging are concepts common to almost all version control systems. If you're not familiar with these ideas, we provide a good introduction in this chapter. If you are familiar, then hopefully you'll find it interesting to see how Subversion implements these ideas."
msgstr "分支、标签和合并是所有版本控制系统的共同概念，如果你并不熟悉这些概念，我们会在这一章里很好的介绍，如果你很熟悉，非常希望你有兴趣知道Subversion是怎样实现这些概念的。"

#: build/en/book.xml:7149(para)
msgid "Branching is a fundamental part of version control. If you're going to allow Subversion to manage your data, then this is a feature you'll eventually come to depend on. This chapter assumes that you're already familiar with Subversion's basic concepts (<xref linkend=\"svn.basic\"/>)."
msgstr "分支是版本控制的基础组成部分，如果你允许Subversion来管理你的数据，这个特性将是你所必须依赖的 ，这一章假定你已经熟悉了Subversion的基本概念（<xref linkend=\"svn.basic\"/>）。"

#: build/en/book.xml:7160(title)
msgid "What's a Branch?"
msgstr "什么是分支？"

#: build/en/book.xml:7162(para)
msgid "Suppose it's your job to maintain a document for a division in your company, a handbook of some sort. One day a different division asks you for the same handbook, but with a few parts <quote>tweaked</quote> for them, since they do things slightly differently."
msgstr "假设你的工作是维护本公司一个部门的手册文档，一天，另一个部门问你要相同的手册，但一些地方会有<quote>区别</quote>，因为他们有不同的需要。"

#: build/en/book.xml:7168(para)
msgid "What do you do in this situation? You do the obvious thing: you make a second copy of your document, and begin maintaining the two copies separately. As each department asks you to make small changes, you incorporate them into one copy or the other."
msgstr "这种情况下你会怎样做？显而易见的方法是：作一个版本的拷贝，然后分别维护两个版本，只要任何一个部门告诉要做一些小修改，你必须选择在对应的版本进行更改。"

#: build/en/book.xml:7174(para)
msgid "You often want to make the same change to both copies. For example, if you discover a typo in the first copy, it's very likely that the same typo exists in the second copy. The two documents are almost the same, after all; they only differ in small, specific ways."
msgstr "你也许希望在两个版本同时作修改，举个例子，你在第一个版本发现了一个拼写错误，很显然这个错误也会出现在第二个版本里。两份文档几乎相同，毕竟，只有许多特定的微小区别。"

#: build/en/book.xml:7180(para)
msgid "This is the basic concept of a <firstterm>branch</firstterm>—namely, a line of development that exists independently of another line, yet still shares a common history if you look far enough back in time. A branch always begins life as a copy of something, and moves on from there, generating its own history (see <xref linkend=\"svn.branchmerge.whatis.dia-1\"/>)."
msgstr "这是<firstterm>分支</firstterm>的基本概念—正如它的名字，开发的一条线独立于另一条线，如果回顾历史，可以发现两条线分享共同的历史，一个分支总是从一个备份开始的，从那里开始，发展自己独有的历史（见 <xref linkend=\"svn.branchmerge.whatis.dia-1\"/>）。"

#: build/en/book.xml:7188(title)
msgid "Branches of development"
msgstr "分支与开发"

#: build/en/book.xml:7192(para)
msgid "Subversion has commands to help you maintain parallel branches of your files and directories. It allows you to create branches by copying your data, and remembers that the copies are related to one another. It also helps you duplicate changes from one branch to another. Finally, it can make portions of your working copy reflect different branches, so that you can <quote>mix and match</quote> different lines of development in your daily work."
msgstr "Subversion允许你并行的维护文件和目录的分支，它允许你通过拷贝数据建立分支，记住，分支互相联系，它也帮助你从一个分支复制修改到另一个分支。最终，它可以让你的工作拷贝反映到不同的分支上，所以你在日常工作可以<quote>混合和比较</quote>不同的开发线。"

#: build/en/book.xml:7207(title)
msgid "Using Branches"
msgstr "使用分支"

#: build/en/book.xml:7209(para)
msgid "At this point, you should understand how each commit creates an entire new filesystem tree (called a <quote>revision</quote>) in the repository. If not, go back and read about revisions in <xref linkend=\"svn.basic.in-action.revs\"/>."
msgstr "在这一点上，你必须理解每一次提交是怎样建立整个新的文件系统树（叫做<quote>修订版本</quote>）的，如果没有，可以回头去读<xref linkend=\"svn.basic.in-action.revs\"/>。"

#: build/en/book.xml:7214(para)
msgid "For this chapter, we'll go back to the same example from <xref linkend=\"svn.basic\"/>. Remember that you and your collaborator, Sally, are sharing a repository that contains two projects, <filename moreinfo=\"none\">paint</filename> and <filename moreinfo=\"none\">calc</filename>. Notice that in <xref linkend=\"svn.branchmerge.using.dia-1\"/>, however, each project directory now contains subdirectories named <filename moreinfo=\"none\">trunk</filename> and <filename moreinfo=\"none\">branches</filename>. The reason for this will soon become clear."
msgstr "对于本章节，我们会回到第2章的同一个例子，还记得你和你的合作者Sally分享一个包含两个项目的版本库，<filename moreinfo=\"none\">paint</filename>和<filename moreinfo=\"none\">calc</filename>。注意<xref linkend=\"svn.branchmerge.using.dia-1\"/>，然而，现在每个项目的都有一个<filename moreinfo=\"none\">trunk</filename>和<filename moreinfo=\"none\">branches</filename>子目录，它们存在的理由很快就会清晰起来。"

#: build/en/book.xml:7224(title)
msgid "Starting repository layout"
msgstr "开始规划版本库"

#: build/en/book.xml:7228(para)
msgid "As before, assume that Sally and you both have working copies of the <quote>calc</quote> project. Specifically, you each have a working copy of <filename moreinfo=\"none\">/calc/trunk</filename>. All the files for the project are in this subdirectory rather than in <filename moreinfo=\"none\">/calc</filename> itself, because your team has decided that <filename moreinfo=\"none\">/calc/trunk</filename> is where the <quote>main line</quote> of development is going to take place."
msgstr "像以前一样，假定Sally和你都有<quote>calc</quote>项目的一份拷贝，更准确地说，你有一份<filename moreinfo=\"none\">/calc/trunk</filename>的工作拷贝，这个项目的所有的文件在这个子目录里，而不是在<filename moreinfo=\"none\">/calc</filename>下，因为你的小组决定使用<filename moreinfo=\"none\">/calc/trunk</filename>作为开发使用的<quote>主线</quote>。"

#: build/en/book.xml:7237(para)
msgid "Let's say that you've been given the task of performing a radical reorganization of the project. It will take a long time to write, and will affect all the files in the project. The problem here is that you don't want to interfere with Sally, who is in the process of fixing small bugs here and there. She's depending on the fact that the latest version of the project (in <filename moreinfo=\"none\">/calc/trunk</filename>) is always usable. If you start committing your changes bit-by-bit, you'll surely break things for Sally."
msgstr "假定你有一个任务，将要对项目做基本的重新组织，这需要花费大量时间来完成，会影响项目的所有文件，问题是你不会希望打扰Sally，她正在处理这样或那样的程序小Bug，一直使用整个项目（<filename moreinfo=\"none\">/calc/trunk</filename>）的最新版本，如果你一点一点的提交你的修改，你一定会干扰Sally的工作。"

#: build/en/book.xml:7247(para)
msgid "One strategy is to crawl into a hole: you and Sally can stop sharing information for a week or two. That is, start gutting and reorganizing all the files in your working copy, but don't commit or update until you're completely finished with the task. There are a number of problems with this, though. First, it's not very safe. Most people like to save their work to the repository frequently, should something bad accidentally happen to their working copy. Second, it's not very flexible. If you do your work on different computers (perhaps you have a working copy of <filename moreinfo=\"none\">/calc/trunk</filename> on two different machines), you'll need to manually copy your changes back and forth, or just do all the work on a single computer. By that same token, it's difficult to share your changes-in-progress with anyone else. A common software development <quote>best practice</quote> is to allow your peers to review your work as you go. If nobody sees your intermediate commits, you lose potential feedback. Finally, when you're finished with all your changes, you might find it very difficult to re-merge your final work with the rest of the company's main body of code. Sally (or others) may have made many other changes in the repository that are difficult to incorporate into your working copy—especially if you run <command moreinfo=\"none\">svn update</command> after weeks of isolation."
msgstr "一种策略是自己闭门造车：你和Sally可以停止一个到两个星期的共享，也就是说，开始作出本质上的修改和重新组织工作拷贝的文件，但是在完成这个任务之前不做提交和更新。这样会有很多问题，首先，这样并不安全，许多人习惯频繁的保存修改到版本库，工作拷贝一定有许多意外的修改。第二，这样并不灵活，如果你的工作在不同的计算机（或许你在不同的机器有两份<filename moreinfo=\"none\">/calc/trunk</filename>的工作拷贝），你需要手工的来回拷贝修改，或者只在一个计算机上工作，这时很难做到共享你即时的修改，一项软件开发的<quote>最佳实践</quote>就是允许审核你做过的工作，如果没有人看到你的提交，你失去了潜在的反馈。最后，当你完成了公司主干代码的修改工作，你会发现合并你的工作拷贝和公司的主干代码会是一件非常困难的事情，Sally（或者其他人）也许已经对版本库做了许多修改，已经很难和你的工作拷贝结合—当你单独工作几周后运行<command moreinfo=\"none\">svn update</command>时就会发现这一点。"

#: build/en/book.xml:7271(para)
msgid "The better solution is to create your own branch, or line of development, in the repository. This allows you to save your half-broken work frequently without interfering with others, yet you can still selectively share information with your collaborators. You'll see exactly how this works later on."
msgstr "最佳方案是创建你自己的分支，或者是版本库的开发线。这允许你保存破坏了一半的工作而不打扰别人，尽管你仍可以选择性的同你的合作者分享信息，你将会看到这是怎样工作的。"

#: build/en/book.xml:7280(title)
msgid "Creating a Branch"
msgstr "创建分支"

#: build/en/book.xml:7282(para)
msgid "Creating a branch is very simple—you make a copy of the project in the repository using the <command moreinfo=\"none\">svn copy</command> command. Subversion is not only able to copy single files, but whole directories as well. In this case, you want to make a copy of the <filename moreinfo=\"none\">/calc/trunk</filename> directory. Where should the new copy live? Wherever you wish—it's a matter of project policy. Let's say that your team has a policy of creating branches in the <filename moreinfo=\"none\">/calc/branches</filename> area of the repository, and you want to name your branch <literal moreinfo=\"none\">my-calc-branch</literal>. You'll want to create a new directory, <filename moreinfo=\"none\">/calc/branches/my-calc-branch</filename>, which begins its life as a copy of <filename moreinfo=\"none\">/calc/trunk</filename>."
msgstr "建立分支非常的简单—使用<command moreinfo=\"none\">svn copy</command>命令给你的工程做个拷贝，Subversion不仅可以拷贝单个文件，也可以拷贝整个目录，在目前情况下，你希望作<filename moreinfo=\"none\">/calc/trunk</filename>的拷贝，新的拷贝应该在哪里？在你希望的任何地方—它只是在于项目的政策，我们假设你们项目的政策是在<filename moreinfo=\"none\">/calc/branches</filename>建立分支，并且你希望把你的分支叫做<literal moreinfo=\"none\">my-calc-branch</literal>，你希望建立一个新的目录<filename moreinfo=\"none\">/calc/branches/my-calc-branch</filename>，作为/calc/trunk的拷贝开始它的生命周期。"

#: build/en/book.xml:7298(para)
msgid "There are two different ways to make a copy. We'll demonstrate the messy way first, just to make the concept clear. To begin, check out a working copy of the project's root directory, <filename moreinfo=\"none\">/calc</filename>:"
msgstr "有两个方法作拷贝，我们首先介绍一个混乱的方法，只是让概念更清楚，作为开始，取出一个工程的根目录，<filename moreinfo=\"none\">/calc</filename>："

#: build/en/book.xml:7303(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://svn.example.com/repos/calc bigwc\n"
"A  bigwc/trunk/\n"
"A  bigwc/trunk/Makefile\n"
"A  bigwc/trunk/integer.c\n"
"A  bigwc/trunk/button.c\n"
"A  bigwc/branches/\n"
"Checked out revision 340.\n"
msgstr ""
"\n"
"$ svn checkout http://svn.example.com/repos/calc bigwc\n"
"A  bigwc/trunk/\n"
"A  bigwc/trunk/Makefile\n"
"A  bigwc/trunk/integer.c\n"
"A  bigwc/trunk/button.c\n"
"A  bigwc/branches/\n"
"Checked out revision 340.\n"

#: build/en/book.xml:7313(para)
msgid "Making a copy is now simply a matter of passing two working-copy paths to the <command moreinfo=\"none\">svn copy</command> command:"
msgstr "建立一个备份只是传递两个目录参数到<command moreinfo=\"none\">svn copy</command>命令："

#: build/en/book.xml:7317(screen)
#, no-wrap
msgid ""
"\n"
"$ cd bigwc\n"
"$ svn copy trunk branches/my-calc-branch\n"
"$ svn status\n"
"A  +   branches/my-calc-branch\n"
msgstr ""
"\n"
"$ cd bigwc\n"
"$ svn copy trunk branches/my-calc-branch\n"
"$ svn status\n"
"A  +   branches/my-calc-branch\n"

#: build/en/book.xml:7324(para)
msgid "In this case, the <command moreinfo=\"none\">svn copy</command> command recursively copies the <filename moreinfo=\"none\">trunk</filename> working directory to a new working directory, <filename moreinfo=\"none\">branches/my-calc-branch</filename>. As you can see from the <command moreinfo=\"none\">svn status</command> command, the new directory is now scheduled for addition to the repository. But also notice the <quote>+</quote> sign next to the letter A. This indicates that the scheduled addition is a <emphasis>copy</emphasis> of something, not something new. When you commit your changes, Subversion will create <filename moreinfo=\"none\">/calc/branches/my-calc-branch</filename> in the repository by copying <filename moreinfo=\"none\">/calc/trunk</filename>, rather than resending all of the working copy data over the network:"
msgstr "在这个情况下，<command moreinfo=\"none\">svn copy</command>命令迭代的将<filename moreinfo=\"none\">trunk</filename>工作目录拷贝到一个新的目录branhes/my-calc-branch，像你从<command moreinfo=\"none\">svn status</command>看到的，新的目录是准备添加到版本库的，但是也要注意A后面的<quote>+</quote>号，这表明这个准备添加的东西是一份<emphasis>备份</emphasis>，而不是新的东西。当你提交修改，Subversion会通过拷贝<filename moreinfo=\"none\">/calc/trunk</filename>建立<filename moreinfo=\"none\">/calc/branches/my-calc-branch</filename>目录，而不是通过网络传递所有数据："

#: build/en/book.xml:7339(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit -m \"Creating a private branch of /calc/trunk.\"\n"
"Adding         branches/my-calc-branch\n"
"Committed revision 341.\n"
msgstr ""
"\n"
"$ svn commit -m \"Creating a private branch of /calc/trunk.\"\n"
"Adding         branches/my-calc-branch\n"
"Committed revision 341.\n"

#: build/en/book.xml:7345(para)
#, fuzzy
msgid "And now here's the easier method of creating a branch, which we should have told you about in the first place: <command moreinfo=\"none\">svn copy</command> is able to operate directly on two URLs."
msgstr "现在，我们必须告诉你建立分支最简单的方法：<command moreinfo=\"none\">svn copy</command>可以直接对两个URL操作。"

#: build/en/book.xml:7350(screen)
#, no-wrap
msgid ""
"\n"
"$ svn copy http://svn.example.com/repos/calc/trunk \\\n"
"           http://svn.example.com/repos/calc/branches/my-calc-branch \\\n"
"      -m \"Creating a private branch of /calc/trunk.\"\n"
"\n"
"Committed revision 341.\n"
msgstr ""
"\n"
"$ svn copy http://svn.example.com/repos/calc/trunk \\\n"
"           http://svn.example.com/repos/calc/branches/my-calc-branch \\\n"
"      -m \"Creating a private branch of /calc/trunk.\"\n"
"\n"
"Committed revision 341.\n"

#: build/en/book.xml:7366(para)
#, fuzzy
msgid "Subversion does not support copying between different repositories. When using URLs with <command moreinfo=\"none\">svn copy</command> or <command moreinfo=\"none\">svn move</command>, you can only copy items within the same repository."
msgstr "Subversion不支持跨版本库的拷贝，当使用<command moreinfo=\"none\">svn copy</command>或者<command moreinfo=\"none\">svn move</command>直接操作URL时你只能在同一个版本库内操作。"

#: build/en/book.xml:7358(para)
#, fuzzy
msgid "There's really no difference between these two methods. Both procedures create a new directory in revision 341, and the new directory is a copy of <filename moreinfo=\"none\">/calc/trunk</filename>. This is shown in <xref linkend=\"svn.branchmerge.using.create.dia-1\"/>. Notice that the second method, however, performs an <emphasis>immediate</emphasis> commit. <placeholder-1/> It's an easier procedure, because it doesn't require you to check out a large portion of the repository. In fact, this technique doesn't even require you to have a working copy at all. This is the way most users create branches."
msgstr "其实这两种方法没有什么区别，两个过程都在版本341建立了一个新目录作为<filename moreinfo=\"none\">/calc/trunk</filename>的一个备份，这些可以在<xref linkend=\"svn.branchmerge.using.create.dia-1\"/>看到，注意第二种方法，只是执行了一个<emphasis>立即</emphasis>提交。 <footnote><placeholder-1/></footnote>这是一个简单的过程，因为你不需要取出版本库一个庞大的镜像，事实上，这个技术不需要你有工作拷贝。"

#: build/en/book.xml:7377(title)
msgid "Repository with new copy"
msgstr "版本库与复制"

#: build/en/book.xml:7382(title)
msgid "Cheap Copies"
msgstr "廉价复制"

#: build/en/book.xml:7384(para)
#, fuzzy
msgid "Subversion's repository has a special design. When you copy a directory, you don't need to worry about the repository growing huge—Subversion doesn't actually duplicate any data. Instead, it creates a new directory entry that points to an <emphasis>existing</emphasis> tree. If you're a Unix user, this is the same concept as a hard-link. As further changes are made to files and directories beneath the copied directory, Subversion continues to employ this hard-link concept where it can. It only duplicates data when it is necessary to disambiguate different versions of objects."
msgstr "Subversion的版本库有特殊的设计，当你复制一个目录，你不需要担心版本库会变得十分巨大—Subversion并不是拷贝所有的数据，相反，它建立了一个<emphasis>已存在</emphasis>目录树的入口，如果你是Unix用户，可以把它理解成硬链接，在这里，这个拷贝被可以被认为是<quote>懒的</quote>，如果你提交一个文件的修改，只有这个文件改变了—余下的文件还是作为原来文件的链接存在。"

#: build/en/book.xml:7396(para)
msgid "This is why you'll often hear Subversion users talk about <quote>cheap copies</quote>. It doesn't matter how large the directory is—it takes a very tiny, constant amount of time to make a copy of it. In fact, this feature is the basis of how commits work in Subversion: each revision is a <quote>cheap copy</quote> of the previous revision, with a few items lazily changed within. (To read more about this, visit Subversion's website and read about the <quote>bubble up</quote> method in Subversion's design documents.)"
msgstr "这就是为什么经常听到Subversion用户谈论<quote>廉价的拷贝</quote>，与目录的大小无关—这个操作会使用很少的时间，事实上，这个特性是Subversion提交工作的基础：每一次版本都是前一个版本的一个<quote>廉价的拷贝</quote>，只有少数项目修改了。（要阅读更多关于这部分的内容，访问Subversion网站并且阅读设计文档中的<quote>bubble up</quote>方法）。"

#: build/en/book.xml:7407(para)
#, fuzzy
msgid "Of course, these internal mechanics of copying and sharing data are hidden from the user, who simply sees copies of trees. The main point here is that copies are cheap, both in time and space. If you create a branch entirely within the repository (by running <command moreinfo=\"none\">svn copy URL1 URL2</command>), it's a quick, constant-time operation. Make branches as often as you want."
msgstr "当然，拷贝与分享的内部机制对用户来讲是不可见的，用户只是看到拷贝树，这里的要点是拷贝的时间与空间代价很小，所以你可以随意做想要的分支。"

#: build/en/book.xml:7420(title)
msgid "Working with Your Branch"
msgstr "在分支上工作"

#: build/en/book.xml:7422(para)
msgid "Now that you've created a branch of the project, you can check out a new working copy to start using it:"
msgstr "现在你已经在项目里建立分支了，你可以取出一个新的工作拷贝来开始使用："

#: build/en/book.xml:7425(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch\n"
"A  my-calc-branch/Makefile\n"
"A  my-calc-branch/integer.c\n"
"A  my-calc-branch/button.c\n"
"Checked out revision 341.\n"
msgstr ""
"\n"
"$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch\n"
"A  my-calc-branch/Makefile\n"
"A  my-calc-branch/integer.c\n"
"A  my-calc-branch/button.c\n"
"Checked out revision 341.\n"

#: build/en/book.xml:7433(para)
msgid "There's nothing special about this working copy; it simply mirrors a different directory in the repository. When you commit changes, however, Sally won't ever see them when she updates. Her working copy is of <filename moreinfo=\"none\">/calc/trunk</filename>. (Be sure to read <xref linkend=\"svn.branchmerge.switchwc\"/> later in this chapter: the <command moreinfo=\"none\">svn switch</command> command is an alternate way of creating a working copy of a branch.)"
msgstr "这一份工作拷贝没有什么特别的，它只是版本库另一个目录的一个镜像罢了，当你提交修改时，Sally在更新时不会看到改变，她是<filename moreinfo=\"none\">/calc/trunk</filename>的工作拷贝。（确定要读本章后面的<xref linkend=\"svn.branchmerge.switchwc\"/>，<command moreinfo=\"none\">svn switch</command>命令是建立分支工作拷贝的另一个选择。）"

#: build/en/book.xml:7441(para)
msgid "Let's pretend that a week goes by, and the following commits happen:"
msgstr "我们假定本周就要过去了，如下的提交发生："

#: build/en/book.xml:7445(para)
msgid "You make a change to <filename moreinfo=\"none\">/calc/branches/my-calc-branch/button.c</filename>, which creates revision 342."
msgstr "你修改了<filename moreinfo=\"none\">/calc/branches/my-calc-branch/button.c</filename>，生成版本号342。"

#: build/en/book.xml:7451(para)
msgid "You make a change to <filename moreinfo=\"none\">/calc/branches/my-calc-branch/integer.c</filename>, which creates revision 343."
msgstr "你修改了<filename moreinfo=\"none\">/calc/branches/my-calc-branch/integer.c</filename>，生成版本号343。"

#: build/en/book.xml:7457(para)
msgid "Sally makes a change to <filename moreinfo=\"none\">/calc/trunk/integer.c</filename>, which creates revision 344."
msgstr "Sally修改了<filename moreinfo=\"none\">/calc/trunk/integer.c</filename>，生成了版本号344。"

#: build/en/book.xml:7464(para)
msgid "There are now two independent lines of development, shown in <xref linkend=\"svn.branchmerge.using.work.dia-1\"/>, happening on <filename moreinfo=\"none\">integer.c</filename>."
msgstr "现在有两个独立开发线，<xref linkend=\"svn.branchmerge.using.work.dia-1\"/>显示了<filename moreinfo=\"none\">integer.c</filename>的历史。"

#: build/en/book.xml:7469(title)
msgid "The branching of one file's history"
msgstr "一个文件的分支历史"

#: build/en/book.xml:7473(para)
msgid "Things get interesting when you look at the history of changes made to your copy of <filename moreinfo=\"none\">integer.c</filename>:"
msgstr "当你看到<filename moreinfo=\"none\">integer.c</filename>的改变时，你会发现很有趣："

#: build/en/book.xml:7477(screen)
#, no-wrap
msgid ""
"\n"
"$ pwd\n"
"/home/user/my-calc-branch\n"
"\n"
"$ svn log -v integer.c\n"
"------------------------------------------------------------------------\n"
"r343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines\n"
"Changed paths:\n"
"   M /calc/branches/my-calc-branch/integer.c\n"
"\n"
"* integer.c:  frozzled the wazjub.\n"
"\n"
"------------------------------------------------------------------------\n"
"r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines\n"
"Changed paths:\n"
"   A /calc/branches/my-calc-branch (from /calc/trunk:340)\n"
"\n"
"Creating a private branch of /calc/trunk.\n"
"\n"
"------------------------------------------------------------------------\n"
"r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines\n"
"Changed paths:\n"
"   M /calc/trunk/integer.c\n"
"\n"
"* integer.c:  changed a docstring.\n"
"\n"
"------------------------------------------------------------------------\n"
"r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines\n"
"Changed paths:\n"
"   M /calc/trunk/integer.c\n"
"\n"
"* integer.c:  adding this file to the project.\n"
"\n"
"------------------------------------------------------------------------\n"
msgstr ""
"\n"
"$ pwd\n"
"/home/user/my-calc-branch\n"
"\n"
"$ svn log -v integer.c\n"
"------------------------------------------------------------------------\n"
"r343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines\n"
"Changed paths:\n"
"   M /calc/branches/my-calc-branch/integer.c\n"
"\n"
"* integer.c:  frozzled the wazjub.\n"
"\n"
"------------------------------------------------------------------------\n"
"r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines\n"
"Changed paths:\n"
"   A /calc/branches/my-calc-branch (from /calc/trunk:340)\n"
"\n"
"Creating a private branch of /calc/trunk.\n"
"\n"
"------------------------------------------------------------------------\n"
"r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines\n"
"Changed paths:\n"
"   M /calc/trunk/integer.c\n"
"\n"
"* integer.c:  changed a docstring.\n"
"\n"
"------------------------------------------------------------------------\n"
"r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines\n"
"Changed paths:\n"
"   M /calc/trunk/integer.c\n"
"\n"
"* integer.c:  adding this file to the project.\n"
"\n"
"------------------------------------------------------------------------\n"

#: build/en/book.xml:7513(para)
msgid "Notice that Subversion is tracing the history of your branch's <filename moreinfo=\"none\">integer.c</filename> all the way back through time, even traversing the point where it was copied. It shows the creation of the branch as an event in the history, because <filename moreinfo=\"none\">integer.c</filename> was implicitly copied when all of <filename moreinfo=\"none\">/calc/trunk/</filename> was copied. Now look what happens when Sally runs the same command on her copy of the file:"
msgstr "注意，Subversion追踪分支上的<filename moreinfo=\"none\">integer.c</filename>的历史，包括所有的操作，甚至追踪到拷贝之前。这表示了建立分支也是历史中的一次事件，因为在拷贝整个<filename moreinfo=\"none\">/calc/trunk/</filename>时已经拷贝了一份<filename moreinfo=\"none\">integer.c</filename>。现在看Sally在她的工作拷贝运行同样的命令："

#: build/en/book.xml:7522(screen)
#, no-wrap
msgid ""
"\n"
"$ pwd\n"
"/home/sally/calc\n"
"\n"
"$ svn log -v integer.c\n"
"------------------------------------------------------------------------\n"
"r344 | sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines\n"
"Changed paths:\n"
"   M /calc/trunk/integer.c\n"
"\n"
"* integer.c:  fix a bunch of spelling errors.\n"
"\n"
"------------------------------------------------------------------------\n"
"r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines\n"
"Changed paths:\n"
"   M /calc/trunk/integer.c\n"
"\n"
"* integer.c:  changed a docstring.\n"
"\n"
"------------------------------------------------------------------------\n"
"r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines\n"
"Changed paths:\n"
"   M /calc/trunk/integer.c\n"
"\n"
"* integer.c:  adding this file to the project.\n"
"\n"
"------------------------------------------------------------------------\n"
msgstr ""
"\n"
"$ pwd\n"
"/home/sally/calc\n"
"\n"
"$ svn log -v integer.c\n"
"------------------------------------------------------------------------\n"
"r344 | sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines\n"
"Changed paths:\n"
"   M /calc/trunk/integer.c\n"
"\n"
"* integer.c:  fix a bunch of spelling errors.\n"
"\n"
"------------------------------------------------------------------------\n"
"r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines\n"
"Changed paths:\n"
"   M /calc/trunk/integer.c\n"
"\n"
"* integer.c:  changed a docstring.\n"
"\n"
"------------------------------------------------------------------------\n"
"r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines\n"
"Changed paths:\n"
"   M /calc/trunk/integer.c\n"
"\n"
"* integer.c:  adding this file to the project.\n"
"\n"
"------------------------------------------------------------------------\n"

#: build/en/book.xml:7551(para)
msgid "Sally sees her own revision 344 change, but not the change you made in revision 343. As far as Subversion is concerned, these two commits affected different files in different repository locations. However, Subversion <emphasis>does</emphasis> show that the two files share a common history. Before the branch-copy was made in revision 341, they used to be the same file. That's why you and Sally both see the changes made in revisions 303 and 98."
msgstr "sally看到她自己的344修订，你做的343修改她看不到，从Subversion看来，两次提交只是影响版本库中不同位置上的两个文件。然而，Subversion<emphasis>显示</emphasis>了两个文件有共同的历史，在分支拷贝之前，他们使用同一个文件，所以你和Sally都看到版本号303到98的修改。"

#: build/en/book.xml:7564(title)
msgid "The Key Concepts Behind Branches"
msgstr "分支背后的关键概念"

#: build/en/book.xml:7566(para)
#, fuzzy
msgid "There are two important lessons that you should remember from this section. First, Subversion has no internal concept of a branch—it only knows how to make copies. When you copy a directory, the resulting directory is only a <quote>branch</quote> because <emphasis>you</emphasis> attach that meaning to it. You may think of the directory differently, or treat it differently, but to Subversion it's just an ordinary directory that happens to carry some extra historical information. Second, because of this copy mechanism, Subversion's branches exist as <emphasis>normal filesystem directories</emphasis> in the repository. This is different from other version control systems, where branches are typically defined by adding extra-dimensional <quote>labels</quote> to collections of files."
msgstr "Subversion并没有内在的分支概念—只有拷贝，当你拷贝一个目录，这个结果目录就是一个<quote>分支</quote>，只是因为你给了它这样一个含义而已。你可以换一种角度考虑，或者特别处理，但是对于Subversion它只是一个普通的拷贝的结果。"

#: build/en/book.xml:7590(title)
msgid "Copying Changes Between Branches"
msgstr "在分支间复制修改"

#: build/en/book.xml:7592(para)
msgid "Now you and Sally are working on parallel branches of the project: you're working on a private branch, and Sally is working on the <firstterm>trunk</firstterm>, or main line of development."
msgstr "现在你与Sally在同一个项目的并行分支上工作：你在私有分支上，而Sally在主干（<firstterm>trunk</firstterm>）或者叫做开发主线上。"

#: build/en/book.xml:7597(para)
msgid "For projects that have a large number of contributors, it's common for most people to have working copies of the trunk. Whenever someone needs to make a long-running change that is likely to disrupt the trunk, a standard procedure is to create a private branch and commit changes there until all the work is complete."
msgstr "由于有众多的人参与项目，大多数人拥有主干拷贝是很正常的，任何人如果进行一个长周期的修改会使得主干陷入混乱，所以通常的做法是建立一个私有分支，提交修改到自己的分支，直到这阶段工作结束。"

#: build/en/book.xml:7604(para)
msgid "So, the good news is that you and Sally aren't interfering with each other. The bad news is that it's very easy to drift <emphasis>too</emphasis> far apart. Remember that one of the problems with the <quote>crawl in a hole</quote> strategy is that by the time you're finished with your branch, it may be near-impossible to merge your changes back into the trunk without a huge number of conflicts."
msgstr "所以，好消息就是你和Sally不会互相打扰，坏消息是有时候分离会<emphasis>太</emphasis>远。记住<quote>闭门造车</quote>策略的问题，当你完成你的分支后，可能因为太多冲突，已经无法轻易合并你的分支和主干的修改。"

#: build/en/book.xml:7612(para)
msgid "Instead, you and Sally might continue to share changes as you work. It's up to you to decide which changes are worth sharing; Subversion gives you the ability to selectively <quote>copy</quote> changes between branches. And when you're completely finished with your branch, your entire set of branch changes can be copied back into the trunk."
msgstr "相反，在你工作的时候你和Sally仍然可以继续分享修改，这依赖于你决定什么值得分享，Subversion给你在分支间选择性<quote>拷贝</quote>修改的能力，当你完成了分支上的所有工作，所有的分支修改可以被拷贝回到主干。"

#: build/en/book.xml:7622(title)
msgid "Copying Specific Changes"
msgstr "复制特定的修改"

#: build/en/book.xml:7625(para)
msgid "In the previous section, we mentioned that both you and Sally made changes to <filename moreinfo=\"none\">integer.c</filename> on different branches. If you look at Sally's log message for revision 344, you can see that she fixed some spelling errors. No doubt, your copy of the same file still has the same spelling errors. It's likely that your future changes to this file will be affecting the same areas that have the spelling errors, so you're in for some potential conflicts when you merge your branch someday. It's better, then, to receive Sally's change now, <emphasis>before</emphasis> you start working too heavily in the same places."
msgstr "在上一章节，我们提到你和Sally对<filename moreinfo=\"none\">integer.c</filename>在不同的分支上做过修改，如果你看了Sally的344版本的日志信息，你会知道她修正了一些拼写错误，毋庸置疑，你的拷贝的文件也一定存在这些拼写错误，所以你以后的对这个文件修改也会保留这些拼写错误，所以你会在将来合并时得到许多冲突。最好是现在接收Sally的修改，而不是作了许多工作之后才来做。"

#: build/en/book.xml:7637(para)
msgid "It's time to use the <command moreinfo=\"none\">svn merge</command> command. This command, it turns out, is a very close cousin to the <command moreinfo=\"none\">svn diff</command> command (which you read about in <xref linkend=\"svn.tour\"/>). Both commands are able to compare any two objects in the repository and describe the differences. For example, you can ask <command moreinfo=\"none\">svn diff</command> to show you the exact change made by Sally in revision 344:"
msgstr "是时间使用<command moreinfo=\"none\">svn merge</command>命令，这个命令的结果非常类似<command moreinfo=\"none\">svn diff</command>命令（在第3章的内容），两个命令都可以比较版本库中的任何两个对象并且描述其区别，举个例子，你可以使用<command moreinfo=\"none\">svn diff</command>来查看Sally在版本344作的修改："

#: build/en/book.xml:7646(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff -c 344 http://svn.example.com/repos/calc/trunk\n"
"\n"
"Index: integer.c\n"
"===================================================================\n"
"--- integer.c\t(revision 343)\n"
"+++ integer.c\t(revision 344)\n"
"@@ -147,7 +147,7 @@\n"
"     case 6:  sprintf(info-&gt;operating_system, \"HPFS (OS/2 or NT)\"); break;\n"
"     case 7:  sprintf(info-&gt;operating_system, \"Macintosh\"); break;\n"
"     case 8:  sprintf(info-&gt;operating_system, \"Z-System\"); break;\n"
"-    case 9:  sprintf(info-&gt;operating_system, \"CPM\"); break;\n"
"+    case 9:  sprintf(info-&gt;operating_system, \"CP/M\"); break;\n"
"     case 10:  sprintf(info-&gt;operating_system, \"TOPS-20\"); break;\n"
"     case 11:  sprintf(info-&gt;operating_system, \"NTFS (Windows NT)\"); break;\n"
"     case 12:  sprintf(info-&gt;operating_system, \"QDOS\"); break;\n"
"@@ -164,7 +164,7 @@\n"
"     low = (unsigned short) read_byte(gzfile);  /* read LSB */\n"
"     high = (unsigned short) read_byte(gzfile); /* read MSB */\n"
"     high = high &lt;&lt; 8;  /* interpret MSB correctly */\n"
"-    total = low + high; /* add them togethe for correct total */\n"
"+    total = low + high; /* add them together for correct total */\n"
"\n"
"     info-&gt;extra_header = (unsigned char *) my_malloc(total);\n"
"     fread(info-&gt;extra_header, total, 1, gzfile);\n"
"@@ -241,7 +241,7 @@\n"
"      Store the offset with ftell() ! */\n"
"\n"
"   if ((info-&gt;data_offset = ftell(gzfile))== -1) {\n"
"-    printf(\"error: ftell() retturned -1.\\n\");\n"
"+    printf(\"error: ftell() returned -1.\\n\");\n"
"     exit(1);\n"
"   }\n"
"\n"
"@@ -249,7 +249,7 @@\n"
"   printf(\"I believe start of compressed data is %u\\n\", info-&gt;data_offset);\n"
"   #endif\n"
"\n"
"-  /* Set postion eight bytes from the end of the file. */\n"
"+  /* Set position eight bytes from the end of the file. */\n"
"\n"
"   if (fseek(gzfile, -8, SEEK_END)) {\n"
"     printf(\"error: fseek() returned non-zero\\n\");\n"
msgstr ""
"\n"
"$ svn diff -c 344 http://svn.example.com/repos/calc/trunk\n"
"\n"
"Index: integer.c\n"
"===================================================================\n"
"--- integer.c\t(revision 343)\n"
"+++ integer.c\t(revision 344)\n"
"@@ -147,7 +147,7 @@\n"
"     case 6:  sprintf(info-&gt;operating_system, \"HPFS (OS/2 or NT)\"); break;\n"
"     case 7:  sprintf(info-&gt;operating_system, \"Macintosh\"); break;\n"
"     case 8:  sprintf(info-&gt;operating_system, \"Z-System\"); break;\n"
"-    case 9:  sprintf(info-&gt;operating_system, \"CPM\"); break;\n"
"+    case 9:  sprintf(info-&gt;operating_system, \"CP/M\"); break;\n"
"     case 10:  sprintf(info-&gt;operating_system, \"TOPS-20\"); break;\n"
"     case 11:  sprintf(info-&gt;operating_system, \"NTFS (Windows NT)\"); break;\n"
"     case 12:  sprintf(info-&gt;operating_system, \"QDOS\"); break;\n"
"@@ -164,7 +164,7 @@\n"
"     low = (unsigned short) read_byte(gzfile);  /* read LSB */\n"
"     high = (unsigned short) read_byte(gzfile); /* read MSB */\n"
"     high = high &lt;&lt; 8;  /* interpret MSB correctly */\n"
"-    total = low + high; /* add them togethe for correct total */\n"
"+    total = low + high; /* add them together for correct total */\n"
"\n"
"     info-&gt;extra_header = (unsigned char *) my_malloc(total);\n"
"     fread(info-&gt;extra_header, total, 1, gzfile);\n"
"@@ -241,7 +241,7 @@\n"
"      Store the offset with ftell() ! */\n"
"\n"
"   if ((info-&gt;data_offset = ftell(gzfile))== -1) {\n"
"-    printf(\"error: ftell() retturned -1.\\n\");\n"
"+    printf(\"error: ftell() returned -1.\\n\");\n"
"     exit(1);\n"
"   }\n"
"\n"
"@@ -249,7 +249,7 @@\n"
"   printf(\"I believe start of compressed data is %u\\n\", info-&gt;data_offset);\n"
"   #endif\n"
"\n"
"-  /* Set postion eight bytes from the end of the file. */\n"
"+  /* Set position eight bytes from the end of the file. */\n"
"\n"
"   if (fseek(gzfile, -8, SEEK_END)) {\n"
"     printf(\"error: fseek() returned non-zero\\n\");\n"

#: build/en/book.xml:7691(para)
msgid "The <command moreinfo=\"none\">svn merge</command> command is almost exactly the same. Instead of printing the differences to your terminal, however, it applies them directly to your working copy as <emphasis>local modifications</emphasis>:"
msgstr "<command moreinfo=\"none\">svn merge</command>命令几乎完全相同，但不是打印区别到你的终端，它会直接作为<emphasis>本地修改</emphasis>作用到你的本地拷贝："

#: build/en/book.xml:7696(screen)
#, no-wrap
msgid ""
"\n"
"$ svn merge -c 344 http://svn.example.com/repos/calc/trunk\n"
"U  integer.c\n"
"\n"
"$ svn status\n"
"M  integer.c\n"
msgstr ""
"\n"
"$ svn merge -c 344 http://svn.example.com/repos/calc/trunk\n"
"U  integer.c\n"
"\n"
"$ svn status\n"
"M  integer.c\n"

#: build/en/book.xml:7704(para)
msgid "The output of <command moreinfo=\"none\">svn merge</command> shows that your copy of <filename moreinfo=\"none\">integer.c</filename> was patched. It now contains Sally's change—the change has been <quote>copied</quote> from the trunk to your working copy of your private branch, and now exists as a local modification. At this point, it's up to you to review the local modification and make sure it works correctly."
msgstr "<command moreinfo=\"none\">svn merge</command>的输出告诉你的<filename moreinfo=\"none\">integer.c</filename>文件已经作了补丁（patched），现在已经保留了Sally修改—修改从主干<quote>拷贝</quote>到你的私有分支的工作拷贝，现在作为一个本地修改，在这种情况下，要靠你审查本地的修改来确定它们工作正常。"

#: build/en/book.xml:7712(para)
msgid "In another scenario, it's possible that things may not have gone so well, and that <filename moreinfo=\"none\">integer.c</filename> may have entered a conflicted state. You might need to resolve the conflict using standard procedures (see <xref linkend=\"svn.tour\"/>), or if you decide that the merge was a bad idea altogether, simply give up and <command moreinfo=\"none\">svn revert</command> the local change."
msgstr "在另一种情境下，事情并不会运行得这样正常，也许<filename moreinfo=\"none\">integer.c</filename>也许会进入冲突状态，你必须使用标准过程（见第三章）来解决这种状态，或者你认为合并是一个错误的决定，你只需要运行<command moreinfo=\"none\">svn revert</command>放弃。"

#: build/en/book.xml:7719(para)
msgid "But assuming that you've reviewed the merged change, you can <command moreinfo=\"none\">svn commit</command> the change as usual. At that point, the change has been merged into your repository branch. In version control terminology, this act of copying changes between branches is commonly called <firstterm>porting</firstterm> changes."
msgstr "但是当你审查过你的合并结果后，你可以使用<command moreinfo=\"none\">svn commit</command>提交修改，在那一刻，修改已经合并到你的分支上了，在版本控制术语中，这种在分支之间拷贝修改的行为叫做<firstterm>搬运</firstterm>修改。"

#: build/en/book.xml:7726(para)
msgid "When you commit the local modification, make sure your log message mentions that you're porting a specific change from one branch to another. For example:"
msgstr "当你提交你的修改时，确定你的日志信息中说明你是从某一版本搬运了修改，举个例子："

#: build/en/book.xml:7730(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit -m \"integer.c: ported r344 (spelling fixes) from trunk.\"\n"
"Sending        integer.c\n"
"Transmitting file data .\n"
"Committed revision 360.\n"
msgstr ""
"\n"
"$ svn commit -m \"integer.c: ported r344 (spelling fixes) from trunk.\"\n"
"Sending        integer.c\n"
"Transmitting file data .\n"
"Committed revision 360.\n"

#: build/en/book.xml:7737(para)
msgid "As you'll see in the next sections, this is a very important <quote>best practice</quote> to follow."
msgstr "你将会在下一节看到，这是一条非常重要的<quote>最佳实践</quote>。"

#: build/en/book.xml:7741(title)
msgid "Why Not Use Patches Instead?"
msgstr "为什么不使用补丁？"

#: build/en/book.xml:7743(para)
msgid "A question may be on your mind, especially if you're a Unix user: why bother to use <command moreinfo=\"none\">svn merge</command> at all? Why not simply use the operating system's <command moreinfo=\"none\">patch</command> command to accomplish the same job? For example:"
msgstr "也许你的脑中会出现一个问题，特别如果你是Unix用户，为什么非要使用<command moreinfo=\"none\">svn merge</command>？为什么不简单的使用操作系统的<command moreinfo=\"none\">patch</command>命令来进行相同的工作？举个例子："

#: build/en/book.xml:7749(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff -c 344 http://svn.example.com/repos/calc/trunk &gt; patchfile\n"
"$ patch -p0  &lt; patchfile\n"
"Patching file integer.c using Plan A...\n"
"Hunk #1 succeeded at 147.\n"
"Hunk #2 succeeded at 164.\n"
"Hunk #3 succeeded at 241.\n"
"Hunk #4 succeeded at 249.\n"
"done\n"
msgstr ""
"\n"
"$ svn diff -c 344 http://svn.example.com/repos/calc/trunk &gt; patchfile\n"
"$ patch -p0  &lt; patchfile\n"
"Patching file integer.c using Plan A...\n"
"Hunk #1 succeeded at 147.\n"
"Hunk #2 succeeded at 164.\n"
"Hunk #3 succeeded at 241.\n"
"Hunk #4 succeeded at 249.\n"
"done\n"

#: build/en/book.xml:7760(para)
#, fuzzy
msgid "In this particular case, yes, there really is no difference. But <command moreinfo=\"none\">svn merge</command> has special abilities that surpass the <command moreinfo=\"none\">patch</command> program. The file format used by <command moreinfo=\"none\">patch</command> is quite limited; it's only able to tweak file contents. There's no way to represent changes to <emphasis>trees</emphasis>, such as the addition, removal, or renaming of files and directories. Nor can the <command moreinfo=\"none\">patch</command> program notice changes to property changes. If Sally's change had, say, added a new directory, the output of <command moreinfo=\"none\">svn diff</command> wouldn't have mentioned it at all. <command moreinfo=\"none\">svn diff</command> only outputs the limited patch-format, so there are some ideas it simply can't express. The <command moreinfo=\"none\">svn merge</command> command, however, can express changes in tree structure and properties by directly applying them to your working copy."
msgstr "在这种情况下，确实没有区别，但是<command moreinfo=\"none\">svn merge</command>有超越<command moreinfo=\"none\">patch</command>的特别能力，使用<command moreinfo=\"none\">patch</command>对文件格式有一定的限制，它只能针对文件内容，没有方法表现<emphasis>目录树</emphasis>的修改，例如添加、删除或是改名。如果Sally的修改包括增加一个新的目录，<command moreinfo=\"none\">svn diff</command>不会注意到这些，<command moreinfo=\"none\">svn diff</command>只会输出有限的补丁格式，所以有些问题无法表达。<footnote><placeholder-1/></footnote> 但是<command moreinfo=\"none\">svn merge</command>命令会通过直接作用你的工作拷贝来表示目录树的结构和属性变化。"

#: build/en/book.xml:7779(para)
msgid "A word of warning: while <command moreinfo=\"none\">svn diff</command> and <command moreinfo=\"none\">svn merge</command> are very similar in concept, they do have different syntax in many cases. Be sure to read about them in <xref linkend=\"svn.ref\"/> for details, or ask <command moreinfo=\"none\">svn help</command>. For example, <command moreinfo=\"none\">svn merge</command> requires a working-copy path as a target, i.e. a place where it should apply the tree-changes. If the target isn't specified, it assumes you are trying to perform one of the following common operations:"
msgstr "一个警告：为什么<command moreinfo=\"none\">svn diff</command>和<command moreinfo=\"none\">svn merge</command>在概念上是很接近，但语法上有许多不同，一定阅读第9章来查看其细节或者使用<command moreinfo=\"none\">svn help</command>查看帮助。举个例子，<command moreinfo=\"none\">svn merge</command>需要一个工作拷贝作为目标，就是一个地方来施展目录树修改，如果一个目标都没有指定，它会假定你要做以下某个普通的操作："

#: build/en/book.xml:7791(para)
msgid "You want to merge directory changes into your current working directory."
msgstr "你希望合并目录修改到工作拷贝的当前目录。"

#: build/en/book.xml:7795(para)
msgid "You want to merge the changes in a specific file into a file by the same name which exists in your current working directory."
msgstr "你希望合并修改到你的当前工作目录的相同文件名的文件。"

#: build/en/book.xml:7801(para)
msgid "If you are merging a directory and haven't specified a target path, <command moreinfo=\"none\">svn merge</command> assumes the first case above and tries to apply the changes into your current directory. If you are merging a file, and that file (or a file by the same name) exists in your current working directory, <command moreinfo=\"none\">svn merge</command> assumes the second case and tries to apply the changes to a local file with the same name."
msgstr "如果你合并一个目录而没有指定特定的目标，<command moreinfo=\"none\">svn merge</command>假定第一种情况，在你的当前目录应用修改。如果你合并一个文件，而这个文件（或是一个有相同的名字文件）在你的当前工作目录存在，<command moreinfo=\"none\">svn merge</command>假定第二种情况，你想对这个同名文件使用合并。"

#: build/en/book.xml:7809(para)
msgid "If you want changes applied somewhere else, you'll need to say so. For example, if you're sitting in the parent directory of your working copy, you'll have to specify the target directory to receive the changes:"
msgstr "如果你希望修改应用到别的目录，你需要说出来。举个例子，你在工作拷贝的父目录，你需要指定目标目录："

#: build/en/book.xml:7814(screen)
#, no-wrap
msgid ""
"\n"
"$ svn merge -c 344 http://svn.example.com/repos/calc/trunk my-calc-branch\n"
"U   my-calc-branch/integer.c\n"
msgstr ""
"\n"
"$ svn merge -c 344 http://svn.example.com/repos/calc/trunk my-calc-branch\n"
"U   my-calc-branch/integer.c\n"

#: build/en/book.xml:7823(title)
msgid "The Key Concept Behind Merging"
msgstr "合并背后的关键概念"

#: build/en/book.xml:7825(para)
msgid "You've now seen an example of the <command moreinfo=\"none\">svn merge</command> command, and you're about to see several more. If you're feeling confused about exactly how merging works, you're not alone. Many users (especially those new to version control) are initially perplexed about the proper syntax of the command, and about how and when the feature should be used. But fear not, this command is actually much simpler than you think! There's a very easy technique for understanding exactly how <command moreinfo=\"none\">svn merge</command> behaves."
msgstr "你已经看到了<command moreinfo=\"none\">svn merge</command>命令的例子，你将会看到更多，如果你对合并是如何工作的感到迷惑，这并不奇怪，很多人和你一样。许多新用户（特别是对版本控制很陌生的用户）会对这个命令的正确语法感到不知所措，不知道怎样和什么时候使用这个特性，不要害怕，这个命令实际上比你想象的简单！有一个简单的技巧来帮助你理解<command moreinfo=\"none\">svn merge</command>的行为。"

#: build/en/book.xml:7836(para)
msgid "The main source of confusion is the <emphasis>name</emphasis> of the command. The term <quote>merge</quote> somehow denotes that branches are combined together, or that there's some sort of mysterious blending of data going on. That's not the case. A better name for the command might have been <command moreinfo=\"none\">svn diff-and-apply</command>, because that's all that happens: two repository trees are compared, and the differences are applied to a working copy."
msgstr "迷惑的主要原因是这个命令的<emphasis>名称</emphasis>，术语<quote>合并</quote>不知什么原因被用来表明分支的组合，或者是其他什么神奇的数据混合，这不是事实，一个更好的名称应该是<command moreinfo=\"none\">svn diff-and-apply</command>，这是发生的所有事件：首先两个版本库树比较，然后将区别应用到本地拷贝。"

#: build/en/book.xml:7846(para)
msgid "The command takes three arguments:"
msgstr "这个命令包括三个参数："

#: build/en/book.xml:7850(para)
msgid "An initial repository tree (often called the <firstterm>left side</firstterm> of the comparison),"
msgstr "初始的版本树（通常叫做比较的<firstterm>左边</firstterm>），"

#: build/en/book.xml:7854(para)
msgid "A final repository tree (often called the <firstterm>right side</firstterm> of the comparison),"
msgstr "最终的版本树（通常叫做比较的<firstterm>右边</firstterm>），"

#: build/en/book.xml:7858(para)
msgid "A working copy to accept the differences as local changes (often called the <firstterm>target</firstterm> of the merge)."
msgstr "一个接收区别的工作拷贝（通常叫做合并的<firstterm>目标</firstterm>）。"

#: build/en/book.xml:7864(para)
msgid "Once these three arguments are specified, the two trees are compared, and the resulting differences are applied to the target working copy as local modifications. When the command is done, the results are no different than if you had hand-edited the files, or run various <command moreinfo=\"none\">svn add</command> or <command moreinfo=\"none\">svn delete</command> commands yourself. If you like the results, you can commit them. If you don't like the results, you can simply <command moreinfo=\"none\">svn revert</command> all of the changes."
msgstr "一旦这三个参数指定以后，两个目录树将要做比较，比较结果将会作为本地修改应用到目标工作拷贝，当命令结束后，结果同你手工修改或者是使用<command moreinfo=\"none\">svn add</command>或<command moreinfo=\"none\">svn delete</command>没有什么区别，如果你喜欢这结果，你可以提交，如果不喜欢，你可以使用<command moreinfo=\"none\">svn revert</command>恢复修改。"

#: build/en/book.xml:7874(para)
msgid "The syntax of <command moreinfo=\"none\">svn merge</command> allows you to specify the three necessary arguments rather flexibly. Here are some examples:"
msgstr "<command moreinfo=\"none\">svn merge</command>的语法允许非常灵活的指定参数，如下是一些例子："

#: build/en/book.xml:7878(screen)
#, no-wrap
msgid ""
"\n"
"$ svn merge http://svn.example.com/repos/branch1@150 \\\n"
"            http://svn.example.com/repos/branch2@212 \\\n"
"            my-working-copy\n"
"\n"
"$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy\n"
"\n"
"$ svn merge -r 100:200 http://svn.example.com/repos/trunk\n"
msgstr ""
"\n"
"$ svn merge http://svn.example.com/repos/branch1@150 \\\n"
"            http://svn.example.com/repos/branch2@212 \\\n"
"            my-working-copy\n"
"\n"
"$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy\n"
"\n"
"$ svn merge -r 100:200 http://svn.example.com/repos/trunk\n"

#: build/en/book.xml:7888(para)
msgid "The first syntax lays out all three arguments explicitly, naming each tree in the form <emphasis>URL@REV</emphasis> and naming the working copy target. The second syntax can be used as a shorthand for situations when you're comparing two different revisions of the same URL. The last syntax shows how the working-copy argument is optional; if omitted, it defaults to the current directory."
msgstr "第一种语法使用<emphasis>URL@REV</emphasis>的形式直接列出了所有参数，第二种语法可以用来作为比较同一个URL的不同版本的简略写法，最后一种语法表示工作拷贝是可选的，如果省略，默认是当前目录。"

#: build/en/book.xml:7901(title)
msgid "Best Practices for Merging"
msgstr "合并的最佳实践"

#: build/en/book.xml:7905(title)
msgid "Tracking Merges Manually"
msgstr "手工跟踪合并"

#: build/en/book.xml:7907(para)
msgid "Merging changes sounds simple enough, but in practice it can become a headache. The problem is that if you repeatedly merge changes from one branch to another, you might accidentally merge the same change <emphasis>twice</emphasis>. When this happens, sometimes things will work fine. When patching a file, Subversion typically notices if the file already has the change, and does nothing. But if the already-existing change has been modified in any way, you'll get a conflict."
msgstr "合并修改听起来很简单，但是实践起来会是很头痛的事，如果你重复合并两个分支，你也许会合并<emphasis>两次</emphasis>同样的修改。当这种事情发生时，有时候事情会依然正常，当对文件打补丁时，Subversion如果注意到这个文件已经有了相应的修改，而不会作任何操作，但是如果已经应用的修改又被修改了，你会得到冲突。"

#: build/en/book.xml:7917(para)
msgid "Ideally, your version control system should prevent the double-application of changes to a branch. It should automatically remember which changes a branch has already received, and be able to list them for you. It should use this information to help automate merges as much as possible."
msgstr "理想情况下，你的版本控制系统应该会阻止对一个分支做两次改变操作，必须自动的记住那一个分支的修改已经接收了，并且可以显示出来，用来尽可能帮助自动化的合并。"

#: build/en/book.xml:7926(para)
msgid "However, at the time of writing, this feature is being worked on!"
msgstr ""

#: build/en/book.xml:7924(para)
#, fuzzy
msgid "Unfortunately, Subversion is not such a system; it does not yet record any information about merge operations. <placeholder-1/> When you commit local modifications, the repository has no idea whether those changes came from running <command moreinfo=\"none\">svn merge</command>, or from just hand-editing the files."
msgstr "不幸的是，Subversion不是这样一个系统，类似于CVS，Subversion并不记录任何合并操作，当你提交本地修改，版本库并不能判断出你是通过<command moreinfo=\"none\">svn merge</command>还是手工修改得到这些文件。"

#: build/en/book.xml:7932(para)
msgid "What does this mean to you, the user? It means that until the day Subversion grows this feature, you'll have to track merge information yourself. The best place to do this is in the commit log-message. As demonstrated in the earlier example, it's recommended that your log-message mention a specific revision number (or range of revisions) that are being merged into your branch. Later on, you can run <command moreinfo=\"none\">svn log</command> to review which changes your branch already contains. This will allow you to carefully construct a subsequent <command moreinfo=\"none\">svn merge</command> command that won't be redundant with previously ported changes."
msgstr "这对你这样的用户意味着什么？这意味着除非Subversion以后发展这个特性，你必须手工的记录这些信息。最佳的方式是使用提交日志信息，像前面的例子提到的，推荐你在日志信息中说明合并的特定版本号（或是版本号的范围），之后，你可以运行<command moreinfo=\"none\">svn log</command>来查看你的分支包含哪些修改。这可以帮助你小心的依序运行<command moreinfo=\"none\">svn merge</command>命令而不会进行多余的合并。"

#: build/en/book.xml:7945(para)
msgid "In the next section, we'll show some examples of this technique in action."
msgstr "在下一小节，我们要展示一些这种技巧的例子。"

#: build/en/book.xml:7952(title)
msgid "Previewing Merges"
msgstr "预览合并"

#: build/en/book.xml:7954(para)
msgid "Because merging only results in local modifications, it's not usually a high-risk operation. If you get the merge wrong the first time, simply <command moreinfo=\"none\">svn revert</command> the changes and try again."
msgstr "因为合并只是导致本地修改，它不是一个高风险的操作，如果你在第一次操作错误，你可以运行<command moreinfo=\"none\">svn revert</command>来再试一次。"

#: build/en/book.xml:7959(para)
msgid "It's possible, however, that your working copy might already have local modifications. The changes applied by a merge will be mixed with your pre-existing ones, and running <command moreinfo=\"none\">svn revert</command> is no longer an option. The two sets of changes may be impossible to separate."
msgstr "有时候你的工作拷贝很可能已经改变了，合并会针对存在的那一个文件，这时运行<command moreinfo=\"none\">svn revert</command>不会恢复你在本地作的修改，两部分的修改无法识别出来。"

#: build/en/book.xml:7965(para)
msgid "In cases like this, people take comfort in being able to predict or examine merges before they happen. One simple way to do that is to run <command moreinfo=\"none\">svn diff</command> with the same arguments you plan to pass to <command moreinfo=\"none\">svn merge</command>, as we already showed in our first example of merging. Another method of previewing is to pass the <option>--dry-run</option> option to the merge command:"
msgstr "在这个情况下，人们很乐意能够在合并之前预测一下，一个简单的方法是使用运行<command moreinfo=\"none\">svn merge</command>同样的参数运行<command moreinfo=\"none\">svn diff</command>，另一种方式是传递<option>--dry-run</option>选项给merge命令："

#: build/en/book.xml:7974(screen)
#, no-wrap
msgid ""
"\n"
"$ svn merge --dry-run -c 344 http://svn.example.com/repos/calc/trunk\n"
"U  integer.c\n"
"\n"
"$ svn status\n"
"#  nothing printed, working copy is still unchanged.\n"
msgstr ""
"\n"
"$ svn merge --dry-run -c 344 http://svn.example.com/repos/calc/trunk\n"
"U  integer.c\n"
"\n"
"$ svn status\n"
"#  nothing printed, working copy is still unchanged.\n"

#: build/en/book.xml:7982(para)
msgid "The <option>--dry-run</option> option doesn't actually apply any local changes to the working copy. It only shows status codes that <emphasis>would</emphasis> be printed in a real merge. It's useful for getting a <quote>high level</quote> preview of the potential merge, for those times when running <command moreinfo=\"none\">svn diff</command> gives too much detail."
msgstr "<option>--dry-run</option>选项实际上并不修改本地拷贝，它只是显示实际合并时的状态信息，对于得到<quote>整体</quote>的印象，这个命令很有用，因为<command moreinfo=\"none\">svn diff</command>包括太多细节。"

#: build/en/book.xml:7994(title)
msgid "Merge Conflicts"
msgstr "合并冲突"

#: build/en/book.xml:7996(para)
msgid "Just like the <command moreinfo=\"none\">svn update</command> command, <command moreinfo=\"none\">svn merge</command> applies changes to your working copy. And therefore it's also capable of creating conflicts. The conflicts produced by <command moreinfo=\"none\">svn merge</command>, however, are sometimes different, and this section explains those differences."
msgstr "就像<command moreinfo=\"none\">svn update</command>命令，<command moreinfo=\"none\">svn merge</command>会把修改应用到工作拷贝，因此它也会造成冲突，因为<command moreinfo=\"none\">svn merge</command>造成的冲突有时候会有些不同，本小节会解释这些区别。"

#: build/en/book.xml:8003(para)
msgid "To begin with, assume that your working copy has no local edits. When you <command moreinfo=\"none\">svn update</command> to a particular revision, the changes sent by the server will always apply <quote>cleanly</quote> to your working copy. The server produces the delta by comparing two trees: a virtual snapshot of your working copy, and the revision tree you're interested in. Because the left-hand side of the comparison is exactly equal to what you already have, the delta is guaranteed to correctly convert your working copy into the right-hand tree."
msgstr "作为开始，我们假定本地没有修改，当你<command moreinfo=\"none\">svn update</command>到一个特定修订版本时，修改会<quote>干净的</quote>应用到工作拷贝，服务器产生比较两树的增量数据：一个工作拷贝和你关注的版本树的虚拟快照，因为比较的左边同你拥有的完全相同，增量数据确保你把工作拷贝转化到右边的树。"

#: build/en/book.xml:8014(para)
msgid "But <command moreinfo=\"none\">svn merge</command> has no such guarantees and can be much more chaotic: the user can ask the server to compare <emphasis>any</emphasis> two trees at all, even ones that are unrelated to the working copy! This means there's large potential for human error. Users will sometimes compare the wrong two trees, creating a delta that doesn't apply cleanly. <command moreinfo=\"none\">svn merge</command> will do its best to apply as much of the delta as possible, but some parts may be impossible. Just like the Unix <command moreinfo=\"none\">patch</command> command sometimes complains about <quote>failed hunks</quote>, <command moreinfo=\"none\">svn merge</command> will complain about <quote>skipped targets</quote>:"
msgstr "但是<command moreinfo=\"none\">svn merge</command>没有这样的保证，会导致很多的混乱：用户可以询问服务器比较<emphasis>任何</emphasis>两个树，即使一个与工作拷贝毫不相关的！这意味着有潜在的人为错误，用户有时候会比较两个错误的树，创建的增量数据不会干净的应用，<command moreinfo=\"none\">svn merge</command>会尽力应用更多的增量数据，但是有一些部分也许会难以完成，就像Unix下<command moreinfo=\"none\">patch</command>命令有时候会报告<quote>failed hunks</quote>错误，<command moreinfo=\"none\">svn merge</command>会报告<quote>skipped targets</quote>："

#: build/en/book.xml:8027(screen)
#, no-wrap
msgid ""
"\n"
"$ svn merge -r 1288:1351 http://svn.example.com/repos/branch\n"
"U  foo.c\n"
"U  bar.c\n"
"Skipped missing target: 'baz.c'\n"
"U  glub.c\n"
"C  glorb.h\n"
"\n"
"$\n"
msgstr ""
"\n"
"$ svn merge -r 1288:1351 http://svn.example.com/repos/branch\n"
"U  foo.c\n"
"U  bar.c\n"
"Skipped missing target: 'baz.c'\n"
"U  glub.c\n"
"C  glorb.h\n"
"\n"
"$\n"

#: build/en/book.xml:8038(para)
#, fuzzy
msgid "In the previous example it might be the case that <filename moreinfo=\"none\">baz.c</filename> exists in both snapshots of the branch being compared, and the resulting delta wants to change the file's contents, but the file doesn't exist in the working copy. Whatever the case, the <quote>skipped</quote> message means that the user is most likely comparing the wrong two trees; they're the classic sign of user error. When this happens, it's easy to recursively revert all the changes created by the merge (<command moreinfo=\"none\">svn revert --recursive</command>), delete any unversioned files or directories left behind after the revert, and re-run <command moreinfo=\"none\">svn merge</command> with different arguments."
msgstr "在前一个例子中，<filename moreinfo=\"none\">baz.c</filename>也许会存在于比较的两个分支快照里，但工作拷贝里不存在，比较的增量数据要应用到这个文件，这种情况下会发生什么？<quote>skipped</quote>信息意味着用户可能是在比较错误的两棵树，这是经典的驱动器错误，当发生这种情况，可以使用迭代恢复（<command moreinfo=\"none\">svn revert --recursive</command>）合并所作的修改，删除恢复后留下的所有未版本化的文件和目录，并且使用另外的参数运行<command moreinfo=\"none\">svn merge</command>。"

#: build/en/book.xml:8052(para)
msgid "Also notice that the previous example shows a conflict happening on <filename moreinfo=\"none\">glorb.h</filename>. We already stated that the working copy has no local edits: how can a conflict possibly happen? Again, because the user can use <command moreinfo=\"none\">svn merge</command> to define and apply any old delta to the working copy, that delta may contain textual changes that don't cleanly apply to a working file, even if the file has no local modifications."
msgstr "也应当注意前一个例子显示<filename moreinfo=\"none\">glorb.h</filename>发生了冲突，我们已经规定本地拷贝没有修改：冲突怎么会发生呢？因为用户可以使用<command moreinfo=\"none\">svn merge</command>将过去的任何变化应用到当前工作拷贝，变化包含的文本修改也许并不能干净的应用到工作拷贝文件，即使这些文件没有本地修改。"

#: build/en/book.xml:8061(para)
msgid "Another small difference between <command moreinfo=\"none\">svn update</command> and <command moreinfo=\"none\">svn merge</command> are the names of the full-text files created when a conflict happens. In <xref linkend=\"svn.tour.cycle.resolve\"/>, we saw that an update produces files named <filename moreinfo=\"none\">filename.mine</filename>, <filename moreinfo=\"none\">filename.rOLDREV</filename>, and <filename moreinfo=\"none\">filename.rNEWREV</filename>. When <command moreinfo=\"none\">svn merge</command> produces a conflict, though, it creates three files named <filename moreinfo=\"none\">filename.working</filename>, <filename moreinfo=\"none\">filename.left</filename>, and <filename moreinfo=\"none\">filename.right</filename>. In this case, the terms <quote>left</quote> and <quote>right</quote> are describing which side of the double-tree comparison the file came from. In any case, these differing names will help you distinguish between conflicts that happened as a result of an update versus ones that happened as a result of a merge."
msgstr "另一个<command moreinfo=\"none\">svn update</command>和<command moreinfo=\"none\">svn merge</command>的小区别是冲突产生的文件的名字不同，在<xref linkend=\"svn.tour.cycle.resolve\"/>，我们看到过更新产生的文件名字为<filename moreinfo=\"none\">filename.mine</filename>、<filename moreinfo=\"none\">filename.rOLDREV</filename>和<filename moreinfo=\"none\">filename.rNEWREV</filename>，当<command moreinfo=\"none\">svn merge</command>产生冲突时，它产生的三个文件分别为 <filename moreinfo=\"none\">filename.working</filename>、<filename moreinfo=\"none\">filename.left</filename>和<filename moreinfo=\"none\">filename.right</filename>。在这种情况下，术语<quote>left</quote>和<quote>right</quote>表示了两棵树比较时的两边，在两种情况下，不同的名字会帮助你区分冲突是因为更新造成的还是合并造成的。"

#: build/en/book.xml:8084(title)
msgid "Noticing or Ignoring Ancestry"
msgstr "关注还是忽视祖先"

#: build/en/book.xml:8086(para)
msgid "When conversing with a Subversion developer, you might very likely hear reference to the term <firstterm>ancestry</firstterm>. This word is used to describe the relationship between two objects in a repository: if they're related to each other, then one object is said to be an ancestor of the other."
msgstr "当与Subversion开发者交谈时你一定会听到提及术语<firstterm>祖先</firstterm>，这个词是用来描述两个对象的关系：如果他们互相关联，一个对象就是另一个的祖先，或者相反。"

#: build/en/book.xml:8093(para)
msgid "For example, suppose you commit revision 100, which includes a change to a file <filename moreinfo=\"none\">foo.c</filename>. Then <filename moreinfo=\"none\">foo.c@99</filename> is an <quote>ancestor</quote> of <filename moreinfo=\"none\">foo.c@100</filename>. On the other hand, suppose you commit the deletion of <filename moreinfo=\"none\">foo.c</filename> in revision 101, and then add a new file by the same name in revision 102. In this case, <filename moreinfo=\"none\">foo.c@99</filename> and <filename moreinfo=\"none\">foo.c@102</filename> may appear to be related (they have the same path), but in fact are completely different objects in the repository. They share no history or <quote>ancestry</quote>."
msgstr "举个例子，假设你提交版本100，包括对<filename moreinfo=\"none\">foo.c</filename>的修改，则foo.c@99是foo.c@100的一个<quote>祖先</quote>，另一方面，假设你在版本101删除这个文件，而在102版本提交一个同名的文件，在这个情况下，<filename moreinfo=\"none\">foo.c@99</filename>与<filename moreinfo=\"none\">foo.c@102</filename>看起来是关联的（有同样的路径），但是事实上他们是完全不同的对象，它们并不共享同一个历史或者说<quote>祖先</quote>。"

#: build/en/book.xml:8106(para)
msgid "The reason for bringing this up is to point out an important difference between <command moreinfo=\"none\">svn diff</command> and <command moreinfo=\"none\">svn merge</command>. The former command ignores ancestry, while the latter command is quite sensitive to it. For example, if you asked <command moreinfo=\"none\">svn diff</command> to compare revisions 99 and 102 of <filename moreinfo=\"none\">foo.c</filename>, you would see line-based diffs; the <literal moreinfo=\"none\">diff</literal> command is blindly comparing two paths. But if you asked <command moreinfo=\"none\">svn merge</command> to compare the same two objects, it would notice that they're unrelated and first attempt to delete the old file, then add the new file; the output would indicate a deletion followed by an add:"
msgstr "指出<command moreinfo=\"none\">svn diff</command>和<command moreinfo=\"none\">svn merge</command>区别的重要性在于，前一个命令忽略祖先，如果你询问<command moreinfo=\"none\">svn diff</command>来比较文件<filename moreinfo=\"none\">foo.c</filename>的版本99和102，你会看到行为基础的区别，<literal moreinfo=\"none\">diff</literal>命令只是盲目的比较两条路径，但是如果你使用<command moreinfo=\"none\">svn merge</command>是比较同样的两个对象，它会注意到他们是不关联的，而且首先尝试删除旧文件，然后添加新文件，输出会是一个删除紧接着一个增加："

#: build/en/book.xml:8119(screen)
#, no-wrap
msgid ""
"\n"
"D  foo.c\n"
"A  foo.c\n"
msgstr ""
"\n"
"D  foo.c\n"
"A  foo.c\n"

#: build/en/book.xml:8124(para)
msgid "Most merges involve comparing trees that are ancestrally related to one another, and therefore <command moreinfo=\"none\">svn merge</command> defaults to this behavior. Occasionally, however, you may want the <literal moreinfo=\"none\">merge</literal> command to compare two unrelated trees. For example, you may have imported two source-code trees representing different vendor releases of a software project (see <xref linkend=\"svn.advanced.vendorbr\"/>). If you asked <command moreinfo=\"none\">svn merge</command> to compare the two trees, you'd see the entire first tree being deleted, followed by an add of the entire second tree!"
msgstr "大多数合并包括比较包括祖先关联的两条树，因此<command moreinfo=\"none\">svn merge</command>这样运作，然而，你也许会希望<literal moreinfo=\"none\">merge</literal>命令能够比较两个不相关的目录树，举个例子，你有两个目录树分别代表了卖主软件项目的不同版本（见<xref linkend=\"svn.advanced.vendorbr\"/>），如果你使用<command moreinfo=\"none\">svn merge</command>进行比较，你会看到第一个目录树被删除，而第二个树添加上！"

#: build/en/book.xml:8135(para)
msgid "In these situations, you'll want <command moreinfo=\"none\">svn merge</command> to do a path-based comparison only, ignoring any relations between files and directories. Add the <option>--ignore-ancestry</option> option to your merge command, and it will behave just like <command moreinfo=\"none\">svn diff</command>. (And conversely, the <option>--notice-ancestry</option> option will cause <command moreinfo=\"none\">svn diff</command> to behave like the <literal moreinfo=\"none\">merge</literal> command.)"
msgstr "在这个情况下，你只是希望<command moreinfo=\"none\">svn merge</command>能够做一个以路径为基础的比较，忽略所有文件和目录的关系，增加<option>--ignore-ancestry</option>选项会导致命令象<command moreinfo=\"none\">svn diff</command>一样。（相应的，<option>--notice-ancestry</option>选项会使<command moreinfo=\"none\">svn diff</command>象<literal moreinfo=\"none\">merge</literal>命令一样行事。）"

#: build/en/book.xml:8149(title)
msgid "Merges and Moves"
msgstr "合并和移动"

#: build/en/book.xml:8151(para)
msgid "A common desire is to refactor source code, especially in Java-based software projects. Files and directories are shuffled around and renamed, often causing great disruption to everyone working on the project. Sounds like a perfect case to use a branch, doesn't it? Just create a branch, shuffle things around, then merge the branch back to the trunk, right?"
msgstr ""

#: build/en/book.xml:8159(para)
msgid "Alas, this scenario doesn't work so well right now, and is considered one of Subversion's current weak spots. The problem is that Subversion's <command moreinfo=\"none\">update</command> command isn't as robust as it should be, particularly when dealing with copy and move operations."
msgstr ""

#: build/en/book.xml:8165(para)
msgid "When you use <command moreinfo=\"none\">svn copy</command> to duplicate a file, the repository remembers where the new file came from, but it fails to transmit that information to the client which is running <command moreinfo=\"none\">svn update</command> or <command moreinfo=\"none\">svn merge</command>. Instead of telling the client, <quote>Copy that file you already have to this new location</quote>, it instead sends down an entirely new file. This can lead to problems, especially because the same thing happens with renamed files. A lesser-known fact about Subversion is that it lacks <quote>true renames</quote> — the <command moreinfo=\"none\">svn move</command> command is nothing more than an aggregation of <command moreinfo=\"none\">svn copy</command> and <command moreinfo=\"none\">svn delete</command>."
msgstr ""

#: build/en/book.xml:8179(para)
msgid "For example, suppose that while working on your private branch, you rename <filename moreinfo=\"none\">integer.c</filename> to <filename moreinfo=\"none\">whole.c</filename>. Effectively you've created a new file in your branch that is a copy of the original file, and deleted the original file. Meanwhile, back on <filename moreinfo=\"none\">trunk</filename>, Sally has committed some improvements to <filename moreinfo=\"none\">integer.c</filename>. Now you decide to merge your branch to the trunk:"
msgstr ""

#: build/en/book.xml:8188(screen)
#, no-wrap
msgid ""
"\n"
"$ cd calc/trunk\n"
"\n"
"$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch\n"
"D   integer.c\n"
"A   whole.c\n"
msgstr ""
"\n"
"$ cd calc/trunk\n"
"\n"
"$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch\n"
"D   integer.c\n"
"A   whole.c\n"

#: build/en/book.xml:8196(para)
msgid "This doesn't look so bad at first glance, but it's also probably not what you or Sally expected. The merge operation has deleted the latest version of <filename moreinfo=\"none\">integer.c</filename> file (the one containing Sally's latest changes), and blindly added your new <filename moreinfo=\"none\">whole.c</filename> file — which is a duplicate of the <emphasis>older</emphasis> version of <filename moreinfo=\"none\">integer.c</filename>. The net effect is that merging your <quote>rename</quote> to the branch has removed Sally's recent changes from the latest revision!"
msgstr ""

#: build/en/book.xml:8207(para)
msgid "This isn't true data-loss; Sally's changes are still in the repository's history, but it may not be immediately obvious that this has happened. The moral of this story is that until Subversion improves, be very careful about merging copies and renames from one branch to another."
msgstr ""

#: build/en/book.xml:8225(title)
msgid "Common Use-Cases"
msgstr "常见用例"

#: build/en/book.xml:8227(para)
msgid "There are many different uses for branching and <command moreinfo=\"none\">svn merge</command>, and this section describes the most common ones you're likely to run into."
msgstr "分支和<command moreinfo=\"none\">svn merge</command>有很多不同的用法，这个小节描述了最常见的用法。"

#: build/en/book.xml:8233(title)
msgid "Merging a Whole Branch to Another"
msgstr "合并分支到另一分支"

#: build/en/book.xml:8235(para)
msgid "To complete our running example, we'll move forward in time. Suppose several days have passed, and many changes have happened on both the trunk and your private branch. Suppose that you've finished working on your private branch; the feature or bug fix is finally complete, and now you want to merge all of your branch changes back into the trunk for others to enjoy."
msgstr "为了完成这个例子，我们将时间往前推进，假定已经过了几天，在主干和你的分支上都有许多更改，假定你完成了分支上的工作，已经完成了特性或bug修正，你想合并所有分支的修改到主干上，让别人也可以使用。"

#: build/en/book.xml:8243(para)
msgid "So how do we use <command moreinfo=\"none\">svn merge</command> in this scenario? Remember that this command compares two trees, and applies the differences to a working copy. So to receive the changes, you need to have a working copy of the trunk. We'll assume that either you still have your original one lying around (fully updated), or that you recently checked out a fresh working copy of <filename moreinfo=\"none\">/calc/trunk</filename>."
msgstr "这种情况下如何使用<command moreinfo=\"none\">svn merge</command>？记住这个命令比较两个目录树，然后应用比较结果到工作拷贝，所以要接受这种变化，你需要主干的工作拷贝，我们假设你有一个最初的主干工作拷贝（完全更新），或者是你最近取出了<filename moreinfo=\"none\">/calc/trunk</filename>的一个干净的工作拷贝。"

#: build/en/book.xml:8251(para)
msgid "But which two trees should be compared? At first glance, the answer may seem obvious: just compare the latest trunk tree with your latest branch tree. But beware—this assumption is <emphasis>wrong</emphasis>, and has burned many a new user! Since <command moreinfo=\"none\">svn merge</command> operates like <command moreinfo=\"none\">svn diff</command>, comparing the latest trunk and branch trees will <emphasis>not</emphasis> merely describe the set of changes you made to your branch. Such a comparison shows too many changes: it would not only show the addition of your branch changes, but also the <emphasis>removal</emphasis> of trunk changes that never happened on your branch."
msgstr "但是要哪两个树进行比较呢？乍一看，回答很明确，只要比较最新的主干与分支。但是你要意识到—这个想法是<emphasis>错误的</emphasis>，伤害了许多新用户！因为<command moreinfo=\"none\">svn merge</command>的操作很像<command moreinfo=\"none\">svn diff</command>，比较最新的主干和分支树不仅仅会描述你在分支上所作的修改，这样的比较会展示太多的不同，不仅包括分支上的增加，也包括了主干上的删除操作，而这些删除根本就没有在分支上发生过。"

#: build/en/book.xml:8263(para)
msgid "To express only the changes that happened on your branch, you need to compare the initial state of your branch to its final state. Using <command moreinfo=\"none\">svn log</command> on your branch, you can see that your branch was created in revision 341. And the final state of your branch is simply a matter of using the <literal moreinfo=\"none\">HEAD</literal> revision. That means you want to compare revisions 341 and <literal moreinfo=\"none\">HEAD</literal> of your branch directory, and apply those differences to a working copy of the trunk."
msgstr "为了表示你的分支上的修改，你只需要比较分支的初始状态与最终状态，在你的分支上使用<command moreinfo=\"none\">svn log</command>命令，你可以看到你的分支在341版本建立，你的分支最终的状态用<literal moreinfo=\"none\">HEAD</literal>版本表示，这意味着你希望能够比较版本341和<literal moreinfo=\"none\">HEAD</literal>的分支目录，然后应用这些分支的修改到主干目录的工作拷贝。"

#: build/en/book.xml:8274(para)
msgid "A nice way of finding the revision in which a branch was created (the <quote>base</quote> of the branch) is to use the <option>--stop-on-copy</option> option to <command moreinfo=\"none\">svn log</command>. The log subcommand will normally show every change ever made to the branch, including tracing back through the copy which created the branch. So normally, you'll see history from the trunk as well. The <option>--stop-on-copy</option> will halt log output as soon as <command moreinfo=\"none\">svn log</command> detects that its target was copied or renamed."
msgstr "查找分支产生的版本（分支的<quote>基准</quote>）的最好方法是在<command moreinfo=\"none\">svn log</command>中使用<option>--stop-on-copy</option>选项，log子命令通常会显示所有关于分支的变化，包括 创建分支的过程，就好像你在主干上一样，<option>--stop-on-copy</option>会在<command moreinfo=\"none\">svn log</command>检测到目标拷贝或者改名时中止日志输出。"

#: build/en/book.xml:8285(para)
msgid "So in our continuing example,"
msgstr "所以，在我们的例子里，"

#: build/en/book.xml:8287(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log -v --stop-on-copy \\\n"
"          http://svn.example.com/repos/calc/branches/my-calc-branch\n"
"…\n"
"------------------------------------------------------------------------\n"
"r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines\n"
"Changed paths:\n"
"   A /calc/branches/my-calc-branch (from /calc/trunk:340)\n"
"\n"
"$\n"
msgstr ""
"\n"
"$ svn log -v --stop-on-copy \\\n"
"          http://svn.example.com/repos/calc/branches/my-calc-branch\n"
"…\n"
"------------------------------------------------------------------------\n"
"r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines\n"
"Changed paths:\n"
"   A /calc/branches/my-calc-branch (from /calc/trunk:340)\n"
"\n"
"$\n"

#: build/en/book.xml:8299(para)
msgid "As expected, the final revision printed by this command is the revision in which <filename moreinfo=\"none\">my-calc-branch</filename> was created by copying."
msgstr "正如所料，最后的打印出的版本正是<filename moreinfo=\"none\">my-calc-branch</filename>生成的版本。"

#: build/en/book.xml:8305(para)
msgid "Here's the final merging procedure, then:"
msgstr "如下是最终的合并过程，然后："

#: build/en/book.xml:8307(screen)
#, no-wrap
msgid ""
"\n"
"$ cd calc/trunk\n"
"$ svn update\n"
"At revision 405.\n"
"\n"
"$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch\n"
"U   integer.c\n"
"U   button.c\n"
"U   Makefile\n"
"\n"
"$ svn status\n"
"M   integer.c\n"
"M   button.c\n"
"M   Makefile\n"
"\n"
"# ...examine the diffs, compile, test, etc...\n"
"\n"
"$ svn commit -m \"Merged my-calc-branch changes r341:405 into the trunk.\"\n"
"Sending        integer.c\n"
"Sending        button.c\n"
"Sending        Makefile\n"
"Transmitting file data ...\n"
"Committed revision 406.\n"
msgstr ""
"\n"
"$ cd calc/trunk\n"
"$ svn update\n"
"At revision 405.\n"
"\n"
"$ svn merge -r 341:405 http://svn.example.com/repos/calc/branches/my-calc-branch\n"
"U   integer.c\n"
"U   button.c\n"
"U   Makefile\n"
"\n"
"$ svn status\n"
"M   integer.c\n"
"M   button.c\n"
"M   Makefile\n"
"\n"
"# ...examine the diffs, compile, test, etc...\n"
"\n"
"$ svn commit -m \"Merged my-calc-branch changes r341:405 into the trunk.\"\n"
"Sending        integer.c\n"
"Sending        button.c\n"
"Sending        Makefile\n"
"Transmitting file data ...\n"
"Committed revision 406.\n"

#: build/en/book.xml:8332(para)
msgid "Again, notice that the commit log message very specifically mentions the range of changes that was merged into the trunk. Always remember to do this, because it's critical information you'll need later on."
msgstr "再次说明，日志信息中详细描述了合并到主干的的修改范围，记住一定要这么做，这是你以后需要的重要信息。"

#: build/en/book.xml:8337(para)
msgid "For example, suppose you decide to keep working on your branch for another week, in order to complete an enhancement to your original feature or bug fix. The repository's <literal moreinfo=\"none\">HEAD</literal> revision is now 480, and you're ready to do another merge from your private branch to the trunk. But as discussed in <xref linkend=\"svn.branchmerge.copychanges.bestprac\"/>, you don't want to merge the changes you've already merged before; you only want to merge everything <quote>new</quote> on your branch since the last time you merged. The trick is to figure out what's new."
msgstr "举个例子，你希望在分支上继续工作一周，来进一步加强你的修正，这时版本库的<literal moreinfo=\"none\">HEAD</literal>版本是480，你准备好了另一次合并，但是我们在<xref linkend=\"svn.branchmerge.copychanges.bestprac\"/>提到过，你不想合并已经合并的内容，你只想合并新的东西，技巧就是指出什么是<quote>新</quote>的。"

#: build/en/book.xml:8348(para)
msgid "The first step is to run <command moreinfo=\"none\">svn log</command> on the trunk, and look for a log message about the last time you merged from the branch:"
msgstr "第一步是在主干上运行<command moreinfo=\"none\">svn log</command>察看最后一次与分支合并的日志信息："

#: build/en/book.xml:8352(screen)
#, no-wrap
msgid ""
"\n"
"$ cd calc/trunk\n"
"$ svn log\n"
"…\n"
"------------------------------------------------------------------------\n"
"r406 | user | 2004-02-08 11:17:26 -0600 (Sun, 08 Feb 2004) | 1 line\n"
"\n"
"Merged my-calc-branch changes r341:405 into the trunk.\n"
"------------------------------------------------------------------------\n"
"…\n"
msgstr ""
"\n"
"$ cd calc/trunk\n"
"$ svn log\n"
"…\n"
"------------------------------------------------------------------------\n"
"r406 | user | 2004-02-08 11:17:26 -0600 (Sun, 08 Feb 2004) | 1 line\n"
"\n"
"Merged my-calc-branch changes r341:405 into the trunk.\n"
"------------------------------------------------------------------------\n"
"…\n"

#: build/en/book.xml:8364(para)
msgid "Aha! Since all branch-changes that happened between revisions 341 and 405 were previously merged to the trunk as revision 406, you now know that you want to merge only the branch changes after that—by comparing revisions 406 and <literal moreinfo=\"none\">HEAD</literal>."
msgstr "阿哈！因为分支上341到405之间的所有修改已经在版本406合并了，现在你只需要合并分支在此之后的修改—通过比较406和<literal moreinfo=\"none\">HEAD</literal>。"

#: build/en/book.xml:8370(screen)
#, no-wrap
msgid ""
"\n"
"$ cd calc/trunk\n"
"$ svn update\n"
"At revision 480.\n"
"\n"
"# We notice that HEAD is currently 480, so we use it to do the merge:\n"
"\n"
"$ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch\n"
"U   integer.c\n"
"U   button.c\n"
"U   Makefile\n"
"\n"
"$ svn commit -m \"Merged my-calc-branch changes r406:480 into the trunk.\"\n"
"Sending        integer.c\n"
"Sending        button.c\n"
"Sending        Makefile\n"
"Transmitting file data ...\n"
"Committed revision 481.\n"
msgstr ""
"\n"
"$ cd calc/trunk\n"
"$ svn update\n"
"At revision 480.\n"
"\n"
"# We notice that HEAD is currently 480, so we use it to do the merge:\n"
"\n"
"$ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch\n"
"U   integer.c\n"
"U   button.c\n"
"U   Makefile\n"
"\n"
"$ svn commit -m \"Merged my-calc-branch changes r406:480 into the trunk.\"\n"
"Sending        integer.c\n"
"Sending        button.c\n"
"Sending        Makefile\n"
"Transmitting file data ...\n"
"Committed revision 481.\n"

#: build/en/book.xml:8390(para)
msgid "Now the trunk contains the complete second wave of changes made to the branch. At this point, you can either delete your branch (we'll discuss this later on), or continue working on your branch and repeat this procedure for subsequent merges."
msgstr "现在主干有了分支上第二波修改的完全结果，此刻，你可以删除你的分支（我们会在以后讨论），或是继续在你分支上工作，重复这个步骤。"

#: build/en/book.xml:8400(title)
msgid "Undoing Changes"
msgstr "取消修改"

#: build/en/book.xml:8402(para)
#, fuzzy
msgid "Another common use for <command moreinfo=\"none\">svn merge</command> is to roll back a change that has already been committed. Suppose you're working away happily on a working copy of <filename moreinfo=\"none\">/calc/trunk</filename>, and you discover that the change made way back in revision 303, which changed <filename moreinfo=\"none\">integer.c</filename>, is completely wrong. It never should have been committed. You can use <command moreinfo=\"none\">svn merge</command> to <quote>undo</quote> the change in your working copy, and then commit the local modification to the repository. All you need to do is to specify a <emphasis>reverse</emphasis> difference. (You can do this by specifying <option>--revision 303:302</option>, or by an equivalent <option>--change -303</option>.)"
msgstr "<command moreinfo=\"none\">svn merge</command>另一个常用的做法是取消已经做得提交，假设你愉快的在<filename moreinfo=\"none\">/calc/trunk</filename>工作，你发现303版本对<filename moreinfo=\"none\">integer.c</filename>的修改完全错了，它不应该被提交，你可以使用<command moreinfo=\"none\">svn merge</command>来<quote>取消</quote>这个工作拷贝上所作的操作，然后提交本地修改到版本库，你要做得只是指定一个相反的区别："

#: build/en/book.xml:8417(screen)
#, no-wrap
msgid ""
"\n"
"$ svn merge -c -303 http://svn.example.com/repos/calc/trunk\n"
"U  integer.c\n"
"\n"
"$ svn status\n"
"M  integer.c\n"
"\n"
"$ svn diff\n"
"…\n"
"# verify that the change is removed\n"
"…\n"
"\n"
"$ svn commit -m \"Undoing change committed in r303.\"\n"
"Sending        integer.c\n"
"Transmitting file data .\n"
"Committed revision 350.\n"
msgstr ""
"\n"
"$ svn merge -c -303 http://svn.example.com/repos/calc/trunk\n"
"U  integer.c\n"
"\n"
"$ svn status\n"
"M  integer.c\n"
"\n"
"$ svn diff\n"
"…\n"
"# verify that the change is removed\n"
"…\n"
"\n"
"$ svn commit -m \"Undoing change committed in r303.\"\n"
"Sending        integer.c\n"
"Transmitting file data .\n"
"Committed revision 350.\n"

#: build/en/book.xml:8435(para)
msgid "One way to think about a repository revision is as a specific group of changes (some version control systems call these <firstterm>changesets</firstterm>). By using the <option>-r</option> switch, you can ask <command moreinfo=\"none\">svn merge</command> to apply a changeset, or whole range of changesets, to your working copy. In our case of undoing a change, we're asking <command moreinfo=\"none\">svn merge</command> to apply changeset #303 to our working copy <emphasis>backwards</emphasis>."
msgstr "我们可以把版本库修订版本想象成一组修改（一些版本控制系统叫做<firstterm>修改集</firstterm>），通过<option>-r</option>选项，你可以告诉<command moreinfo=\"none\">svn merge</command>来应用修改集或是一个修改集范围到你的工作拷贝，在我们的情况例子里，我们使用<command moreinfo=\"none\">svn merge</command>合并修改集#303到工作拷贝。"

#: build/en/book.xml:8446(title)
msgid "Subversion and Changesets"
msgstr "Subversion 与修改集"

#: build/en/book.xml:8448(para)
msgid "Everyone seems to have a slightly different definition of <quote>changeset</quote>, or at least a different expectation of what it means for a version control system to have <quote>changeset features</quote>. For our purpose, let's say that a changeset is just a collection of changes with a unique name. The changes might include textual edits to file contents, modifications to tree structure, or tweaks to metadata. In more common speak, a changeset is just a patch with a name you can refer to."
msgstr "每一个人对于<quote>修改集</quote>的概念都有些不一样，至少对于版本控制系统的<quote>修改集特性</quote>这一概念有着不同的期望，根据我们的用途，可以说修改集只是一个有唯一名字的一系列修改集合，修改也许包括文件内容的修改，目录树结构的修改，或是元数据的调整，更通常的说法，一个修改集就是我们可以引用的有名字的补丁。"

#: build/en/book.xml:8458(para)
#, fuzzy
msgid "In Subversion, a global revision number N names a tree in the repository: it's the way the repository looked after the Nth commit. It's also the name of an implicit changeset: if you compare tree N with tree N-1, you can derive the exact patch that was committed. For this reason, it's easy to think of <quote>revision N</quote> as not just a tree, but a changeset as well. If you use an issue tracker to manage bugs, you can use the revision numbers to refer to particular patches that fix bugs—for example, <quote>this issue was fixed by revision 9238.</quote>. Somebody can then run <command moreinfo=\"none\">svn log -r9238</command> to read about the exact changeset which fixed the bug, and run <command moreinfo=\"none\">svn diff -c 9238</command> to see the patch itself. And Subversion's <literal moreinfo=\"none\">merge</literal> command also uses revision numbers. You can merge specific changesets from one branch to another by naming them in the merge arguments: <command moreinfo=\"none\">svn merge -r9237:9238</command> would merge changeset #9238 into your working copy."
msgstr "在Subversion里，一个全局的修订版本号N标示一个版本库中的树：它代表版本库在N次提交后的样子，它也是一个修改集的隐含名称：如果你比较树N与树N-1，你可以得到你提交的补丁。出于这个原因，想象<quote>版本N</quote>并不只是一棵树，也是一个修改集。如果你使用一个问题追踪工具来管理bug，你可以使用版本号来表示特定的补丁修正了bug—举个例子，<quote>这个问题是在版本9238修正的</quote>，然后其他人可以运行<command moreinfo=\"none\">svn log -r9238</command>来查看修正这个bug的修改集，或者使用<command moreinfo=\"none\">svn diff -r9237:9238</command>来看补丁本身。Subversion的<literal moreinfo=\"none\">合并</literal>命令也使用版本号作为参数，可以将特定修改集从一个分支合到另一个分支：<command moreinfo=\"none\">svn merge -r9237:9238</command>将会合并修改集#9238到本地拷贝。"

#: build/en/book.xml:8478(para)
msgid "Keep in mind that rolling back a change like this is just like any other <command moreinfo=\"none\">svn merge</command> operation, so you should use <command moreinfo=\"none\">svn status</command> and <command moreinfo=\"none\">svn diff</command> to confirm that your work is in the state you want it to be in, and then use <command moreinfo=\"none\">svn commit</command> to send the final version to the repository. After committing, this particular changeset is no longer reflected in the <literal moreinfo=\"none\">HEAD</literal> revision."
msgstr "记住回滚修改和任何一个<command moreinfo=\"none\">svn merge</command>命令都一样，所以你应该使用<command moreinfo=\"none\">svn status</command>或是<command moreinfo=\"none\">svn diff</command>来确定你的工作处于期望的状态中，然后使用<command moreinfo=\"none\">svn commit</command>来提交，提交之后，这个特定修改集不会反映到<literal moreinfo=\"none\">HEAD</literal>版本了。"

#: build/en/book.xml:8487(para)
msgid "Again, you may be thinking: well, that really didn't undo the commit, did it? The change still exists in revision 303. If somebody checks out a version of the <filename moreinfo=\"none\">calc</filename> project between revisions 303 and 349, they'll still see the bad change, right?"
msgstr "继续，你也许会想：好吧，这不是真的取消提交吧！是吧？版本303还依然存在着修改，如果任何人取出<filename moreinfo=\"none\">calc</filename>的303-349版本，他还会得到错误的修改，对吧？"

#: build/en/book.xml:8509(para)
#, fuzzy
msgid "The Subversion project has plans, however, to someday implement a command that would accomplish the task of permanently deleting information. In the meantime, see <xref linkend=\"svn.reposadmin.maint.tk.svndumpfilter\"/> for a possible workaround."
msgstr "Subversion项目有计划，不管用什么方式，总有一天要实现<command moreinfo=\"none\">svnadmin obliterate</command>命令来进行永久删除操作，而此时可以看<xref linkend=\"svn.reposadmin.maint.tk.svndumpfilter\"/>。"

#: build/en/book.xml:8493(para)
#, fuzzy
msgid "Yes, that's true. When we talk about <quote>removing</quote> a change, we're really talking about removing it from <literal moreinfo=\"none\">HEAD</literal>. The original change still exists in the repository's history. For most situations, this is good enough. Most people are only interested in tracking the <literal moreinfo=\"none\">HEAD</literal> of a project anyway. There are special cases, however, where you really might want to destroy all evidence of the commit. (Perhaps somebody accidentally committed a confidential document.) This isn't so easy, it turns out, because Subversion was deliberately designed to never lose information. Revisions are immutable trees which build upon one another. Removing a revision from history would cause a domino effect, creating chaos in all subsequent revisions and possibly invalidating all working copies. <placeholder-1/>"
msgstr "是的，这是对的。当我们说<quote>删除</quote>一个修改时，我们只是说从<literal moreinfo=\"none\">HEAD</literal>删除，原始的修改还保存在版本库历史中，在多数情况下，这是足够好的。大多数人只是对追踪<literal moreinfo=\"none\">HEAD</literal>版本感兴趣，在一些特定情况下，你也许希望毁掉所有提交的证据（或许某个人提交了一个秘密文件），这不是很容易的，因为Subversion设计用来不丢失任何信息，每个修订版本都是不可变的目录树 ，从历史删除一个版本会导致多米诺效应，会在后面的版本导致混乱甚至会影响所有的工作拷贝。 <footnote><placeholder-1/></footnote>"

#: build/en/book.xml:8521(title)
msgid "Resurrecting Deleted Items"
msgstr "找回删除的项目"

#: build/en/book.xml:8523(para)
msgid "The great thing about version control systems is that information is never lost. Even when you delete a file or directory, it may be gone from the <literal moreinfo=\"none\">HEAD</literal> revision, but the object still exists in earlier revisions. One of the most common questions new users ask is, <quote>How do I get my old file or directory back?</quote>."
msgstr "版本控制系统非常重要的一个特性就是它的信息从不丢失，即使当你删除了文件或目录，它也许从HEAD版本消失了 ，但这个对象依然存在于历史的早期版本 ，一个新手经常问到的问题是<quote>怎样找回我的文件和目录？</quote>"

#: build/en/book.xml:8530(para)
#, fuzzy
msgid "The first step is to define exactly <emphasis role=\"bold\">which</emphasis> item you're trying to resurrect. Here's a useful metaphor: you can think of every object in the repository as existing in a sort of two-dimensional coordinate system. The first coordinate is a particular revision tree, and the second coordinate is a path within that tree. So every version of your file or directory can be defined by a specific coordinate pair. (Remember the familiar <quote>peg revision</quote> syntax — foo.c@224 — mentioned back in <xref linkend=\"svn.advanced.pegrevs\"/>.)"
msgstr "第一步首先要知道需要拯救的项目是<emphasis role=\"bold\">什么</emphasis>，这里有个很有用的比喻：你可以认为任何存在于版本库的对象生活在一个二维的坐标系统里，第一维是一个特定的版本树，第二维是在树中的路径，所以你的文件或目录的任何版本可以有这样一对坐标定义。"

#: build/en/book.xml:8542(para)
#, fuzzy
msgid "First, you might need to use <command moreinfo=\"none\">svn log</command> to discover the exact coordinate pair you wish to resurrect. A good strategy is to run <command moreinfo=\"none\">svn log --verbose</command> in a directory which used to contain your deleted item. The <option>--verbose (-v)</option> option shows a list of all changed items in each revision; all you need to do is find the revision in which you deleted the file or directory. You can do this visually, or by using another tool to examine the log output (via <command moreinfo=\"none\">grep</command>, or perhaps via an incremental search in an editor)."
msgstr "Subversion没有向CVS一样的<filename moreinfo=\"none\">古典</filename>目录， <footnote><placeholder-1/></footnote> 所以你需要<command moreinfo=\"none\">svn log</command>来察看你需要找回的坐标对，一个好的策略是使用<command moreinfo=\"none\">svn log --verbose</command>来察看你删除的项目，--verbose选项显示所有改变的项目的每一个版本 ，你只需要找出你删除文件或目录的那一个版本。你可以通过目测找出这个版本，也可以使用另一种工具来检查日志的输出 （通过<command moreinfo=\"none\">grep</command>或是在编辑器里增量查找）。"

#: build/en/book.xml:8553(screen)
#, no-wrap
msgid ""
"\n"
"$ cd parent-dir\n"
"$ svn log -v\n"
"…\n"
"------------------------------------------------------------------------\n"
"r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines\n"
"Changed paths:\n"
"   D /calc/trunk/real.c\n"
"   M /calc/trunk/integer.c\n"
"\n"
"Added fast fourier transform functions to integer.c.\n"
"Removed real.c because code now in double.c.\n"
"…\n"
msgstr ""
"\n"
"$ cd parent-dir\n"
"$ svn log -v\n"
"…\n"
"------------------------------------------------------------------------\n"
"r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines\n"
"Changed paths:\n"
"   D /calc/trunk/real.c\n"
"   M /calc/trunk/integer.c\n"
"\n"
"Added fast fourier transform functions to integer.c.\n"
"Removed real.c because code now in double.c.\n"
"…\n"

#: build/en/book.xml:8568(para)
msgid "In the example, we're assuming that you're looking for a deleted file <filename moreinfo=\"none\">real.c</filename>. By looking through the logs of a parent directory, you've spotted that this file was deleted in revision 808. Therefore, the last version of the file to exist was in the revision right before that. Conclusion: you want to resurrect the path <filename moreinfo=\"none\">/calc/trunk/real.c</filename> from revision 807."
msgstr "在这个例子里，你可以假定你正在找已经删除了的文件<filename moreinfo=\"none\">real.c</filename>，通过查找父目录的历史 ，你知道这个文件在808版本被删除，所以存在这个对象的版本在此之前 。结论：你想从版本807找回<filename moreinfo=\"none\">/calc/trunk/real.c</filename>。"

#: build/en/book.xml:8577(para)
msgid "That was the hard part—the research. Now that you know what you want to restore, you have two different choices."
msgstr "以上是最重要的部分—重新找到你需要恢复的对象。现在你已经知道该恢复的文件，而你有两种选择。"

#: build/en/book.xml:8581(para)
msgid "One option is to use <command moreinfo=\"none\">svn merge</command> to apply revision 808 <quote>in reverse</quote>. (We've already discussed how to undo changes, see <xref linkend=\"svn.branchmerge.commonuses.undo\"/>.) This would have the effect of re-adding <filename moreinfo=\"none\">real.c</filename> as a local modification. The file would be scheduled for addition, and after a commit, the file would again exist in <literal moreinfo=\"none\">HEAD</literal>."
msgstr "一种是对版本反向使用<command moreinfo=\"none\">svn merge</command>到808（我们已经学会了如何取消修改，见<xref linkend=\"svn.branchmerge.commonuses.undo\"/>），这样会重新添加<filename moreinfo=\"none\">real.c</filename>，这个文件会列入增加的计划，经过一次提交，这个文件重新回到<literal moreinfo=\"none\">HEAD</literal>。"

#: build/en/book.xml:8590(para)
msgid "In this particular example, however, this is probably not the best strategy. Reverse-applying revision 808 would not only schedule <filename moreinfo=\"none\">real.c</filename> for addition, but the log message indicates that it would also undo certain changes to <filename moreinfo=\"none\">integer.c</filename>, which you don't want. Certainly, you could reverse-merge revision 808 and then <command moreinfo=\"none\">svn revert</command> the local modifications to <filename moreinfo=\"none\">integer.c</filename>, but this technique doesn't scale well. What if there were 90 files changed in revision 808?"
msgstr "在这个例子里，这不是一个好的策略，这样做不仅把<filename moreinfo=\"none\">real.c</filename>加入添加到计划，也取消了对<filename moreinfo=\"none\">integer.c</filename>的修改，而这不是你期望的。确实，你可以恢复到版本808，然后对<filename moreinfo=\"none\">integer.c</filename>执行取消<command moreinfo=\"none\">svn revert</command>操作，但这样的操作无法扩大使用，因为如果从版本808修改了90个文件怎么办？"

#: build/en/book.xml:8601(para)
msgid "A second, more targeted strategy is not to use <command moreinfo=\"none\">svn merge</command> at all, but rather the <command moreinfo=\"none\">svn copy</command> command. Simply copy the exact revision and path <quote>coordinate pair</quote> from the repository to your working copy:"
msgstr "所以第二个方法不是使用<command moreinfo=\"none\">svn merge</command>，而是使用<command moreinfo=\"none\">svn copy</command>命令，精确的拷贝版本和路径<quote>坐标对</quote>到你的工作拷贝："

#: build/en/book.xml:8607(screen)
#, no-wrap
msgid ""
"\n"
"$ svn copy -r 807 \\\n"
"           http://svn.example.com/repos/calc/trunk/real.c ./real.c\n"
"\n"
"$ svn status\n"
"A  +   real.c\n"
"\n"
"$ svn commit -m \"Resurrected real.c from revision 807, /calc/trunk/real.c.\"\n"
"Adding         real.c\n"
"Transmitting file data .\n"
"Committed revision 1390.\n"
msgstr ""
"\n"
"$ svn copy -r 807 \\\n"
"           http://svn.example.com/repos/calc/trunk/real.c ./real.c\n"
"\n"
"$ svn status\n"
"A  +   real.c\n"
"\n"
"$ svn commit -m \"Resurrected real.c from revision 807, /calc/trunk/real.c.\"\n"
"Adding         real.c\n"
"Transmitting file data .\n"
"Committed revision 1390.\n"

#: build/en/book.xml:8620(para)
msgid "The plus sign in the status output indicates that the item isn't merely scheduled for addition, but scheduled for addition <quote>with history</quote>. Subversion remembers where it was copied from. In the future, running <command moreinfo=\"none\">svn log</command> on this file will traverse back through the file's resurrection and through all the history it had prior to revision 807. In other words, this new <filename moreinfo=\"none\">real.c</filename> isn't really new; it's a direct descendant of the original, deleted file."
msgstr "加号标志表明这个项目不仅仅是计划增加中，而且还包含了历史，Subversion记住了它是从哪个拷贝过来的。在将来，对这个文件运行<command moreinfo=\"none\">svn log</command>会看到这个文件在版本807之前的历史，换句话说，<filename moreinfo=\"none\">real.c</filename>不是新的，而是原先删除的那一个的后代。"

#: build/en/book.xml:8630(para)
msgid "Although our example shows us resurrecting a file, note that these same techniques work just as well for resurrecting deleted directories."
msgstr "尽管我们的例子告诉我们如何找回文件，对于恢复删除的目录也是一样的。"

#: build/en/book.xml:8638(title)
msgid "Common Branching Patterns"
msgstr "常用分支模式"

#: build/en/book.xml:8640(para)
msgid "Version control is most often used for software development, so here's a quick peek at two of the most common branching/merging patterns used by teams of programmers. If you're not using Subversion for software development, feel free to skip this section. If you're a software developer using version control for the first time, pay close attention, as these patterns are often considered best practices by experienced folk. These processes aren't specific to Subversion; they're applicable to any version control system. Still, it may help to see them described in Subversion terms."
msgstr "版本控制在软件开发中广泛使用，这里是团队里程序员最常用的两种分支/合并模式的介绍，如果你不是使用Subversion软件开发，可随意跳过本小节，如果你是第一次使用版本控制的软件开发者，请更加注意，以下模式被许多老兵当作最佳实践，这个过程并不只是针对Subversion，在任何版本控制系统中都一样，但是在这里使用Subversion术语会感觉更方便一点。"

#: build/en/book.xml:8654(title)
msgid "Release Branches"
msgstr "发布分支"

#: build/en/book.xml:8656(para)
msgid "Most software has a typical lifecycle: code, test, release, repeat. There are two problems with this process. First, developers need to keep writing new features while quality-assurance teams take time to test supposedly-stable versions of the software. New work cannot halt while the software is tested. Second, the team almost always needs to support older, released versions of software; if a bug is discovered in the latest code, it most likely exists in released versions as well, and customers will want to get that bugfix without having to wait for a major new release."
msgstr "大多数软件存在这样一个生命周期：编码、测试、发布，然后重复。这样有两个问题，第一，开发者需要在质量保证小组测试假定稳定版本时继续开发新特性，新工作在软件测试时不可以中断，第二，小组必须一直支持老的发布版本和软件；如果一个bug在最新的代码中发现，它一定也存在已发布的版本中，客户希望立刻得到错误修正而不必等到新版本发布。"

#: build/en/book.xml:8668(para)
msgid "Here's where version control can help. The typical procedure looks like this:"
msgstr "这是版本控制可以做的帮助，典型的过程如下："

#: build/en/book.xml:8674(para)
msgid "<emphasis>Developers commit all new work to the trunk.</emphasis> Day-to-day changes are committed to <filename moreinfo=\"none\">/trunk</filename>: new features, bugfixes, and so on."
msgstr "<emphasis>开发者提交所有的新特性到主干。</emphasis> 每日的修改提交到<filename moreinfo=\"none\">/trunk</filename>：新特性，bug修正和其他。"

#: build/en/book.xml:8683(para)
msgid "<emphasis>The trunk is copied to a <quote>release</quote> branch.</emphasis> When the team thinks the software is ready for release (say, a 1.0 release), then <filename moreinfo=\"none\">/trunk</filename> might be copied to <filename moreinfo=\"none\">/branches/1.0</filename>."
msgstr "<emphasis>这个主干被拷贝到<quote>发布</quote>分支。</emphasis> 当小组认为软件已经做好发布的准备（如，版本1.0）然后<filename moreinfo=\"none\">/trunk</filename>会被拷贝到<filename moreinfo=\"none\">/branches/1.0</filename>。"

#: build/en/book.xml:8693(para)
msgid "<emphasis>Teams continue to work in parallel.</emphasis> One team begins rigorous testing of the release branch, while another team continues new work (say, for version 2.0) on <filename moreinfo=\"none\">/trunk</filename>. If bugs are discovered in either location, fixes are ported back and forth as necessary. At some point, however, even that process stops. The branch is <quote>frozen</quote> for final testing right before a release."
msgstr "<emphasis>项目组继续并行工作，</emphasis>一个小组开始对分支进行严酷的测试，同时另一个小组在<filename moreinfo=\"none\">/trunk</filename>继续新的工作（如，准备2.0），如果一个bug在任何一个位置被发现，错误修正需要来回运送。然而这个过程有时候也会结束，例如分支已经为发布前的最终测试<quote>停滞</quote>了。"

#: build/en/book.xml:8705(para)
msgid "<emphasis>The branch is tagged and released.</emphasis> When testing is complete, <filename moreinfo=\"none\">/branches/1.0</filename> is copied to <filename moreinfo=\"none\">/tags/1.0.0</filename> as a reference snapshot. The tag is packaged and released to customers."
msgstr "<emphasis>分支已经作了标签并且发布，</emphasis>当测试结束，<filename moreinfo=\"none\">/branches/1.0</filename>作为引用快照已经拷贝到<filename moreinfo=\"none\">/tags/1.0.0</filename>，这个标签被打包发布给客户。"

#: build/en/book.xml:8715(para)
msgid "<emphasis>The branch is maintained over time.</emphasis> While work continues on <filename moreinfo=\"none\">/trunk</filename> for version 2.0, bugfixes continue to be ported from <filename moreinfo=\"none\">/trunk</filename> to <filename moreinfo=\"none\">/branches/1.0</filename>. When enough bugfixes have accumulated, management may decide to do a 1.0.1 release: <filename moreinfo=\"none\">/branches/1.0</filename> is copied to <filename moreinfo=\"none\">/tags/1.0.1</filename>, and the tag is packaged and released."
msgstr "<emphasis>分支多次维护。</emphasis>当继续在<filename moreinfo=\"none\">/trunk</filename>上为版本2.0工作，bug修正继续从<filename moreinfo=\"none\">/trunk</filename>运送到<filename moreinfo=\"none\">/branches/1.0</filename>，如果积累了足够的bug修正，管理部门决定发布1.0.1版本：拷贝<filename moreinfo=\"none\">/branches/1.0</filename>到<filename moreinfo=\"none\">/tags/1.0.1</filename>，标签被打包发布。"

#: build/en/book.xml:8729(para)
msgid "This entire process repeats as the software matures: when the 2.0 work is complete, a new 2.0 release branch is created, tested, tagged, and eventually released. After some years, the repository ends up with a number of release branches in <quote>maintenance</quote> mode, and a number of tags representing final shipped versions."
msgstr "整个过程随着软件的成熟不断重复：当2.0完成，一个新的2.0分支被创建，测试、打标签和最终发布，经过许多年，版本库结束了许多版本发布，进入了<quote>维护</quote>模式，许多标签代表了最终的发布版本。"

#: build/en/book.xml:8740(title)
msgid "Feature Branches"
msgstr "特性分支"

#: build/en/book.xml:8742(para)
msgid "A <firstterm>feature branch</firstterm> is the sort of branch that's been the dominant example in this chapter, the one you've been working on while Sally continues to work on <filename moreinfo=\"none\">/trunk</filename>. It's a temporary branch created to work on a complex change without interfering with the stability of <filename moreinfo=\"none\">/trunk</filename>. Unlike release branches (which may need to be supported forever), feature branches are born, used for a while, merged back to the trunk, then ultimately deleted. They have a finite span of usefulness."
msgstr "一个<firstterm>特性分支</firstterm>是本章中那个重要例子中的分支，你正在那个分支上工作，而Sally还在<filename moreinfo=\"none\">/trunk</filename>继续工作，这是一个临时分支，用来作复杂的修改而不会干扰<filename moreinfo=\"none\">/trunk</filename>的稳定性，不象发布分支（也许要永远支持），特性分支出生，使用了一段时间，合并到主干，然后最终被删除掉，它们在有限的时间里有用。"

#: build/en/book.xml:8753(para)
msgid "Again, project policies vary widely concerning exactly when it's appropriate to create a feature branch. Some projects never use feature branches at all: commits to <filename moreinfo=\"none\">/trunk</filename> are a free-for-all. The advantage to this system is that it's simple—nobody needs to learn about branching or merging. The disadvantage is that the trunk code is often unstable or unusable. Other projects use branches to an extreme: no change is <emphasis>ever</emphasis> committed to the trunk directly. Even the most trivial changes are created on a short-lived branch, carefully reviewed and merged to the trunk. Then the branch is deleted. This system guarantees an exceptionally stable and usable trunk at all times, but at the cost of tremendous process overhead."
msgstr "还有，关于是否创建特性分支的项目政策也变化广泛，一些项目永远不使用特性分支：大家都可以提交到<filename moreinfo=\"none\">/trunk</filename>，好处是系统的简单—没有人需要知道分支和合并，坏处是主干会经常不稳定或者不可用，另外一些项目使用分支达到极限：没有修改<emphasis>曾经</emphasis>直接提交到主干，即使最细小的修改都要创建短暂的分支，然后小心的审核合并到主干，然后删除分支，这样系统保持主干一直稳定和可用，但是造成了巨大的负担。"

#: build/en/book.xml:8768(para)
msgid "Most projects take a middle-of-the-road approach. They commonly insist that <filename moreinfo=\"none\">/trunk</filename> compile and pass regression tests at all times. A feature branch is only required when a change requires a large number of destabilizing commits. A good rule of thumb is to ask this question: if the developer worked for days in isolation and then committed the large change all at once (so that <filename moreinfo=\"none\">/trunk</filename> were never destabilized), would it be too large a change to review? If the answer to that question is <quote>yes</quote>, then the change should be developed on a feature branch. As the developer commits incremental changes to the branch, they can be easily reviewed by peers."
msgstr "许多项目采用折中的方式，坚持每次编译<filename moreinfo=\"none\">/trunk</filename>并进行回归测试，只有需要多次不稳定提交时才需要一个特性分支，这个规则可以用这样一个问题检验：如果开发者在好几天里独立工作，一次提交大量修改（这样<filename moreinfo=\"none\">/trunk</filename>就不会不稳定。），是否会有太多的修改要来回顾？如果答案是<quote>是</quote>，这些修改应该在特性分支上进行，因为开发者增量的提交修改，你可以容易的回头检查。"

#: build/en/book.xml:8782(para)
msgid "Finally, there's the issue of how to best keep a feature branch in <quote>sync</quote> with the trunk as work progresses. As we mentioned earlier, there's a great risk to working on a branch for weeks or months; trunk changes may continue to pour in, to the point where the two lines of development differ so greatly that it may become a nightmare trying to merge the branch back to the trunk."
msgstr "最终，有一个问题就是怎样保持一个特性分支<quote>同步</quote>于工作中的主干，在前面提到过，在一个分支上工作数周或几个月是很有风险的，主干的修改也许会持续涌入，因为这一点，两条线的开发会区别巨大，合并分支回到主干会成为一个噩梦。"

#: build/en/book.xml:8790(para)
msgid "This situation is best avoided by regularly merging trunk changes to the branch. Make up a policy: once a week, merge the last week's worth of trunk changes to the branch. Take care when doing this; the merging needs to be hand-tracked to avoid the problem of repeated merges (as described in <xref linkend=\"svn.branchmerge.copychanges.bestprac.track\"/>). You'll need to write careful log messages detailing exactly which revision ranges have been merged already (as demonstrated in <xref linkend=\"svn.branchmerge.commonuses.wholebr\"/>). It may sound intimidating, but it's actually pretty easy to do."
msgstr "这种情况最好通过有规律的将主干合并到分支来避免，制定这样一个政策：每周将上周的修改合并到分支，注意这样做时需要小心，需要手工记录合并的过程，以避免重复的合并（在<xref linkend=\"svn.branchmerge.copychanges.bestprac.track\"/>描述过），你需要小心的撰写合并的日志信息，精确的描述合并包括的范围（在<xref linkend=\"svn.branchmerge.commonuses.wholebr\"/>中描述过），这看起来像是胁迫，可是实际上是容易做到的。"

#: build/en/book.xml:8804(para)
msgid "At some point, you'll be ready to merge the <quote>synchronized</quote> feature branch back to the trunk. To do this, begin by doing a final merge of the latest trunk changes to the branch. When that's done, the latest versions of branch and trunk will be absolutely identical except for your branch changes. So in this special case, you would merge by comparing the branch with the trunk:"
msgstr "在一些时候，你已经准备好了将<quote>同步的</quote>特性分支合并回到主干，为此，开始做一次将主干最新修改和分支的最终合并，这样以后，除了你的分支修改的部分，最新的分支和主干将会绝对一致，所以在这个特别的例子里，你会通过直接比较分支和主干来进行合并："

#: build/en/book.xml:8813(screen)
#, no-wrap
msgid ""
"\n"
"$ cd trunk-working-copy\n"
"\n"
"$ svn update\n"
"At revision 1910.\n"
"\n"
"$ svn merge http://svn.example.com/repos/calc/trunk@1910 \\\n"
"            http://svn.example.com/repos/calc/branches/mybranch@1910\n"
"U  real.c\n"
"U  integer.c\n"
"A  newdirectory\n"
"A  newdirectory/newfile\n"
"…\n"
msgstr ""
"\n"
"$ cd trunk-working-copy\n"
"\n"
"$ svn update\n"
"At revision 1910.\n"
"\n"
"$ svn merge http://svn.example.com/repos/calc/trunk@1910 \\\n"
"            http://svn.example.com/repos/calc/branches/mybranch@1910\n"
"U  real.c\n"
"U  integer.c\n"
"A  newdirectory\n"
"A  newdirectory/newfile\n"
"…\n"

#: build/en/book.xml:8828(para)
msgid "By comparing the <literal moreinfo=\"none\">HEAD</literal> revision of the trunk with the <literal moreinfo=\"none\">HEAD</literal> revision of the branch, you're defining a delta that describes only the changes you made to the branch; both lines of development already have all of the trunk changes."
msgstr "通过比较<literal moreinfo=\"none\">HEAD</literal>修订版本的主干和<literal moreinfo=\"none\">HEAD</literal>修订版本的分支，你确定了只在分支上的增量信息，两条开发线都有了分枝的修改。"

#: build/en/book.xml:8834(para)
msgid "Another way of thinking about this pattern is that your weekly sync of trunk to branch is analogous to running <command moreinfo=\"none\">svn update</command> in a working copy, while the final merge step is analogous to running <command moreinfo=\"none\">svn commit</command> from a working copy. After all, what else <emphasis>is</emphasis> a working copy but a very shallow private branch? It's a branch that's only capable of storing one change at a time."
msgstr "可以用另一种考虑这种模式，你每周按时同步分支到主干，类似于在工作拷贝执行<command moreinfo=\"none\">svn update</command>的命令，最终的合并操作类似于在工作拷贝运行<command moreinfo=\"none\">svn commit</command>，毕竟，工作拷贝不就是一个非常浅的分支吗？只是它一次只可以保存一个修改。"

#: build/en/book.xml:8853(title)
msgid "Traversing Branches"
msgstr "使用分支"

#: build/en/book.xml:8855(para)
#, fuzzy
msgid "The <command moreinfo=\"none\">svn switch</command> command transforms an existing working copy to reflect a different branch. While this command isn't strictly necessary for working with branches, it provides a nice shortcut to users. In our earlier example, after creating your private branch, you checked out a fresh working copy of the new repository directory. Instead, you can simply ask Subversion to change your working copy of <filename moreinfo=\"none\">/calc/trunk</filename> to mirror the new branch location:"
msgstr "<command moreinfo=\"none\">svn switch</command>命令改变存在的工作拷贝到另一个分支，然而这个命令在分支上工作时不是严格必要的，它只是提供了一个快捷方式。在前面的例子里，完成了私有分支的建立，你取出了新目录的工作拷贝，相反，你可以简单的告诉Subversion改变你的<filename moreinfo=\"none\">/calc/trunk</filename>的工作拷贝到分支的路径："

#: build/en/book.xml:8865(screen)
#, no-wrap
msgid ""
"\n"
"$ cd calc\n"
"\n"
"$ svn info | grep URL\n"
"URL: http://svn.example.com/repos/calc/trunk\n"
"\n"
"$ svn switch http://svn.example.com/repos/calc/branches/my-calc-branch\n"
"U   integer.c\n"
"U   button.c\n"
"U   Makefile\n"
"Updated to revision 341.\n"
"\n"
"$ svn info | grep URL\n"
"URL: http://svn.example.com/repos/calc/branches/my-calc-branch\n"
msgstr ""
"\n"
"$ cd calc\n"
"\n"
"$ svn info | grep URL\n"
"URL: http://svn.example.com/repos/calc/trunk\n"
"\n"
"$ svn switch http://svn.example.com/repos/calc/branches/my-calc-branch\n"
"U   integer.c\n"
"U   button.c\n"
"U   Makefile\n"
"Updated to revision 341.\n"
"\n"
"$ svn info | grep URL\n"
"URL: http://svn.example.com/repos/calc/branches/my-calc-branch\n"

#: build/en/book.xml:8881(para)
msgid "After <quote>switching</quote> to the branch, your working copy is no different than what you would get from doing a fresh checkout of the directory. And it's usually more efficient to use this command, because often branches only differ by a small degree. The server sends only the minimal set of changes necessary to make your working copy reflect the branch directory."
msgstr "完成了到分支的<quote>跳转</quote>，你的目录与直接取出一个干净的版本没有什么不同。这样会更有效率，因为分支只有很小的区别，服务器只是发送修改的部分来使你的工作拷贝反映分支。"

#: build/en/book.xml:8889(para)
msgid "The <command moreinfo=\"none\">svn switch</command> command also takes a <option>--revision</option> (<option>-r</option>) option, so you need not always move your working copy to the <quote>tip</quote> of the branch."
msgstr "<command moreinfo=\"none\">svn switch</command>命令也可以带<option>--revision</option>（<option>-r</option>）参数，所以你不需要一直移动你的工作拷贝到最新版本。"

#: build/en/book.xml:8894(para)
msgid "Of course, most projects are more complicated than our <filename moreinfo=\"none\">calc</filename> example, containing multiple subdirectories. Subversion users often follow a specific algorithm when using branches:"
msgstr "当然，许多项目比我们的<filename moreinfo=\"none\">calc</filename>要复杂的多，有更多的子目录，Subversion用户通常用如下的法则使用分支："

#: build/en/book.xml:8901(para)
msgid "Copy the project's entire <quote>trunk</quote> to a new branch directory."
msgstr "拷贝整个项目的<quote>trunk</quote>目录到一个新的分支目录。"

#: build/en/book.xml:8905(para)
msgid "Switch only <emphasis>part</emphasis> of the trunk working copy to mirror the branch."
msgstr "只是转换工作拷贝的<emphasis>部分</emphasis>目录到分支。"

#: build/en/book.xml:8910(para)
msgid "In other words, if a user knows that the branch-work only needs to happen on a specific subdirectory, they use <command moreinfo=\"none\">svn switch</command> to move only that subdirectory to the branch. (Or sometimes users will switch just a single working file to the branch!) That way, they can continue to receive normal <quote>trunk</quote> updates to most of their working copy, but the switched portions will remain immune (unless someone commits a change to their branch). This feature adds a whole new dimension to the concept of a <quote>mixed working copy</quote>—not only can working copies contain a mixture of working revisions, but a mixture of repository locations as well."
msgstr "换句话说，如果一个用户知道分支工作只发生在部分子目录，我们使用<command moreinfo=\"none\">svn switch</command>来跳转部分目录（有时候只是单个文件），这样的话，他们依然可以继续得到普通的<quote>trunk</quote>主干的更新，但是已经跳转的部分则被免去了更新（除非分支上有更新）。这个特性给<quote>混合工作拷贝</quote>概念添加了新的维度—不仅工作拷贝的版本可以混合，在版本库中的位置也可以混合。"

#: build/en/book.xml:8923(para)
msgid "If your working copy contains a number of switched subtrees from different repository locations, it continues to function as normal. When you update, you'll receive patches to each subtree as appropriate. When you commit, your local changes will still be applied as a single, atomic change to the repository."
msgstr "如果你的工作拷贝包含许多来自不同版本库目录跳转的子树，它会工作如常。当你更新时，你会得到每一个目录适当的补丁，当你提交时，你的本地修改会一直作为一个单独的原子修改提交到版本库。"

#: build/en/book.xml:8936(para)
#, fuzzy
msgid "You <emphasis>can</emphasis>, however, use <command moreinfo=\"none\">svn switch</command> with the <option>--relocate</option> switch if the URL of your server changes and you don't want to abandon an existing working copy. See <xref linkend=\"svn.ref.svn.c.switch\"/> for more information and an example."
msgstr "当你的服务器位置改变，而你不想放弃存在的本地拷贝，你<emphasis>可以</emphasis>使用带选项<option>--relocate</option>的<command moreinfo=\"none\">svn switch</command>命令转换URL，见<xref linkend=\"svn.ref\"/>的<command moreinfo=\"none\">svn switch</command>查看更多信息和例子。"

#: build/en/book.xml:8929(para)
#, fuzzy
msgid "Note that while it's okay for your working copy to reflect a mixture of repository locations, these locations must all be within the <emphasis>same</emphasis> repository. Subversion repositories aren't yet able to communicate with one another; that's a feature planned for the future. <placeholder-1/>"
msgstr "注意，因为你的工作拷贝可以在混合位置的情况下工作正常，但是所有的位置必须在同一个版本库，Subversion的版本库不能互相通信，这个特性还不在Subversion 1.0的计划里。<footnote><placeholder-1/></footnote>"

#: build/en/book.xml:8944(title)
msgid "Switches and Updates"
msgstr "切换和更新"

#: build/en/book.xml:8946(para)
msgid "Have you noticed that the output of <command moreinfo=\"none\">svn switch</command> and <command moreinfo=\"none\">svn update</command> look the same? The <literal moreinfo=\"none\">switch</literal> command is actually a superset of the update command."
msgstr "你注意到<command moreinfo=\"none\">svn switch</command>和<command moreinfo=\"none\">svn update</command>的输出很像？<literal moreinfo=\"none\">switch</literal>命令只是update命令的一个超集。"

#: build/en/book.xml:8951(para)
msgid "When you run <command moreinfo=\"none\">svn update</command>, you're asking the repository to compare two trees. The repository does so, and then sends a description of the differences back to the client. The only difference between <command moreinfo=\"none\">svn switch</command> and <command moreinfo=\"none\">svn update</command> is that the <literal moreinfo=\"none\">update</literal> command always compares two identical paths."
msgstr "当你运行<command moreinfo=\"none\">svn update</command>时，你会告诉版本库比较两个目录树，版本库这样做，并且返回给客户区别的描述，<command moreinfo=\"none\">svn switch</command>和<command moreinfo=\"none\">svn update</command>两个命令唯一区别就是<command moreinfo=\"none\">svn update</command>会一直比较同一路径。"

#: build/en/book.xml:8959(para)
msgid "That is, if your working copy is a mirror of <filename moreinfo=\"none\">/calc/trunk</filename>, then <command moreinfo=\"none\">svn update</command> will automatically compare your working copy of <filename moreinfo=\"none\">/calc/trunk</filename> to <filename moreinfo=\"none\">/calc/trunk</filename> in the <literal moreinfo=\"none\">HEAD</literal> revision. If you're switching your working copy to a branch, then <command moreinfo=\"none\">svn switch</command> will compare your working copy of <filename moreinfo=\"none\">/calc/trunk</filename> to some <emphasis>other</emphasis> branch-directory in the <literal moreinfo=\"none\">HEAD</literal> revision."
msgstr "也就是了，如果你的工作拷贝是<filename moreinfo=\"none\">/calc/trunk</filename>的一个镜像，当运行<command moreinfo=\"none\">svn update</command>时会自动地比较你的工作拷贝的<filename moreinfo=\"none\">/calc/trunk</filename>与HEAD版本的<filename moreinfo=\"none\">/calc/trunk</filename>。如果你使用<command moreinfo=\"none\">svn switch</command>跳转工作拷贝到分支，则会比较你的工作拷贝的<filename moreinfo=\"none\">/calc/trunk</filename>与相应分支目录的HEAD版本。"

#: build/en/book.xml:8971(para)
msgid "In other words, an update moves your working copy through time. A switch moves your working copy through time <emphasis>and</emphasis> space."
msgstr "换句话说，一个更新通过时间移动你的工作拷贝，一个转换通过时间和空间移动工作拷贝。"

#: build/en/book.xml:8976(para)
msgid "Because <command moreinfo=\"none\">svn switch</command> is essentially a variant of <command moreinfo=\"none\">svn update</command>, it shares the same behaviors; any local modifications in your working copy are preserved when new data arrives from the repository. This allows you to perform all sorts of clever tricks."
msgstr "因为<command moreinfo=\"none\">svn switch</command>是<command moreinfo=\"none\">svn update</command>的一个变种，具有相同的行为，当新的数据到达时，任何工作拷贝的已经完成的本地修改会被保存，这里允许你作各种聪明的把戏。"

#: build/en/book.xml:8982(para)
msgid "For example, suppose you have a working copy of <filename moreinfo=\"none\">/calc/trunk</filename> and make a number of changes to it. Then you suddenly realize that you meant to make the changes to a branch instead. No problem! When you <command moreinfo=\"none\">svn switch</command> your working copy to the branch, the local changes will remain. You can then test and commit them to the branch."
msgstr "举个例子，你的工作拷贝目录是<filename moreinfo=\"none\">/calc/trunk</filename>，你已经做了很多修改，然后你突然发现应该在分支上修改更好，没问题！你可以使用<command moreinfo=\"none\">svn switch</command>，而你本地修改还会保留，你可以测试并提交它们到分支。"

#: build/en/book.xml:8997(title)
msgid "Tags"
msgstr "标签"

#: build/en/book.xml:8999(para)
msgid "Another common version control concept is a <firstterm>tag</firstterm>. A tag is just a <quote>snapshot</quote> of a project in time. In Subversion, this idea already seems to be everywhere. Each repository revision is exactly that—a snapshot of the filesystem after each commit."
msgstr "另一个常见的版本控制系统概念是标­¾（<firstterm>tag</firstterm>），一个标签只是一个项目某一时间的<quote>快照</quote>，在Subversion里这个概念无处不在—每一次提交的修订版本都是一个精确的快照。"

#: build/en/book.xml:9006(para)
msgid "However, people often want to give more human-friendly names to tags, like <literal moreinfo=\"none\">release-1.0</literal>. And they want to make snapshots of smaller subdirectories of the filesystem. After all, it's not so easy to remember that release-1.0 of a piece of software is a particular subdirectory of revision 4822."
msgstr "然而人们希望更人性化的标签名称，像<literal moreinfo=\"none\">release-1.0</literal>。他们也希望可以对一个子目录快照，毕竟，记住release-1.0是修订版本4822的某一小部分不是件很容易的事。"

#: build/en/book.xml:9015(title)
msgid "Creating a Simple Tag"
msgstr "建立简单标签"

#: build/en/book.xml:9017(para)
msgid "Once again, <command moreinfo=\"none\">svn copy</command> comes to the rescue. If you want to create a snapshot of <filename moreinfo=\"none\">/calc/trunk</filename> exactly as it looks in the <literal moreinfo=\"none\">HEAD</literal> revision, then make a copy of it:"
msgstr "<command moreinfo=\"none\">svn copy</command>再次登场，你希望建立一个<filename moreinfo=\"none\">/calc/trunk</filename>的一个快照，就像<literal moreinfo=\"none\">HEAD</literal>修订版本，建立这样一个拷贝："

#: build/en/book.xml:9022(screen)
#, no-wrap
msgid ""
"\n"
"$ svn copy http://svn.example.com/repos/calc/trunk \\\n"
"           http://svn.example.com/repos/calc/tags/release-1.0 \\\n"
"      -m \"Tagging the 1.0 release of the 'calc' project.\"\n"
"\n"
"Committed revision 351.\n"
msgstr ""
"\n"
"$ svn copy http://svn.example.com/repos/calc/trunk \\\n"
"           http://svn.example.com/repos/calc/tags/release-1.0 \\\n"
"      -m \"Tagging the 1.0 release of the 'calc' project.\"\n"
"\n"
"Committed revision 351.\n"

#: build/en/book.xml:9030(para)
#, fuzzy
msgid "This example assumes that a <filename moreinfo=\"none\">/calc/tags</filename> directory already exists. (If it doesn't, you can create it using <command moreinfo=\"none\">svn mkdir</command>.) After the copy completes, the new <filename moreinfo=\"none\">release-1.0</filename> directory is forever a snapshot of how the project looked in the <literal moreinfo=\"none\">HEAD</literal> revision at the time you made the copy. Of course you might want to be more precise about exactly which revision you copy, in case somebody else may have committed changes to the project when you weren't looking. So if you know that revision 350 of <filename moreinfo=\"none\">/calc/trunk</filename> is exactly the snapshot you want, you can specify it by passing <option>-r 350</option> to the <command moreinfo=\"none\">svn copy</command> command."
msgstr "这个例子假定<filename moreinfo=\"none\">/calc/tags</filename>目录已经存在（如果不是，见<xref linkend=\"svn.ref.svn.c.mkdir\"/>），拷贝完成之后，一个表示当时<literal moreinfo=\"none\">HEAD</literal>版本的/calc/trunk目录的镜像已经永久的拷贝到<filename moreinfo=\"none\">release-1.0</filename>目录。当然，你会希望更精确一点，以防其他人在你不注意的时候提交修改，所以，如果你知道<filename moreinfo=\"none\">/calc/trunk</filename>的版本350是你想要的快照，你可以使用<command moreinfo=\"none\">svn copy</command>加参数 <option>-r 350</option>。"

#: build/en/book.xml:9045(para)
msgid "But wait a moment: isn't this tag-creation procedure the same procedure we used to create a branch? Yes, in fact, it is. In Subversion, there's no difference between a tag and a branch. Both are just ordinary directories that are created by copying. Just as with branches, the only reason a copied directory is a <quote>tag</quote> is because <emphasis>humans</emphasis> have decided to treat it that way: as long as nobody ever commits to the directory, it forever remains a snapshot. If people start committing to it, it becomes a branch."
msgstr "但是等一下：标签的产生过程与建立分支是一样的？是的，实际上在Subversion中标签与分支没有区别，都是普通的目录，通过copy命令得到，与分支一样，一个目录之所以是标签只是<emphasis>人们</emphasis>决定这样使用它，只要没有人提交这个目录，它永远是一个快照，但如果人们开始提交，它就变成了分支。"

#: build/en/book.xml:9056(para)
msgid "If you are administering a repository, there are two approaches you can take to managing tags. The first approach is <quote>hands off</quote>: as a matter of project policy, decide where your tags will live, and make sure all users know how to treat the directories they copy in there. (That is, make sure they know not to commit to them.) The second approach is more paranoid: you can use one of the access-control scripts provided with Subversion to prevent anyone from doing anything but creating new copies in the tags-area (See <xref linkend=\"svn.serverconfig\"/>.) The paranoid approach, however, isn't usually necessary. If a user accidentally commits a change to a tag-directory, you can simply undo the change as discussed in the previous section. This is version control, after all."
msgstr "如果你管理一个版本库，你有两种方式管理标签，第一种方法是禁止命令：作为项目的政策，我们要决定标签所在的位置，确定所有用户知道如何处理拷贝的目录（也就是确保他们不会提交他们），第二种方法看来很过分：使用访问控制脚本来阻止任何想对标签目录做的非拷贝的操作（见<xref linkend=\"svn.serverconfig\"/>）这种方法通常是不必要的，如果一个人不小心提交了到标签目录一个修改，你可以简单的取消，毕竟这是版本控制啊。"

#: build/en/book.xml:9075(title)
msgid "Creating a Complex Tag"
msgstr "建立复杂标签"

#: build/en/book.xml:9077(para)
msgid "Sometimes you may want your <quote>snapshot</quote> to be more complicated than a single directory at a single revision."
msgstr "有时候你希望你的<quote>快照</quote>能够很复杂，而不只是一个单独修订版本的一个单独目录。"

#: build/en/book.xml:9081(para)
msgid "For example, pretend your project is much larger than our <filename moreinfo=\"none\">calc</filename> example: suppose it contains a number of subdirectories and many more files. In the course of your work, you may decide that you need to create a working copy that is designed to have specific features and bug fixes. You can accomplish this by selectively backdating files or directories to particular revisions (using <command moreinfo=\"none\">svn update -r</command> liberally), or by switching files and directories to particular branches (making use of <command moreinfo=\"none\">svn switch</command>). When you're done, your working copy is a hodgepodge of repository locations from different revisions. But after testing, you know it's the precise combination of data you need."
msgstr "举个例子，假定你的项目比我们的的例子<filename moreinfo=\"none\">calc</filename>大的多：假设它保存了一组子目录和许多文件，在你工作时，你或许决定创建一个包括特定特性和Bug修正的工作拷贝，你可以通过选择性的回溯文件和目录到特定修订版本（使用<command moreinfo=\"none\">svn update -r</command>）来实现，或者转换文件和目录到特定分支（使用<command moreinfo=\"none\">svn switch</command>），这样做之后，你的工作拷贝成为版本库不同版本和分支的司令部，但是经过测试，你会知道这是你需要的一种精确数据组合。"

#: build/en/book.xml:9095(para)
msgid "Time to make a snapshot. Copying one URL to another won't work here. In this case, you want to make a snapshot of your exact working copy arrangement and store it in the repository. Luckily, <command moreinfo=\"none\">svn copy</command> actually has four different uses (which you can read about in <xref linkend=\"svn.ref\"/>), including the ability to copy a working-copy tree to the repository:"
msgstr "是时候进行快照了，拷贝URL在这里不能工作，在这个例子里，你希望把本地拷贝的布局做镜像并且保存到版本库中，幸运的是，<command moreinfo=\"none\">svn copy</command>包括四种不同的使用方式（在第9章可以详细阅读），包括拷贝工作拷贝到版本库："

#: build/en/book.xml:9102(screen)
#, no-wrap
msgid ""
"\n"
"$ ls\n"
"my-working-copy/\n"
"\n"
"$ svn copy my-working-copy http://svn.example.com/repos/calc/tags/mytag\n"
"\n"
"Committed revision 352.\n"
msgstr ""
"\n"
"$ ls\n"
"my-working-copy/\n"
"\n"
"$ svn copy my-working-copy http://svn.example.com/repos/calc/tags/mytag\n"
"\n"
"Committed revision 352.\n"

#: build/en/book.xml:9111(para)
msgid "Now there is a new directory in the repository, <filename moreinfo=\"none\">/calc/tags/mytag</filename>, which is an exact snapshot of your working copy—mixed revisions, URLs, and all."
msgstr "现在在版本库有一个新的目录<filename moreinfo=\"none\">/calc/tags/mytag</filename>，这是你的本地拷贝的一个快照—混合了修订版本，URL等等。"

#: build/en/book.xml:9116(para)
msgid "Other users have found interesting uses for this feature. Sometimes there are situations where you have a bunch of local changes made to your working copy, and you'd like a collaborator to see them. Instead of running <command moreinfo=\"none\">svn diff</command> and sending a patch file (which won't capture tree changes, symlink changes or changes in properties), you can instead use <command moreinfo=\"none\">svn copy</command> to <quote>upload</quote> your working copy to a private area of the repository. Your collaborator can then either checkout a verbatim copy of your working copy, or use <command moreinfo=\"none\">svn merge</command> to receive your exact changes."
msgstr "一些人也发现这一特性一些有趣的使用方式，有些时候本地拷贝有一组本地修改，你希望你的协作者看到这些，不使用<command moreinfo=\"none\">svn diff</command>并发送一个补定文件（不会捕捉到目录、符号链和属性的修改），而是使用<command moreinfo=\"none\">svn copy</command>来<quote>上传</quote>你的工作拷贝到一个版本库的私有区域，你的协作者可以选择完整的取出你的工作拷贝，或使用<command moreinfo=\"none\">svn merge</command>来接受你的精确修改。"

#: build/en/book.xml:9136(title)
msgid "Branch Maintenance"
msgstr "分支维护"

#: build/en/book.xml:9138(para)
msgid "You may have noticed by now that Subversion is extremely flexible. Because it implements branches and tags with the same underlying mechanism (directory copies), and because branches and tags appear in normal filesystem space, many people find Subversion intimidating. It's almost <emphasis>too</emphasis> flexible. In this section, we'll offer some suggestions for arranging and managing your data over time."
msgstr "你一定注意到了Subversion极度的灵活性，因为它用相同的底层机制（目录拷贝）实现了分支和标签，因为分支和标签是作为普通的文件系统出现，会让人们感到害怕，因为它<emphasis>太</emphasis>灵活了，在这个小节里，我们会提供安排和管理数据的一些建议。"

#: build/en/book.xml:9148(title)
msgid "Repository Layout"
msgstr "版本库布局"

#: build/en/book.xml:9150(para)
msgid "There are some standard, recommended ways to organize a repository. Most people create a <filename moreinfo=\"none\">trunk</filename> directory to hold the <quote>main line</quote> of development, a <filename moreinfo=\"none\">branches</filename> directory to contain branch copies, and a <filename moreinfo=\"none\">tags</filename> directory to contain tag copies. If a repository holds only one project, then often people create these top-level directories:"
msgstr "有一些标准的，推荐的组织版本库的方式，许多人创建一个<filename moreinfo=\"none\">trunk</filename>目录来保存开发的<quote>主线</quote>，一个<filename moreinfo=\"none\">branches</filename>目录存放分支拷贝，一个目录保存标签拷贝，如果一个版本库只是存放一个项目，人们会在顶级目录创建这些目录："

#: build/en/book.xml:9158(screen)
#, no-wrap
msgid ""
"\n"
"/trunk\n"
"/branches\n"
"/tags\n"
msgstr ""
"\n"
"/trunk\n"
"/branches\n"
"/tags\n"

#: build/en/book.xml:9164(para)
msgid "If a repository contains multiple projects, admins typically index their layout by project (see <xref linkend=\"svn.reposadmin.projects.chooselayout\"/> to read more about <quote>project roots</quote>):"
msgstr "如果一个版本库保存了多个项目，管理员会通过项目来布局（见<xref linkend=\"svn.reposadmin.projects.chooselayout\"/>关于<quote>项目根目录</quote>）："

#: build/en/book.xml:9168(screen)
#, no-wrap
msgid ""
"\n"
"/paint/trunk\n"
"/paint/branches\n"
"/paint/tags\n"
"/calc/trunk\n"
"/calc/branches\n"
"/calc/tags\n"
msgstr ""
"\n"
"/paint/trunk\n"
"/paint/branches\n"
"/paint/tags\n"
"/calc/trunk\n"
"/calc/branches\n"
"/calc/tags\n"

#: build/en/book.xml:9177(para)
msgid "Of course, you're free to ignore these common layouts. You can create any sort of variation, whatever works best for you or your team. Remember that whatever you choose, it's not a permanent commitment. You can reorganize your repository at any time. Because branches and tags are ordinary directories, the <command moreinfo=\"none\">svn move</command> command can move or rename them however you wish. Switching from one layout to another is just a matter of issuing a series of server-side moves; if you don't like the way things are organized in the repository, just juggle the directories around."
msgstr "当然，你可以自由的忽略这些通常的布局方式，你可以创建任意的变化，只要是对你和你的项目有益，记住无论你选择什么，这不会是一种永久的承诺，你可以随时重新组织你的版本库。因为分支和标签都是普通的目录，<command moreinfo=\"none\">svn move</command>命令可以任意的改名和移动它们，从一种布局到另一种大概只是一系列服务器端的移动，如果你不喜欢版本库的组织方式，你可以任意修改目录结构。"

#: build/en/book.xml:9188(para)
msgid "Remember, though, that while moving directories may be easy to do, you need to be considerate of your users as well. Your juggling can be disorienting to users with existing working copies. If a user has a working copy of a particular repository directory, your <command moreinfo=\"none\">svn move</command> operation might remove the path from the latest revision. When the user next runs <command moreinfo=\"none\">svn update</command>, she will be told that her working copy represents a path that no longer exists, and the user will be forced to <command moreinfo=\"none\">svn switch</command> to the new location."
msgstr "记住，尽管移动目录非常容易，你必须体谅你的用户，你的修改会让你的用户感到迷惑，如果一个用户的拥有一个版本库目录的工作拷贝，你的<command moreinfo=\"none\">svn move</command>命令也许会删除最新的版本的这个路径，当用户运行<command moreinfo=\"none\">svn update</command>，会被告知这个工作拷贝引用的路径已经不再存在，用户需要强制使用<command moreinfo=\"none\">svn switch</command>转到新的位置。"

#: build/en/book.xml:9204(title)
msgid "Data Lifetimes"
msgstr "数据的生命周期"

#: build/en/book.xml:9206(para)
msgid "Another nice feature of Subversion's model is that branches and tags can have finite lifetimes, just like any other versioned item. For example, suppose you eventually finish all your work on your personal branch of the <filename moreinfo=\"none\">calc</filename> project. After merging all of your changes back into <filename moreinfo=\"none\">/calc/trunk</filename>, there's no need for your private branch directory to stick around anymore:"
msgstr "另一个Subversion模型的可爱特性是分支和标签可以有有限的生命周期，就像其它的版本化的项目，举个例子，假定你最终完成了<filename moreinfo=\"none\">calc</filename>项目你的个人分支上的所有工作，在合并了你的所有修改到<filename moreinfo=\"none\">/calc/trunk</filename>后，没有必要继续保留你的私有分支目录："

#: build/en/book.xml:9215(screen)
#, no-wrap
msgid ""
"\n"
"$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \\\n"
"             -m \"Removing obsolete branch of calc project.\"\n"
"\n"
"Committed revision 375.\n"
msgstr ""
"\n"
"$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \\\n"
"             -m \"Removing obsolete branch of calc project.\"\n"
"\n"
"Committed revision 375.\n"

#: build/en/book.xml:9222(para)
msgid "And now your branch is gone. Of course it's not really gone: the directory is simply missing from the <literal moreinfo=\"none\">HEAD</literal> revision, no longer distracting anyone. If you use <command moreinfo=\"none\">svn checkout</command>, <command moreinfo=\"none\">svn switch</command>, or <command moreinfo=\"none\">svn list</command> to examine an earlier revision, you'll still be able to see your old branch."
msgstr "你的分支已经消失了，当然不是真的消失了：这个目录只是在<literal moreinfo=\"none\">HEAD</literal>修订版本里消失了，如果你使用<command moreinfo=\"none\">svn checkout</command>、<command moreinfo=\"none\">svn switch</command>或者<command moreinfo=\"none\">svn list</command>来检查一个旧的版本，你仍会见到这个旧的分支。"

#: build/en/book.xml:9230(para)
msgid "If browsing your deleted directory isn't enough, you can always bring it back. Resurrecting data is very easy in Subversion. If there's a deleted directory (or file) that you'd like to bring back into <literal moreinfo=\"none\">HEAD</literal>, simply use <command moreinfo=\"none\">svn copy -r</command> to copy it from the old revision:"
msgstr "如果浏览你删除的目录还不足够，你可以把它找回来，恢复数据对Subversion来说很简单，如果你希望恢复一个已经删除的目录（或文件）到<literal moreinfo=\"none\">HEAD</literal>，仅需要使用<command moreinfo=\"none\">svn copy -r</command>来从旧的版本拷贝出来："

#: build/en/book.xml:9237(screen)
#, no-wrap
msgid ""
"\n"
"$ svn copy -r 374 http://svn.example.com/repos/calc/branches/my-calc-branch \\\n"
"                  http://svn.example.com/repos/calc/branches/my-calc-branch\n"
"\n"
"Committed revision 376.\n"
msgstr ""
"\n"
"$ svn copy -r 374 http://svn.example.com/repos/calc/branches/my-calc-branch \\\n"
"                  http://svn.example.com/repos/calc/branches/my-calc-branch\n"
"\n"
"Committed revision 376.\n"

#: build/en/book.xml:9244(para)
msgid "In our example, your personal branch had a relatively short lifetime: you may have created it to fix a bug or implement a new feature. When your task is done, so is the branch. In software development, though, it's also common to have two <quote>main</quote> branches running side-by-side for very long periods. For example, suppose it's time to release a stable version of the <filename moreinfo=\"none\">calc</filename> project to the public, and you know it's going to take a couple of months to shake bugs out of the software. You don't want people to add new features to the project, but you don't want to tell all developers to stop programming either. So instead, you create a <quote>stable</quote> branch of the software that won't change much:"
msgstr "在我们的例子里，你的个人分支只有一个相对短的生命周期：你会为修复一个Bug或实现一个小的特性来创建它，当任务完成，分支也该结束了。在软件开发过程中，有两个<quote>主要的</quote>分支一直存在很长的时间也是很常见的情况，举个例子，假定我们是发布一个稳定的<filename moreinfo=\"none\">calc</filename>项目的时候了，但我们仍会需要几个月的时间来修复Bug，你不希望添加新的特性，但你不希望告诉开发者停止开发，所以作为替代，你为软件创建了一个<quote>分支</quote>，这个分支更改不会很多："

#: build/en/book.xml:9258(screen)
#, no-wrap
msgid ""
"\n"
"$ svn copy http://svn.example.com/repos/calc/trunk \\\n"
"         http://svn.example.com/repos/calc/branches/stable-1.0 \\\n"
"         -m \"Creating stable branch of calc project.\"\n"
"\n"
"Committed revision 377.\n"
msgstr ""
"\n"
"$ svn copy http://svn.example.com/repos/calc/trunk \\\n"
"         http://svn.example.com/repos/calc/branches/stable-1.0 \\\n"
"         -m \"Creating stable branch of calc project.\"\n"
"\n"
"Committed revision 377.\n"

#: build/en/book.xml:9266(para)
msgid "And now developers are free to continue adding cutting-edge (or experimental) features to <filename moreinfo=\"none\">/calc/trunk</filename>, and you can declare a project policy that only bug fixes are to be committed to <filename moreinfo=\"none\">/calc/branches/stable-1.0</filename>. That is, as people continue to work on the trunk, a human selectively ports bug fixes over to the stable branch. Even after the stable branch has shipped, you'll probably continue to maintain the branch for a long time—that is, as long as you continue to support that release for customers."
msgstr "而且开发者可以自由的继续添加新的（试验的）特性到<filename moreinfo=\"none\">/calc/trunk</filename>，你可以宣布这样一种政策，只有bug修正提交到<filename moreinfo=\"none\">/calc/branches/stable-1.0</filename>，这样的话，人们继续在主干上工作，某个人会选择在稳定分支上做出一些Bug修正，甚至在稳定版本发布之后。你或许会在这个维护分支上工作很长时间—也就是说，你会一直继续为客户提供这个版本的支持。"

#: build/en/book.xml:9286(title)
msgid "Vendor branches"
msgstr "卖主分支"

#: build/en/book.xml:9288(para)
msgid "As is especially the case when developing software, the data that you maintain under version control is often closely related to, or perhaps dependent upon, someone else's data. Generally, the needs of your project will dictate that you stay as up-to-date as possible with the data provided by that external entity without sacrificing the stability of your own project. This scenario plays itself out all the time—anywhere that the information generated by one group of people has a direct effect on that which is generated by another group."
msgstr "当开发软件时有这样一个情况，你版本控制的数据可能关联于或者是依赖于其他人的数据，通常来讲，你的项目的需要会要求你自己的项目对外部实体提供的数据保持尽可能最新的版本，同时不会牺牲稳定性，这种情况总是会出现—只要某个小组的信息对另一个小组的信息有直接的影响。"

#: build/en/book.xml:9298(para)
msgid "For example, software developers might be working on an application which makes use of a third-party library. Subversion has just such a relationship with the Apache Portable Runtime library (see <xref linkend=\"svn.developer.usingapi.apr\"/>). The Subversion source code depends on the APR library for all its portability needs. In earlier stages of Subversion's development, the project closely tracked APR's changing API, always sticking to the <quote>bleeding edge</quote> of the library's code churn. Now that both APR and Subversion have matured, Subversion attempts to synchronize with APR's library API only at well-tested, stable release points."
msgstr "举个例子，软件开发者会工作在一个使用第三方库的应用，Subversion恰好是和Apache的Portable Runtime library（见<xref linkend=\"svn.developer.usingapi.apr\"/>）有这样一个关系。Subversion源代码依赖于APR库来实现可移植需求。在Subversion的早期开发阶段，项目紧密地追踪APR的API修改，经常在库代码的<quote>流血的边缘</quote>粘住，现在APR和Subversion都已经成熟了，Subversion只尝试同步APR的经过良好测试的，稳定的API库。"

#: build/en/book.xml:9310(para)
msgid "Now, if your project depends on someone else's information, there are several ways that you could attempt to synchronize that information with your own. Most painfully, you could issue oral or written instructions to all the contributors of your project, telling them to make sure that they have the specific versions of that third-party information that your project needs. If the third-party information is maintained in a Subversion repository, you could also use Subversion's externals definitions to effectively <quote>pin down</quote> specific versions of that information to some location in your own working copy directory (see <xref linkend=\"svn.advanced.externals\"/>)."
msgstr "现在，如果你的项目依赖于其他人的信息，有许多方法可以用来尝试同步你的信息，最痛苦的，你可以为项目所有的贡献者发布口头或书写的指导，告诉他们确信他们拥有你们的项目需要的特定版本的第三方信息。如果第三方信息是用Subversion版本库维护，你可以使用Subversion的外部定义来有效的<quote>强制</quote>特定的版本的信息在你的工作拷贝的的位置（见<xref linkend=\"svn.advanced.externals\"/>）。"

#: build/en/book.xml:9322(para)
msgid "But sometimes you want to maintain custom modifications to third-party data in your own version control system. Returning to the software development example, programmers might need to make modifications to that third-party library for their own purposes. These modifications might include new functionality or bug fixes, maintained internally only until they become part of an official release of the third-party library. Or the changes might never be relayed back to the library maintainers, existing solely as custom tweaks to make the library further suit the needs of the software developers."
msgstr "但是有时候，你希望在你自己的版本控制系统维护一个针对第三方数据的自定义修改，回到软件开发的例子，程序员为了他们自己的目的会需要修改第三方库，这些修改会包括新的功能和bug修正，在成为第三方工具官方发布之前，只是内部维护。或者这些修改永远不会传给库的维护者，只是作为满足软件开发需要的单独的自定义修改存在。"

#: build/en/book.xml:9333(para)
msgid "Now you face an interesting situation. Your project could house its custom modifications to the third-party data in some disjointed fashion, such as using patch files or full-fledged alternate versions of files and directories. But these quickly become maintenance headaches, requiring some mechanism by which to apply your custom changes to the third-party data, and necessitating regeneration of those changes with each successive version of the third-party data that you track."
msgstr "现在你会面对一个有趣的情形，你的项目可以用某种脱节的样式保持它关于第三方数据自己的修改，如使用补丁文件或者是完全的可选版本的文件和目录。但是这很快会成为维护的头痛的事情，需要一种机制来应用你对第三方数据的自定义修改，并且迫使在第三方数据的后续版本重建这些修改。"

#: build/en/book.xml:9342(para)
msgid "The solution to this problem is to use <firstterm>vendor branches</firstterm>. A vendor branch is a directory tree in your own version control system that contains information provided by a third-party entity, or vendor. Each version of the vendor's data that you decide to absorb into your project is called a <firstterm>vendor drop</firstterm>."
msgstr "这个问题的解决方案是使用<firstterm>卖主分支</firstterm>，一个卖主分支是一个目录树保存了第三方实体或卖主的信息，每一个卖主数据的版本吸收到你的项目叫做<firstterm>卖主drop</firstterm>。"

#: build/en/book.xml:9349(para)
msgid "Vendor branches provide two key benefits. First, by storing the currently supported vendor drop in your own version control system, the members of your project never need to question whether they have the right version of the vendor's data. They simply receive that correct version as part of their regular working copy updates. Secondly, because the data lives in your own Subversion repository, you can store your custom changes to it in-place—you have no more need of an automated (or worse, manual) method for swapping in your customizations."
msgstr "卖主分支提供了两个关键的益处，第一，通过在我们的版本控制系统保存现在支持的卖主drop，你项目的成员不需要指导他们是否有了正确版本的卖主数据，他们只需要作为不同工作拷贝更新的一部份，简单的接受正确的版本就可以了。第二，因为数据存在于你自己的Subversion版本库，你可以在恰当的位置保存你的自定义修改—你不需要一个自动的（或者是更坏，手工的）方法来交换你的自定义行为。"

#: build/en/book.xml:9361(title)
msgid "General Vendor Branch Management Procedure"
msgstr "常规的卖主分支管理过程"

#: build/en/book.xml:9363(para)
msgid "Managing vendor branches generally works like this. You create a top-level directory (such as <filename moreinfo=\"none\">/vendor</filename>) to hold the vendor branches. Then you import the third party code into a subdirectory of that top-level directory. You then copy that subdirectory into your main development branch (for example, <filename moreinfo=\"none\">/trunk</filename>) at the appropriate location. You always make your local changes in the main development branch. With each new release of the code you are tracking you bring it into the vendor branch and merge the changes into <filename moreinfo=\"none\">/trunk</filename>, resolving whatever conflicts occur between your local changes and the upstream changes."
msgstr "管理卖主分支通常会像这个样子，你创建一个顶级的目录（如<filename moreinfo=\"none\">/vendor</filename>）来保存卖主分支，然后你导入第三方的代码到你的子目录。然后你将拷贝这个子目录到主要的开发分支（例如<filename moreinfo=\"none\">/trunk</filename>）的适当位置。你一直在你的主要开发分支上做本地修改，当你的追踪的代码有了新版本，你会把带到卖主分支并且把它合并到你的<filename moreinfo=\"none\">/trunk</filename>，解决任何你的本地修改和他们的修改的冲突。"

#: build/en/book.xml:9377(para)
msgid "Perhaps an example will help to clarify this algorithm. We'll use a scenario where your development team is creating a calculator program that links against a third-party complex number arithmetic library, libcomplex. We'll begin with the initial creation of the vendor branch, and the import of the first vendor drop. We'll call our vendor branch directory <filename moreinfo=\"none\">libcomplex</filename>, and our code drops will go into a subdirectory of our vendor branch called <filename moreinfo=\"none\">current</filename>. And since <command moreinfo=\"none\">svn import</command> creates all the intermediate parent directories it needs, we can actually accomplish both of these steps with a single command."
msgstr "也许一个例子有助于我们阐述这个算法，我们会使用这样一个场景，我们的开发团队正在开发一个计算器程序，与一个第三方的复杂数字运算库libcomplex关联。我们从卖主分支的初始创建开始，并且导入卖主drop，我们会把每株分支目录叫做<filename moreinfo=\"none\">libcomplex</filename>，我们的代码drop会进入到卖主分支的子目录<filename moreinfo=\"none\">current</filename>，并且因为<command moreinfo=\"none\">svn import</command>创建所有的需要的中间父目录，我们可以使用一个命令完成这一步。"

#: build/en/book.xml:9390(screen)
#, no-wrap
msgid ""
"\n"
"$ svn import /path/to/libcomplex-1.0 \\\n"
"             http://svn.example.com/repos/vendor/libcomplex/current \\\n"
"             -m 'importing initial 1.0 vendor drop'\n"
"…\n"
msgstr ""
"\n"
"$ svn import /path/to/libcomplex-1.0 \\\n"
"             http://svn.example.com/repos/vendor/libcomplex/current \\\n"
"             -m 'importing initial 1.0 vendor drop'\n"
"…\n"

#: build/en/book.xml:9397(para)
msgid "We now have the current version of the libcomplex source code in <filename moreinfo=\"none\">/vendor/libcomplex/current</filename>. Now, we tag that version (see <xref linkend=\"svn.branchmerge.tags\"/>) and then copy it into the main development branch. Our copy will create a new directory called <filename moreinfo=\"none\">libcomplex</filename> in our existing <filename moreinfo=\"none\">calc</filename> project directory. It is in this copied version of the vendor data that we will make our customizations."
msgstr "我们现在在<filename moreinfo=\"none\">/vendor/libcomplex/current</filename>有了libcomplex当前版本的代码，现在我们为那个版本作标签（见<xref linkend=\"svn.branchmerge.tags\"/>），然后拷贝它到主要开发分支，我们的拷贝会在<filename moreinfo=\"none\">calc</filename>项目目录创建一个新的目录<filename moreinfo=\"none\">libcomplex</filename>，它是这个我们将要进行自定义的卖主数据的拷贝版本。"

#: build/en/book.xml:9407(screen)
#, no-wrap
msgid ""
"\n"
"$ svn copy http://svn.example.com/repos/vendor/libcomplex/current  \\\n"
"           http://svn.example.com/repos/vendor/libcomplex/1.0      \\\n"
"           -m 'tagging libcomplex-1.0'\n"
"…\n"
"$ svn copy http://svn.example.com/repos/vendor/libcomplex/1.0  \\\n"
"           http://svn.example.com/repos/calc/libcomplex        \\\n"
"           -m 'bringing libcomplex-1.0 into the main branch'\n"
"…\n"
msgstr ""
"\n"
"$ svn copy http://svn.example.com/repos/vendor/libcomplex/current  \\\n"
"           http://svn.example.com/repos/vendor/libcomplex/1.0      \\\n"
"           -m 'tagging libcomplex-1.0'\n"
"…\n"
"$ svn copy http://svn.example.com/repos/vendor/libcomplex/1.0  \\\n"
"           http://svn.example.com/repos/calc/libcomplex        \\\n"
"           -m 'bringing libcomplex-1.0 into the main branch'\n"
"…\n"

#: build/en/book.xml:9424(para)
msgid "And entirely bug-free, of course!"
msgstr "而且完全没有bug，当然！"

#: build/en/book.xml:9418(para)
#, fuzzy
msgid "We check out our project's main branch—which now includes a copy of the first vendor drop—and we get to work customizing the libcomplex code. Before we know it, our modified version of libcomplex is now completely integrated into our calculator program. <placeholder-1/>"
msgstr "我们取出我们项目的主分支—现在包括了第一个卖主drop的拷贝—我们开始自定义libcomplex的代码，我们知道，我们的libcomplex修改版本是已经与我们的计算器程序完全集成。 <footnote><placeholder-1/></footnote>"

#: build/en/book.xml:9428(para)
msgid "A few weeks later, the developers of libcomplex release a new version of their library—version 1.1—which contains some features and functionality that we really want. We'd like to upgrade to this new version, but without losing the customizations we made to the existing version. What we essentially would like to do is to replace our current baseline version of libcomplex 1.0 with a copy of libcomplex 1.1, and then re-apply the custom modifications we previously made to that library to the new version. But we actually approach the problem from the other direction, applying the changes made to libcomplex between versions 1.0 and 1.1 to our modified copy of it."
msgstr "几周之后，libcomplex得开发者发布了一个新的版本—版本1.1—包括了我们很需要的一些特性和功能。我们很希望升级到这个版本，但不希望失去在当前版本所作的修改。我们本质上会希望把我们当前基线版本是的libcomplex1.0的拷贝替换为libcomplex 1.1，然后把前面自定义的修改应用到新的版本。但是实际上我们通过一个相反的方向解决这个问题，应用libcomplex从版本1.0到1.1的修改到我们修改的拷贝。"

#: build/en/book.xml:9441(para)
msgid "To perform this upgrade, we checkout a copy of our vendor branch, and replace the code in the <filename moreinfo=\"none\">current</filename> directory with the new libcomplex 1.1 source code. We quite literally copy new files on top of existing files, perhaps exploding the libcomplex 1.1 release tarball atop our existing files and directories. The goal here is to make our <filename moreinfo=\"none\">current</filename> directory contain only the libcomplex 1.1 code, and to ensure that all that code is under version control. Oh, and we want to do this with as little version control history disturbance as possible."
msgstr "为了执行这个升级，我们取出一个我们卖主分支的拷贝，替换<filename moreinfo=\"none\">current</filename>目录为新的libcomplex 1.1的代码，我们只是拷贝新文件到存在的文件上，或者是解压缩libcomplex 1.1的打包文件到我们存在的文件和目录。此时的目标是让我们的<filename moreinfo=\"none\">current</filename>目录只保留libcomplex 1.1的代码，并且保证所有的代码在版本控制之下，哦，我们希望在最小的版本控制历史扰动下完成这件事。"

#: build/en/book.xml:9453(para)
msgid "After replacing the 1.0 code with 1.1 code, <command moreinfo=\"none\">svn status</command> will show files with local modifications as well as, perhaps, some unversioned or missing files. If we did what we were supposed to do, the unversioned files are only those new files introduced in the 1.1 release of libcomplex—we run <command moreinfo=\"none\">svn add</command> on those to get them under version control. The missing files are files that were in 1.0 but not in 1.1, and on those paths we run <command moreinfo=\"none\">svn delete</command>. Finally, once our <filename moreinfo=\"none\">current</filename> working copy contains only the libcomplex 1.1 code, we commit the changes we made to get it looking that way."
msgstr "完成了这个从1.0到1.1的代码替换，<command moreinfo=\"none\">svn status</command>会显示文件的本地修改，或许也包括了一些未版本化或者丢失的文件，如果我们做了我们应该做的事情，未版本化的文件应该都是libcomplex在1.1新引入的文件—我们运行<command moreinfo=\"none\">svn add</command>来将它们加入到版本控制。丢失的文件是存在于1.1但是不是在1.1，在这些路径我们运行<command moreinfo=\"none\">svn delete</command>。最终一旦我们的<filename moreinfo=\"none\">current</filename>工作拷贝只是包括了libcomplex1.1的代码，我们可以提交这些改变目录和文件的修改。"

#: build/en/book.xml:9466(para)
msgid "Our <filename moreinfo=\"none\">current</filename> branch now contains the new vendor drop. We tag the new version (in the same way we previously tagged the version 1.0 vendor drop), and then merge the differences between the tag of the previous version and the new current version into our main development branch."
msgstr "我们的<filename moreinfo=\"none\">current</filename>分支现在保存了新的卖主drop，我们为这个新的版本创建一个新的标签（就像我们为1.0版本drop所作的），然后合并这从个标签前一个版本的区别到主要开发分支。"

#: build/en/book.xml:9473(screen)
#, no-wrap
msgid ""
"\n"
"$ cd working-copies/calc\n"
"$ svn merge http://svn.example.com/repos/vendor/libcomplex/1.0      \\\n"
"            http://svn.example.com/repos/vendor/libcomplex/current  \\\n"
"            libcomplex\n"
"… # resolve all the conflicts between their changes and our changes\n"
"$ svn commit -m 'merging libcomplex-1.1 into the main branch'\n"
"…\n"
msgstr ""
"\n"
"$ cd working-copies/calc\n"
"$ svn merge http://svn.example.com/repos/vendor/libcomplex/1.0      \\\n"
"            http://svn.example.com/repos/vendor/libcomplex/current  \\\n"
"            libcomplex\n"
"… # resolve all the conflicts between their changes and our changes\n"
"$ svn commit -m 'merging libcomplex-1.1 into the main branch'\n"
"…\n"

#: build/en/book.xml:9483(para)
msgid "In the trivial use case, the new version of our third-party tool would look, from a files-and-directories point of view, just like the previous version. None of the libcomplex source files would have been deleted, renamed or moved to different locations—the new version would contain only textual modifications against the previous one. In a perfect world, our modifications would apply cleanly to the new version of the library, with absolutely no complications or conflicts."
msgstr "在这个琐碎的用例里，第三方工具的新版本会从一个文件和目录的角度来看，就像前一个版本。没有任何libcomplex源文件会被删除、被改名或是移动到别的位置—新的版本只会保存针对上一个版本的文本修改。在完美世界，我们对呢修改会干净得应用到库的新版本，不会产生任何并发和冲突。"

#: build/en/book.xml:9493(para)
msgid "But things aren't always that simple, and in fact it is quite common for source files to get moved around between releases of software. This complicates the process of ensuring that our modifications are still valid for the new version of code, and can quickly degrade into a situation where we have to manually recreate our customizations in the new version. Once Subversion knows about the history of a given source file—including all its previous locations—the process of merging in the new version of the library is pretty simple. But we are responsible for telling Subversion how the source file layout changed from vendor drop to vendor drop."
msgstr "但是事情总不是这样简单，实际上源文件在不同的版本间的移动是很常见的，这种过程复杂性可以确保我们的修改会一直对新的版本代码有效，可以很快使形势退化到我们需要在新版本手工的重新创建我们的自定义修改。一旦Subversion知道了给定文件的历史—包括了所有以前的位置—合并到新版本的进程就会很简单，但是我们需要负责告诉Subversion卖主drop之间源文件布局的改变。"

#: build/en/book.xml:9515(command)
msgid "svn_load_dirs.pl"
msgstr "svn_load_dirs.pl"

#: build/en/book.xml:9517(para)
msgid "Vendor drops that contain more than a few deletes, additions and moves complicate the process of upgrading to each successive version of the third-party data. So Subversion supplies the <command moreinfo=\"none\">svn_load_dirs.pl</command> script to assist with this process. This script automates the importing steps we mentioned in the general vendor branch management procedure to make sure that mistakes are minimized. You will still be responsible for using the merge commands to merge the new versions of the third-party data into your main development branch, but <command moreinfo=\"none\">svn_load_dirs.pl</command> can help you more quickly and easily arrive at that stage."
msgstr "不仅仅包含一些删除、添加和移动的卖主drops使得升级第三方数据后续版本的过程变得复杂，所以Subversion提供了一个<command moreinfo=\"none\">svn_load_dirs.pl</command>脚本来辅助这个过程，这个脚本自动进行我们前面提到的常规卖主分支管理过程的导入步骤，从而使得错误最小化。你仍要负责使用合并命令合并第三方的新 版本数据合并到主要开发分支，但是<command moreinfo=\"none\">svn_load_dirs.pl</command>帮助你快速到达这一步骤。"

#: build/en/book.xml:9530(para)
msgid "In short, <command moreinfo=\"none\">svn_load_dirs.pl</command> is an enhancement to <command moreinfo=\"none\">svn import</command> that has several important characteristics:"
msgstr "一句话，<command moreinfo=\"none\">svn_load_dirs.pl</command>是一个增强的<command moreinfo=\"none\">svn import</command>，具备了许多重要的特性："

#: build/en/book.xml:9536(para)
msgid "It can be run at any point in time to bring an existing directory in the repository to exactly match an external directory, performing all the necessary adds and deletes, and optionally performing moves, too."
msgstr "它可以在任何有一个存在的版本库目录与一个外部的目录匹配时执行，会执行所有必要的添加和删除并且可以选则执行移动。"

#: build/en/book.xml:9542(para)
msgid "It takes care of complicated series of operations between which Subversion requires an intermediate commit—such as before renaming a file or directory twice."
msgstr "它可以用来操作一系列复杂的操作，如那些需要一个中间媒介的提交—如在操作之前重命名一个文件或者目录两次。"

#: build/en/book.xml:9547(para)
msgid "It will optionally tag the newly imported directory."
msgstr "它可以随意的为新导入目录打上标签。"

#: build/en/book.xml:9550(para)
msgid "It will optionally add arbitrary properties to files and directories that match a regular expression."
msgstr "它可以随意为符合正则表达式的文件和目录添加任意的属性。"

#: build/en/book.xml:9555(para)
msgid "<command moreinfo=\"none\">svn_load_dirs.pl</command> takes three mandatory arguments. The first argument is the URL to the base Subversion directory to work in. This argument is followed by the URL—relative to the first argument—into which the current vendor drop will be imported. Finally, the third argument is the local directory to import. Using our previous example, a typical run of <command moreinfo=\"none\">svn_load_dirs.pl</command> might look like:"
msgstr "<command moreinfo=\"none\">svn_load_dirs.pl</command>利用三个强制的参数，第一个参数是Subversion工作的基本目录URL，第二个参数在URL之后—相对于第一个参数—指向当前的卖主分支将会导入的目录，最后，第三个参数是一个需要导入的本地目录，使用前面的例子，一个典型的<command moreinfo=\"none\">svn_load_dirs.pl</command>调用看起来如下："

#: build/en/book.xml:9564(screen)
#, no-wrap
msgid ""
"\n"
"$ svn_load_dirs.pl http://svn.example.com/repos/vendor/libcomplex \\\n"
"                   current                                        \\\n"
"                   /path/to/libcomplex-1.1\n"
"…\n"
msgstr ""
"\n"
"$ svn_load_dirs.pl http://svn.example.com/repos/vendor/libcomplex \\\n"
"                   current                                        \\\n"
"                   /path/to/libcomplex-1.1\n"
"…\n"

#: build/en/book.xml:9571(para)
msgid "You can indicate that you'd like <command moreinfo=\"none\">svn_load_dirs.pl</command> to tag the new vendor drop by passing the <option>-t</option> command-line option and specifying a tag name. This tag is another URL relative to the first program argument."
msgstr "你可以说明你会希望<command moreinfo=\"none\">svn_load_dirs.pl</command>同时打上标签，这使用<option>-t</option>命令行选项，需要制定一个标签名。这个标签是第一个参数的一个相对URL。"

#: build/en/book.xml:9577(screen)
#, no-wrap
msgid ""
"\n"
"$ svn_load_dirs.pl -t libcomplex-1.1                              \\\n"
"                   http://svn.example.com/repos/vendor/libcomplex \\\n"
"                   current                                        \\\n"
"                   /path/to/libcomplex-1.1\n"
"…\n"
msgstr ""
"\n"
"$ svn_load_dirs.pl -t libcomplex-1.1                              \\\n"
"                   http://svn.example.com/repos/vendor/libcomplex \\\n"
"                   current                                        \\\n"
"                   /path/to/libcomplex-1.1\n"
"…\n"

#: build/en/book.xml:9585(para)
msgid "When you run <command moreinfo=\"none\">svn_load_dirs.pl</command>, it examines the contents of your existing <quote>current</quote> vendor drop, and compares them with the proposed new vendor drop. In the trivial case, there will be no files that are in one version and not the other, and the script will perform the new import without incident. If, however, there are discrepancies in the file layouts between versions, <command moreinfo=\"none\">svn_load_dirs.pl</command> will prompt you for how you would like to resolve those differences. For example, you will have the opportunity to tell the script that you know that the file <filename moreinfo=\"none\">math.c</filename> in version 1.0 of libcomplex was renamed to <filename moreinfo=\"none\">arithmetic.c</filename> in libcomplex 1.1. Any discrepancies not explained by moves are treated as regular additions and deletions."
msgstr "当你运行<command moreinfo=\"none\">svn_load_dirs.pl</command>，它会检验你的存在的<quote>current</quote>卖主drop，并且与提议的新卖主drop比较，在这个琐碎的例子里，没有文件只出现在一个版本里，脚本执行新的导入而不会发生意外。然而如果版本之间有了文件布局的区别，<command moreinfo=\"none\">svn_load_dirs.pl</command>会询问你如何解决这个区别，例如你会有机会告诉脚本libcomplex版本1.0的<filename moreinfo=\"none\">math.c</filename>文件在1.1已经重命名为<filename moreinfo=\"none\">arithmetic.c</filename>，任何没有解释为移动的差异都会被看作是常规的添加和删除。"

#: build/en/book.xml:9600(para)
msgid "The script also accepts a separate configuration file for setting properties on files and directories matching a regular expression that are <emphasis>added</emphasis> to the repository. This configuration file is specified to <command moreinfo=\"none\">svn_load_dirs.pl</command> using the <option>-p</option> command-line option. Each line of the configuration file is a whitespace-delimited set of two or four values: a Perl-style regular expression to match the added path against, a control keyword (either <literal moreinfo=\"none\">break</literal> or <literal moreinfo=\"none\">cont</literal>), and then optionally a property name and value."
msgstr "这个脚本也接受单独配置文件用来为<emphasis>添加到</emphasis>版本库的文件和目录设置匹配正则表达式的属性。配置文件通过<command moreinfo=\"none\">svn_load_dirs.pl</command>的<option>-p</option>命令行选项指定，这个配置文件的每一行都是一个空白分割的两列或者四列值：一个Perl样式的正则表达式来匹配添加的路径、一个控制关键字（<literal moreinfo=\"none\">break</literal>或者是<literal moreinfo=\"none\">cont</literal>）和可选的属性名和值。"

#: build/en/book.xml:9612(screen)
#, no-wrap
msgid ""
"\n"
"\\.png$              break   svn:mime-type   image/png\n"
"\\.jpe?g$            break   svn:mime-type   image/jpeg\n"
"\\.m3u$              cont    svn:mime-type   audio/x-mpegurl\n"
"\\.m3u$              break   svn:eol-style   LF\n"
".*                  break   svn:eol-style   native\n"
msgstr ""
"\n"
"\\.png$              break   svn:mime-type   image/png\n"
"\\.jpe?g$            break   svn:mime-type   image/jpeg\n"
"\\.m3u$              cont    svn:mime-type   audio/x-mpegurl\n"
"\\.m3u$              break   svn:eol-style   LF\n"
".*                  break   svn:eol-style   native\n"

#: build/en/book.xml:9620(para)
msgid "For each added path, the configured property changes whose regular expression matches the path are applied in order, unless the control specification is <literal moreinfo=\"none\">break</literal> (which means that no more property changes should be applied to that path). If the control specification is <literal moreinfo=\"none\">cont</literal>—an abbreviation for <literal moreinfo=\"none\">continue</literal>—then matching will continue with the next line of the configuration file."
msgstr "对每一个添加的路径，会按照顺序为匹配正则表达式的文件配置属性，除非控制标志是<literal moreinfo=\"none\">break</literal>（意味着不需要更多的路径匹配应用到这个路径）。如果控制说明是<literal moreinfo=\"none\">cont</literal>—<literal moreinfo=\"none\">continue</literal>的缩写—然后匹配工作会继续到配置文件的下一行。"

#: build/en/book.xml:9629(para)
msgid "Any whitespace in the regular expression, property name, or property value must be surrounded by either single or double quote characters. You can escape quote characters that are not used for wrapping whitespace by preceding them with a backslash (<literal moreinfo=\"none\">\\</literal>) character. The backslash escapes only quotes when parsing the configuration file, so do not protect any other characters beyond what is necessary for the regular expression."
msgstr "任何正则表达式，属性名或者属性值的空格必须使用单引号或者双银行环绕，你可以使用反斜杠（<literal moreinfo=\"none\">\\</literal>）换码符来回避引号，反斜杠只会在解析配置文件时回避引号，所以不要保护对正则表达式不需要的其它字符。"

#: build/en/book.xml:9647(para)
msgid "We've covered a lot of ground in this chapter. We've discussed the concepts of tags and branches, and demonstrated how Subversion implements these concepts by copying directories with the <command moreinfo=\"none\">svn copy</command> command. We've shown how to use <command moreinfo=\"none\">svn merge</command> to copy changes from one branch to another, or roll back bad changes. We've gone over the use of <command moreinfo=\"none\">svn switch</command> to create mixed-location working copies. And we've talked about how one might manage the organization and lifetimes of branches in a repository."
msgstr "我们已经在本章覆盖了许多基础知识，我们讨论了标签和分支的概念，然后描述了Subversion怎样用<command moreinfo=\"none\">svn copy</command>命令拷贝目录实现了这些概念，我们也已经展示了怎样使用<command moreinfo=\"none\">svn merge</command>命令来在分支之间拷贝修改，或是撤销错误的修改。我们仔细研究了使用<command moreinfo=\"none\">svn switch</command>来创建混合位置的工作拷贝，然后我们也讨论了怎样管理和组织版本库中分支的生命周期。"

#: build/en/book.xml:9658(para)
msgid "Remember the Subversion mantra: branches and tags are cheap. So use them liberally! At the same time, don't forget to use good merging habits. Cheap copies are only useful when you're careful about tracking your merging actions."
msgstr ""

#: build/en/book.xml:9676(title)
msgid "Repository Administration"
msgstr "版本库管理"

#: build/en/book.xml:9678(para)
#, fuzzy
msgid "The Subversion repository is the central storehouse of all your versioned data. As such, it becomes an obvious candidate for all the love and attention an administrator can offer. While the repository is generally a low-maintenance item, it is important to understand how to properly configure and care for it so that potential problems are avoided, and actual problems are safely resolved."
msgstr "Subversion版本库是保存任意数量项目版本化数据的中央仓库，因此，版本库成为管理员关注的对象。版本库的维护一般并不需要太多的关注，但为了避免一些潜在的问题和解决一些实际问题，理解怎样适当的配置和维护还是非常重要的。"

#: build/en/book.xml:9686(para)
#, fuzzy
msgid "In this chapter, we'll discuss how to create and configure a Subversion repository. We'll also talk about repository maintenance, providing examples of how and when to use the <command moreinfo=\"none\">svnlook</command> and <command moreinfo=\"none\">svnadmin</command> tools provided with Subversion. We'll address some common questions and mistakes, and give some suggestions on how to arrange the data in the repository."
msgstr "在这一章里，我们将讨论如何建立和配置一个Subversion版本库，还会讨论版本库的维护，包括<command moreinfo=\"none\">svnlook</command>和<command moreinfo=\"none\">svnadmin</command>工具的使用（它们都包含在Subversion中）。我们将说明一些常见的问题和错误，并提供一些安排版本库数据的建议。"

#: build/en/book.xml:9700(para)
msgid "This may sound really prestigious and lofty, but we're just talking about anyone who is interested in that mysterious realm beyond the working copy where everyone's data hangs out."
msgstr "这可能听起来很崇高， 但我们所指的只是那些对管理别人工作拷贝数据之外的神秘领域感兴趣的人。"

#: build/en/book.xml:9694(para)
#, fuzzy
msgid "If you plan to access a Subversion repository only in the role of a user whose data is under version control (that is, via a Subversion client), you can skip this chapter altogether. However, if you are, or wish to become, a Subversion repository administrator, <placeholder-1/> this chapter is for you."
msgstr "如果您只是以普通用户的身份访问版本库对数据进行版本控制（就是说通过Subversion客户端），您完全可以跳过本章。但是如果您已经是或打算成为Subversion版本库的管理员，<footnote><placeholder-1/></footnote>您一定要关注一下本章的内容。"

#: build/en/book.xml:9712(title)
msgid "The Subversion Repository, Defined"
msgstr "Subversion 版本库的定义"

#: build/en/book.xml:9714(para)
#, fuzzy
msgid "Before jumping into the broader topic of repository administration, let's further define what a repository is. How does it look? How does it feel? Does it take its tea hot or iced, sweetened, and with lemon? As an administrator, you'll be expected to understand the composition of a repository both from a literal, OS-level perspective—how a repository looks and acts with respect to non-Subversion tools—and from a logical perspective—dealing with how data is represented <emphasis>inside</emphasis> the repository."
msgstr "在进入版本库管理这块宽广的主题之前，让我们进一步确定一下版本库的定义，它是怎样工作的？让人有什么感觉？它希望茶是热的还是冰的，加糖或柠檬吗？作为一名管理员，你应该既从逻辑视角－数据在版本库中如何展示，又能从物理具体细节的视角－版本库如何响应一个非Subversion的工具，来理解版本库的组成。下面的小节从一个比较高的层面覆盖了这些基本概念。"

#: build/en/book.xml:9724(para)
msgid "Seen through the eyes of a typical file browser application (such as the Windows Explorer) or command-line based filesystem navigation tools, the Subversion repository is just another directory full of stuff. There are some subdirectories with human-readable configuration files in them, some subdirectories with some not-so-human-readable data files, and so on. As in other areas of the Subversion design, modularity is given high regard, and hierarchical organization is preferred to cluttered chaos. So a shallow glance into a typical repository from a nuts-and-bolts perspective is sufficient to reveal the basic components of the repository:"
msgstr ""

#: build/en/book.xml:9736(screen)
#, no-wrap
msgid ""
"\n"
"$ ls repos\n"
"conf/  dav/  db/  format  hooks/  locks/  README.txt\n"
msgstr ""
"\n"
"$ ls repos\n"
"conf/  dav/  db/  format  hooks/  locks/  README.txt\n"

#: build/en/book.xml:9741(para)
msgid "Here's a quick fly-by overview of what exactly you're seeing in this directory listing. (Don't get bogged down in the terminology—detailed coverage of these components exists elsewhere in this and other chapters.)"
msgstr ""

#: build/en/book.xml:9748(term)
msgid "conf"
msgstr "conf"

#: build/en/book.xml:9750(para)
msgid "A directory containing repository configuration files."
msgstr "一个存储版本库配置文件的目录。"

#: build/en/book.xml:9754(term)
msgid "dav"
msgstr "dav"

#: build/en/book.xml:9756(para)
#, fuzzy
msgid "A directory provided to mod_dav_svn for its private housekeeping data."
msgstr "提供给Apache和mod_dav_svn的目录，让它们存储自己的数据。"

#: build/en/book.xml:9761(term)
msgid "db"
msgstr "db"

#: build/en/book.xml:9763(para)
msgid "The data store for all of your versioned data."
msgstr ""

#: build/en/book.xml:9767(term)
msgid "format"
msgstr "format"

#: build/en/book.xml:9769(para)
msgid "A file whose contents are a single integer value that dictates the version number of the repository layout."
msgstr "包含了用来表示版本库布局版本号的整数。"

#: build/en/book.xml:9774(term) build/en/book.xml:24512(secondary)
#: build/en/book.xml:24564(secondary) build/en/book.xml:24619(secondary)
#: build/en/book.xml:24671(secondary) build/en/book.xml:24742(secondary)
#: build/en/book.xml:24812(secondary) build/en/book.xml:24869(secondary)
#: build/en/book.xml:24923(secondary) build/en/book.xml:24982(secondary)
msgid "hooks"
msgstr "hooks"

#: build/en/book.xml:9776(para)
msgid "A directory full of hook script templates (and hook scripts themselves, once you've installed some)."
msgstr "一个存储钩子脚本模版的目录（还有钩子脚本本身， 如果你安装了的话）。"

#: build/en/book.xml:9781(term)
msgid "locks"
msgstr "locks"

#: build/en/book.xml:9783(para)
#, fuzzy
msgid "A directory for Subversion's repository lock files, used for tracking accessors to the repository."
msgstr "一个存储Subversion版本库锁定数据的目录，被用来追踪对版本库的访问。"

#: build/en/book.xml:9788(term)
msgid "README.txt"
msgstr "README.txt"

#: build/en/book.xml:9790(para)
#, fuzzy
msgid "A file whose contents merely inform its readers that they are looking at a Subversion repository."
msgstr "这个文件只是用来告诉它的阅读者，他现在看的是 Subversion 的版本库。"

#: build/en/book.xml:9796(para)
msgid "Of course, when accessed via the Subversion libraries, this otherwise unremarkable collection of files and directories suddenly becomes an implementation of a virtual, versioned filesystem, complete with customizable event triggers. This filesystem has its own notions of directories and files, very similar to the notions of such things held by real filesystems (such as NTFS, FAT32, ext3, and so on). But this is a special filesystem—it hangs these directories and files from revisions, keeping all the changes you've ever made to them safely stored and forever accessible. This is where the entirety of your versioned data lives."
msgstr ""

#: build/en/book.xml:9814(title)
msgid "Strategies for Repository Deployment"
msgstr "版本库开发策略"

#: build/en/book.xml:9816(para)
msgid "Due largely to the simplicity of the overall design of the Subversion repository and the technologies on which it relies, creating and configuring a repository are fairly straightforward tasks. There are a few preliminary decisions you'll want to make, but the actual work involved in any given setup of a Subversion repository is pretty straightforward, tending towards mindless repetition if you find yourself setting up multiples of these things."
msgstr ""

#: build/en/book.xml:9825(para)
msgid "Some of things you'll want to consider up front, though, are as follows:"
msgstr ""

#: build/en/book.xml:9830(para)
msgid "What data do you expect to live in your repository (or repositories), and how will that data be organized?"
msgstr ""

#: build/en/book.xml:9834(para)
msgid "Where will your repository live, and how will it be accessed?"
msgstr ""

#: build/en/book.xml:9838(para)
msgid "What types of access control and repository event reporting do you need?"
msgstr ""

#: build/en/book.xml:9842(para)
msgid "Which of the available types of data store do you want to use?"
msgstr ""

#: build/en/book.xml:9847(para)
msgid "In this section, we'll try to help you answer those questions."
msgstr "在本节，我们要尝试帮你回答这些问题。"

#: build/en/book.xml:9852(title)
msgid "Planning Your Repository Organization"
msgstr "规划你的版本库结构"

#: build/en/book.xml:9854(para)
#, fuzzy
msgid "While Subversion allows you to move around versioned files and directories without any loss of information, and even provides ways of moving whole sets of versioned history from one repository to another, doing so can greatly disrupt the workflow of those who access the repository often and come to expect things to be at certain locations. So before creating a new repository, try to peer into the future a bit; plan ahead before placing your data under version control. By conscientiously <quote>laying out</quote> your repository or repositories and their versioned contents ahead of time, you can prevent many future headaches."
msgstr "在Subversion版本库中，移动版本化的文件和目录不会损失任何信息，但是这样一来那些经常访问版本库并且以为文件总是在同一个路径的用户可能会受到干扰。为将来着想，最好预先对你的版本库布局进行规划。以一种高效的<quote>布局</quote>开始项目，可以减少将来很多不必要的麻烦。"

#: build/en/book.xml:9866(para)
#, fuzzy
msgid "Let's assume that as repository administrator, you will be responsible for supporting the version control system for several projects. Your first decision is whether to use a single repository for multiple projects, or to give each project its own repository, or some compromise of these two."
msgstr "在建立Subversion版本库之前，有很多事情需要考虑。假如你是一个版本库管理员，需要向多个项目提供版本控制支持。那么，你首先要决定的是，用一个版本库支持多个项目，还是为每个项目建立一个版本库，还是为其中的某些项目提供独立的版本库支持，而将另外一些项目分布在几个版本库中。"

#: build/en/book.xml:9873(para)
#, fuzzy
msgid "There are benefits to using a single repository for multiple projects, most obviously the lack of duplicated maintenance. A single repository means that there is one set of hook programs, one thing to routinely backup, one thing to dump and load if Subversion releases an incompatible new version, and so on. Also, you can move data between projects easily, and without losing any historical versioning information."
msgstr "使用一个版本库支持多个项目有很多好处，最明显的无过于不需要维护好几个版本库。单一版本库就意味着只有一个钩子集，只需要备份一个数据库，当Subversion进行不兼容升级时，只需要一次转储和装载操作，等等。还有，你可以轻易的在项目之间移动数据，还不会损失任何历史版本信息。"

#: build/en/book.xml:9899(para)
msgid "Whether founded in ignorance or in poorly considered concepts about how to derive legitimate software development metrics, global revision numbers are a silly thing to fear, and <emphasis>not</emphasis> the kind of thing you should weigh when deciding how to arrange your projects and repositories."
msgstr ""

#: build/en/book.xml:9882(para)
#, fuzzy
msgid "The downside of using a single repository is that different projects may have different requirements in terms of the repository event triggers, such as needing to send commit notification emails to different mailing lists, or having different definitions about what does and does not constitute a legitimate commit. These aren't insurmountable problems, of course—it just means that all of your hook scripts have to be sensitive to the layout of your repository rather than assuming that the whole repository is associated with a single group of people. Also, remember that Subversion uses repository-global revision numbers. While those numbers don't have any particular magical powers, some folks still don't like the fact that even though no changes have been made to their project lately, the youngest revision number for the repository keeps climbing because other projects are actively adding new revisions. <placeholder-1/>"
msgstr "单一版本库的缺点是，不同的项目通常都有不同的提交邮件列表或者不同的权限认证和权限要求。还有，别忘了Subversion的修订版本号是针对整个版本库的。即使最近没有对某个项目作出修改，版本库的修订版本号还是会因为其它项目的修改而不停的提升，许多人并不喜欢这样的事实。"

#: build/en/book.xml:9908(para)
msgid "A middle-ground approach can be taken, too. For example, projects can be grouped by how well they relate to each other. You might have a few repositories with a handful of projects in each repository. That way, projects that are likely to want to share data can do so easily, and as new revisions are added to the repository, at least the developers know that those new revisions are at least remotely related to everyone who uses that repository."
msgstr "可以采用折中的办法。比如，可以把许多项目按照彼此之间的关联程度划分为几个组合，然后为每一个项目组合建立一个版本库。这样，在相关项目之间共享数据依旧很简单，而如果修订版本号有了变化，至少开发人员知道，改变的东西多少和他们有些关系。"

#: build/en/book.xml:9935(para)
msgid "The <filename moreinfo=\"none\">trunk</filename>, <filename moreinfo=\"none\">tags</filename>, and <filename moreinfo=\"none\">branches</filename> trio are sometimes referred to as <quote>the TTB directories</quote>."
msgstr "<filename moreinfo=\"none\">trunk</filename>、<filename moreinfo=\"none\">tags</filename>和<filename moreinfo=\"none\">branches</filename>可以使用<quote>TTB目录</quote>来表示。"

#: build/en/book.xml:9917(para)
#, fuzzy
msgid "After deciding how to organize your projects with respect to repositories, you'll probably want to think about directory hierarchies within the repositories themselves. Because Subversion uses regular directory copies for branching and tagging (see <xref linkend=\"svn.branchmerge\"/>), the Subversion community recommends that you choose a repository location for each <firstterm>project root</firstterm>—the <quote>top-most</quote> directory which contains data related to that project—and then create three subdirectories beneath that root: <filename moreinfo=\"none\">trunk</filename>, meaning the directory under which the main project development occurs; <filename moreinfo=\"none\">branches</filename>, which is a directory in which to create various named branches of the main development line; <filename moreinfo=\"none\">tags</filename>, which is a collection of tree snapshots that are created, and perhaps destroyed, but never changed. <placeholder-1/>"
msgstr "在决定了如何用版本库组织项目以后，就该决定如何设置版本库的目录层次了。由于Subversion按普通的目录复制方式完成分支和标签操作（参见<xref linkend=\"svn.branchmerge\"/>），Subversion社区建议为每一个项目建立一个<firstterm>项目根目录</firstterm>—项目的<quote>顶级</quote>目录—然后在根目录下建立三个子目录：<filename moreinfo=\"none\">trunk</filename>，保存项目的开发主线；<filename moreinfo=\"none\">branches</filename>，保存项目的各种开发分支；<filename moreinfo=\"none\">tags</filename>，保存项目的标签，也就是创建后永远不会修改的分支（可能会删除）。 <footnote><placeholder-1/></footnote>"

#: build/en/book.xml:9941(para)
msgid "For example, your repository might look like:"
msgstr "举个例子，一个版本库可能会有如下的布局："

#: build/en/book.xml:9943(screen)
#, no-wrap
msgid ""
"\n"
"/\n"
"   calc/\n"
"      trunk/\n"
"      tags/\n"
"      branches/\n"
"   calendar/\n"
"      trunk/\n"
"      tags/\n"
"      branches/\n"
"   spreadsheet/\n"
"      trunk/\n"
"      tags/\n"
"      branches/\n"
"   …\n"
msgstr ""
"\n"
"/\n"
"   calc/\n"
"      trunk/\n"
"      tags/\n"
"      branches/\n"
"   calendar/\n"
"      trunk/\n"
"      tags/\n"
"      branches/\n"
"   spreadsheet/\n"
"      trunk/\n"
"      tags/\n"
"      branches/\n"
"   …\n"

#: build/en/book.xml:9960(para)
msgid "Note that it doesn't matter where in your repository each project root is. If you have only one project per repository, the logical place to put each project root is at the root of that project's respective repository. If you have multiple projects, you might want to arrange them in groups inside the repository, perhaps putting projects with similar goals or shared code in the same subdirectory, or maybe just grouping them alphabetically. Such an arrangement might look like:"
msgstr "项目在版本库中的根目录地址并不重要。如果每个版本库中只有一个项目，那么就可以认为项目的根目录就是版本库的根目录。如果版本库中包含多个项目，那么可以将这些项目划分成不同的组合（按照项目的目标或者是否需要共享代码甚至是字母顺序）保存在不同子目录中，下面的例子给出了一个类似的布局："

#: build/en/book.xml:9970(screen)
#, no-wrap
msgid ""
"\n"
"/\n"
"   utils/\n"
"      calc/\n"
"         trunk/\n"
"         tags/\n"
"         branches/\n"
"      calendar/\n"
"         trunk/\n"
"         tags/\n"
"         branches/\n"
"      …\n"
"   office/\n"
"      spreadsheet/\n"
"         trunk/\n"
"         tags/\n"
"         branches/\n"
"      …\n"
msgstr ""
"\n"
"/\n"
"   utils/\n"
"      calc/\n"
"         trunk/\n"
"         tags/\n"
"         branches/\n"
"      calendar/\n"
"         trunk/\n"
"         tags/\n"
"         branches/\n"
"      …\n"
"   office/\n"
"      spreadsheet/\n"
"         trunk/\n"
"         tags/\n"
"         branches/\n"
"      …\n"

#: build/en/book.xml:9990(para)
msgid "Lay out your repository in whatever way you see fit. Subversion does not expect or enforce a layout schema—in its eyes, a directory is a directory is a directory. Ultimately, you should choose the repository arrangement that meets the needs of the people who work on the projects that live there."
msgstr "按照你因为合适方式安排版本库的布局。Subversion自身并不强制或者偏好某一种布局形式，对于Subversion来说，目录就是目录。最后，在设计版本库布局的时候，不要忘了考虑一下项目参与者们的意见。"

#: build/en/book.xml:9997(para)
#, fuzzy
msgid "In the name of full disclosure, though, we'll mention another very common layout. In this layout, the <filename moreinfo=\"none\">trunk</filename>, <filename moreinfo=\"none\">tags</filename>, and <filename moreinfo=\"none\">branches</filename> directories live in the root directory of your repository, and your projects are in subdirectories beneath those, like:"
msgstr "<filename moreinfo=\"none\">trunk</filename>、<filename moreinfo=\"none\">tags</filename>和<filename moreinfo=\"none\">branches</filename>可以使用<quote>TTB目录</quote>来表示。"

#: build/en/book.xml:10004(screen)
#, no-wrap
msgid ""
"\n"
"/\n"
"   trunk/\n"
"      calc/\n"
"      calendar/\n"
"      spreadsheet/\n"
"      …\n"
"   tags/\n"
"      calc/\n"
"      calendar/\n"
"      spreadsheet/\n"
"      …\n"
"   branches/\n"
"      calc/\n"
"      calendar/\n"
"      spreadsheet/\n"
"      …\n"
msgstr ""
"\n"
"/\n"
"   trunk/\n"
"      calc/\n"
"      calendar/\n"
"      spreadsheet/\n"
"      …\n"
"   tags/\n"
"      calc/\n"
"      calendar/\n"
"      spreadsheet/\n"
"      …\n"
"   branches/\n"
"      calc/\n"
"      calendar/\n"
"      spreadsheet/\n"
"      …\n"

#: build/en/book.xml:10023(para)
msgid "There's nothing particularly incorrect about such a layout, but it may or may not seem as intuitive for your users. Especially in large, multi-project situations with many users, those users may tend to be familiar with only one or two of the projects in the repository. But the projects-as-branch-siblings tends to de-emphasize project individuality and focus on the entire set of projects as a single entity. That's a social issue though. We like our originally suggested arrangement for purely practical reasons—it's easier to ask about (or modify, or migrate elsewhere) the entire history of a single project when there's a single repository path that holds the entire history—past, present, tagged, and branched—for that project and that project alone."
msgstr ""

#: build/en/book.xml:10042(title)
msgid "Deciding Where and How to Host Your Repository"
msgstr "决定在哪里与如何部署你的版本库"

#: build/en/book.xml:10044(para)
msgid "Before creating your Subversion repository, an obvious question you'll need to answer is where the thing is going to live. This is strongly connected to a myriad of other questions involving how the repository will be accessed (via a Subversion server or directly), by whom (users behind your corporate firewall or the whole world out on the open Internet), what other services you'll be providing around Subversion (repository browsing interfaces, e-mail based commit notification, etc.), your data backup strategy, and so on."
msgstr ""

#: build/en/book.xml:10055(para)
msgid "We cover server choice and configuration in <xref linkend=\"svn.serverconfig\"/>, but the point we'd like to briefly make here is simply that the answers to some of these other questions might have implications that force your hand when deciding where your repository will live. For example, certain deployment scenarios might require accessing the repository via a remote filesystem from multiple computers, in which case (as you'll read in the next section) your choice of a repository back-end data store turns out not to be a choice at all because only one of the available back-ends will work in this scenario."
msgstr ""

#: build/en/book.xml:10066(para)
msgid "To try to address each and every possible way to deploy Subversion is both not possible and outside the scope of this book. We simply encourage you to evaluate your options using these pages and other sources as your reference material, and plan ahead."
msgstr ""

#: build/en/book.xml:10076(title)
msgid "Choosing a Data Store"
msgstr "选择数据存储格式"

#: build/en/book.xml:10090(para)
#, fuzzy
msgid "Often pronounced <quote>fuzz-fuzz</quote>, if Jack Repenning has anything to say about it. (This book, however, assumes that the reader is thinking <quote>eff-ess-eff-ess</quote>.)"
msgstr "读作<quote>fuzz-fuzz</quote>, 如果Jack Repenning说起这个问题。"

#: build/en/book.xml:10078(para)
#, fuzzy
msgid "As of version 1.1, Subversion provides two options for the type of underlying data store—often referred to as <quote>the back-end</quote> or, somewhat confusingly, <quote>the (versioned) filesystem</quote>—that each repository uses. One type of data store keeps everything in a Berkeley DB (or BDB) database environment; repositories that use this type are often referred to as being <quote>BDB-backed</quote>. The other type stores data in ordinary flat files, using a custom format. Subversion developers have adopted the habit of referring to this latter data storage mechanism as <firstterm>FSFS</firstterm><placeholder-1/> —a versioned filesystem implementation that uses the native OS filesystem to store data."
msgstr "在Subversion1.2中，版本库中存储数据有两种方式。一种是在Berkeley DB数据库中存储数据；另一种是使用普通的文件，使用自定义格式。因为Subversion的开发者称版本库为（版本化的）文件系统，他们接受了称后一种存储方式为FSFS<footnote><placeholder-1/></footnote>的习惯，也就是说，使用本地操作系统文件系统来存储数据的版本化文件的系统。"

#: build/en/book.xml:10098(para)
#, fuzzy
msgid "<xref linkend=\"svn.reposadmin.basics.backends.tbl-1\"/> gives a comparative overview of Berkeley DB and FSFS repositories."
msgstr "<xref linkend=\"svn.reposadmin.basics.backends.tbl-1\"/>从总体上比较了Berkeley DB和FSFS版本库，下一部分将会详细讲述细节。"

#: build/en/book.xml:10103(title)
msgid "Repository Data Store Comparison"
msgstr "版本库数据存储对照表"

#: build/en/book.xml:10107(entry)
msgid "Category"
msgstr "分类"

#: build/en/book.xml:10108(entry) build/en/book.xml:12676(entry)
msgid "Feature"
msgstr "特性"

#: build/en/book.xml:10109(entry) build/en/book.xml:10213(title)
msgid "Berkeley DB"
msgstr "Berkeley DB"

#: build/en/book.xml:10110(entry) build/en/book.xml:10341(title)
msgid "FSFS"
msgstr "FSFS"

#: build/en/book.xml:10115(entry)
msgid "Reliability"
msgstr "可靠性"

#: build/en/book.xml:10116(entry)
msgid "Data integrity"
msgstr ""

#: build/en/book.xml:10117(entry)
msgid "when properly deployed, extremely reliable; Berkeley DB 4.4 brings auto-recovery"
msgstr ""

#: build/en/book.xml:10119(entry)
msgid "older versions had some rarely demonstrated, but data-destroying bugs"
msgstr ""

#: build/en/book.xml:10123(entry)
msgid "Sensitivity to interruptions"
msgstr "对操作中断的敏感"

#: build/en/book.xml:10125(quote)
msgid "wedged"
msgstr "塞住"

#: build/en/book.xml:10124(entry)
#, fuzzy
msgid "very; crashes and permission problems can leave the database <placeholder-1/>, requiring journaled recovery procedures"
msgstr "很敏感；系统崩溃或者权限问题会导致数据库<placeholder-1/>，需要定期进行恢复。"

#: build/en/book.xml:10127(entry)
msgid "quite insensitive"
msgstr "十分敏感"

#: build/en/book.xml:10130(entry)
msgid "Accessibility"
msgstr "可用性"

#: build/en/book.xml:10131(entry)
msgid "Usable from a read-only mount"
msgstr "可只读加载"

#: build/en/book.xml:10132(entry) build/en/book.xml:10137(entry)
msgid "no"
msgstr "不能"

#: build/en/book.xml:10133(entry) build/en/book.xml:10138(entry)
#: build/en/book.xml:10143(entry)
msgid "yes"
msgstr "可以"

#: build/en/book.xml:10136(entry)
msgid "Platform-independent storage"
msgstr "存储平台无关"

#: build/en/book.xml:10141(entry)
msgid "Usable over network filesystems"
msgstr "可从网络文件系统访问"

#: build/en/book.xml:10142(entry)
msgid "generally, no"
msgstr ""

#: build/en/book.xml:10146(entry)
msgid "Group permissions handling"
msgstr "组访问权处理"

#: build/en/book.xml:10147(entry)
#, fuzzy
msgid "sensitive to user umask problems; best if accessed by only one user"
msgstr "对于用户的umask设置十分敏感，最好只由一个用户访问。"

#: build/en/book.xml:10149(entry)
msgid "works around umask problems"
msgstr "对umask设置不敏感"

#: build/en/book.xml:10152(entry)
msgid "Scalability"
msgstr "伸缩性"

#: build/en/book.xml:10153(entry)
msgid "Repository disk usage"
msgstr "版本库磁盘使用情况"

#: build/en/book.xml:10154(entry)
msgid "larger (especially if logfiles aren't purged)"
msgstr ""

#: build/en/book.xml:10155(entry)
msgid "smaller"
msgstr "较小"

#: build/en/book.xml:10158(entry)
msgid "Number of revision trees"
msgstr "修订版本树的数量"

#: build/en/book.xml:10159(entry)
msgid "database; no problems"
msgstr "数据库，没有限制"

#: build/en/book.xml:10160(entry)
#, fuzzy
msgid "some older native filesystems don't scale well with thousands of entries in a single directory"
msgstr "许多古老的本地文件系统在处理单一目录包含上千个条目时出现问题。"

#: build/en/book.xml:10164(entry)
msgid "Directories with many files"
msgstr "有很多文件的目录"

#: build/en/book.xml:10165(entry)
msgid "slower"
msgstr "较慢"

#: build/en/book.xml:10166(entry)
msgid "faster"
msgstr "较快"

#: build/en/book.xml:10169(entry)
msgid "Performance"
msgstr "性能"

#: build/en/book.xml:10170(entry)
msgid "Checking out latest revision"
msgstr "检出最新的代码"

#: build/en/book.xml:10171(entry) build/en/book.xml:10172(entry)
msgid "no meaningful difference"
msgstr ""

#: build/en/book.xml:10175(entry)
msgid "Large commits"
msgstr "大的提交"

#: build/en/book.xml:10176(entry)
msgid "slower overall, but cost is amortized across the lifetime of the commit"
msgstr ""

#: build/en/book.xml:10178(entry)
#, fuzzy
msgid "faster overall, but finalization delay may cause client timeouts"
msgstr "较快，但是最后较长的延时可能会导致客户端操作超时"

#: build/en/book.xml:10185(para)
msgid "There are advantages and disadvantages to each of these two back-end types. Neither of them is more <quote>official</quote> than the other, though the newer FSFS is the default data store as of Subversion 1.2. Both are reliable enough to trust with your versioned data. But as you can see in <xref linkend=\"svn.reposadmin.basics.backends.tbl-1\"/>, the FSFS backend provides quite a bit more flexibility in terms of its supported deployment scenarios. More flexibility means you have to work a little harder to find ways to deploy it incorrectly. Those reasons—plus the fact that not using Berkeley DB means there's one fewer component in the system—largely explain why today almost everyone uses the FSFS backend when creating new repositories."
msgstr ""

#: build/en/book.xml:10199(para)
msgid "Fortunately, most programs which access Subversion repositories are blissfully ignorant of which back-end data store is in use. And you aren't even necessarily stuck with your first choice of a data store—in the event that you change your mind later, Subversion provides ways of migrating your repository's data into another repository that uses a different back-end data store. We talk more about that later in this chapter."
msgstr ""

#: build/en/book.xml:10208(para)
msgid "The following subsections provide a more detailed look at the available data store types."
msgstr ""

#: build/en/book.xml:10215(para)
msgid "When the initial design phase of Subversion was in progress, the developers decided to use Berkeley DB for a variety of reasons, including its open-source license, transaction support, reliability, performance, API simplicity, thread-safety, support for cursors, and so on."
msgstr "在Subversion的初始设计阶段，开发者因为多种原因而决定采用Berkeley DB，比如它的开源协议、事务支持、可靠性、性能、简单的API、线程安全、支持游标等。"

#: build/en/book.xml:10222(para)
msgid "Berkeley DB provides real transaction support—perhaps its most powerful feature. Multiple processes accessing your Subversion repositories don't have to worry about accidentally clobbering each other's data. The isolation provided by the transaction system is such that for any given operation, the Subversion repository code sees a static view of the database—not a database that is constantly changing at the hand of some other process—and can make decisions based on that view. If the decision made happens to conflict with what another process is doing, the entire operation is rolled back as if it never happened, and Subversion gracefully retries the operation against a new, updated (and yet still static) view of the database."
msgstr "Berkeley DB提供了真正的事务支持－这或许是它最强大的特性，访问你的Subversion版本库的多个进程不必担心偶尔会破坏其他进程的数据。事务系统提供的隔离对于任何给定的操作，Subversion版本库代码看到的只是数据库的静态视图－而不是一个在其他进程影响不断变化的数据库－并能够根据该视图作出决定。如果该决定正好同其他进程所做操作冲突，整个操作会回滚，就像什么都没有发生一样，并且Subversion会优雅的再次对更新的静态视图进行操作。"

#: build/en/book.xml:10237(para)
msgid "Another great feature of Berkeley DB is <firstterm>hot backups</firstterm>—the ability to backup the database environment without taking it <quote>offline</quote>. We'll discuss how to backup your repository in <xref linkend=\"svn.reposadmin.maint.backup\"/>, but the benefits of being able to make fully functional copies of your repositories without any downtime should be obvious."
msgstr "Berkeley DB另一个强大的特性是热备份－不必<quote>脱机</quote>就可以备份数据库环境的能力。我们将会在<xref linkend=\"svn.reposadmin.maint.backup\"/>讨论如何备份你的版本库，能够不停止系统对版本库做全面备份的好处是显而易见的。"

#: build/en/book.xml:10244(para)
#, fuzzy
msgid "Berkeley DB is also a very reliable database system when properly used. Subversion uses Berkeley DB's logging facilities, which means that the database first writes to on-disk log files a description of any modifications it is about to make, and then makes the modification itself. This is to ensure that if anything goes wrong, the database system can back up to a previous <firstterm>checkpoint</firstterm>—a location in the log files known not to be corrupt—and replay transactions until the data is restored to a usable state. See <xref linkend=\"svn.reposadmin.maint.diskspace\"/> for more about Berkeley DB log files."
msgstr "Berkeley DB同时是一个可信赖的数据库系统。Subversion利用了Berkeley DB可以记日志的便利，这意味着数据库先在磁盘上写一个日志文件，描述它将要做的修改，然后再做这些修改。这是为了确保如果如果任何地方出了差错，数据库系统能恢复到先前的检查点—一个日志文件认为没有错误的位置，重新开始事务直到数据恢复为一个可用的状态。关于Berkeley DB日志文件的更多信息请查看<xref linkend=\"svn.reposadmin.maint.diskspace\"/>。"

#: build/en/book.xml:10257(para)
#, fuzzy
msgid "But every rose has its thorn, and so we must note some known limitations of Berkeley DB. First, Berkeley DB environments are not portable. You cannot simply copy a Subversion repository that was created on a Unix system onto a Windows system and expect it to work. While much of the Berkeley DB database format is architecture independent, there are other aspects of the environment that are not. Secondly, Subversion uses Berkeley DB in a way that will not operate on Windows 95/98 systems—if you need to house a BDB-backed repository on a Windows machine, stick with Windows 2000 or newer."
msgstr "但是每朵玫瑰都有刺，我们也必须记录一些Berkeley DB已知的缺陷。首先，Berkeley DB环境不是跨平台的。你不能简单的拷贝一个在Unix上创建的Subversion版本库到一个Windows系统并期望它能够正常工作。尽管Berkeley DB数据库的大部分格式是不受架构约束的，但环境还是有一些方面没有独立出来。其次，使用Berkeley DB的Subversion不能在95/98系统上运行—如果你需要将版本库建在一个Windows机器上，请装到Windows2000或WindowsXP上。另外，Berkeley DB版本库不能放在网络共享文件夹中，尽管Berkeley DB承诺如果按照一套特定规范的话，可以在网络共享上正常运行，但实际上已知的共享类型几乎都不满足这套规范。"

#: build/en/book.xml:10272(para)
msgid "Berkeley DB requires that the underlying filesystem implement strict POSIX locking semantics, and more importantly, the ability to map files directly into process memory."
msgstr ""

#: build/en/book.xml:10269(para)
msgid "While Berkeley DB promises to behave correctly on network shares that meet a particular set of specifications, <placeholder-1/> most networked filesystem types and appliances do <emphasis>not</emphasis> actually meet those requirements. And in no case can you allow a BDB-backed repository that resides on a network share to be accessed by multiple clients of that share at once (which quite often is the whole point of having the repository live on a network share in the first place)."
msgstr ""

#: build/en/book.xml:10286(para)
msgid "If you attempt to use Berkeley DB on a non-compliant remote filesystem, the results are unpredictable—you may see mysterious errors right away, or it may be months before you discover that your repository database is subtly corrupted. You should strongly consider using the FSFS data store for repositories that need to live on a network share."
msgstr ""

#: build/en/book.xml:10295(para)
#, fuzzy
msgid "Finally, because Berkeley DB is a library linked directly into Subversion, it's more sensitive to interruptions than a typical relational database system. Most SQL systems, for example, have a dedicated server process that mediates all access to tables. If a program accessing the database crashes for some reason, the database daemon notices the lost connection and cleans up any mess left behind. And because the database daemon is the only process accessing the tables, applications don't need to worry about permission conflicts. These things are not the case with Berkeley DB, however. Subversion (and programs using Subversion libraries) access the database tables directly, which means that a program crash can leave the database in a temporarily inconsistent, inaccessible state. When this happens, an administrator needs to ask Berkeley DB to restore to a checkpoint, which is a bit of an annoyance. Other things can cause a repository to <quote>wedge</quote> besides crashed processes, such as programs conflicting over ownership and permissions on the database files."
msgstr "最后，因为Berkeley DB的库直接链接到了Subversion中，它对于中断比典型的关系型数据库系统更为敏感。大多数SQL系统，举例来说，有一个主服务进程来协调对数据库表的访问。如果一个访问数据库的程序因为某种原因出现问题，数据库守护进程察觉到连接中断会做一些清理。因为数据库守护进程是唯一访问数据库表的进程，应用程序不需要担心访问许可的冲突。但是，这些情况与Berkeley DB不同。Subversion（和使用Subversion库的程序）直接访问数据库的表，这意味着如果有一个程序崩溃，就会使数据库处于一个暂时的不一致、不可访问的状态。当这种情况发生时，管理员需要让Berkeley DB恢复到一个检查点，这的确有点讨厌。除了崩溃的进程，还有一些情况能让版本库出现异常，比如程序在数据库文件的所有权或访问权限上发生冲突。因为Berkeley DB版本库非常快，并且可以扩展，非常适合使用一个单独的服务进程，通过一个用户来访问—比如Apache的<command moreinfo=\"none\">httpd</command>或<command moreinfo=\"none\">svnserve</command>（参见<xref linkend=\"svn.serverconfig\"/>）—而不是多用户通过<literal moreinfo=\"none\">file:///</literal>或<literal moreinfo=\"none\">svn+ssh://</literal>URL的方式多用户访问。如果将Berkeley DB版本库直接用作多用户访问，请先阅读<xref linkend=\"svn.serverconfig.multimethod\"/>。"

#: build/en/book.xml:10316(para)
msgid "Berkeley DB 4.4 brings (to Subversion 1.4 and better) the ability for Subversion to automatically and transparently recover Berkeley DB environments in need of such recovery. When a Subversion process attaches to a repository's Berkeley DB environment, it uses some process accounting mechanisms to detect any unclean disconnections by previous processes, performs any necessary recovery, and then continues on as if nothing happened. This doesn't completely eliminate instances of repository wedging, but it does drastically reduce the amount of human interaction required to recover from them."
msgstr ""

#: build/en/book.xml:10329(para)
msgid "So while a Berkeley DB repository is quite fast and scalable, it's best used by a single server process running as one user—such as Apache's <command moreinfo=\"none\">httpd</command> or <command moreinfo=\"none\">svnserve</command> (see <xref linkend=\"svn.serverconfig\"/>)—rather than accessing it as many different users via <literal moreinfo=\"none\">file://</literal> or <literal moreinfo=\"none\">svn+ssh://</literal> URLs. If using a Berkeley DB repository directly as multiple users, be sure to read <xref linkend=\"svn.serverconfig.multimethod\"/>."
msgstr ""

#: build/en/book.xml:10343(para)
#, fuzzy
msgid "In mid-2004, a second type of repository storage system—one which doesn't use a database at all—came into being. An FSFS repository stores the changes associated with a revision in a single file, and so all of a repository's revisions can be found in a single subdirectory full of numbered files. Transactions are created in separate subdirectories as individual files. When complete, the transaction file is renamed and moved into the revisions directory, thus guaranteeing that commits are atomic. And because a revision file is permanent and unchanging, the repository also can be backed up while <quote>hot</quote>, just like a BDB-backed repository."
msgstr "在2004年中期，另一种版本库存储系统慢慢形成了：一种不需要数据库的存储系统。FSFS版本库在单一文件中存储修订版本树，所以版本库中所有的修订版本都在一个子文件夹中有限的几个文件里。事务在单独的子目录中被创建，创建完成后，一个单独的事务文件被创建并移动到修订版本目录，这保证提交是原子性的。因为一个修订版本文件是持久不可改变的，版本库也可以做到热备份，就象Berkeley DB版本库一样。"

#: build/en/book.xml:10357(para)
#, fuzzy
msgid "The FSFS revision files describe a revision's directory structure, file contents, and deltas against files in other revision trees. Unlike a Berkeley DB database, this storage format is portable across different operating systems and isn't sensitive to CPU architecture. Because there's no journaling or shared-memory files being used, the repository can be safely accessed over a network filesystem and examined in a read-only environment. The lack of database overhead also means that the overall repository size is a bit smaller."
msgstr "修订版本文件格式代表了一个修订版本的目录结构，文件内容，和其它修订版本树中相关信息。不像Berkeley DB数据库，这种存储格式可跨平台并且与CPU架构无关。因为没有日志或用到共享内存的文件，数据库能被网络文件系统安全的访问和在只读环境下检查。缺少数据库花消同时也意味着版本库的总体体积可以稍小一点。"

#: build/en/book.xml:10368(para)
#, fuzzy
msgid "FSFS has different performance characteristics too. When committing a directory with a huge number of files, FSFS is able to more quickly append directory entries. On the other hand, FSFS writes the latest version of a file as a delta against an earlier version, which means that checking out the latest tree is a bit slower than fetching the fulltexts stored in a Berkeley DB HEAD revision. FSFS also has a longer delay when finalizing a commit, which could in extreme cases cause clients to time out while waiting for a response."
msgstr "FSFS也有一种不同的性能特性。当提交大量文件时，FSFS使用O(N)算法来追加条目，而Berkeley DB则用(N^2)算法来重写整个目录。另一方面，FSFS通过写入与上一个版本比较的变化来记录新版本，这也意味着获取最新修订版本时会比Berkeley DB慢一点，提交时FSFS也会有一个更长的延迟，在某些极端情况下会导致客护端在等待回应时超时。"

#: build/en/book.xml:10379(para)
#, fuzzy
msgid "The most important distinction, however, is FSFS's inability to be <quote>wedged</quote> when something goes wrong. If a process using a Berkeley DB database runs into a permissions problem or suddenly crashes, the database can be left in an unusable state until an administrator recovers it. If the same scenarios happen to a process using an FSFS repository, the repository isn't affected at all. At worst, some transaction data is left behind."
msgstr "最重要的区别是当出现错误时FSFS不会楔住的能力。如果使用Berkeley DB的进程发生许可错误或突然崩溃，数据库会一直无法使用，直到管理员恢复。假如在应用FSFS版本库时发生同样的情况，版本库不会受到任何干扰，最坏情况下也就是会留下一些事务数据。"

#: build/en/book.xml:10393(para)
msgid "Oracle bought Sleepycat and its flagship software, Berkeley DB, on Valentine's Day in 2006."
msgstr ""

#: build/en/book.xml:10388(para)
msgid "The only real argument against FSFS is its relative immaturity compared to Berkeley DB. Unlike Berkeley DB, which has years of history, its own dedicated development team and, now, Oracle's mighty name attached to it, <placeholder-1/> FSFS is a much newer bit of engineering. Prior to Subversion 1.4, it was still shaking out some pretty serious data integrity bugs which, while only triggered in very rare cases, nonetheless did occur. That said, FSFS has quickly become the back-end of choice for some of the largest public and private Subversion repositories, and promises a lower barrier to entry for Subversion across the board."
msgstr ""

#: build/en/book.xml:10413(title)
msgid "Creating and Configuring Your Repository"
msgstr "创建和配置你的版本库"

#: build/en/book.xml:10415(para)
msgid "In <xref linkend=\"svn.reposadmin.planning\"/>, we looked at some of the important decisions that should be made before creating and configuring your Subversion repository. Now, we finally get to get our hands dirty! In this section, we'll see how to actually create a Subversion repository and configure it to perform custom actions when special repository events occur."
msgstr ""

#: build/en/book.xml:10425(title)
msgid "Creating the Repository"
msgstr "创建版本库"

#: build/en/book.xml:10427(para)
#, fuzzy
msgid "Subversion repository creation is an incredibly simple task. The <command moreinfo=\"none\">svnadmin</command> utility that comes with Subversion provides a subcommand (<literal moreinfo=\"none\">create</literal>) for doing just that."
msgstr "创建一个 Subversion 版本库出乎寻常的简单。 Subversion 提供的<command moreinfo=\"none\">svnadmin</command> 工具，有一个执行这个功能的子命令。要建立一个新的版本库，只需要运行："

#: build/en/book.xml:10432(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create /path/to/repos\n"
msgstr ""
"\n"
"$ svnadmin create /path/to/repos\n"

#: build/en/book.xml:10436(para)
msgid "This creates a new repository in the directory <filename moreinfo=\"none\">/path/to/repos</filename>, and with the default filesystem data store. Prior to Subversion 1.2, the default was to use Berkeley DB; the default is now FSFS. You can explicitly choose the filesystem type using the <option>--fs-type</option> argument, which accepts as a parameter either <literal moreinfo=\"none\">fsfs</literal> or <literal moreinfo=\"none\">bdb</literal>."
msgstr ""

#: build/en/book.xml:10445(screen)
#, no-wrap
msgid ""
"\n"
"$ # Create an FSFS-backed repository\n"
"$ svnadmin create --fs-type fsfs /path/to/repos\n"
"$\n"
msgstr ""
"\n"
"$ # Create an FSFS-backed repository\n"
"$ svnadmin create --fs-type fsfs /path/to/repos\n"
"$\n"

#: build/en/book.xml:10451(screen)
#, no-wrap
msgid ""
"\n"
"# Create a Berkeley-DB-backed repository\n"
"$ svnadmin create --fs-type bdb /path/to/repos\n"
"$\n"
msgstr ""
"\n"
"# Create a Berkeley-DB-backed repository\n"
"$ svnadmin create --fs-type bdb /path/to/repos\n"
"$\n"

#: build/en/book.xml:10457(para)
#, fuzzy
msgid "After running this simple command, you have a Subversion repository."
msgstr "目前Subversion有已实现了九种钩子："

#: build/en/book.xml:10461(para)
#, fuzzy
msgid "The path argument to <command moreinfo=\"none\">svnadmin</command> is just a regular filesystem path and not a URL like the <command moreinfo=\"none\">svn</command> client program uses when referring to repositories. Both <command moreinfo=\"none\">svnadmin</command> and <command moreinfo=\"none\">svnlook</command> are considered server-side utilities—they are used on the machine where the repository resides to examine or modify aspects of the repository, and are in fact unable to perform tasks across a network. A common mistake made by Subversion newcomers is trying to pass URLs (even <quote>local</quote><literal moreinfo=\"none\">file://</literal> ones) to these two programs."
msgstr "你可能已经注意到了，<command moreinfo=\"none\">svnadmin</command>命令的路径参数只是一个普通的文件系统路径，而不是一个<command moreinfo=\"none\">svn</command>客户端程序访问版本库时使用的URL。<command moreinfo=\"none\">svnadmin</command>和<command moreinfo=\"none\">svnlook</command>都被认为是服务器端工具—它们在版本库所在的机器上使用，用来检查或修改版本库，不能通过网络来执行任务。一个Subversion的新手通常会犯的错误，就是试图将URL（甚至<quote>本地</quote><literal moreinfo=\"none\">file:</literal>路径）传给这两个程序。"

#: build/en/book.xml:10474(para)
#, fuzzy
msgid "Present in the <filename moreinfo=\"none\">db/</filename> subdirectory of your repository is the implementation of the versioned filesystem. Your new repository's versioned filesystem begins life at revision 0, which is defined to consist of nothing but the top-level root (<filename moreinfo=\"none\">/</filename>) directory. Initially, revision 0 also has a single revision property, <literal moreinfo=\"none\">svn:date</literal>, set to the time at which the repository was created."
msgstr "这个命令在目录<filename moreinfo=\"none\">/path/to/repos</filename>创建了一个新的版本库。这个新的版本库会以修订版本版本0开始其生命周期，里面除了最上层的根目录(<filename moreinfo=\"none\">/</filename>)，什么都没有。刚开始，修订版本0有一个修订版本属性<literal moreinfo=\"none\">svn:date</literal>，设置为版本库创建的时间。"

#: build/en/book.xml:10483(para)
msgid "Now that you have a repository, it's time to customize it."
msgstr ""

#: build/en/book.xml:10487(para)
#, fuzzy
msgid "While some parts of a Subversion repository—such as the configuration files and hook scripts—are meant to be examined and modified manually, you shouldn't (and shouldn't need to) tamper with the other parts of the repository <quote>by hand</quote>. The <command moreinfo=\"none\">svnadmin</command> tool should be sufficient for any changes necessary to your repository, or you can look to third-party tools (such as Berkeley DB's tool suite) for tweaking relevant subsections of the repository. Do <emphasis>not</emphasis> attempt manual manipulation of your version control history by poking and prodding around in your repository's data store files!"
msgstr "一般来说，你不需要手动干预版本库。<command moreinfo=\"none\">svnadmin</command>工具应该足以用来处理对版本库的任何修改，或者你也可以使用第三方工具（比如Berkeley DB的工具包）来调整部分版本库。不过还是会有些例外情况，我们会在这里提到。"

#: build/en/book.xml:10505(title)
msgid "Implementing Repository Hooks"
msgstr "实现版本库钩子"

#: build/en/book.xml:10507(para)
msgid "A <firstterm>hook</firstterm> is a program triggered by some repository event, such as the creation of a new revision or the modification of an unversioned property. Some hooks (the so-called <quote>pre hooks</quote>) run in advance of a repository operation and provide a means by which to both report what is about to happen and to prevent it from happening at all. Other hooks (the <quote>post hooks</quote>) run after the completion of a repository event, and are useful for reporting purposes only. Each hook is handed enough information to tell what that event is (or was), the specific repository changes proposed (or completed), and the username of the person who triggered the event."
msgstr ""

#: build/en/book.xml:10520(para)
msgid "The <filename moreinfo=\"none\">hooks</filename> subdirectory is, by default, filled with templates for various repository hooks."
msgstr "默认情况下，钩子的子目录中包含各种版本库钩子模板。"

#: build/en/book.xml:10524(screen)
#, no-wrap
msgid ""
"\n"
"$ ls repos/hooks/\n"
"post-commit.tmpl\t  post-unlock.tmpl  pre-revprop-change.tmpl\n"
"post-lock.tmpl\t\t  pre-commit.tmpl   pre-unlock.tmpl\n"
"post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl\n"
msgstr ""
"\n"
"$ ls repos/hooks/\n"
"post-commit.tmpl\t  post-unlock.tmpl  pre-revprop-change.tmpl\n"
"post-lock.tmpl\t\t  pre-commit.tmpl   pre-unlock.tmpl\n"
"post-revprop-change.tmpl  pre-lock.tmpl     start-commit.tmpl\n"

#: build/en/book.xml:10531(para)
#, fuzzy
msgid "There is one template for each hook that the Subversion repository supports, and by examining the contents of those template scripts, you can see what triggers each script to run and what data is passed to that script. Also present in many of these templates are examples of how one might use that script, in conjunction with other Subversion-supplied programs, to perform common useful tasks. To actually install a working hook, you need only place some executable program or script into the <filename moreinfo=\"none\">repos/hooks</filename> directory which can be executed as the name (like <command moreinfo=\"none\">start-commit</command> or <command moreinfo=\"none\">post-commit</command>) of the hook."
msgstr "对每种Subversion版本库支持的钩子的都有一个模板，通过查看这些脚本的内容，你能看到是什么事件触发了脚本及如何给传脚本传递数据。同时，这些模版也是如何使用这些脚本，结合Subversion支持的工具来完成有用任务的例子。要实际安装一个可用的钩子，你需要在<filename moreinfo=\"none\">repos/hooks</filename>目录下安装一些与钩子同名（如 <command moreinfo=\"none\">start-commit</command>或者<command moreinfo=\"none\">post-commit</command>）的可执行程序或脚本。"

#: build/en/book.xml:10544(para)
msgid "On Unix platforms, this means supplying a script or program (which could be a shell script, a Python program, a compiled C binary, or any number of other things) named exactly like the name of the hook. Of course, the template files are present for more than just informational purposes—the easiest way to install a hook on Unix platforms is to simply copy the appropriate template file to a new file that lacks the <literal moreinfo=\"none\">.tmpl</literal> extension, customize the hook's contents, and ensure that the script is executable. Windows, however, uses file extensions to determine whether or not a program is executable, so you would need to supply a program whose basename is the name of the hook, and whose extension is one of the special extensions recognized by Windows for executable programs, such as <filename moreinfo=\"none\">.exe</filename> or <filename moreinfo=\"none\">.com</filename> for programs, and <filename moreinfo=\"none\">.bat</filename> for batch files."
msgstr "在Unix平台上，这意味着要提供一个与钩子同名的脚本或程序（可能是shell 脚本，Python 程序，编译过的c语言二进制文件或其他东西）。当然，脚本模板文件不仅仅是展示了一些信息—在Unix下安装钩子最简单的办法就是拷贝这些模板，并且去掉.tmpl扩展名，然后自定义钩子的内容，确定脚本是可运行的。Windows用文件的扩展名来决定一个程序是否可运行，所以你要使程序的基本名与钩子同名，同时，它的扩展名是Windows系统所能辨认的，例如<filename moreinfo=\"none\">exe</filename>、<filename moreinfo=\"none\">com</filename>和批处理的<filename moreinfo=\"none\">bat</filename>。"

#: build/en/book.xml:10563(para)
#, fuzzy
msgid "For security reasons, the Subversion repository executes hook programs with an empty environment—that is, no environment variables are set at all, not even <literal moreinfo=\"none\">$PATH</literal> (or <literal moreinfo=\"none\">%PATH%</literal>, under Windows). Because of this, many administrators are baffled when their hook program runs fine by hand, but doesn't work when run by Subversion. Be sure to explicitly set any necessary environment variables in your hook program and/or use absolute paths to programs."
msgstr "由于安全原因，Subversion版本库在一个空环境中执行钩子脚本—就是没有任何环境变量，甚至没有<literal moreinfo=\"none\">$PATH</literal>或<literal moreinfo=\"none\">%PATH%</literal>。由于这个原因，许多管理员会感到很困惑，它们的钩子脚本手工运行时正常，可在Subversion中却不能运行。要注意，必须在你的钩子中设置好环境变量或为你的程序指定好绝对路径。"

#: build/en/book.xml:10574(para)
#, fuzzy
msgid "Subversion will attempt to execute hooks as the same user who owns the process which is accessing the Subversion repository. In most cases, the repository is being accessed via a Subversion server, so this user is the same user as which that server runs on the system. The hooks themselves will need to be configured with OS-level permissions that allow that user to execute them. Also, this means that any file or programs (including the Subversion repository itself) accessed directly or indirectly by the hook will be accessed as the same user. In other words, be alert to potential permission-related problems that could prevent the hook from performing the tasks it is designed to perform."
msgstr "Subversion会试图以当前访问版本库的用户身份执行钩子。通常，对版本库的访问总是通过Apache HTTP服务器和mod_dav_svn进行，因此，执行钩子的用户就是运行Apache的用户。钩子本身需要具有操作系统级的访问许可，用户可以运行它。另外，其它被钩子直接或间接使用的文件或程序（包括Subversion版本库本身）也要被同一个用户访问。换句话说，要注意潜在的访问控制问题，它可能会让你的钩子无法按照你的目的顺利执行。"

#: build/en/book.xml:10587(para)
msgid "There are nine hooks implemented by the Subversion repository, and you can get details about each of them in <xref linkend=\"svn.ref.reposhooks\"/>. As a repository administrator, you'll need to decide which of hooks you wish to implement (by way of providing an appropriately named and permissioned hook program), and how. This decision needs to be made with the bigger picture of how repository is deployed in mind. For example, if you are using server configuration stuffs to determine which usernames are permitted to commit changes to your repository, then you don't need to do this sort of access control via the hook system."
msgstr ""

#: build/en/book.xml:10599(para)
msgid "There is no shortage of Subversion hook programs and scripts freely available either from the Subversion community itself or elsewhere. These scripts cover a wide range of utility—basic access control, policy adherence checking, issue tracker integration, email- or syndication-based commit notification, and beyond. See <xref linkend=\"svn.3rdparty\"/> for discussion of some of the most commonly used hook programs. Or, if you wish to write your own, see <xref linkend=\"svn.developer\"/>."
msgstr ""

#: build/en/book.xml:10609(para)
msgid "While hook scripts can be leveraged to do almost anything, there is one dimension in which hook script authors should show restraint: do <emphasis>not</emphasis> modify a commit transaction using hook scripts. While it might be tempting to use hook scripts to automatically correct errors or shortcomings or policy violations present in the files being committed, doing so can cause problems. Subversion keeps client-side caches of certain bits of repository data, and if you change a commit transaction in this way, those caches become indetectably stale. This inconsistency can lead to surprising and unexpected behavior. Instead of modifying the transaction, you should simply <emphasis>validate</emphasis> the transaction in the <filename moreinfo=\"none\">pre-commit</filename> hook and reject the commit if it does not meet the desired requirements. As an added bonus, your users will learn the value of careful, compliance-minded work habits."
msgstr ""

#: build/en/book.xml:10632(title)
msgid "Berkeley DB Configuration"
msgstr "Berkeley DB 配置"

#: build/en/book.xml:10634(para)
#, fuzzy
msgid "A Berkeley DB environment is an encapsulation of one or more databases, log files, region files and configuration files. The Berkeley DB environment has its own set of default configuration values for things like the number of database locks allowed to be taken out at any given time, or the maximum size of the journaling log files, etc. Subversion's filesystem logic additionally chooses default values for some of the Berkeley DB configuration options. However, sometimes your particular repository, with its unique collection of data and access patterns, might require a different set of configuration option values."
msgstr "Berkeley DB环境是对一个或多个数据库、日志文件、区域文件和配置文件的封装。Berkeley DB环境对许多参数有自己的缺省值，例如任何时间里可用的数据库锁定数目、日志文件的最大值等。Subversion文件系统会使用Berkeley DB的默认值。 不过，有时候你的特定版本库与它独特的数据集合和访问类型，可能需要不同的配置选项。"

#: build/en/book.xml:10646(para)
#, fuzzy
msgid "The producers of Berkeley DB understand that different applications and database environments have different requirements, and so they have provided a mechanism for overriding at runtime many of the configuration values for the Berkeley DB environment. Berkeley checks for the presence of a file named <filename moreinfo=\"none\">DB_CONFIG</filename> in the environment directory, and parses the options found in that file for use with that particular Berkeley DB environment."
msgstr "Sleepycat（Berkeley DB的制造厂商）的人们清楚不同的数据库有不同的需求，所以他们提供了在运行中覆盖Berkeley DB环境配置参数的机制。Berkeley在每一个环境目录中检查是否存在一个名叫<filename moreinfo=\"none\">DB_CONFIG</filename>的文件，然后解析其中的参数成为Berkeley环境所用的选项。"

#: build/en/book.xml:10655(para)
#, fuzzy
msgid "The Berkeley DB configuration file for a BDB-backed repository is located in the repository's <filename moreinfo=\"none\">db</filename> subdirectory, at <filename moreinfo=\"none\">db/DB_CONFIG</filename>. Subversion itself creates this file when it creates the rest of the repository. The file initially contains some default options, as well as pointers to the Berkeley DB online documentation so you can read about what those options do. Of course, you are free to add any of the supported Berkeley DB options to your <filename moreinfo=\"none\">DB_CONFIG</filename> file. Just be aware that while Subversion never attempts to read or interpret the contents of the file, and makes no direct use of the option settings in it, you'll want to avoid any configuration changes that may cause Berkeley DB to behave in a fashion that is at odds with what Subversion might expect. Also, changes made to <filename moreinfo=\"none\">DB_CONFIG</filename> won't take effect until you recover the database environment (using <command moreinfo=\"none\">svnadmin recover</command>)."
msgstr "你的版本库的Berkeley配置文件位于<filename moreinfo=\"none\">db</filename>目录的<filename moreinfo=\"none\">repos/db/DB_CONFIG</filename>， Subversion在创建版本库时自己创建了这个文件。这个文件初始时包含了一些默认选项，也包含了Berkeley DB在线文档，使你能够了解这些选项是做什么的。当然，你也可以为你的<filename moreinfo=\"none\">DB_CONFIG</filename> 文件添加任何Berkeley DB支持的选项。需要注意到，虽然Subversion不会尝试读取并解析这个文件，或使用其中的设置，你一定要避免会导致Berkeley DB按照Subversion代码不习惯的方式工作的修改。另外，<filename moreinfo=\"none\">DB_CONFIG</filename>的修改在复原数据库环境（用<command moreinfo=\"none\">svnadmin recover</command>）之前不会产生任何效果。"

#: build/en/book.xml:10682(title)
msgid "Repository Maintenance"
msgstr "版本库维护"

#: build/en/book.xml:10684(para)
#, fuzzy
msgid "Maintaining a Subversion repository can be a daunting task, mostly due to the complexities inherent in systems which have a database backend. Doing the task well is all about knowing the tools—what they are, when to use them, and how to use them. This section will introduce you to the repository administration tools provided by Subversion, and how to wield them to accomplish tasks such as repository data migration, upgrades, backups and cleanups."
msgstr "维护一个Subversion版本库是一项令人沮丧的工作，主要因为有数据库后端与生俱来的复杂性。做好这项工作需要知道一些工具——它们是什么，什么时候用以及如何使用。这一节将会向你介绍Subversion自带的版本库管理工具，以及如何使用它们来完成诸如版本库移植、升级、备份和整理之类的任务。"

#: build/en/book.xml:10695(title)
msgid "An Administrator's Toolkit"
msgstr "管理员的工具箱"

#: build/en/book.xml:10697(para)
msgid "Subversion provides a handful of utilities useful for creating, inspecting, modifying and repairing your repository. Let's look more closely at each of those tools. Afterward, we'll briefly examine some of the utilities included in the Berkeley DB distribution that provide functionality specific to your repository's database backend not otherwise provided by Subversion's own tools."
msgstr "Subversion提供了一些用来创建、查看、修改和修复版本库的工具。让我们首先详细了解一下每个工具，然后，我们再看一下仅在Berkeley DB后端分发版本中提供的版本数据库工具。"

#: build/en/book.xml:10709(para)
#, fuzzy
msgid "The <command moreinfo=\"none\">svnadmin</command> program is the repository administrator's best friend. Besides providing the ability to create Subversion repositories, this program allows you to perform several maintenance operations on those repositories. The syntax of <command moreinfo=\"none\">svnadmin</command> is similar to that of other Subversion command-line programs:"
msgstr "<command moreinfo=\"none\">svnadmin</command>程序是版本库管理员最好的朋友。除了提供创建Subversion版本库的功能，这个程序使你可以维护这些版本库。<command moreinfo=\"none\">svnadmin</command>的语法跟<command moreinfo=\"none\">svnlook</command>类似："

#: build/en/book.xml:10717(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin help\n"
"general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnadmin --version' to see the program version and FS modules.\n"
"\n"
"Available subcommands:\n"
"   crashtest\n"
"   create\n"
"   deltify\n"
"…\n"
msgstr ""
"\n"
"$ svnadmin help\n"
"general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnadmin help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnadmin --version' to see the program version and FS modules.\n"
"\n"
"Available subcommands:\n"
"   crashtest\n"
"   create\n"
"   deltify\n"
"…\n"

#: build/en/book.xml:10730(para)
#, fuzzy
msgid "We've already mentioned <command moreinfo=\"none\">svnadmin</command>'s <literal moreinfo=\"none\">create</literal> subcommand (see <xref linkend=\"svn.reposadmin.basics.creating\"/>). Most of the others we will cover as they become topically relevant later in this chapter. And you can consult <xref linkend=\"svn.ref.svnadmin\"/> for a full rundown of subcommands and what each of them offers."
msgstr "我们已经提过<command moreinfo=\"none\">svnadmin</command>的<literal moreinfo=\"none\">create</literal>子命令（参照<xref linkend=\"svn.reposadmin.create\"/>）。本章中我们会详细讲解大多数其他的命令。现在，我们来简单的看一下每个可用的子命令提供了什么功能。"

#: build/en/book.xml:10742(para)
#, fuzzy
msgid "<command moreinfo=\"none\">svnlook</command> is a tool provided by Subversion for examining the various revisions and transactions in a repository. No part of this program attempts to change the repository. <command moreinfo=\"none\">svnlook</command> is typically used by the repository hooks for reporting the changes that are about to be committed (in the case of the <command moreinfo=\"none\">pre-commit</command> hook) or that were just committed (in the case of the <command moreinfo=\"none\">post-commit</command> hook) to the repository. A repository administrator may use this tool for diagnostic purposes."
msgstr "<command moreinfo=\"none\">svnlook</command>是Subversion提供的用来查看版本库中不同的修订版本和事务。这个程序不会修改版本库内容－这是个<quote>只读</quote>的工具。<command moreinfo=\"none\">svnlook</command>通常用在版本库钩子程序中，用来记录版本库即将提交（<command moreinfo=\"none\">用在pre-commit钩子时）</command>或者已经提交的（用在<command moreinfo=\"none\">post-commit</command>钩子时）修改。版本库管理员可以将这个工具用于诊断。"

#: build/en/book.xml:10753(para)
msgid "<command moreinfo=\"none\">svnlook</command> has a straightforward syntax:"
msgstr "<command moreinfo=\"none\">svnlook</command> 的语法很直接："

#: build/en/book.xml:10756(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook help\n"
"general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]\n"
"Note: any subcommand which takes the '--revision' and '--transaction'\n"
"      options will, if invoked without one of those options, act on\n"
"      the repository's youngest revision.\n"
"Type 'svnlook help &lt;subcommand$gt;' for help on a specific subcommand.\n"
"Type 'svnlook --version' to see the program version and FS modules.\n"
"…\n"
msgstr ""
"\n"
"$ svnlook help\n"
"general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]\n"
"Note: any subcommand which takes the '--revision' and '--transaction'\n"
"      options will, if invoked without one of those options, act on\n"
"      the repository's youngest revision.\n"
"Type 'svnlook help &lt;subcommand$gt;' for help on a specific subcommand.\n"
"Type 'svnlook --version' to see the program version and FS modules.\n"
"…\n"

#: build/en/book.xml:10767(para)
#, fuzzy
msgid "Nearly every one of <command moreinfo=\"none\">svnlook</command>'s subcommands can operate on either a revision or a transaction tree, printing information about the tree itself, or how it differs from the previous revision of the repository. You use the <option>--revision (-r)</option> and <option>--transaction (-t)</option> options to specify which revision or transaction, respectively, to examine. In the absence of both the <option>--revision (-r)</option> and <option>--transaction (-t)</option> options, <command moreinfo=\"none\">svnlook</command> will examine the youngest (or <quote>HEAD</quote>) revision in the repository. So the following two commands do exactly the same thing when 19 is the youngest revision in the repository located at <filename moreinfo=\"none\">/path/to/repos</filename>:"
msgstr "几乎<command moreinfo=\"none\">svnlook</command>的每一个子命令都能操作修订版本或事务树，显示树本身的信息，或是它与版本库中上一个修订版本的不同。你可以用<option>--revision</option> 和 <option>--transaction</option>选项指定要查看的修订版本或事务。注意，虽然修订版本号看起来像自然数，但是事务名称是包含英文字母与数字的字符串。请记住文件系统只允许浏览未提交的事务（还没有形成一个新的修订版本的事务）。多数版本库没有这种事务，因为事务通常或者被提交了（这样便不能被查看），或者被中止并删除了。"

#: build/en/book.xml:10782(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook info /path/to/repos\n"
"$ svnlook info /path/to/repos -r 19\n"
msgstr ""
"\n"
"$ svnlook info /path/to/repos\n"
"$ svnlook info /path/to/repos -r 19\n"

#: build/en/book.xml:10787(para)
#, fuzzy
msgid "The only exception to these rules about subcommands is the <command moreinfo=\"none\">svnlook youngest</command> subcommand, which takes no options, and simply prints out the repository's youngest revision number."
msgstr "这些子命令的唯一例外，是<command moreinfo=\"none\">svnlook youngest</command>命令，它不需要选项，只会显示出<literal moreinfo=\"none\">HEAD</literal>的修订版本号。"

#: build/en/book.xml:10792(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook youngest /path/to/repos\n"
"19\n"
msgstr ""
"\n"
"$ svnlook youngest /path/to/repos\n"
"19\n"

#: build/en/book.xml:10798(para)
msgid "Keep in mind that the only transactions you can browse are uncommitted ones. Most repositories will have no such transactions, because transactions are usually either committed (in which case, you should access them as revision with the <option>--revision (-r)</option> option) or aborted and removed."
msgstr ""

#: build/en/book.xml:10806(para)
msgid "Output from <command moreinfo=\"none\">svnlook</command> is designed to be both human- and machine-parsable. Take as an example the output of the <literal moreinfo=\"none\">info</literal> subcommand:"
msgstr "<command moreinfo=\"none\">svnlook</command>的输出被设计为人和机器都易理解，拿<literal moreinfo=\"none\">info</literal>子命令举例来说："

#: build/en/book.xml:10810(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook info /path/to/repos\n"
"sally\n"
"2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)\n"
"27\n"
"Added the usual\n"
"Greek tree.\n"
msgstr ""
"\n"
"$ svnlook info /path/to/repos\n"
"sally\n"
"2002-11-04 09:29:13 -0600 (Mon， 04 Nov 2002)\n"
"27\n"
"Added the usual\n"
"Greek tree.\n"

#: build/en/book.xml:10819(para)
msgid "The output of the <literal moreinfo=\"none\">info</literal> subcommand is defined as:"
msgstr "<literal moreinfo=\"none\">info</literal>子命令的输出定义如下："

#: build/en/book.xml:10824(para)
msgid "The author, followed by a newline."
msgstr "作者，后接换行。"

#: build/en/book.xml:10827(para)
msgid "The date, followed by a newline."
msgstr "日期，后接换行。"

#: build/en/book.xml:10830(para)
msgid "The number of characters in the log message, followed by a newline."
msgstr "日志消息的字数，后接换行。"

#: build/en/book.xml:10834(para)
msgid "The log message itself, followed by a newline."
msgstr "日志信息本身， 后接换行。"

#: build/en/book.xml:10838(para)
#, fuzzy
msgid "This output is human-readable, meaning items like the datestamp are displayed using a textual representation instead of something more obscure (such as the number of nanoseconds since the Tasty Freeze guy drove by). But the output is also machine-parsable—because the log message can contain multiple lines and be unbounded in length, <command moreinfo=\"none\">svnlook</command> provides the length of that message before the message itself. This allows scripts and other wrappers around this command to make intelligent decisions about the log message, such as how much memory to allocate for the message, or at least how many bytes to skip in the event that this output is not the last bit of data in the stream."
msgstr "这种输出是人可阅读的，像是时间戳这种有意义的条目，使用文本表示，而不是其他比较晦涩的方式（例如许多无聊的人推荐的十亿分之一秒的数量）。这种输出也是机器可读的—因为日志信息可以有多行，没有长度的限制，<command moreinfo=\"none\">svnlook</command>在日志消息之前提供了消息的长度，这使得脚本或者其他对这个命令进行的封装提供了更强的功能，比如日志消息使用了多少内存，或在这个输出成为最后一个字节之前应该略过多少字节。"

#: build/en/book.xml:10852(para)
#, fuzzy
msgid "<command moreinfo=\"none\">svnlook</command> can perform a variety of other queries: displaying subsets of bits of information we've mentioned previously, recursively listing versioned directory trees, reporting which paths were modified in a given revision or transaction, showing textual and property differences made to files and directories, and so on. See <xref linkend=\"svn.ref.svnlook\"/> for a full reference of <command moreinfo=\"none\">svnlook</command>'s features."
msgstr "<command moreinfo=\"none\">svnlook</command>还可以做很多别的查询，显示我们先前提到的信息的一些子集，报告指定的修订版本或事务中哪些路径曾经被修改过，显示对文件和目录做过的文本和属性的修改，等等。下面是<command moreinfo=\"none\">svnlook</command>命令能接受的子命令的介绍，以及这些子命令的输出："

#: build/en/book.xml:10867(para)
#, fuzzy
msgid "While it won't be the most commonly used tool at the administrator's disposal, <command moreinfo=\"none\">svndumpfilter</command> provides a very particular brand of useful functionality—the ability to quickly and easily modify streams of Subversion repository history data by acting as a path-based filter."
msgstr "虽然在管理员的日常工作中并不会经常使用，不过<command moreinfo=\"none\">svndumpfilter</command>可以对特定的路径进行过滤。这是一个独特而很有意义的用法，可以帮助你快速方便的修改转储的数据。使用时，只需提供一个你想要保留的（或者不想保留的）路径列表，然后把你的版本库转储文件送进这个过滤器。最后你就可以得到一个仅包含你想保留的路径的转储数据流。"

#: build/en/book.xml:10874(para)
msgid "The syntax of <command moreinfo=\"none\">svndumpfilter</command> is as follows:"
msgstr "<command moreinfo=\"none\">svndumpfilter</command>的语法如下："

#: build/en/book.xml:10877(screen)
#, no-wrap
msgid ""
"\n"
"$ svndumpfilter help\n"
"general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]\n"
"Type \"svndumpfilter help &lt;subcommand&gt;\" for help on a specific subcommand.\n"
"Type 'svndumpfilter --version' to see the program version.\n"
"  \n"
"Available subcommands:\n"
"   exclude\n"
"   include\n"
"   help (?, h)\n"
msgstr ""
"\n"
"$ svndumpfilter help\n"
"general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]\n"
"Type \"svndumpfilter help &lt;subcommand&gt;\" for help on a specific subcommand.\n"
"Type 'svndumpfilter --version' to see the program version.\n"
"  \n"
"Available subcommands:\n"
"   exclude\n"
"   include\n"
"   help (?, h)\n"

#: build/en/book.xml:10889(para)
msgid "There are only two interesting subcommands. They allow you to make the choice between explicit or implicit inclusion of paths in the stream:"
msgstr "有意义的子命令只有两个。你可以使用这两个子命令说明你希望保留和不希望保留的路径："

#: build/en/book.xml:10895(literal)
msgid "exclude"
msgstr "exclude"

#: build/en/book.xml:10897(para)
msgid "Filter out a set of paths from the dump data stream."
msgstr "将指定路径的数据从转储数据流中排除。"

#: build/en/book.xml:10903(literal)
msgid "include"
msgstr "include"

#: build/en/book.xml:10905(para)
msgid "Allow only the requested set of paths to pass through the dump data stream."
msgstr "将指定路径的数据添加到转储数据流中。"

#: build/en/book.xml:10911(para)
#, fuzzy
msgid "You can learn more about these subcommands and <command moreinfo=\"none\">svndumpfilter</command>'s unique purpose in <xref linkend=\"svn.reposadmin.maint.filtering\"/>."
msgstr "关于<command moreinfo=\"none\">svn update</command>的详细讨论，见<xref linkend=\"svn.tour.cycle.update\"/>。"

#: build/en/book.xml:10930(para)
msgid "Or is that, the <quote>sync</quote>?"
msgstr "或者是, <quote>sync</quote> ？"

#: build/en/book.xml:10920(para)
msgid "The <command moreinfo=\"none\">svnsync</command> program, which is new to the 1.4 release of Subversion, provides all the functionality required for maintaining a read-only mirror of a Subversion repository. The program really has one job—to transfer one repository's versioned history into another repository. And while there are few ways to do that, its primary strength is that it can operate remotely—the <quote>source</quote> and <quote>sink</quote><placeholder-1/> repositories may be on different computers from each other and from <command moreinfo=\"none\">svnsync</command> itself."
msgstr ""

#: build/en/book.xml:10935(para)
msgid "As you might expect, <command moreinfo=\"none\">svnsync</command> has a syntax that looks very much like every other program we've mentioned in this chapter:"
msgstr ""

#: build/en/book.xml:10939(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help\n"
"general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnsync --version' to see the program version and RA modules.\n"
"\n"
"Available subcommands:\n"
"   initialize (init)\n"
"   synchronize (sync)\n"
"   copy-revprops\n"
"   help (?, h)\n"
"$\n"
msgstr ""
"\n"
"$ svnsync help\n"
"general usage: svnsync SUBCOMMAND DEST_URL  [ARGS &amp; OPTIONS ...]\n"
"Type 'svnsync help &lt;subcommand&gt;' for help on a specific subcommand.\n"
"Type 'svnsync --version' to see the program version and RA modules.\n"
"\n"
"Available subcommands:\n"
"   initialize (init)\n"
"   synchronize (sync)\n"
"   copy-revprops\n"
"   help (?, h)\n"
"$\n"

#: build/en/book.xml:10953(para)
#, fuzzy
msgid "We talk more about replication repositories with <command moreinfo=\"none\">svnsync</command> in <xref linkend=\"svn.reposadmin.maint.replication\"/>."
msgstr "关于<command moreinfo=\"none\">svn status</command>的详细讨论，见<xref linkend=\"svn.tour.cycle.examine.status\"/>。"

#: build/en/book.xml:10960(title)
msgid "Berkeley DB Utilities"
msgstr "Berkeley DB 工具"

#: build/en/book.xml:10962(para)
#, fuzzy
msgid "If you're using a Berkeley DB repository, then all of your versioned filesystem's structure and data live in a set of database tables within the <filename moreinfo=\"none\">db/</filename> subdirectory of your repository. This subdirectory is a regular Berkeley DB environment directory, and can therefore be used in conjunction with any of the Berkeley database tools, typically provided as part of the Berkeley DB distribution."
msgstr "如果你使用Berkeley DB版本库，那么所有纳入版本控制的文件系统结构和数据都储存在一系列数据库的表中，而这个位于版本库的<filename moreinfo=\"none\">db</filename>子目录下。这个子目录是一个标准的Berkeley DB环境目录，可以应用任何Berkeley数据库工具进行操作（参考SleepyCat网站<ulink url=\"http://www.sleepycat.com/\"/>上关于这些工具的介绍）。"

#: build/en/book.xml:10971(para)
msgid "For day-to-day Subversion use, these tools are unnecessary. Most of the functionality typically needed for Subversion repositories has been duplicated in the <command moreinfo=\"none\">svnadmin</command> tool. For example, <command moreinfo=\"none\">svnadmin list-unused-dblogs</command> and <command moreinfo=\"none\">svnadmin list-dblogs</command> perform a subset of what is provided by the Berkeley <command moreinfo=\"none\">db_archive</command> command, and <command moreinfo=\"none\">svnadmin recover</command> reflects the common use cases of the <command moreinfo=\"none\">db_recover</command> utility."
msgstr "对于Subversion的日常使用来说，这些工具并没有什么用处。大多数Subversion版本库必须的数据库操作都集成到<command moreinfo=\"none\">svnadmin</command>工具中。比如，<command moreinfo=\"none\">svnadmin list-unused-dblogs</command>和<command moreinfo=\"none\">svnadmin list-dblogs</command>实现了Berkeley <command moreinfo=\"none\">db_archive</command>命令功能的一个子集，而<command moreinfo=\"none\">svnadmin recover</command>则起到了 <command moreinfo=\"none\">db_recover</command>工具的作用。"

#: build/en/book.xml:10982(para)
msgid "There are still a few Berkeley DB utilities that you might find useful. The <command moreinfo=\"none\">db_dump</command> and <command moreinfo=\"none\">db_load</command> programs write and read, respectively, a custom file format which describes the keys and values in a Berkeley DB database. Since Berkeley databases are not portable across machine architectures, this format is a useful way to transfer those databases from machine to machine, irrespective of architecture or operating system. Also, the <command moreinfo=\"none\">db_stat</command> utility can provide useful information about the status of your Berkeley DB environment, including detailed statistics about the locking and storage subsystems."
msgstr "当然，还有一些Berkeley DB工具有时是有用的。<command moreinfo=\"none\">db_dump</command>将Berkeley DB数据库中的键值对以特定的格式写入文件中，而<command moreinfo=\"none\">db_load</command>则可以将这些键值对注入到数据库中。Berkeley数据库本身不支持跨平台转移，这两个工具在这样的情况下就可以实现在平台间转移数据库的功能，而无需关心操作系统或机器架构。此外，<command moreinfo=\"none\">db_stat</command>工具能够提供关于Berkeley DB环境的许多有用信息，包括详细的锁定和存储子系统的统计信息。"

#: build/en/book.xml:10995(para)
msgid "For more information on the Berkeley DB tool chain, visit the documentation section of the Berkeley DB section of Oracle's website, located at <ulink url=\"http://www.oracle.com/technology/documentation/berkeley-db/db/\"/>."
msgstr ""

#: build/en/book.xml:11004(title)
msgid "Commit Log Message Correction"
msgstr "修正提交消息"

#: build/en/book.xml:11006(para)
msgid "Sometimes a user will have an error in her log message (a misspelling or some misinformation, perhaps). If the repository is configured (using the <literal moreinfo=\"none\">pre-revprop-change</literal> and <literal moreinfo=\"none\">post-revprop-change</literal> hooks; see <xref linkend=\"svn.reposadmin.create.hooks\"/>) to accept changes to this log message after the commit is finished, then the user can <quote>fix</quote> her log message remotely using the <command moreinfo=\"none\">svn</command> program's <literal moreinfo=\"none\">propset</literal> command (see <xref linkend=\"svn.ref\"/>). However, because of the potential to lose information forever, Subversion repositories are not, by default, configured to allow changes to unversioned properties—except by an administrator."
msgstr "有时用户输入的日志信息有错误（比如拼写错误或者内容错误）。如果配置版本库时设置了（使用<literal moreinfo=\"none\">pre-revprop-change</literal>和 <literal moreinfo=\"none\">post-revprop-change</literal>钩子；参见<xref linkend=\"svn.reposadmin.create.hooks\"/>）允许用户在提交后修改日志信息的选项，那么用户可以使用<command moreinfo=\"none\">svn</command>程序的<literal moreinfo=\"none\">propset</literal>命令（参见<xref linkend=\"svn.ref\"/>）<quote>修正</quote>日志信息中的错误。不过为了避免永远丢失信息，Subversion版本库通常设置为仅能由管理员修改非版本化属性（这也是默认的选项）。"

#: build/en/book.xml:11019(para)
msgid "If a log message needs to be changed by an administrator, this can be done using <command moreinfo=\"none\">svnadmin setlog</command>. This command changes the log message (the <literal moreinfo=\"none\">svn:log</literal> property) on a given revision of a repository, reading the new value from a provided file."
msgstr "如果管理员想要修改日志信息，那么可以使用<command moreinfo=\"none\">svnadmin setlog</command>命令。这个命令从指定的文件中读取信息，取代版本库中某个修订版本的日志信息（<literal moreinfo=\"none\">svn:log</literal>属性）。"

#: build/en/book.xml:11025(screen)
#, no-wrap
msgid ""
"\n"
"$ echo \"Here is the new, correct log message\" &gt; newlog.txt\n"
"$ svnadmin setlog myrepos newlog.txt -r 388\n"
msgstr ""
"\n"
"$ echo \"Here is the new， correct log message\" &gt; newlog.txt\n"
"$ svnadmin setlog myrepos newlog.txt -r 388\n"

#: build/en/book.xml:11030(para)
msgid "The <command moreinfo=\"none\">svnadmin setlog</command> command alone is still bound by the same protections against modifying unversioned properties as a remote client is—the <literal moreinfo=\"none\">pre-</literal> and <literal moreinfo=\"none\">post-revprop-change</literal> hooks are still triggered, and therefore must be setup to accept changes of this nature. But an administrator can get around these protections by passing the <option>--bypass-hooks</option> option to the <command moreinfo=\"none\">svnadmin setlog</command> command."
msgstr "即使是<command moreinfo=\"none\">svnadmin setlog</command>命令也受到限制。<literal moreinfo=\"none\">pre-</literal>和 <literal moreinfo=\"none\">post-revprop-change</literal>钩子同样会被触发，因此必须进行相应的设置才能允许修改非版本化属性。不过管理员可以使用<command moreinfo=\"none\">svnadmin setlog</command>命令的<option>--bypass-hooks</option>选项跳过钩子。"

#: build/en/book.xml:11041(para)
msgid "Remember, though, that by bypassing the hooks, you are likely avoiding such things as email notifications of property changes, backup systems which track unversioned property changes, and so on. In other words, be very careful about what you are changing, and how you change it."
msgstr "不过需要注意的是，一旦跳过钩子也就跳过了钩子所提供的所有功能，比如邮件通知（通知属性有改动）、系统备份（可以用来跟踪非版本化的属性变更）等等。换句话说，要留心你所作出的修改，以及你作出修改的方式。"

#: build/en/book.xml:11054(title)
msgid "Managing Disk Space"
msgstr "管理磁盘空间"

#: build/en/book.xml:11056(para)
#, fuzzy
msgid "While the cost of storage has dropped incredibly in the past few years, disk usage is still a valid concern for administrators seeking to version large amounts of data. Every bit of version history information stored in the live repository is information that needs to be backed up elsewhere, perhaps multiple times as part of rotating backup schedules. It is useful to know what pieces of Subversion's repository data need to remain on the live site, which need to be backed up, and which can be safely removed."
msgstr "虽然存储器的价格在过去的几年里以让人难以致信的速度滑落，但是对于那些需要对大量数据进行版本管理的管理员们来说，磁盘空间的消耗依然是一个重要的因素。版本库每增加一个字节都意味着需要多一个字节的磁盘空间进行备份，对于多重备份来说，就需要消耗更多的磁盘空间。Berkeley DB版本库的主要存储机制是基于一个复杂的数据库系统建立的，因此了解一些数据性质是有意义的，比如哪些数据必须保留。哪些数据需要备份、哪些数据可以安全的删除等等。本节的内容专注于Berkeley DB类型的版本库。FSFS类型的版本库不需要进行数据清理和回收。"

#: build/en/book.xml:11068(title)
msgid "How Subversion saves disk space"
msgstr "Subversion 如何节约磁盘空间"

#: build/en/book.xml:11070(para)
#, fuzzy
msgid "To keep the size of the repository as small as possible, Subversion uses <firstterm>deltification</firstterm> (or, <quote>deltified storage</quote>) within the repository itself. Deltification involves encoding the representation of a chunk of data as a collection of differences against some other chunk of data. If the two pieces of data are very similar, this deltification results in storage savings for the deltified chunk—rather than taking up space equal to the size of the original data, it takes up only enough space to say, <quote>I look just like this other piece of data over here, except for the following couple of changes</quote>. The result is that most of the repository data that tends to be sizable—namely, the contents of versioned files—is stored at a much smaller size than the original <quote>fulltext</quote> representation of that data. And for repositories created with Subversion 1.4 or later, the space saving get even better—now those fulltext representations of file contents are themselves compressed."
msgstr "为了尽可能减小版本库的体积，Subversion在版本库中采用了<firstterm>增量化技术</firstterm>（或称为<quote>增量存储技术</quote>）。增量化技术可以将一组数据表示为相对于另一组数据的不同。如果这两组数据十分相似，增量化技术就可以仅保存其中一组数据以及两组数据的差别，而不需要同时保存两组数据，从而节省了磁盘空间。每次一个文件的新版本提交到版本库，版本库就会将之前的版本（之前的多个版本）相对于新版本做增量化处理。采用了这项技术，版本库的数据量大小基本上是可以估算出来的—主要是版本化的文件的大小—并且远小于<quote>全文</quote>保存所需的数据量。"

#: build/en/book.xml:11091(para)
#, fuzzy
msgid "Because all of the data that is subject to deltification in a BDB-backed repository is stored in a single Berkeley DB database file, reducing the size of the stored values will not immediately reduce the size of the database file itself. Berkeley DB will, however, keep internal records of unused areas of the database file, and consume those areas first before growing the size of the database file. So while deltification doesn't produce immediate space savings, it can drastically slow future growth of the database."
msgstr "由于Subversion版本库的增量化数据保存在单一Berkeley DB数据库文件中，减少数据的体积并不一定能够减小数据库文件的大小。但是，Berkeley DB会在内部记录未使用的数据库文件区域，并且在增加数据库文件大小之前会首先使用这些未使用的区域。因此，即使增量化技术不能立杆见影的节省磁盘空间，也可以极大的减慢数据库的膨胀速度。"

#: build/en/book.xml:11107(title)
msgid "Removing dead transactions"
msgstr "删除终止的事务"

#: build/en/book.xml:11109(para)
#, fuzzy
msgid "Though they are uncommon, there are circumstances in which a Subversion commit process might fail, leaving behind in the repository the remnants of the revision-to-be that wasn't—an uncommitted transaction and all the file and directory changes associated with it. This could happen for several reasons: perhaps the client operation was inelegantly terminated by the user, or a network failure might have occurred in the middle of an operation, etc. Regardless of the reason, dead transactions can happen. They don't do any real harm, other than consuming disk space. A fastidious administrator may nonetheless wish to remove them."
msgstr "<command moreinfo=\"none\">svnadmin</command>的另一个常见用途是查询异常的—可能是已经死亡的—Subversion事务。通常提交操作失败时，与之相关的事务就会被清除。也就是说，事务本身及所有与该事务相关（且仅与该事务相关）的数据会从版本库中删除。不过偶尔也会出现操作失败而事务没有被清除的情况。出现这种情况可能有以下原因：客户端的用户粗暴的结束了操作，操作过程中出现网络故障，等等。不管是什么原因，死亡的事务总是有可能会出现。这类事务不会产生什么负面影响，仅仅是消耗了一点点磁盘空间。不过，严厉的管理员总是希望能够将它们清除出去。"

#: build/en/book.xml:11122(para)
msgid "You can use <command moreinfo=\"none\">svnadmin</command>'s <literal moreinfo=\"none\">lstxns</literal> command to list the names of the currently outstanding transactions."
msgstr "可以使用<command moreinfo=\"none\">svnadmin</command>的<literal moreinfo=\"none\">lstxns</literal> 命令列出当前的异常事务名。"

#: build/en/book.xml:11126(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin lstxns myrepos\n"
"19\n"
"3a1\n"
"a45\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin lstxns myrepos\n"
"19\n"
"3a1\n"
"a45\n"
"$\n"

#: build/en/book.xml:11134(para)
#, fuzzy
msgid "Each item in the resultant output can then be used with <command moreinfo=\"none\">svnlook</command> (and its <option>--transaction (-t)</option> option) to determine who created the transaction, when it was created, what types of changes were made in the transaction—information that is helpful in determining whether or not the transaction is a safe candidate for removal! If so, the transaction's name can be passed to <command moreinfo=\"none\">svnadmin rmtxns</command>, which will perform the cleanup of the transaction. In fact, the <literal moreinfo=\"none\">rmtxns</literal> subcommand can take its input directly from the output of <literal moreinfo=\"none\">lstxns</literal>!"
msgstr "将输出的结果条目作为<command moreinfo=\"none\">svnlook</command>（设置<option>--transaction</option>选项）的参数，就可以获得事务的详细信息，如事务的创建者、创建时间，事务已作出的更改类型，由这些信息可以判断出是否可以将这个事务安全的删除。如果可以安全删除，那么只需将事务名作为参数输入到<command moreinfo=\"none\">svnadmin rmtxns</command>，就可以将事务清除掉了。其实<literal moreinfo=\"none\">rmtxns</literal>子命令可以直接以<literal moreinfo=\"none\">lstxns</literal>的输出作为输入进行清理。"

#: build/en/book.xml:11147(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`\n"
"$\n"

#: build/en/book.xml:11152(para)
#, fuzzy
msgid "If you use these two subcommands like this, you should consider making your repository temporarily inaccessible to clients. That way, no one can begin a legitimate transaction before you start your cleanup. <xref linkend=\"svn.reposadmin.maint.diskspace.deadtxns.ex-1\"/> contains a bit of shell-scripting that can quickly generate information about each outstanding transaction in your repository."
msgstr "在按照上面例子中的方法清理版本库之前，你或许应该暂时关闭版本库和客户端的连接。这样在你开始清理之前，不会有正常的事务进入版本库。下面例子中的shell脚本可以用来迅速获得版本库中异常事务的信息："

#: build/en/book.xml:11161(title)
msgid "txn-info.sh (Reporting Outstanding Transactions)"
msgstr "txn-info.sh（报告异常事务）"

#: build/en/book.xml:11163(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh\n"
"\n"
"### Generate informational output for all outstanding transactions in\n"
"### a Subversion repository.\n"
"\n"
"REPOS=\"${1}\"\n"
"if [ \"x$REPOS\" = x ] ; then\n"
"  echo \"usage: $0 REPOS_PATH\"\n"
"  exit\n"
"fi\n"
"\n"
"for TXN in `svnadmin lstxns ${REPOS}`; do \n"
"  echo \"---[ Transaction ${TXN} ]-------------------------------------------\"\n"
"  svnlook info \"${REPOS}\" -t \"${TXN}\"\n"
"done\n"
msgstr ""
"\n"
"#!/bin/sh\n"
"\n"
"### Generate informational output for all outstanding transactions in\n"
"### a Subversion repository.\n"
"\n"
"REPOS=\"${1}\"\n"
"if [ \"x$REPOS\" = x ] ; then\n"
"  echo \"usage: $0 REPOS_PATH\"\n"
"  exit\n"
"fi\n"
"\n"
"for TXN in `svnadmin lstxns ${REPOS}`; do \n"
"  echo \"---[ Transaction ${TXN} ]-------------------------------------------\"\n"
"  svnlook info \"${REPOS}\" -t \"${TXN}\"\n"
"done\n"

#: build/en/book.xml:11182(para)
#, fuzzy
msgid "The output of the script is basically a concatenation of several chunks of <command moreinfo=\"none\">svnlook info</command> output (see <xref linkend=\"svn.reposadmin.maint.tk.svnlook\"/>), and will look something like:"
msgstr "可以用下面的命令使用上例中脚本： <command moreinfo=\"none\">/path/to/txn-info.sh /path/to/repos</command>。该命令的输出主要由多个<command moreinfo=\"none\">svnlook info</command>参见<xref linkend=\"svn.reposadmin.maint.tk.svnlook\"/>）的输出组成，类似于下面的例子："

#: build/en/book.xml:11187(screen)
#, no-wrap
msgid ""
"\n"
"$ txn-info.sh myrepos\n"
"---[ Transaction 19 ]-------------------------------------------\n"
"sally\n"
"2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)\n"
"0\n"
"---[ Transaction 3a1 ]-------------------------------------------\n"
"harry\n"
"2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)\n"
"39\n"
"Trying to commit over a faulty network.\n"
"---[ Transaction a45 ]-------------------------------------------\n"
"sally\n"
"2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)\n"
"0\n"
"$\n"
msgstr ""
"\n"
"$ txn-info.sh myrepos\n"
"---[ Transaction 19 ]-------------------------------------------\n"
"sally\n"
"2001-09-04 11:57:19 -0500 (Tue， 04 Sep 2001)\n"
"0\n"
"---[ Transaction 3a1 ]-------------------------------------------\n"
"harry\n"
"2001-09-10 16:50:30 -0500 (Mon， 10 Sep 2001)\n"
"39\n"
"Trying to commit over a faulty network.\n"
"---[ Transaction a45 ]-------------------------------------------\n"
"sally\n"
"2001-09-12 11:09:28 -0500 (Wed， 12 Sep 2001)\n"
"0\n"
"$\n"

#: build/en/book.xml:11205(para)
msgid "A long-abandoned transaction usually represents some sort of failed or interrupted commit. A transaction's datestamp can provide interesting information—for example, how likely is it that an operation begun nine months ago is still active?"
msgstr "一个废弃了很长时间的事务通常是提交错误或异常中断的结果。事务的时间戳可以提供给我们一些有趣的信息，比如一个进行了9个月的操作居然还是活动的等等。"

#: build/en/book.xml:11211(para)
#, fuzzy
msgid "In short, transaction cleanup decisions need not be made unwisely. Various sources of information—including Apache's error and access logs, Subversion's operational logs, Subversion revision history, and so on—can be employed in the decision-making process. And of course, an administrator can often simply communicate with a seemingly dead transaction's owner (via email, for example) to verify that the transaction is, in fact, in a zombie state."
msgstr "简言之，作出事务清理的决定前应该仔细考虑一下。许多信息源—比如Apache的错误和访问日志，已成功完成的Subversion提交日志等等—都可以作为决策的参考。管理员还可以直接和那些似乎已经死亡事务的提交者直接交流（比如通过邮件），来确认该事务确实已经死亡了。"

#: build/en/book.xml:11224(title)
msgid "Purging unused Berkeley DB logfiles"
msgstr "删除不使用的 Berkeley DB 日志文件"

#: build/en/book.xml:11226(para)
#, fuzzy
msgid "Until recently, the largest offender of disk space usage with respect to BDB-backed Subversion repositories was the log files in which Berkeley DB performs its pre-writes before modifying the actual database files. These files capture all the actions taken along the route of changing the database from one state to another—while the database files reflect at any given time some state, the log files contain all the many changes along the way between states. As such, they can grow and accumulate quite rapidly."
msgstr "目前为止，Subversion版本库中耗费磁盘空间的最大凶手是日志文件，每次Berkeley DB在修改真正的数据文件之前都会进行预写入（pre-writes）操作。这些文件记录了数据库从一个状态变化到另一个状态的所有动作——数据库文件反应了特定时刻数据库的状态，而日志文件则记录了所有状态变化的信息。因此，日志文件会以很快的速度膨胀起来。"

#: build/en/book.xml:11237(para)
msgid "Fortunately, beginning with the 4.2 release of Berkeley DB, the database environment has the ability to remove its own unused log files without any external procedures. Any repositories created using an <command moreinfo=\"none\">svnadmin</command> which is compiled against Berkeley DB version 4.2 or greater will be configured for this automatic log file removal. If you don't want this feature enabled, simply pass the <option>--bdb-log-keep</option> option to the <command moreinfo=\"none\">svnadmin create</command> command. If you forget to do this, or change your mind at a later time, simple edit the <filename moreinfo=\"none\">DB_CONFIG</filename> file found in your repository's <filename moreinfo=\"none\">db</filename> directory, comment out the line which contains the <literal moreinfo=\"none\">set_flags DB_LOG_AUTOREMOVE</literal> directive, and then run <command moreinfo=\"none\">svnadmin recover</command> on your repository to force the configuration changes to take effect. See <xref linkend=\"svn.reposadmin.create.bdb\"/> for more information about database configuration."
msgstr "幸运的是，从版本4.2开始，Berkeley DB的数据库环境无需额外的操作即可删除无用的日志文件。如果编译<command moreinfo=\"none\">svnadmin</command>时使用了高于4.2版本的Berkeley DB，那么由此<command moreinfo=\"none\">svnadmin</command>程序创建的版本库就具备了自动清除日志文件的功能。如果想屏蔽这个功能，只需设置<command moreinfo=\"none\">svnadmin create</command>命令的<option>--bdb-log-keep</option>选项即可。如果创建版本库以后想要修改关于此功能的设置，只需编辑版本库中<filename moreinfo=\"none\">db</filename>目录下的<filename moreinfo=\"none\">DB_CONFIG</filename>文件，注释掉包含<literal moreinfo=\"none\">set_flags DB_LOG_AUTOREMOVE</literal>内容的这一行，然后运行<command moreinfo=\"none\">svnadmin recover</command>强制设置生效就行了。查阅<xref linkend=\"svn.reposadmin.create.bdb\"/>获得更多关于数据库配置的帮助信息。"

#: build/en/book.xml:11255(para)
msgid "Without some sort of automatic log file removal in place, log files will accumulate as you use your repository. This is actually somewhat of a feature of the database system—you should be able to recreate your entire database using nothing but the log files, so these files can be useful for catastrophic database recovery. But typically, you'll want to archive the log files that are no longer in use by Berkeley DB, and then remove them from disk to conserve space. Use the <command moreinfo=\"none\">svnadmin list-unused-dblogs</command> command to list the unused log files:"
msgstr "如果不自动删除日志文件，那么日志文件会随着版本库的使用逐渐增加。这多少应该算是数据库系统的特性，通过这些日志文件可以在数据库严重损坏时恢复整个数据库的内容。但是一般情况下，最好是能够将无用的日志文件收集起来并删除，这样就可以节省磁盘空间。使用<command moreinfo=\"none\">svnadmin list-unused-dblogs</command>命令可以列出无用的日志文件："

#: build/en/book.xml:11267(screen) build/en/book.xml:22459(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos\n"
"/path/to/repos/log.0000000031\n"
"/path/to/repos/log.0000000032\n"
"/path/to/repos/log.0000000033\n"
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos | xargs rm\n"
"## disk space reclaimed!\n"
msgstr ""
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos\n"
"/path/to/repos/log.0000000031\n"
"/path/to/repos/log.0000000032\n"
"/path/to/repos/log.0000000033\n"
"\n"
"$ svnadmin list-unused-dblogs /path/to/repos | xargs rm\n"
"## disk space reclaimed!\n"

#: build/en/book.xml:11278(para)
msgid "BDB-backed repositories whose log files are used as part of a backup or disaster recovery plan should <emphasis>not</emphasis> make use of the log file autoremoval feature. Reconstruction of a repository's data from log files can only be accomplished when the log files are all available. If some of the log files are removed from disk before the backup system has a chance to copy them elsewhere, the incomplete set of backed-up log files is essentially useless."
msgstr ""

#: build/en/book.xml:11295(title)
msgid "Berkeley DB Recovery"
msgstr "Berkeley DB 恢复"

#: build/en/book.xml:11297(para)
msgid "As mentioned in <xref linkend=\"svn.reposadmin.basics.backends.bdb\"/>, a Berkeley DB repository can sometimes be left in frozen state if not closed properly. When this happens, an administrator needs to rewind the database back into a consistent state. This is unique to BDB-backed repositories, though—if you are using FSFS-backed ones instead, this won't apply to you. And for those of you using Subversion 1.4 with Berkeley DB 4.4 or better, you should find that Subversion has become much more resilient in these types of situations. Still, wedged Berkeley DB repositories do occur, and an administrator needs to know how to safely deal with this circumstance."
msgstr ""

#: build/en/book.xml:11309(para)
#, fuzzy
msgid "In order to protect the data in your repository, Berkeley DB uses a locking mechanism. This mechanism ensures that portions of the database are not simultaneously modified by multiple database accessors, and that each process sees the data in the correct state when that data is being read from the database. When a process needs to change something in the database, it first checks for the existence of a lock on the target data. If the data is not locked, the process locks the data, makes the change it wants to make, and then unlocks the data. Other processes are forced to wait until that lock is removed before they are permitted to continue accessing that section of the database. (This has nothing to do with the locks that you, as a user, can apply to versioned files within the repository; we try to clear up the confusion caused by this terminology collision in <xref linkend=\"svn.advanced.locking.meanings\"/>.)"
msgstr "Berkeley DB使用一种锁机制保护版本库中的数据。锁机制确保数据库不会同时被多个访问进程修改，也就保证了从数据库中读取到的数据始终是稳定而且正确的。当一个进程需要修改数据库中的数据时，首先必须检查目标数据是否已经上锁。如果目标数据没有上锁，进程就将它锁上，然后作出修改，最后再将锁解除。而其它进程则必须等待锁解除后才能继续访问数据库中的相关内容。"

#: build/en/book.xml:11325(para)
#, fuzzy
msgid "In the course of using your Subversion repository, fatal errors or interruptions can prevent a process from having the chance to remove the locks it has placed in the database. The result is that the back-end database system gets <quote>wedged</quote>. When this happens, any attempts to access the repository hang indefinitely (since each new accessor is waiting for a lock to go away—which isn't going to happen)."
msgstr "在操作Subversion版本库的过程中，致命错误（如内存或硬盘空间不足）或异常中断可能会导致某个进程没能及时将锁解除。结果就是后端的数据库系统被<quote>塞住</quote>了。一旦发生这种情况，任何访问版本库的进程都会挂起（每个访问进程都在等待锁被解除，但是锁已经无法解除了）。"

#: build/en/book.xml:11339(para)
msgid "E.g.: hard drive + huge electromagnet = disaster."
msgstr "比如：硬盘 + 大号电磁铁 = 毁灭。"

#: build/en/book.xml:11334(para)
#, fuzzy
msgid "If this happens to your repository, don't panic. The Berkeley DB filesystem takes advantage of database transactions and checkpoints and pre-write journaling to ensure that only the most catastrophic of events <placeholder-1/> can permanently destroy a database environment. A sufficiently paranoid repository administrator will have made off-site backups of the repository data in some fashion, but don't head off to the tape backup storage closet just yet."
msgstr "首先，如果你的版本库出现这种情况，没什么好惊慌的。Berkeley DB的文件系统采用了数据库事务、检查点以及预写入日志等技术来取保只有灾难性的事件<footnote><placeholder-1/></footnote>才能永久性的破坏数据库环境。所以虽然一个过于稳重的版本库管理员通常都会按照某种方案进行大量的版本库离线备份，不过不要急着通知你的管理员进行恢复。"

#: build/en/book.xml:11346(para)
#, fuzzy
msgid "Instead, use the following recipe to attempt to <quote>unwedge</quote> your repository:"
msgstr "然后，使用下面的方法试着<quote>恢复</quote>你的版本库："

#: build/en/book.xml:11351(para)
#, fuzzy
msgid "Make sure that there are no processes accessing (or attempting to access) the repository. For networked repositories, this means shutting down the Apache HTTP Server or svnserve daemon, too."
msgstr "确保没有其它进程访问（或者试图访问）版本库。对于网络版本库，关闭Apache HTTP服务器是个好办法。"

#: build/en/book.xml:11357(para)
msgid "Become the user who owns and manages the repository. This is important, as recovering a repository while running as the wrong user can tweak the permissions of the repository's files in such a way that your repository will still be inaccessible even after it is <quote>unwedged</quote>."
msgstr "成为版本库的拥有者和管理员。这一点很重要，如果以其它用户的身份恢复版本库，可能会改变版本库文件的访问权限，导致在版本库<quote>恢复</quote>后依旧无法访问。"

#: build/en/book.xml:11365(para)
msgid "Run the command <command moreinfo=\"none\">svnadmin recover /path/to/repos</command>. You should see output like this:"
msgstr "运行命令<command moreinfo=\"none\">svnadmin recover /path/to/repos</command>。 输出如下："

#: build/en/book.xml:11369(screen)
#, no-wrap
msgid ""
"\n"
"Repository lock acquired.\n"
"Please wait; recovering the repository may take some time...\n"
"\n"
"Recovery completed.\n"
"The latest repos revision is 19.\n"
msgstr ""
"\n"
"Repository lock acquired。\n"
"Please wait; recovering the repository may take some time...\n"
"\n"
"Recovery completed.\n"
"The latest repos revision is 19.\n"

#: build/en/book.xml:11376(para)
msgid "This command may take many minutes to complete."
msgstr "此命令可能需要数分钟才能完成。"

#: build/en/book.xml:11379(para)
msgid "Restart the server process."
msgstr "重新启动服务进程。"

#: build/en/book.xml:11383(para)
msgid "This procedure fixes almost every case of repository lock-up. Make sure that you run this command as the user that owns and manages the database, not just as <literal moreinfo=\"none\">root</literal>. Part of the recovery process might involve recreating from scratch various database files (shared memory regions, for example). Recovering as <literal moreinfo=\"none\">root</literal> will create those files such that they are owned by <literal moreinfo=\"none\">root</literal>, which means that even after you restore connectivity to your repository, regular users will be unable to access it."
msgstr "这个方法能修复几乎所有版本库锁住的问题。记住，要以数据库的拥有者和管理员的身份运行这个命令，而不一定是<literal moreinfo=\"none\">root</literal>用户。恢复过程中可能会使用其它数据存储区（例如共享内存区）重建一些数据库文件。如果以<literal moreinfo=\"none\">root</literal>用户身份恢复版本库，这些重建的文件拥有者将变成<literal moreinfo=\"none\">root</literal>用户，也就是说，即使恢复了到版本库的连接，一般的用户也无权访问这些文件。"

#: build/en/book.xml:11394(para)
msgid "If the previous procedure, for some reason, does not successfully unwedge your repository, you should do two things. First, move your broken repository out of the way and restore your latest backup of it. Then, send an email to the Subversion user list (at <email>users@subversion.tigris.org</email>) describing your problem in detail. Data integrity is an extremely high priority to the Subversion developers."
msgstr "如果因为某些原因，上面的方法没能成功的恢复版本库，那么你可以做两件事。首先，将破损的版本库保存到其它地方，然后从最新的备份中恢复版本库。然后，发送一封邮件到Subversion用户列表（地址是：<email>users@subversion.tigris.org</email>），写清你所遇到的问题。对于Subversion的开发者来说，数据安全是最重要的问题。"

#: build/en/book.xml:11407(title)
msgid "Migrating Repository Data Elsewhere"
msgstr "版本库数据的移植"

#: build/en/book.xml:11409(para)
#, fuzzy
msgid "A Subversion filesystem has its data spread throughout various back-end data store files in a fashion generally understood by (and of interest to) only the Subversion developers themselves. However, circumstances may arise that call for all, or some subset, of that data to be copied or moved into another repository."
msgstr "Subversion文件系统将数据保存在许多数据库表中，而这些表的结构只有Subversion开发者们才了解（也只有他们才感兴趣）不过，有些时候我们会想到把所有的数据（或者一部分数据）保存在一个独立的、可移植的、普通格式的文件中。Subversion通过<command moreinfo=\"none\">svnadmin</command>的两个子命令<literal moreinfo=\"none\">dump</literal>和<literal moreinfo=\"none\">load</literal>提供了类似的功能。"

#: build/en/book.xml:11416(para)
msgid "Subversion provides such functionality by way of repository dump streams. A repository dump stream (often referred to as a <quote>dumpfile</quote> when stored as a file on disk) is a portable, flat file format that describes the various revisions in your repository—what was changed, by whom, when, and so on. This dump stream is the primary mechanism used to marshal versioned history—in whole or in part, with or without modification—between repositories. And Subversion provides the tools necessary for creating and loading these dump streams—the <command moreinfo=\"none\">svnadmin dump</command> and <command moreinfo=\"none\">svnadmin load</command> subcommands, respectively."
msgstr ""

#: build/en/book.xml:11430(para)
msgid "While the Subversion repository dump format contains human-readable portions and a familiar structure (it resembles an RFC-822 format, the same type of format used for most email), it is <emphasis>not</emphasis> a plaintext file format. The format should be treated as a binary file format, highly sensitive to meddling. Many text editor tools will corrupt the file's contents, often due to automatic line ending character conversion."
msgstr ""

#: build/en/book.xml:11440(para)
msgid "There are many reasons for dumping and loading Subversion repository data. Early in Subversion's life, the most common reason was due to the evolution of Subversion itself. As Subversion matured, there were times when changes made to the back-end database schema caused compatibility issues with previous versions of the repository, so users had to dump their repository data using the previous version of Subversion, and load it into a freshly created repository with the new version of Subversion. Now, these types of schema changes haven't occurred since Subversion's 1.0 release, and the Subversion developers promise not to force users to dump and load their repositories when upgrading between minor versions (such as from 1.3 to 1.4) of Subversion. But there are still other reasons for dumping and loading, including re-deploying a Berkeley DB repository on a new OS or CPU architecture, switching between the Berkeley DB and FSFS back-ends, or (as we'll cover in <xref linkend=\"svn.reposadmin.maint.filtering\"/> purging versioned data from repository history."
msgstr ""

#: build/en/book.xml:11459(para)
#, fuzzy
msgid "Whatever your reason for migration repository history, using the <command moreinfo=\"none\">svnadmin dump</command> and <command moreinfo=\"none\">svnadmin load</command> subcommands is straightforward. <command moreinfo=\"none\">svnadmin dump</command> will output a range of repository revisions that are formatted using Subversion's custom filesystem dump format. The dump format is printed to the standard output stream, while informative messages are printed to the standard error stream. This allows you to redirect the output stream to a file while watching the status output in your terminal window. For example:"
msgstr "<command moreinfo=\"none\">svnadmin dump</command>命令会将版本库中的修订版本数据按照特定的格式输出到转储流中。转储数据会输出到标准输出流，而提示信息会输出到标准错误流。这就是说，可以将转储数据存储到文件中，而同时在终端窗口中监视运行状态。例如："

#: build/en/book.xml:11471(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook youngest myrepos\n"
"26\n"
"$ svnadmin dump myrepos &gt; dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"…\n"
"* Dumped revision 25.\n"
"* Dumped revision 26.\n"
msgstr ""
"\n"
"$ svnlook youngest myrepos\n"
"26\n"
"$ svnadmin dump myrepos &gt; dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"…\n"
"* Dumped revision 25.\n"
"* Dumped revision 26.\n"

#: build/en/book.xml:11483(para)
msgid "At the end of the process, you will have a single file (<filename moreinfo=\"none\">dumpfile</filename> in the previous example) that contains all the data stored in your repository in the requested range of revisions. Note that <command moreinfo=\"none\">svnadmin dump</command> is reading revision trees from the repository just like any other <quote>reader</quote> process would (<command moreinfo=\"none\">svn checkout</command>, for example). So it's safe to run this command at any time."
msgstr "最后，版本库中的指定的修订版本数据被转储到一个独立的文件中（在上面的例子中是<filename moreinfo=\"none\">dumpfile</filename>）。注意，<command moreinfo=\"none\">svnadmin dump</command>从版本库中读取修订版本树与其它<quote>读者</quote>（比如<command moreinfo=\"none\">svn checkout</command>）的过程相同，所以可以在任何时候安全的运行这个命令。"

#: build/en/book.xml:11492(para)
msgid "The other subcommand in the pair, <command moreinfo=\"none\">svnadmin load</command>, parses the standard input stream as a Subversion repository dump file, and effectively replays those dumped revisions into the target repository for that operation. It also gives informative feedback, this time using the standard output stream:"
msgstr "另一个命令，<command moreinfo=\"none\">svnadmin load</command>，从标准输入流中读取Subversion转储数据，并且高效的将数据转载到目标版本库中。这个命令的提示信息输出到标准输出流中："

#: build/en/book.xml:11499(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile\n"
"&lt;&lt;&lt; Started new txn, based on original revision 1\n"
"     * adding path : A ... done.\n"
"     * adding path : A/B ... done.\n"
"     …\n"
"------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 2\n"
"     * editing path : A/mu ... done.\n"
"     * editing path : A/D/G/rho ... done.\n"
"\n"
"------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;\n"
"\n"
"…\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 25\n"
"     * editing path : A/D/gamma ... done.\n"
"\n"
"------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 26\n"
"     * adding path : A/Z/zeta ... done.\n"
"     * editing path : A/mu ... done.\n"
"\n"
"------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;\n"
"\n"
msgstr ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile\n"
"&lt;&lt;&lt; Started new txn, based on original revision 1\n"
"     * adding path : A ... done.\n"
"     * adding path : A/B ... done.\n"
"     …\n"
"------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 2\n"
"     * editing path : A/mu ... done.\n"
"     * editing path : A/D/G/rho ... done.\n"
"\n"
"------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;\n"
"\n"
"…\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 25\n"
"     * editing path : A/D/gamma ... done.\n"
"\n"
"------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;\n"
"\n"
"&lt;&lt;&lt; Started new txn, based on original revision 26\n"
"     * adding path : A/Z/zeta ... done.\n"
"     * editing path : A/mu ... done.\n"
"\n"
"------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;\n"
"\n"

#: build/en/book.xml:11528(para)
#, fuzzy
msgid "The result of a load is new revisions added to a repository—the same thing you get by making commits against that repository from a regular Subversion client. And just as in a commit, you can use hook programs to perform actions before and after each of the commits made during a load process. By passing the <option>--use-pre-commit-hook</option> and <option>--use-post-commit-hook</option> options to <command moreinfo=\"none\">svnadmin load</command>, you can instruct Subversion to execute the pre-commit and post-commit hook programs, respectively, for each loaded revision. You might use these, for example, to ensure that loaded revisions pass through the same validation steps that regular commits pass through. Of course, you should use these options with care—if your post-commit hook sends emails to a mailing list for each new commit, you might not want to spew hundreds or thousands of commit emails in rapid succession at that list for each of the loaded revisions! You can read more about the use of hook scripts in <xref linkend=\"svn.reposadmin.create.hooks\"/>."
msgstr "load命令的结果就是添加一些新的修订版本—与使用普通Subversion客户端直接提交到版本库相同。正像一次简单的提交，你也可以使用钩子脚本在每次load的开始和结束执行一些操作。通过传递<option>--use-pre-commit-hook</option>和<option>--use-post-commit-hook</option>选项给<command moreinfo=\"none\">svnadmin load</command>，你可以告诉Subversion的对每一个加载修订版本执行pre-commit和post-commit钩子脚本，可以利用这个选项确保这种提交也能通过一般提交的检验。当然，你要小心使用这个选项，你一定不像接受一大堆提交邮件。你可以查看<xref linkend=\"svn.reposadmin.create.hooks\"/>来得到更多相关信息。"

#: build/en/book.xml:11548(para)
msgid "Note that because <command moreinfo=\"none\">svnadmin</command> uses standard input and output streams for the repository dump and load process, people who are feeling especially saucy can try things like this (perhaps even using different versions of <command moreinfo=\"none\">svnadmin</command> on each side of the pipe):"
msgstr "既然<command moreinfo=\"none\">svnadmin</command>使用标准输入流和标准输出流作为转储和装载的输入和输出，那么更漂亮的用法是（管道两端可以是不同版本的<command moreinfo=\"none\">svnadmin</command>："

#: build/en/book.xml:11554(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create newrepos\n"
"$ svnadmin dump myrepos | svnadmin load newrepos\n"
msgstr ""
"\n"
"$ svnadmin create newrepos\n"
"$ svnadmin dump myrepos | svnadmin load newrepos\n"

#: build/en/book.xml:11559(para)
#, fuzzy
msgid "By default, the dump file will be quite large—much larger than the repository itself. That's because by default every version of every file is expressed as a full text in the dump file. This is the fastest and simplest behavior, and nice if you're piping the dump data directly into some other process (such as a compression program, filtering program, or into a loading process). But if you're creating a dump file for longer-term storage, you'll likely want to save disk space by using the <option>--deltas</option> switch. With this option, successive revisions of files will be output as compressed, binary differences—just as file revisions are stored in a repository. This option is slower, but results in a dump file much closer in size to the original repository."
msgstr "默认情况下，转储文件的体积可能会相当庞大——比版本库自身大很多。这是因为在转储文件中，每个文件的每个版本都以完整的文本形式保存下来。这种方法速度很快，而且很简单，尤其是直接将转储数据通过管道输入到其它进程中时（比如一个压缩程序，过滤程序，或者一个装载进程）。不过如果要长期保存转储文件，那么可以使用<option>--deltas</option>选项来节省磁盘空间。设置这个选项，同一个文件的数个连续修订版本会以增量式的方式保存—就像储存在版本库中一样。这个方法较慢，但是转储文件的体积则基本上与版本库的体积相当。"

#: build/en/book.xml:11574(para)
#, fuzzy
msgid "We mentioned previously that <command moreinfo=\"none\">svnadmin dump</command> outputs a range of revisions. Use the <option>--revision (-r)</option> option to specify a single revision to dump, or a range of revisions. If you omit this option, all the existing repository revisions will be dumped."
msgstr "之前我们提到<command moreinfo=\"none\">svnadmin dump</command>输出指定的修订版本。使用<option>--revision</option>选项可以指定一个单独的修订版本，或者一个修订版本的范围。如果忽略这个选项，所有版本库中的修订版本都会被转储。"

#: build/en/book.xml:11581(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile\n"
"$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile\n"
msgstr ""
"\n"
"$ svnadmin dump myrepos -r 23 &gt; rev-23.dumpfile\n"
"$ svnadmin dump myrepos -r 100:200 &gt; revs-100-200.dumpfile\n"

#: build/en/book.xml:11586(para)
msgid "As Subversion dumps each new revision, it outputs only enough information to allow a future loader to re-create that revision based on the previous one. In other words, for any given revision in the dump file, only the items that were changed in that revision will appear in the dump. The only exception to this rule is the first revision that is dumped with the current <command moreinfo=\"none\">svnadmin dump</command> command."
msgstr "Subversion在转储修订版本时，仅会输出与前一个修订版本之间的差异，通过这些差异足以从前一个修订版本中重建当前的修订版本。换句话说，在转储文件中的每一个修订版本仅包含这个修订版本作出的修改。这个规则的唯一一个例外是当前<command moreinfo=\"none\">svnadmin dump</command>转储的第一个修订版本。"

#: build/en/book.xml:11595(para)
msgid "By default, Subversion will not express the first dumped revision as merely differences to be applied to the previous revision. For one thing, there is no previous revision in the dump file! And secondly, Subversion cannot know the state of the repository into which the dump data will be loaded (if it ever, in fact, occurs). To ensure that the output of each execution of <command moreinfo=\"none\">svnadmin dump</command> is self-sufficient, the first dumped revision is by default a full representation of every directory, file, and property in that revision of the repository."
msgstr "默认情况下，Subversion不会把转储的第一个修订版本看作对前一个修订版本的更改。 首先，转储文件中没有比第一个修订版本更靠前的修订版本了！其次，Subversion不知道装载转储数据时（如果真的需要装载的话）的版本库是什么样的情况。为了保证每次运行<command moreinfo=\"none\">svnadmin dump</command>都能得到一个独立的结果，第一个转储的修订版本默认情况下会完整的保存目录、文件以及属性等数据。"

#: build/en/book.xml:11606(para)
msgid "However, you can change this default behavior. If you add the <option>--incremental</option> option when you dump your repository, <command moreinfo=\"none\">svnadmin</command> will compare the first dumped revision against the previous revision in the repository, the same way it treats every other revision that gets dumped. It will then output the first revision exactly as it does the rest of the revisions in the dump range—mentioning only the changes that occurred in that revision. The benefit of this is that you can create several small dump files that can be loaded in succession, instead of one large one, like so:"
msgstr "不过，这些都是可以改变的。如果转储时设置了<option>--incremental</option>选项，<command moreinfo=\"none\">svnadmin</command>会比较第一个转储的修订版本和版本库中前一个修订版本，就像对待其它转储的修订版本一样。转储时也是一样，转储文件中将仅包含第一个转储的修订版本的增量信息。这样的好处是，可以创建几个连续的小体积的转储文件代替一个大文件，比如："

#: build/en/book.xml:11618(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1\n"
"$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2\n"
"$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3\n"
msgstr ""
"\n"
"$ svnadmin dump myrepos -r 0:1000 &gt; dumpfile1\n"
"$ svnadmin dump myrepos -r 1001:2000 --incremental &gt; dumpfile2\n"
"$ svnadmin dump myrepos -r 2001:3000 --incremental &gt; dumpfile3\n"

#: build/en/book.xml:11624(para)
msgid "These dump files could be loaded into a new repository with the following command sequence:"
msgstr "这些转储文件可以使用下列命令装载到一个新的版本库中："

#: build/en/book.xml:11627(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile1\n"
"$ svnadmin load newrepos &lt; dumpfile2\n"
"$ svnadmin load newrepos &lt; dumpfile3\n"
msgstr ""
"\n"
"$ svnadmin load newrepos &lt; dumpfile1\n"
"$ svnadmin load newrepos &lt; dumpfile2\n"
"$ svnadmin load newrepos &lt; dumpfile3\n"

#: build/en/book.xml:11633(para)
#, fuzzy
msgid "Another neat trick you can perform with this <option>--incremental</option> option involves appending to an existing dump file a new range of dumped revisions. For example, you might have a <literal moreinfo=\"none\">post-commit</literal> hook that simply appends the repository dump of the single revision that triggered the hook. Or you might have a script that runs nightly to append dump file data for all the revisions that were added to the repository since the last time the script ran. Used like this, <command moreinfo=\"none\">svnadmin dump</command> can be one way to backup changes to your repository over time in case of a system crash or some other catastrophic event."
msgstr "另一个有关的技巧是，可以使用<option>--incremental</option>选项在一个转储文件中增加新的转储修订版本。举个例子，可以使用<literal moreinfo=\"none\">post-commit</literal>钩子在每次新的修订版本提交后将其转储到文件中。或者，可以编写一个脚本，在每天夜里将所有新增的修订版本转储到文件中。这样，<command moreinfo=\"none\">svnadmin</command>的<literal moreinfo=\"none\">dump</literal>和<literal moreinfo=\"none\">load</literal>命令就变成了很好的版本库备份工具，万一出现系统崩溃或其它灾难性事件，它的价值就体现出来了。"

#: build/en/book.xml:11645(para)
msgid "The dump format can also be used to merge the contents of several different repositories into a single repository. By using the <option>--parent-dir</option> option of <command moreinfo=\"none\">svnadmin load</command>, you can specify a new virtual root directory for the load process. That means if you have dump files for three repositories, say <filename moreinfo=\"none\">calc-dumpfile</filename>, <filename moreinfo=\"none\">cal-dumpfile</filename>, and <filename moreinfo=\"none\">ss-dumpfile</filename>, you can first create a new repository to hold them all:"
msgstr "转储还可以用来将几个独立的版本库合并为一个版本库。使用<command moreinfo=\"none\">svnadmin load</command>的<option>--parent-dir</option>选项，可以在装载的时候指定根目录。也就是说，如果有三个不同版本库的转储文件，比如<filename moreinfo=\"none\">calc-dumpfile</filename>，<filename moreinfo=\"none\">cal-dumpfile</filename>，和<filename moreinfo=\"none\">ss-dumpfile</filename>，可以在一个新的版本库中保存所有三个转储文件中的数据："

#: build/en/book.xml:11656(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create /path/to/projects\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin create /path/to/projects\n"
"$\n"

#: build/en/book.xml:11661(para)
msgid "Then, make new directories in the repository which will encapsulate the contents of each of the three previous repositories:"
msgstr "然后在版本库中创建三个目录分别保存来自三个不同版本库的数据："

#: build/en/book.xml:11665(screen)
#, no-wrap
msgid ""
"\n"
"$ svn mkdir -m \"Initial project roots\" \\\n"
"      file:///path/to/projects/calc \\\n"
"      file:///path/to/projects/calendar \\\n"
"      file:///path/to/projects/spreadsheet\n"
"Committed revision 1.\n"
"$ \n"
msgstr ""
"\n"
"$ svn mkdir -m \"Initial project roots\" \\\n"
"      file:///path/to/projects/calc \\\n"
"      file:///path/to/projects/calendar \\\n"
"      file:///path/to/projects/spreadsheet\n"
"Committed revision 1.\n"
"$ \n"

#: build/en/book.xml:11674(para)
msgid "Lastly, load the individual dump files into their respective locations in the new repository:"
msgstr "最后，将转储文件分别装载到各自的目录中："

#: build/en/book.xml:11677(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile\n"
"…\n"
"$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile\n"
"…\n"
"$\n"

#: build/en/book.xml:11687(para)
#, fuzzy
msgid "We'll mention one final way to use the Subversion repository dump format—conversion from a different storage mechanism or version control system altogether. Because the dump file format is, for the most part, human-readable, it should be relatively easy to describe generic sets of changes—each of which should be treated as a new revision—using this file format. In fact, the <command moreinfo=\"none\">cvs2svn</command> utility (see <xref linkend=\"svn.forcvs.convert\"/>) uses the dump format to represent the contents of a CVS repository so that those contents can be copied into a Subversion repository."
msgstr "我们再介绍一下Subversion版本库转储数据的最后一种用途——在不同的存储机制或版本控制系统之间转换。因为转储数据的格式的大部分是可以阅读的，<footnote><placeholder-1/></footnote>所以使用这种格式描述变更集（每个变更集对应一个新的修订版本）会相对容易一些。事实上，<command moreinfo=\"none\">cvs2svn</command>工具（参见 <xref linkend=\"svn.forcvs.convert\"/>）正是将CVS版本库的内容转换为转储数据格式，如此才能将CVS版本库的数据导入Subversion版本库之中。"

#: build/en/book.xml:11702(title)
msgid "Filtering Repository History"
msgstr "过滤版本库历史"

#: build/en/book.xml:11712(para)
msgid "That's rather the reason you use version control at all, right?"
msgstr ""

#: build/en/book.xml:11721(para)
msgid "Conscious, cautious removal of certain bits of versioned data is actually supported by real use-cases. That's why an <quote>obliterate</quote> feature has been one of the most highly requested Subversion features, and one which the Subversion developers hope to soon provide."
msgstr ""

#: build/en/book.xml:11704(para)
#, fuzzy
msgid "Since Subversion stores your versioned history using, at the very least, binary differencing algorithms and data compression (optionally in a completely opaque database system), attempting manual tweaks is unwise, if not quite difficult, and at any rate strongly discouraged. And once data has been stored in your repository, Subversion generally doesn't provide an easy way to remove that data. <placeholder-1/> But inevitably, there will be times when you would like to manipulate the history of your repository. You might need to strip out all instances of a file that was accidentally added to the repository (and shouldn't be there for whatever reason). <placeholder-2/> Or, perhaps you have multiple projects sharing a single repository, and you decide to split them up into their own repositories. To accomplish tasks like this, administrators need a more manageable and malleable representation of the data in their repositories—the Subversion repository dump format."
msgstr "因为Subversion使用底层的数据库储存各类数据，手工调整是不明智的，即使这样做并不困难。何况，一旦你的数据存进了版本库，通常很难再将它们从版本库中删除。<footnote><placeholder-1/></footnote>但是不可避免的，总会有些时候你需要处理版本库的历史数据。你也许想把一个不应该出现的文件从版本库中彻底清除。或者，你曾经用一个版本库管理多个工程，现在又想把它们分开。要完成这样的工作，管理员们需要更易于管理和扩展的方法表示版本库中的数据，Subversion版本库转储文件格式就是一个很好的选择。"

#: build/en/book.xml:11735(para)
#, fuzzy
msgid "As we described in <xref linkend=\"svn.reposadmin.maint.migrate\"/>, the Subversion repository dump format is a human-readable representation of the changes that you've made to your versioned data over time. You use the <command moreinfo=\"none\">svnadmin dump</command> command to generate the dump data, and <command moreinfo=\"none\">svnadmin load</command> to populate a new repository with it (see <xref linkend=\"svn.reposadmin.maint.migrate\"/>). The great thing about the human-readability aspect of the dump format is that, if you aren't careless about it, you can manually inspect and modify it. Of course, the downside is that if you have three years' worth of repository activity encapsulated in what is likely to be a very large dump file, it could take you a long, long time to manually inspect and modify it."
msgstr "Subversion版本库转储文件记录了所有版本数据的变更信息，而且以易于阅读的格式保存。可以使用<command moreinfo=\"none\">svnadmin dump</command>命令生成转储文件，然后用<command moreinfo=\"none\">svnadmin load</command>命令生成一个新的版本库。（参见 <xref linkend=\"svn.reposadmin.maint.migrate\"/>）。转储文件易于阅读意味着你可以小心翼翼的查看和修改它。当然，问题是如果你有一个运行了两年的版本库，那么生成的转储文件会很庞大，阅读和手工修改起来都会花费很多时间。"

#: build/en/book.xml:11750(para)
#, fuzzy
msgid "That's where <command moreinfo=\"none\">svndumpfilter</command> becomes useful. This program acts as path-based filter for repository dump streams. Simply give it either a list of paths you wish to keep, or a list of paths you wish to not keep, then pipe your repository dump data through this filter. The result will be a modified stream of dump data that contains only the versioned paths you (explicitly or implicitly) requested."
msgstr "虽然在管理员的日常工作中并不会经常使用，不过<command moreinfo=\"none\">svndumpfilter</command>可以对特定的路径进行过滤。这是一个独特而很有意义的用法，可以帮助你快速方便的修改转储的数据。使用时，只需提供一个你想要保留的（或者不想保留的）路径列表，然后把你的版本库转储文件送进这个过滤器。最后你就可以得到一个仅包含你想保留的路径的转储数据流。"

#: build/en/book.xml:11759(para)
msgid "Let's look a realistic example of how you might use this program. We discuss elsewhere (see <xref linkend=\"svn.reposadmin.projects.chooselayout\"/>) the process of deciding how to choose a layout for the data in your repositories—using one repository per project or combining them, arranging stuff within your repository, and so on. But sometimes after new revisions start flying in, you rethink your layout and would like to make some changes. A common change is the decision to move multiple projects which are sharing a single repository into separate repositories for each project."
msgstr "现在我来演示如何使用这个命令。我们会在其它章节（参见 <xref linkend=\"svn.reposadmin.projects.chooselayout\"/>）讨论关于如何选择设定版本库布局的问题，比如应该使用一个版本库管理多个项目还是使用一个版本库管理一个项目，或者如何在版本库中安排数据等等。不过，有些时候，即使在项目已经展开以后，你还是希望对版本库的布局做一些调整。最常见的情况是，把原来存放在同一个版本库中的几个项目分开，各自成家。"

#: build/en/book.xml:11770(para)
msgid "Our imaginary repository contains three projects: <literal moreinfo=\"none\">calc</literal>, <literal moreinfo=\"none\">calendar</literal>, and <literal moreinfo=\"none\">spreadsheet</literal>. They have been living side-by-side in a layout like this:"
msgstr "假设有一个包含三个项目的版本库： <literal moreinfo=\"none\">calc</literal>，<literal moreinfo=\"none\">calendar</literal>，和 <literal moreinfo=\"none\">spreadsheet</literal>。它们在版本库中的布局如下："

#: build/en/book.xml:11775(screen)
#, no-wrap
msgid ""
"\n"
"/\n"
"   calc/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   calendar/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   spreadsheet/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
msgstr ""
"\n"
"/\n"
"   calc/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   calendar/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"
"   spreadsheet/\n"
"      trunk/\n"
"      branches/\n"
"      tags/\n"

#: build/en/book.xml:11791(para)
msgid "To get these three projects into their own repositories, we first dump the whole repository:"
msgstr "现在要把这三个项目转移到三个独立的版本库中。首先，转储整个版本库："

#: build/en/book.xml:11794(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin dump /path/to/repos &gt; repos-dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"* Dumped revision 3.\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin dump /path/to/repos &gt; repos-dumpfile\n"
"* Dumped revision 0.\n"
"* Dumped revision 1.\n"
"* Dumped revision 2.\n"
"* Dumped revision 3.\n"
"…\n"
"$\n"

#: build/en/book.xml:11804(para)
msgid "Next, run that dump file through the filter, each time including only one of our top-level directories, and resulting in three new dump files:"
msgstr "然后，将转储文件三次送入过滤器，每次仅保留一个顶级目录，就可以得到三个转储文件："

#: build/en/book.xml:11808(screen)
#, fuzzy, no-wrap
msgid ""
"\n"
"$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile\n"
"…\n"
"$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile\n"
"…\n"
"$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svndumpfilter include calc &lt; repos-dumpfile &gt; calc-dumpfile\n"
"…\n"
"$ svndumpfilter include calendar &lt; repos-dumpfile &gt; cal-dumpfile\n"
"…\n"
"$ svndumpfilter include spreadsheet &lt; repos-dumpfile &gt; ss-dumpfile\n"
"…\n"
"$\n"

#: build/en/book.xml:11818(para)
msgid "At this point, you have to make a decision. Each of your dump files will create a valid repository, but will preserve the paths exactly as they were in the original repository. This means that even though you would have a repository solely for your <literal moreinfo=\"none\">calc</literal> project, that repository would still have a top-level directory named <filename moreinfo=\"none\">calc</filename>. If you want your <filename moreinfo=\"none\">trunk</filename>, <filename moreinfo=\"none\">tags</filename>, and <filename moreinfo=\"none\">branches</filename> directories to live in the root of your repository, you might wish to edit your dump files, tweaking the <literal moreinfo=\"none\">Node-path</literal> and <literal moreinfo=\"none\">Node-copyfrom-path</literal> headers to no longer have that first <filename moreinfo=\"none\">calc/</filename> path component. Also, you'll want to remove the section of dump data that creates the <filename moreinfo=\"none\">calc</filename> directory. It will look something like:"
msgstr "现在你必须要作出一个决定了。这三个转储文件中，每个都可以用来创建一个可用的版本库，不过它们保留了原版本库的精确路径结构。也就是说，虽然项目<literal moreinfo=\"none\">calc</literal>现在独占了一个版本库，但版本库中还保留着名为<filename moreinfo=\"none\">calc</filename>的顶级目录。如果希望<filename moreinfo=\"none\">trunk</filename>、<filename moreinfo=\"none\">tags</filename>和<filename moreinfo=\"none\">branches</filename>这三个目录直接位于版本库的根路径下，你可能需要编辑转储文件，调整<literal moreinfo=\"none\">Node-path</literal>和<literal moreinfo=\"none\">Copyfrom-path</literal>头参数，将路径<filename moreinfo=\"none\">calc/</filename>删除。同时，你还要删除转储数据中创建<filename moreinfo=\"none\">calc</filename>目录的部分。一般来说，就是如下的一些内容："

#: build/en/book.xml:11835(screen)
#, no-wrap
msgid ""
"\n"
"Node-path: calc\n"
"Node-action: add\n"
"Node-kind: dir\n"
"Content-length: 0\n"
"  \n"
msgstr ""
"\n"
"Node-path: calc\n"
"Node-action: add\n"
"Node-kind: dir\n"
"Content-length: 0\n"
"  \n"

#: build/en/book.xml:11844(para)
#, fuzzy
msgid "If you do plan on manually editing the dump file to remove a top-level directory, make sure that your editor is not set to automatically convert end-lines to the native format (e.g. \\r\\n to \\n) as the content will then not agree with the metadata. This will render the dump file useless."
msgstr "如果你打算通过手工编辑转储文件来移除一个顶级目录，注意不要让你的编辑器将换行符转换为本地格式（比如将\\r\\n转换为\\n）。否则文件的内容就与所需的格式不相符，这个转储文件也就失效了。"

#: build/en/book.xml:11852(para)
msgid "All that remains now is to create your three new repositories, and load each dump file into the right repository:"
msgstr "剩下的工作就是创建三个新的版本库，然后将三个转储文件分别导入："

#: build/en/book.xml:11856(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile\n"
"&lt;&lt;&lt; Started new transaction, based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : button.c ... done.\n"
"…\n"
"$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile\n"
"&lt;&lt;&lt; Started new transaction, based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : cal.c ... done.\n"
"…\n"
"$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile\n"
"&lt;&lt;&lt; Started new transaction, based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : ss.c ... done.\n"
"…\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile\n"
"&lt;&lt;&lt; Started new transaction， based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : button.c ... done.\n"
"…\n"
"$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile\n"
"&lt;&lt;&lt; Started new transaction， based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : cal.c ... done.\n"
"…\n"
"$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile\n"
"&lt;&lt;&lt; Started new transaction， based on original revision 1\n"
"     * adding path : Makefile ... done.\n"
"     * adding path : ss.c ... done.\n"
"…\n"
"$\n"

#: build/en/book.xml:11875(para)
msgid "Both of <command moreinfo=\"none\">svndumpfilter</command>'s subcommands accept options for deciding how to deal with <quote>empty</quote> revisions. If a given revision contained only changes to paths that were filtered out, that now-empty revision could be considered uninteresting or even unwanted. So to give the user control over what to do with those revisions, <command moreinfo=\"none\">svndumpfilter</command> provides the following command-line options:"
msgstr "<command moreinfo=\"none\">svndumpfilter</command>的两个子命令都可以通过选项设定如何处理<quote>空</quote>修订版本。如果某个指定的修订版本仅包含路径的更改，过滤器就会将它删除，因为当前为空的修订版本通常是无用的甚至是让人讨厌的。为了让用户有选择的处理这些修订版本，<command moreinfo=\"none\">svndumpfilter</command>提供了以下命令行选项："

#: build/en/book.xml:11886(option)
msgid "--drop-empty-revs"
msgstr "--drop-empty-revs"

#: build/en/book.xml:11888(para)
msgid "Do not generate empty revisions at all—just omit them."
msgstr "不生成任何空修订版本，忽略它们。"

#: build/en/book.xml:11893(option)
msgid "--renumber-revs"
msgstr "--renumber-revs"

#: build/en/book.xml:11895(para)
msgid "If empty revisions are dropped (using the <option>--drop-empty-revs</option> option), change the revision numbers of the remaining revisions so that there are no gaps in the numeric sequence."
msgstr "如果空修订版本被剔除（通过使用<option>--drop-empty-revs</option>选项），依次修改其它修订版本的编号，确保编号序列是连续的。"

#: build/en/book.xml:11902(option)
msgid "--preserve-revprops"
msgstr "--preserve-revprops"

#: build/en/book.xml:11904(para)
msgid "If empty revisions are not dropped, preserve the revision properties (log message, author, date, custom properties, etc.) for those empty revisions. Otherwise, empty revisions will only contain the original datestamp, and a generated log message that indicates that this revision was emptied by <command moreinfo=\"none\">svndumpfilter</command>."
msgstr "如果空修订版本被保留，保持这些空修订版本的属性（日志信息，作者，日期，自定义属性，等等）。如果不设定这个选项，空修订版本将仅保留初始时间戳，以及一个自动生成的日志信息，表明此修订版本由<command moreinfo=\"none\">svndumpfilter</command>处理过。"

#: build/en/book.xml:11915(para)
msgid "While <command moreinfo=\"none\">svndumpfilter</command> can be very useful, and a huge timesaver, there are unfortunately a couple of gotchas. First, this utility is overly sensitive to path semantics. Pay attention to whether paths in your dump file are specified with or without leading slashes. You'll want to look at the <literal moreinfo=\"none\">Node-path</literal> and <literal moreinfo=\"none\">Node-copyfrom-path</literal> headers."
msgstr "尽管<command moreinfo=\"none\">svndumpfilter</command>十分有用，能节省大量的时间，但它却是把不折不扣的双刃剑。首先，这个工具对路径语义极为敏感。仔细检查转储文件中的路径是不是以斜线开头。也许<literal moreinfo=\"none\">Node-path</literal>和<literal moreinfo=\"none\">Copyfrom-path</literal>这两个头参数对你有些帮助。"

#: build/en/book.xml:11923(screen)
#, no-wrap
msgid ""
"\n"
"…\n"
"Node-path: spreadsheet/Makefile\n"
"…\n"
msgstr ""
"\n"
"…\n"
"Node-path: spreadsheet/Makefile\n"
"…\n"

#: build/en/book.xml:11936(para)
msgid "While <command moreinfo=\"none\">svnadmin dump</command> has a consistent leading slash policy—to not include them—other programs which generate dump data might not be so consistent."
msgstr "尽管<command moreinfo=\"none\">svnadmin dump</command>对是否以斜线作为路径的开头有统一的规定——这个规定就是不以斜线作为路径的开头——其它生成转储文件的程序不一定会遵守这个规定。"

#: build/en/book.xml:11929(para)
#, fuzzy
msgid "If the paths have leading slashes, you should include leading slashes in the paths you pass to <command moreinfo=\"none\">svndumpfilter include</command> and <command moreinfo=\"none\">svndumpfilter exclude</command> (and if they don't, you shouldn't). Further, if your dump file has an inconsistent usage of leading slashes for some reason, <placeholder-1/> you should probably normalize those paths so they all have, or lack, leading slashes."
msgstr "如果这些路径以斜线开头，那么你传递给<command moreinfo=\"none\">svndumpfilter include</command>和<command moreinfo=\"none\">svndumpfilter exclude</command>的路径也必须以斜线开头（反之亦然）。如果因为某些原因转储文件中的路径没有统一使用或不使用斜线开头，<footnote><placeholder-1/></footnote>也许需要修正这些路径，统一使用斜线开头或不使用斜线开头。"

#: build/en/book.xml:11944(para)
msgid "Also, copied paths can give you some trouble. Subversion supports copy operations in the repository, where a new path is created by copying some already existing path. It is possible that at some point in the lifetime of your repository, you might have copied a file or directory from some location that <command moreinfo=\"none\">svndumpfilter</command> is excluding, to a location that it is including. In order to make the dump data self-sufficient, <command moreinfo=\"none\">svndumpfilter</command> needs to still show the addition of the new path—including the contents of any files created by the copy—and not represent that addition as a copy from a source that won't exist in your filtered dump data stream. But because the Subversion repository dump format only shows what was changed in each revision, the contents of the copy source might not be readily available. If you suspect that you have any copies of this sort in your repository, you might want to rethink your set of included/excluded paths."
msgstr "此外，复制操作生成的路径也会带来麻烦。Subversion支持在版本库中进行复制操作，也就是复制一个存在的路径，生成一个新的路径。问题是，<command moreinfo=\"none\">svndumpfilter</command>保留的某个文件或目录可能是由某个<command moreinfo=\"none\">svndumpfilter</command>排除的文件或目录复制而来的。也就是说，为了确保转储数据的完整性，<command moreinfo=\"none\">svndumpfilter</command>需要切断这些复制自被排除路径的文件与源文件的关系，还要将这些文件的内容以新建的方式添加到转储数据中。但是由于Subversion版本库转储文件格式中仅包含了修订版本的更改信息，因此源文件的内容基本上无法获得。如果你不能确定版本库中是否存在类似的情况，最好重新考虑一下到底保留/排除哪些路径。"

#: build/en/book.xml:11963(para)
msgid "Finally, <command moreinfo=\"none\">svndumpfilter</command> takes path filtering quite literally. If you are trying to copy the history of a project rooted at <filename moreinfo=\"none\">trunk/my-project</filename> and move it into a repository of its own, you would, of course, use the <command moreinfo=\"none\">svndumpfilter include</command> command to keep all the changes in and under <filename moreinfo=\"none\">trunk/my-project</filename>. But the resulting dump file makes no assumptions about the repository into which you plan to load this data. Specifically, the dump data might begin with the revision which added the <filename moreinfo=\"none\">trunk/my-project</filename> directory, but it will <emphasis>not</emphasis> contain directives which would create the <filename moreinfo=\"none\">trunk</filename> directory itself (because <filename moreinfo=\"none\">trunk</filename> doesn't match the include filter). You'll need to make sure that any directories which the new dump stream expect to exist actually do exist in the target repository before trying to load the stream into that repository."
msgstr ""

#: build/en/book.xml:11987(title)
msgid "Repository Replication"
msgstr "版本库复制"

#: build/en/book.xml:11989(para)
msgid "There are several scenarios in which it is quite handy to have a Subversion repository whose version history is exactly the same as some other repository's. Perhaps the most obvious one is the maintenance of a simple backup repository, used when the primary repository has become inaccessible due to a hardware failure, network outage, or other such annoyance. Other scenarios include deploying mirror repositories to distribute heavy Subversion load across multiple servers, use as a soft-upgrade mechanism, and so on."
msgstr ""

#: build/en/book.xml:11999(para)
msgid "As of version 1.4, Subversion provides a program for managing scenarios like these—<command moreinfo=\"none\">svnsync</command>. <command moreinfo=\"none\">svnsync</command> works by essentially asking the Subversion server to <quote>replay</quote> revisions, one at a time. It then uses that revision information to mimic a commit of the same to another repository. Neither repository needs to be locally accessible to machine on which <command moreinfo=\"none\">svnsync</command> is running—its parameters are repository URLs, and it does all its work through Subversion's repository access (RA) interfaces. All it requires is read access to the source repository and read/write access to the destination repository."
msgstr ""

#: build/en/book.xml:12014(para)
msgid "When using <command moreinfo=\"none\">svnsync</command> against a remote source repository, the Subversion server for that repository must be running Subversion version 1.4 or better."
msgstr ""

#: build/en/book.xml:12032(para)
msgid "In fact, it can't truly be read-only, or <command moreinfo=\"none\">svnsync</command> itself would have a tough time copying revision history into it."
msgstr ""

#: build/en/book.xml:12019(para)
msgid "Assuming you already have a source repository that you'd like to mirror, the next thing you need is an empty target repository which will actually serve as that mirror. This target repository can use either of the available filesystem data-store back-ends (see <xref linkend=\"svn.reposadmin.basics.backends\"/>), but it must not yet have any version history in it. The protocol via which <command moreinfo=\"none\">svnsync</command> communicates revision information is highly sensitive to mismatches between the versioned histories contained in the source and target repositories. For this reason, while <command moreinfo=\"none\">svnsync</command> cannot <emphasis>demand</emphasis> that the target repository be read-only, <placeholder-1/> allowing the revision history in the target repository to change by any mechanism other than the mirroring process is a recipe for disaster."
msgstr ""

#: build/en/book.xml:12041(para)
msgid "Do <emphasis>not</emphasis> modify a mirror repository in such a way as to cause its version history to deviate from that of the repository it mirrors. The only commits and revision property modifications that ever occur on that mirror repository should be those performed by the <command moreinfo=\"none\">svnsync</command> tool."
msgstr ""

#: build/en/book.xml:12049(para)
msgid "Another requirement of the target repository is that the <command moreinfo=\"none\">svnsync</command> process be allowed to modify certain revision properties. <command moreinfo=\"none\">svnsync</command> stores its bookkeeping information in special revision properties on revision 0 of the destination repository. Because <command moreinfo=\"none\">svnsync</command> works within the framework of that repository's hook system, the default state of the repository (which is to disallow revision property changes; see <xref linkend=\"svn.ref.reposhooks.pre-revprop-change\"/>) is insufficient. You'll need to explicitly implement the pre-revprop-change hook, and your script must allow <command moreinfo=\"none\">svnsync</command> to set and change its special properties. With those provisions in place, you are ready to start mirroring repository revisions."
msgstr ""

#: build/en/book.xml:12065(para)
msgid "It's a good idea to implement authorization measures which allow your repository replication process to perform its tasks while preventing other users from modifying the contents of your mirror repository at all."
msgstr ""

#: build/en/book.xml:12071(para)
msgid "Let's walk through the use of <command moreinfo=\"none\">svnsync</command> in a somewhat typical mirroring scenario. We'll pepper this discourse with practical recommendations which you are free to disregard if they aren't required by or suitable for your environment."
msgstr ""

#: build/en/book.xml:12077(para)
msgid "As a service to the fine developers of our favorite version control system, we will be mirroring the public Subversion source code repository and exposing that mirror publicly on the Internet, hosted on a different machine than the one on which the original Subversion source code repository lives. This remote host has a global configuration which permits anonymous users to read the contents of repositories on the host, but requires users to authenticate in order to modify those repositories. (Please forgive us for glossing over the details of Subversion server configuration for the moment—those are covered thoroughly in <xref linkend=\"svn.serverconfig\"/>.) And for no other reason than that it makes for a more interesting example, we'll be driving the replication process from a third machine, the one which we currently find ourselves using."
msgstr ""

#: build/en/book.xml:12092(para)
msgid "First, we'll create the repository which will be our mirror. This and the next couple of steps do require shell access to the machine on which the mirror repository will live. Once the repository is all configured, though, we shouldn't need to touch it directly again."
msgstr ""

#: build/en/book.xml:12098(screen)
#, no-wrap
msgid ""
"\n"
"$ ssh admin@svn.example.com \\\n"
"      \"svnadmin create /path/to/repositories/svn-mirror\"\n"
"admin@svn.example.com's password: ********\n"
"$\n"
msgstr ""
"\n"
"$ ssh admin@svn.example.com \\\n"
"      \"svnadmin create /path/to/repositories/svn-mirror\"\n"
"admin@svn.example.com's password: ********\n"
"$\n"

#: build/en/book.xml:12105(para)
msgid "At this point, we have our repository, and due to our server's configuration, that repository is now <quote>live</quote> on the Internet. Now, because we don't want anything modifying the repository except our replication process, we need a way to distinguish that process from other would-be committers. To do so, we use a dedicated username for our process. Only commits and revision property modifications performed by the special username <literal moreinfo=\"none\">syncuser</literal> will be allowed."
msgstr ""

#: build/en/book.xml:12115(para)
msgid "We'll use the repository's hook system both to allow the replication process to do what it needs to do, and to enforce that only it is doing those things. We accomplish this by implementing two of the repository event hooks—pre-revprop-change and start-commit. Our <filename moreinfo=\"none\">pre-revprop-change</filename> hook script is found in <xref linkend=\"svn.reposadmin.maint.replication.pre-revprop-change\"/>, and basically verifies that the user attempting the property changes is our <literal moreinfo=\"none\">syncuser</literal> user. If so, the change is allowed; otherwise, it is denied."
msgstr ""

#: build/en/book.xml:12126(title)
msgid "Mirror repository's pre-revprop-change hook script"
msgstr "镜像版本库的 pre-revprop-change 钩子"

#: build/en/book.xml:12128(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh \n"
"\n"
"USER=\"$3\"\n"
"\n"
"if [ \"$USER\" = \"syncuser\" ]; then exit 0; fi\n"
"\n"
"echo \"Only the syncuser user may change revision properties\" &gt;&amp;2\n"
"exit 1\n"
msgstr ""
"\n"
"#!/bin/sh \n"
"\n"
"USER=\"$3\"\n"
"\n"
"if [ \"$USER\" = \"syncuser\" ]; then exit 0; fi\n"
"\n"
"echo \"Only the syncuser user may change revision properties\" &gt;&amp;2\n"
"exit 1\n"

#: build/en/book.xml:12140(para)
msgid "That covers revision property changes. Now we need to ensure that only the <literal moreinfo=\"none\">syncuser</literal> user is permitted to commit new revisions to the repository. We do this using a <filename moreinfo=\"none\">start-commit</filename> hook scripts like the one in <xref linkend=\"svn.reposadmin.maint.replication.start-commit\"/>."
msgstr ""

#: build/en/book.xml:12147(title)
msgid "Mirror repository's start-commit hook script"
msgstr "镜像版本库的 start-commit 钩子"

#: build/en/book.xml:12149(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh \n"
"\n"
"USER=\"$2\"\n"
"\n"
"if [ \"$USER\" = \"syncuser\" ]; then exit 0; fi\n"
"\n"
"echo \"Only the syncuser user may commit new revisions\" &gt;&amp;2\n"
"exit 1\n"
msgstr ""
"\n"
"#!/bin/sh \n"
"\n"
"USER=\"$2\"\n"
"\n"
"if [ \"$USER\" = \"syncuser\" ]; then exit 0; fi\n"
"\n"
"echo \"Only the syncuser user may commit new revisions\" &gt;&amp;2\n"
"exit 1\n"

#: build/en/book.xml:12161(para)
msgid "After installing our hook scripts and ensuring that they are executable by the Subversion server, we're finished with the setup of the mirror repository. Now, we get to actually do the mirroring."
msgstr ""

#: build/en/book.xml:12166(para)
msgid "The first thing we need to do with <command moreinfo=\"none\">svnsync</command> is to register in our target repository the fact that it will be a mirror of the source repository. We do this using the <command moreinfo=\"none\">svnsync initialize</command> subcommand. Note that the various <command moreinfo=\"none\">svnsync</command> subcommands provide several of the same authentication-related options that <command moreinfo=\"none\">svn</command> does: <option>--username</option>, <option>--password</option>, <option>--non-interactive</option>, <option>--config-dir</option>, and <option>--no-auth-cache</option>."
msgstr ""

#: build/en/book.xml:12179(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help init\n"
"initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL\n"
"\n"
"Initialize a destination repository for synchronization from\n"
"another repository.\n"
"\n"
"The destination URL must point to the root of a repository with\n"
"no committed revisions.  The destination repository must allow\n"
"revision property changes.\n"
"\n"
"You should not commit to, or make revision property changes in,\n"
"the destination repository by any method other than 'svnsync'.\n"
"In other words, the destination repository should be a read-only\n"
"mirror of the source repository.\n"
"\n"
"Valid options:\n"
"  --non-interactive        : do no interactive prompting\n"
"  --no-auth-cache          : do not cache authentication tokens\n"
"  --username arg           : specify a username ARG\n"
"  --password arg           : specify a password ARG\n"
"  --config-dir arg         : read user configuration files from directory ARG\n"
"\n"
"$ svnsync initialize http://svn.example.com/svn-mirror \\\n"
"                     http://svn.collab.net/repos/svn \\\n"
"                     --username syncuser --password syncpass\n"
"Copied properties for revision 0.\n"
"$\n"
msgstr ""
"\n"
"$ svnsync help init\n"
"initialize (init): usage: svnsync initialize DEST_URL SOURCE_URL\n"
"\n"
"Initialize a destination repository for synchronization from\n"
"another repository.\n"
"\n"
"The destination URL must point to the root of a repository with\n"
"no committed revisions.  The destination repository must allow\n"
"revision property changes.\n"
"\n"
"You should not commit to, or make revision property changes in,\n"
"the destination repository by any method other than 'svnsync'.\n"
"In other words, the destination repository should be a read-only\n"
"mirror of the source repository.\n"
"\n"
"Valid options:\n"
"  --non-interactive        : do no interactive prompting\n"
"  --no-auth-cache          : do not cache authentication tokens\n"
"  --username arg           : specify a username ARG\n"
"  --password arg           : specify a password ARG\n"
"  --config-dir arg         : read user configuration files from directory ARG\n"
"\n"
"$ svnsync initialize http://svn.example.com/svn-mirror \\\n"
"                     http://svn.collab.net/repos/svn \\\n"
"                     --username syncuser --password syncpass\n"
"Copied properties for revision 0.\n"
"$\n"

#: build/en/book.xml:12209(para)
msgid "Our target repository will now remember that it is a mirror of the public Subversion source code repository. Notice that we provided a username and password as arguments to <command moreinfo=\"none\">svnsync</command>—that was required by the pre-revprop-change hook on our mirror repository."
msgstr ""

#: build/en/book.xml:12216(para)
msgid "The URLs provided to <command moreinfo=\"none\">svnsync</command> must point to the root directories of the target and source repositories, respectively. The tool does not handle mirroring of repository subtrees."
msgstr ""

#: build/en/book.xml:12223(para)
msgid "The initial release of <command moreinfo=\"none\">svnsync</command> (in Subversion 1.4) has a small shortcoming—the values given to the <option>--username</option> and <option>--password</option> command-line options get used for authentication against both the source and destination repositories. Obviously, there's no guarantee that the synchronizing user's credentials are the same in both places. In the event that they are not the same, users trying to run <command moreinfo=\"none\">svnsync</command> in non-interactive mode (with the <option>--non-interactive</option> option) might experience problems."
msgstr ""

#: build/en/book.xml:12241(para)
msgid "Be forewarned that while it will take only a few seconds for the average reader to parse this paragraph and the sample output which follows it, the actual time required to complete such a mirroring operation is, shall we say, quite a bit longer."
msgstr ""

#: build/en/book.xml:12236(para)
msgid "And now comes the fun part. With a single subcommand, we can tell <command moreinfo=\"none\">svnsync</command> to copy all the as-yet-unmirrored revisions from the source repository to the target. <placeholder-1/> The <command moreinfo=\"none\">svnsync synchronize</command> subcommand will peek into the special revision properties previously stored on the target repository, and determine what repository it is mirroring and that the most recently mirrored revision was revision 0. Then it will query the source repository and determine what the latest revision in that repository is. Finally, it asks the source repository's server to start replaying all the revisions between 0 and that latest revision. As <command moreinfo=\"none\">svnsync</command> get the resulting response from the source repository's server, it begins forwarding those revisions to the target repository's server as new commits."
msgstr ""

#: build/en/book.xml:12260(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help synchronize\n"
"synchronize (sync): usage: svnsync synchronize DEST_URL\n"
"\n"
"Transfer all pending revisions from source to destination.\n"
"…\n"
"$ svnsync synchronize http://svn.example.com/svn-mirror \\\n"
"                      --username syncuser --password syncpass\n"
"Committed revision 1.\n"
"Copied properties for revision 1.\n"
"Committed revision 2.\n"
"Copied properties for revision 2.\n"
"Committed revision 3.\n"
"Copied properties for revision 3.\n"
"…\n"
"Committed revision 23406.\n"
"Copied properties for revision 23406.\n"
"Committed revision 23407.\n"
"Copied properties for revision 23407.\n"
"Committed revision 23408.\n"
"Copied properties for revision 23408.\n"
msgstr ""
"\n"
"$ svnsync help synchronize\n"
"synchronize (sync): usage: svnsync synchronize DEST_URL\n"
"\n"
"Transfer all pending revisions from source to destination.\n"
"…\n"
"$ svnsync synchronize http://svn.example.com/svn-mirror \\\n"
"                      --username syncuser --password syncpass\n"
"Committed revision 1.\n"
"Copied properties for revision 1.\n"
"Committed revision 2.\n"
"Copied properties for revision 2.\n"
"Committed revision 3.\n"
"Copied properties for revision 3.\n"
"…\n"
"Committed revision 23406.\n"
"Copied properties for revision 23406.\n"
"Committed revision 23407.\n"
"Copied properties for revision 23407.\n"
"Committed revision 23408.\n"
"Copied properties for revision 23408.\n"

#: build/en/book.xml:12283(para)
msgid "Of particular interest here is that for each mirrored revision, there is first a commit of that revision to the target repository, and then property changes follow. This is because the initial commit is performed by (and attributed to) the user <literal moreinfo=\"none\">syncuser</literal>, and datestamped with the time as of that revision's creation. Also, Subversion's underlying repository access interfaces don't provide a mechanism for setting arbitrary revision properties as part of a commit. So <command moreinfo=\"none\">svnsync</command> follows up with an immediate series of property modifications which copy all the revision properties found for that revision in the source repository into the target repository. This also has the effect of fixing the author and datestamp of the revision to match that of the source repository."
msgstr ""

#: build/en/book.xml:12298(para)
msgid "Also noteworthy is that <command moreinfo=\"none\">svnsync</command> performs careful bookkeeping that allows it to be safely interrupted and restarted without ruining the integrity of the mirrored data. If a network glitch occurs while mirroring a repository, simply repeat the <command moreinfo=\"none\">svnsync synchronize</command> command and it will happily pick up right where it left off. In fact, as new revisions appear in the source repository, this is exactly what you to do in order to keep your mirror up-to-date."
msgstr ""

#: build/en/book.xml:12308(para)
msgid "There is, however, one bit of inelegance in the process. Because Subversion revision properties can be changed at any time throughout the lifetime of the repository, and don't leave an audit trail that indicates when they were changed, replication processes have to pay special attention to them. If you've already mirror the first 15 revisions of a repository and someone then changes a revision property on revision 12, <command moreinfo=\"none\">svnsync</command> won't know to go back and patch up its copy of revision 12. You'll need to tell it to do so manually by using (or with some additionally tooling around) the <command moreinfo=\"none\">svnsync copy-revprops</command> subcommand, which simply re-replicates all the revision properties for a particular revision."
msgstr ""

#: build/en/book.xml:12322(screen)
#, no-wrap
msgid ""
"\n"
"$ svnsync help copy-revprops\n"
"copy-revprops: usage: svnsync copy-revprops DEST_URL REV\n"
"\n"
"Copy all revision properties for revision REV from source to\n"
"destination.\n"
"…\n"
"$ svnsync copy-revprops http://svn.example.com/svn-mirror 12 \\\n"
"                        --username syncuser --password syncpass\n"
"Copied properties for revision 12.\n"
"$\n"
msgstr ""
"\n"
"$ svnsync help copy-revprops\n"
"copy-revprops: usage: svnsync copy-revprops DEST_URL REV\n"
"\n"
"Copy all revision properties for revision REV from source to\n"
"destination.\n"
"…\n"
"$ svnsync copy-revprops http://svn.example.com/svn-mirror 12 \\\n"
"                        --username syncuser --password syncpass\n"
"Copied properties for revision 12.\n"
"$\n"

#: build/en/book.xml:12335(para)
msgid "That's repository replication in a nutshell. You'll likely want some automation around such a process. For example, while our example was a pull-and-push setup, you might wish to have your primary repository push changes to one or more blessed mirrors as part of its post-commit and post-revprop-change hook implementations. This would enable the mirror to be up-to-date in as near to realtime as is likely possible."
msgstr ""

#: build/en/book.xml:12344(para)
msgid "Also, while it isn't very commonplace to do so, <command moreinfo=\"none\">svnsync</command> does gracefully mirror repositories in which the user as whom it authenticates only has partial read access. It simply copies only the bits of the repository that it is permitted to see. Obviously such a mirror is not useful as a backup solution."
msgstr ""

#: build/en/book.xml:12351(para)
msgid "As far as user interaction with repositories and mirrors goes, it <emphasis>is</emphasis> possible to have a single working copy that interacts with both, but you'll have to jump through some hoops to make it happen. First, you need to ensure that both the primary and mirror repositories have the same repository UUID (which is not the case by default). You can set the mirror repository's UUID by loading a dump file stub into it which contains the UUID of the primary repository, like so:"
msgstr ""

#: build/en/book.xml:12361(screen)
#, no-wrap
msgid ""
"\n"
"$ cat - &lt;&lt;EOF | svnadmin load --force-uuid dest\n"
"SVN-fs-dump-format-version: 2\n"
"\n"
"UUID: 65390229-12b7-0310-b90b-f21a5aa7ec8e\n"
"EOF\n"
"$\n"
msgstr ""
"\n"
"$ cat - &lt;&lt;EOF | svnadmin load --force-uuid dest\n"
"SVN-fs-dump-format-version: 2\n"
"\n"
"UUID: 65390229-12b7-0310-b90b-f21a5aa7ec8e\n"
"EOF\n"
"$\n"

#: build/en/book.xml:12370(para)
msgid "Now that the two repositories have the same UUID, you can use <command moreinfo=\"none\">svn switch --relocate</command> to point your working copy to whichever of the repositories you wish to operate against, a process which is described in <xref linkend=\"svn.ref.svn.c.switch\"/>. There is a possible danger here, though, in that if the primary and mirror repositories aren't in close synchronization, a working copy up-to-date with and pointing to the primary repository will, if relocated to point to an out-of-date mirror, become confused about the apparent sudden loss of revisions it fully expects to be present."
msgstr ""

#: build/en/book.xml:12381(para)
msgid "Finally, be aware that the revision-based replication provided by <command moreinfo=\"none\">svnsync</command> is only that—replication of revisions. It does not include such things as the hook implementations, repository or server configuration data, uncommitted transactions, or information about user locks on repository paths. Only information carried by the Subversion repository dump file format is available for replication."
msgstr ""

#: build/en/book.xml:12394(title)
msgid "Repository Backup"
msgstr "版本库备份"

#: build/en/book.xml:12396(para)
msgid "Despite numerous advances in technology since the birth of the modern computer, one thing unfortunately rings true with crystalline clarity—sometimes, things go very, very awry. Power outages, network connectivity dropouts, corrupt RAM and crashed hard drives are but a taste of the evil that Fate is poised to unleash on even the most conscientious administrator. And so we arrive at a very important topic—how to make backup copies of your repository data."
msgstr "尽管现代计算机的诞生带来了许多便利，但有一件事听起来是完全正确的—有时候，事情变的糟糕，很糟糕，动力损耗、网络中断、坏掉的内存和损坏的硬盘都是对魔鬼的一种体验，即使对于最尽职的管理员，命运也早已注定。所以我们来到了这个最重要的主题—怎样备份你的版本库数据。"

#: build/en/book.xml:12406(para)
msgid "There are two types of backup methods available for Subversion repository administrators—full and incremental. A full backup of the repository involves squirreling away in one sweeping action all the information required to fully reconstruct that repository in the event of a catastrophe. Usually, it means quite literally the duplication of the entire repository directory (which includes either a Berkeley DB or FSFS environment). Incremental backups are lesser things, backups of only the portion of the repository data that has changed since the previous backup."
msgstr ""

#: build/en/book.xml:12418(para)
msgid "As far as full backups go, the naive approach might seem like a sane one, but unless you temporarily disable all other access to your repository, simply doing a recursive directory copy runs the risk of generating a faulty backup. In the case of Berkeley DB, the documentation describes a certain order in which database files can be copied that will guarantee a valid backup copy. A similar ordering exists for FSFS data. But you don't have to implement these algorithms yourself, because the Subversion development team has already done so. The <command moreinfo=\"none\">svnadmin hotcopy</command> command takes care of the minutia involved in making a hot backup of your repository. And its invocation is as trivial as Unix's <command moreinfo=\"none\">cp</command> or Windows' <command moreinfo=\"none\">copy</command> operations:"
msgstr ""

#: build/en/book.xml:12433(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin hotcopy /path/to/repos /path/to/repos-backup\n"
msgstr ""
"\n"
"$ svnadmin hotcopy /path/to/repos /path/to/repos-backup\n"

#: build/en/book.xml:12437(para)
msgid "The resulting backup is a fully functional Subversion repository, able to be dropped in as a replacement for your live repository should something go horribly wrong."
msgstr "作为结果的备份是一个完全功能的版本库，当发生严重错误时可以作为你的活动版本库的替换。"

#: build/en/book.xml:12441(para)
msgid "When making copies of a Berkeley DB repository, you can even instruct <command moreinfo=\"none\">svnadmin hotcopy</command> to purge any unused Berkeley DB logfiles (see <xref linkend=\"svn.reposadmin.maint.diskspace.bdblogs\"/>) from the original repository upon completion of the copy. Simply provide the <option>--clean-logs</option> option on the command-line."
msgstr ""

#: build/en/book.xml:12448(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin hotcopy --clean-logs /path/to/bdb-repos /path/to/bdb-repos-backup\n"
msgstr ""
"\n"
"$ svnadmin hotcopy --clean-logs /path/to/bdb-repos /path/to/bdb-repos-backup\n"

#: build/en/book.xml:12452(para)
msgid "Additional tooling around this command is available, too. The <filename moreinfo=\"none\">tools/backup/</filename> directory of the Subversion source distribution holds the <command moreinfo=\"none\">hot-backup.py</command> script. This script adds a bit of backup management atop <command moreinfo=\"none\">svnadmin hotcopy</command>, allowing you to keep only the most recent configured number of backups of each repository. It will automatically manage the names of the backed-up repository directories to avoid collisions with previous backups, and will <quote>rotate off</quote> older backups, deleting them so only the most recent ones remain. Even if you also have an incremental backup, you might want to run this program on a regular basis. For example, you might consider using <command moreinfo=\"none\">hot-backup.py</command> from a program scheduler (such as <command moreinfo=\"none\">cron</command> on Unix systems) which will cause it to run nightly (or at whatever granularity of Time you deem safe enough for you)."
msgstr ""

#: build/en/book.xml:12470(para)
msgid "Some administrators use a different backup mechanism built around generating and storing repository dump data. We described in <xref linkend=\"svn.reposadmin.maint.migrate\"/> how to use <command moreinfo=\"none\">svnadmin dump --incremental</command> to perform an incremental backup of a given revision or range of revisions. And of course, there is a full backup variation of this achieved by omitting the <option>--incremental</option> option to that command. There is some value in these methods in that the format of your backed-up information is flexible—it's not tied to a particular platform, versioned filesystem type, or release of Subversion or Berkeley DB. But that flexibility comes at a cost, namely that restoring that data can take a long time—longer with each new revision committed to your repository. Also, as is the case with so many of the various backup methods, revision property changes made to already-backed-up revisions won't get picked up by a non-overlapping, incremental dump generation. For these reasons, we recommend against relying solely on dump-based backup approaches."
msgstr ""

#: build/en/book.xml:12490(para)
#, fuzzy
msgid "As you can see, each of the various backup types and methods has its advantages and disadvantages. The easiest is by far the full hot backup, which will always result in a perfect working replica of your repository. Should something bad happen to your live repository, you can restore from the backup with a simple recursive directory copy. Unfortunately, if you are maintaining multiple backups of your repository, these full copies will each eat up just as much disk space as your live repository. Incremental backups, by contrast, tend to be quicker to generate and smaller to store. But the restoration process can be a pain, often involving applying multiple incremental backups. And other methods have their own peculiarities. Administrators need to find the balance between the cost of making the backup and the cost of restoring it."
msgstr "两种备份方式都有各自的优点，最简单的方式是完全备份，将会每次建立版本库的完美复制品，这意味着如果当你的活动版本库发生了什么事情，你可以用备份恢复。但不幸的是，如果你维护多个备份，每个完全的备份会吞噬掉和你的活动版本库同样的空间。"

#: build/en/book.xml:12506(para)
msgid "The <command moreinfo=\"none\">svnsync</command> program (see <xref linkend=\"svn.reposadmin.maint.replication\"/>) actually provides a rather handy middle-ground approach. If you are regularly synchronizing a read-only mirror with your main repository, then in a pinch, your read-only mirror is probably a good candidate for replacing that main repository if it falls over. The primary disadvantage of this method is that only the versioned repository data gets synchronized—repository configuration files, user-specified repository path locks, and other items which might live in the physical repository directory but not <emphasis>inside</emphasis> the repository's virtual versioned filesystem are not handled by svnsync."
msgstr ""

#: build/en/book.xml:12526(para)
msgid "<command moreinfo=\"none\">svnadmin setlog</command> can be called in a way that bypasses the hook interface altogether."
msgstr "<command moreinfo=\"none\">svnadmin setlog</command>可以被绕过钩子程序被调用。"

#: build/en/book.xml:12519(para)
#, fuzzy
msgid "In any backup scenario, repository administrators need to be aware of how modifications to unversioned revision properties affect their backups. Since these changes do not themselves generate new revisions, they will not trigger post-commit hooks, and may not even trigger the pre-revprop-change and post-revprop-change hooks. <placeholder-1/> And since you can change revision properties without respect to chronological order—you can change any revision's properties at any time—an incremental backup of the latest few revisions might not catch a property modification to a revision that was included as part of a previous backup."
msgstr "在每一种备份情境下，版本库管理员需要意识到对未版本化的修订版本属性的修改对备份的影响，因为这些修改本身不会产生新的修订版本，所以不会触发post-commit的钩子程序，也不会触发pre-revprop-change和post-revprop-change的钩子。 <footnote><placeholder-1/></footnote> 而且因为你可以改变修订版本的属性，而不需要遵照时间顺序—你可在任何时刻修改任何修订版本的属性—因此最新版本的增量备份不会捕捉到以前特定修订版本的属性修改。"

#: build/en/book.xml:12536(para)
#, fuzzy
msgid "Generally speaking, only the truly paranoid would need to backup their entire repository, say, every time a commit occurred. However, assuming that a given repository has some other redundancy mechanism in place with relatively fine granularity (like per-commit emails or incremental dumps), a hot backup of the database might be something that a repository administrator would want to include as part of a system-wide nightly backup. It's your data—protect it as much as you'd like."
msgstr "通常说来，在每次提交时，只有妄想狂才会备份整个版本库，然而，假设一个给定的版本库拥有一些恰当粒度的冗余机制（如每次提交的邮件）。版本库管理员也许会希望将版本库的热备份引入到系统级的每夜备份，对大多数版本库，归档的提交邮件为保存资源提供了足够的冗余措施，至少对于最近的提交。但是它是你的数据—你喜欢怎样保护都可以。"

#: build/en/book.xml:12561(para)
msgid "You know—the collective term for all of her <quote>fickle fingers</quote>."
msgstr "你知道的—只是对各种变化莫测的问题的统称。"

#: build/en/book.xml:12546(para)
#, fuzzy
msgid "Often, the best approach to repository backups is a diversified one which leverages combinations of the methods described here. The Subversion developers, for example, back up the Subversion source code repository nightly using <command moreinfo=\"none\">hot-backup.py</command> and an offsite <command moreinfo=\"none\">rsync</command> of those full backups; keep multiple archives of all the commit and property change notification emails; and have repository mirrors maintained by various volunteers using <command moreinfo=\"none\">svnsync</command>. Your solution might be similar, but should be catered to your needs and that delicate balance of convenience with paranoia. And whatever you do, validate your backups from time to time—what good is a spare tire that has a hole in it? While all of this might not save your hardware from the iron fist of Fate, <placeholder-1/> it should certainly help you recover from those trying times."
msgstr "通常情况下，最好的版本库备份方式是混合的，你可以平衡完全和增量备份，另外配合提交邮件的归档，Subversion开发者，举个例子，在每个新的修订版本建立时备份Subversion的源代码版本库，并且保留所有的提交和属性修改通知文件。你的解决方案类似，必须迎合你的需要，平衡便利和你的偏执。然而这些不会改变你的硬件来自钢铁的命运。<footnote><placeholder-1/></footnote> 这一定会帮助你减少尝试的时间。"

#: build/en/book.xml:12577(para)
msgid "By now you should have a basic understanding of how to create, configure, and maintain Subversion repositories. We've introduced you to the various tools that will assist you with this task. Throughout the chapter, we've noted common administration pitfalls, and suggestions for avoiding them."
msgstr "现在，你应该已经对如何创建、配置以及维护Subversion版本库有了个基本的认识。我们向您介绍了几个可以帮助您工作的工具。通过这一章，我们说明了一些常见的管理误区，并提出了避免陷入误区的建议。"

#: build/en/book.xml:12584(para)
msgid "All that remains is for you to decide what exciting data to store in your repository, and finally, how to make it available over a network. The next chapter is all about networking."
msgstr "剩下的，就是由你决定在你的版本库中存放一些什么有趣的资料，并最终通过网络获得这些资料。下一章是关于网络的内容。"

#: build/en/book.xml:12598(title)
msgid "Server Configuration"
msgstr "服务配置"

#: build/en/book.xml:12600(para)
#, fuzzy
msgid "A Subversion repository can be accessed simultaneously by clients running on the same machine on which the repository resides using the <literal moreinfo=\"none\">file://</literal> method. But the typical Subversion setup involves a single server machine being accessed from clients on computers all over the office—or, perhaps, all over the world."
msgstr "一个Subversion的版本库可以和客户端同时运行在同一个机器上，使用<literal moreinfo=\"none\">file:///</literal>访问，但是一个典型的Subversion设置应该包括一个单独的服务器，可以被办公室的所有客户端访问—或者有可能是整个世界。"

#: build/en/book.xml:12607(para)
#, fuzzy
msgid "This chapter describes how to get your Subversion repository exposed outside its host machine for use by remote clients. We will cover Subversion's currently available server mechanisms, discussing the configuration and use of each. After reading this section, you should be able to decide which networking setup is right for your needs, and understand how to enable such a setup on your host computer."
msgstr "本小节描述了怎样将一个Subversion的版本库暴露给远程客户端，我们会覆盖Subversion已存在的服务器机制，讨论各种方式的配置和使用。经过阅读本小节，你可以决定你需要哪种网络设置，并且明白怎样在你的主机上进行配置。"

#: build/en/book.xml:12621(title)
msgid "Overview"
msgstr "概述"

#: build/en/book.xml:12623(para)
#, fuzzy
msgid "Subversion was designed with an abstract network layer. This means that a repository can be programmatically accessed by any sort of server process, and the client <quote>repository access</quote> API allows programmers to write plugins that speak relevant network protocols. In theory, Subversion can use an infinite number of network implementations. In practice, there are only two servers at the time of this writing."
msgstr "Subversion的设计包括一个抽象的网络层，这意味着版本库可以通过各种服务器进程访问，而且客户端<quote>版本库访问</quote>的API允许程序员写出相关协议的插件，理论上讲，Subversion可以使用无限数量的网络协议实现，目前实践中存在着两种服务器。"

#: build/en/book.xml:12631(para)
#, fuzzy
msgid "Apache is an extremely popular webserver; using the <command moreinfo=\"none\">mod_dav_svn</command> module, Apache can access a repository and make it available to clients via the WebDAV/DeltaV protocol, which is an extension of HTTP. Because Apache is an extremely extensible web server, it provides a number of features <quote>for free</quote>, such as encrypted SSL communication, logging, integration with a number of third-party authentication systems, and limited built-in web browsing of repositories."
msgstr "Apache是最流行的web服务器，通过使用<command moreinfo=\"none\">mod_dav_svn</command>模块，Apache可以访问版本库，并且可以使客户端使用HTTP的扩展协议WebDAV/DeltaV进行访问，另一个是<command moreinfo=\"none\">svnserve</command>：一个小的，独立服务器，使用自己定义的协议和客户端，表格6-1比较了这两种服务器。"

#: build/en/book.xml:12641(para)
msgid "In the other corner is <command moreinfo=\"none\">svnserve</command>: a small, lightweight server program that speaks a custom protocol with clients. Because its protocol is explicitly designed for Subversion and is stateful (unlike HTTP), it provides significantly faster network operations—but at the cost of some features as well. It only understands CRAM-MD5 authentication, has no logging, no web-browsing, and no option to encrypt network traffic. It is, however, extremely easy to set up and is often the best option for small teams just starting out with Subversion."
msgstr ""

#: build/en/book.xml:12652(para)
msgid "A third option is to use <command moreinfo=\"none\">svnserve</command> tunneled over an SSH connection. Even though this scenario still uses <command moreinfo=\"none\">svnserve</command>, it differs quite a bit in features from a traditional <command moreinfo=\"none\">svnserve</command> deployment. SSH is used to encrypt all communication. SSH is also used exclusively to authenticate, so real system accounts are required on the server host (unlike vanilla <command moreinfo=\"none\">svnserve</command>, which has its own private user accounts.) Finally, because this setup requires that each user spawn a private, temporary <command moreinfo=\"none\">svnserve</command> process, it's equivalent (from a permissions point of view) to allowing a group of local users to all access the repository via <literal moreinfo=\"none\">file://</literal> URLs. Path-based access control has no meaning, since each user is accessing the repository database files directly."
msgstr ""

#: build/en/book.xml:12668(para)
msgid "Here's a quick summary of the three typical server deployments."
msgstr ""

#: build/en/book.xml:12672(title)
msgid "Comparison of Subversion Server Options"
msgstr "Subversion 服务器选项比较"

#: build/en/book.xml:12677(entry)
msgid "Apache + mod_dav_svn"
msgstr "Apache + mod_dav_svn"

#: build/en/book.xml:12679(entry)
msgid "svnserve over SSH"
msgstr "svnserve over SSH"

#: build/en/book.xml:12684(entry)
msgid "Authentication options"
msgstr "认证选项"

#: build/en/book.xml:12685(entry)
msgid "HTTP(S) basic auth, X.509 certificates, LDAP, NTLM, or any other mechanism available to Apache httpd"
msgstr "HTTP(S) basic auth、X.509 certificates、LDAP、NTLM或任何Apache httpd已经具备的方式"

#: build/en/book.xml:12687(entry)
msgid "CRAM-MD5"
msgstr "CRAM-MD5"

#: build/en/book.xml:12688(entry)
msgid "SSH"
msgstr "SSH"

#: build/en/book.xml:12692(entry)
msgid "User account options"
msgstr "用户帐号选项"

#: build/en/book.xml:12693(entry) build/en/book.xml:12694(entry)
msgid "private 'users' file"
msgstr "私有的'users'文件"

#: build/en/book.xml:12695(entry)
msgid "system accounts"
msgstr "系统帐号"

#: build/en/book.xml:12699(entry)
msgid "Authorization options"
msgstr "授权选项"

#: build/en/book.xml:12700(entry) build/en/book.xml:12702(entry)
msgid "read/write access can be granted over whole repository, or specified per-path."
msgstr ""

#: build/en/book.xml:12704(entry)
msgid "read/write access only grantable over whole repository"
msgstr ""

#: build/en/book.xml:12709(entry)
msgid "Encryption"
msgstr "加密"

#: build/en/book.xml:12710(entry)
msgid "via optional SSL"
msgstr "通过可选的 SSL"

#: build/en/book.xml:12711(entry)
msgid "none"
msgstr "无"

#: build/en/book.xml:12712(entry)
msgid "SSH tunneled"
msgstr ""

#: build/en/book.xml:12716(entry)
msgid "Logging"
msgstr "日志"

#: build/en/book.xml:12718(quote)
msgid "high-level"
msgstr ""

#: build/en/book.xml:12717(entry)
msgid "full Apache logs of each HTTP request, with optional <placeholder-1/> logging of general client operations"
msgstr ""

#: build/en/book.xml:12720(entry) build/en/book.xml:12721(entry)
msgid "no logging"
msgstr ""

#: build/en/book.xml:12725(entry)
msgid "Interoperability"
msgstr "交互性"

#: build/en/book.xml:12726(entry)
msgid "partially usable by other WebDAV clients"
msgstr "可以部分的被其他WebDAV客户端使用"

#: build/en/book.xml:12727(entry) build/en/book.xml:12728(entry)
msgid "only talks to svn clients"
msgstr ""

#: build/en/book.xml:12732(entry)
msgid "Web viewing"
msgstr "Web浏览能力"

#: build/en/book.xml:12733(entry)
msgid "limited built-in support, or via 3rd-party tools such as ViewVC"
msgstr "有限的内置支持，或者通过第三方工具，如ViewVC"

#: build/en/book.xml:12735(entry) build/en/book.xml:12736(entry)
msgid "only via 3rd-party tools such as ViewVC"
msgstr "只有通过第三方工具，如 ViewVC"

#: build/en/book.xml:12740(entry)
msgid "Speed"
msgstr "速度"

#: build/en/book.xml:12741(entry)
msgid "somewhat slower"
msgstr "有些慢"

#: build/en/book.xml:12742(entry) build/en/book.xml:12743(entry)
msgid "somewhat faster"
msgstr "快一点"

#: build/en/book.xml:12747(entry) build/en/book.xml:13609(title)
msgid "Initial setup"
msgstr "初始设置"

#: build/en/book.xml:12748(entry)
msgid "somewhat complex"
msgstr "有些复杂"

#: build/en/book.xml:12749(entry)
msgid "extremely simple"
msgstr "极为简单"

#: build/en/book.xml:12750(entry)
msgid "moderately simple"
msgstr "相当简单"

#: build/en/book.xml:12761(title)
msgid "Choosing a Server Configuration"
msgstr "选择一个服务器配置"

#: build/en/book.xml:12763(para)
msgid "So, which server should you use? Which is best?"
msgstr ""

#: build/en/book.xml:12765(para)
msgid "Obviously, there's no right answer to that question. Every team has different needs, and the different servers all represent different sets of tradeoffs. The Subversion project itself doesn't endorse one server or another, or consider either server more <quote>official</quote> than another."
msgstr ""

#: build/en/book.xml:12771(para)
msgid "Here are some reasons why you might choose one deployment over another, as well as reasons you might <emphasis>not</emphasis> choose one."
msgstr ""

#: build/en/book.xml:12777(title)
msgid "The <command moreinfo=\"none\">svnserve</command> Server"
msgstr "<command moreinfo=\"none\">svnserve</command> 服务器"

#: build/en/book.xml:12781(term) build/en/book.xml:12832(term)
#: build/en/book.xml:12880(term)
msgid "Why you might want to use it:"
msgstr ""

#: build/en/book.xml:12785(para)
msgid "Quick and easy to set up."
msgstr ""

#: build/en/book.xml:12788(para) build/en/book.xml:12836(para)
msgid "Network protocol is stateful and noticeably faster than WebDAV."
msgstr ""

#: build/en/book.xml:12791(para) build/en/book.xml:12888(para)
msgid "No need to create system accounts on server."
msgstr ""

#: build/en/book.xml:12794(para)
msgid "Password is not passed over the network."
msgstr ""

#: build/en/book.xml:12802(term) build/en/book.xml:12850(term)
#: build/en/book.xml:12911(term)
msgid "Why you might want to avoid it:"
msgstr ""

#: build/en/book.xml:12806(para)
msgid "Network protocol is not encrypted."
msgstr ""

#: build/en/book.xml:12809(para) build/en/book.xml:12854(para)
msgid "Only one choice of authentication method."
msgstr "只有一个认证方法选择。"

#: build/en/book.xml:12812(para)
msgid "Password is stored in the clear on the server."
msgstr "在这个服务器上明文保存密码。"

#: build/en/book.xml:12815(para) build/en/book.xml:12857(para)
msgid "No logging of any kind, not even errors."
msgstr ""

#: build/en/book.xml:12828(title)
msgid "<command moreinfo=\"none\">svnserve</command> over SSH"
msgstr "<command moreinfo=\"none\">svnserve</command> 使用 SSH 隧道"

#: build/en/book.xml:12839(para)
msgid "You can take advantage of existing ssh accounts and user infrastructure."
msgstr ""

#: build/en/book.xml:12842(para)
msgid "All network traffic is encrypted."
msgstr ""

#: build/en/book.xml:12860(para)
msgid "Requires users to be in same system group, or use a shared ssh key."
msgstr ""

#: build/en/book.xml:12863(para)
msgid "Can lead to file permissions problems."
msgstr ""

#: build/en/book.xml:12876(title)
msgid "The Apache HTTP Server"
msgstr "Apache 的 HTTP 服务器"

#: build/en/book.xml:12884(para)
msgid "Allows Subversion to use any of the numerous authentication systems already integrated with Apache."
msgstr ""

#: build/en/book.xml:12891(para)
msgid "Full Apache logging."
msgstr ""

#: build/en/book.xml:12893(para)
msgid "Network traffic can be encrypted via SSL."
msgstr ""

#: build/en/book.xml:12896(para)
msgid "HTTP(S) can usually go through corporate firewalls."
msgstr ""

#: build/en/book.xml:12899(para)
msgid "Built-in repository browsing via web browser."
msgstr ""

#: build/en/book.xml:12902(para)
#, fuzzy
msgid "Repository can be mounted as a network drive for transparent version control. (See <xref linkend=\"svn.webdav.autoversioning\"/>.)"
msgstr "如果出现，则修订版本是通过自动版本化特性创建，见<xref linkend=\"svn.webdav.autoversioning\"/>。"

#: build/en/book.xml:12915(para)
msgid "Noticeably slower than svnserve, because HTTP is a stateless protocol and requires more turnarounds."
msgstr ""

#: build/en/book.xml:12919(para)
msgid "Initial setup can be complex."
msgstr "初始设置可能复杂"

#: build/en/book.xml:12931(title)
msgid "Recommendations"
msgstr "推荐"

#: build/en/book.xml:12933(para)
msgid "In general, the authors of this book recommend a vanilla <command moreinfo=\"none\">svnserve</command> installation for small teams just trying to get started with a Subversion server; it's the simplest to set up, and has the fewest maintenance issues. Remember, you can always switch to a more complex server deployment as your needs change."
msgstr ""

#: build/en/book.xml:12940(para)
msgid "Here are some general recommendations and tips, based on years of supporting users:"
msgstr ""

#: build/en/book.xml:12945(para)
msgid "If you're trying to set up the simplest possible server for your group, then a vanilla <command moreinfo=\"none\">svnserve</command> installation is the easiest, fastest route. Note, however, that your repository data will be transmitted in the clear over the network. If your deployment is entirely within your company's LAN or VPN, this isn't an issue. If the repository is exposed to the wide-open internet, then you might want to make sure the repository's contents aren't sensitive (e.g. it contains only open-source code.)"
msgstr ""

#: build/en/book.xml:12958(para)
msgid "If you need to integrate with existing identity systems (LDAP, Active Directory, NTLM, X.509, etc.), then an Apache-based server is your only real option. Similarly, if you absolutely need server-side logs of either server errors or client activities, then an Apache-based server is required."
msgstr ""

#: build/en/book.xml:12967(para)
msgid "If you've decided to use either Apache or stock <command moreinfo=\"none\">svnserve</command>, create a single <literal moreinfo=\"none\">svn</literal> user on your system and run the server process as that user. Be sure to make the repository directory wholly owned by the <literal moreinfo=\"none\">svn</literal> user as well. From a security point of view, this keeps the repository data nicely siloed and protected by operating system filesystem permissions, changeable by only the Subversion server process itself."
msgstr ""

#: build/en/book.xml:12980(para)
msgid "If you have an existing infrastructure heavily based on SSH accounts, and if your users already have system accounts on your server machine, then it makes sense to deploy an svnserve-over-ssh solution. Otherwise, we don't widely recommend this option to the public. It's generally considered safer to have your users access the repository via (imaginary) accounts managed by <command moreinfo=\"none\">svnserve</command> or Apache, rather than by full-blown system accounts. If your deep desire for encrypted communication still draws you to this option, we recommend using Apache with SSL instead."
msgstr ""

#: build/en/book.xml:12994(para)
msgid "Do <emphasis>not</emphasis> be seduced by the simple idea of having all of your users access a repository directly via <literal moreinfo=\"none\">file://</literal> URLs. Even if the repository is readily available to everyone via network share, this is a bad idea. It removes any layers of protection between the users and the repository: users can accidentally (or intentionally) corrupt the repository database, it becomes hard to take the repository offline for inspection or upgrade, and it can lead to a mess of file-permissions problems (see <xref linkend=\"svn.serverconfig.multimethod\"/>.) Note that this is also one of the reasons we warn against accessing repositories via <literal moreinfo=\"none\">svn+ssh://</literal> URLs — from a security standpoint, it's effectively the same as local users accessing via <literal moreinfo=\"none\">file://</literal>, and can entail all the same problems if the administrator isn't careful."
msgstr ""

#: build/en/book.xml:13023(title)
msgid "svnserve, a custom server"
msgstr "svnserve，一个定制的服务器"

#: build/en/book.xml:13025(para)
msgid "The <command moreinfo=\"none\">svnserve</command> program is a lightweight server, capable of speaking to clients over TCP/IP using a custom, stateful protocol. Clients contact an <command moreinfo=\"none\">svnserve</command> server by using URLs that begin with the <literal moreinfo=\"none\">svn://</literal> or <literal moreinfo=\"none\">svn+ssh://</literal> schema. This section will explain the different ways of running <command moreinfo=\"none\">svnserve</command>, how clients authenticate themselves to the server, and how to configure appropriate access control to your repositories."
msgstr "<command moreinfo=\"none\">svnserve</command>是一个轻型的服务器，可以同客户端通过在TCP/IP基础上的自定义有状态协议通讯，客户端通过使用开头为<literal moreinfo=\"none\">svn://</literal>或者<literal moreinfo=\"none\">svn+ssh://</literal><command moreinfo=\"none\">svnserve</command>的URL来访问一个<command moreinfo=\"none\">svnserve</command>服务器。这一小节将会解释运行<command moreinfo=\"none\">svnserve</command>的不同方式，客户端怎样实现服务器的认证，怎样配置版本库恰当的访问控制。"

#: build/en/book.xml:13037(title)
msgid "Invoking the Server"
msgstr "调用服务器"

#: build/en/book.xml:13039(para)
#, fuzzy
msgid "There are a few different ways to run the <command moreinfo=\"none\">svnserve</command> program:"
msgstr "这是使用<command moreinfo=\"none\">svn revert</command>的好机会。"

#: build/en/book.xml:13043(para)
#, fuzzy
msgid "Run <command moreinfo=\"none\">svnserve</command> as a standalone daemon, listening for requests."
msgstr "<command moreinfo=\"none\">svnlook</command> 的语法很直接："

#: build/en/book.xml:13046(para)
#, fuzzy
msgid "Have the Unix <command moreinfo=\"none\">inetd</command> daemon temporarily spawn <command moreinfo=\"none\">svnserve</command> whenever a request comes in on a certain port."
msgstr "像<command moreinfo=\"none\">svnserve</command>，<command moreinfo=\"none\">svnversion</command>没有子命令，只有选项。"

#: build/en/book.xml:13049(para)
#, fuzzy
msgid "Have SSH invoke a temporary <command moreinfo=\"none\">svnserve</command> over an encrypted tunnel."
msgstr "如果一个客户端连接到<command moreinfo=\"none\">svnserve</command>进程，如下事情会发生："

#: build/en/book.xml:13052(para)
#, fuzzy
msgid "Run <command moreinfo=\"none\">svnserve</command> as a Windows service."
msgstr "<command moreinfo=\"none\">svnserve</command>选项"

#: build/en/book.xml:13058(title)
msgid "<command moreinfo=\"none\">svnserve</command> as Daemon"
msgstr "<command moreinfo=\"none\">svnserve</command> 作为后台程序"

#: build/en/book.xml:13060(para)
#, fuzzy
msgid "The easiest option is to run <command moreinfo=\"none\">svnserve</command> as a standalone <quote>daemon</quote> process. Use the <option>-d</option> option for this:"
msgstr "<command moreinfo=\"none\">svnserve</command>的第二个选项是作为独立<quote>守护</quote>进程，为此要使用<option>-d</option>选项："

#: build/en/book.xml:13064(screen)
#, no-wrap
msgid ""
"\n"
"$ svnserve -d\n"
"$               # svnserve is now running, listening on port 3690\n"
msgstr ""
"\n"
"$ svnserve -d\n"
"$               # svnserve is now running, listening on port 3690\n"

#: build/en/book.xml:13069(para)
msgid "When running <command moreinfo=\"none\">svnserve</command> in daemon mode, you can use the <option>--listen-port=</option> and <option>--listen-host=</option> options to customize the exact port and hostname to <quote>bind</quote> to."
msgstr "当以守护模式运行<command moreinfo=\"none\">svnserve</command>时，你可以使用<option>--listen-port=</option>和<option>--listen-host=</option>选项来自定义<quote>绑定</quote>的端口和主机名。"

#: build/en/book.xml:13074(para)
#, fuzzy
msgid "Once the <command moreinfo=\"none\">svnserve</command> program is running, it makes every repository on your system available to the network. A client needs to specify an <emphasis>absolute</emphasis> path in the repository URL. For example, if a repository is located at <filename moreinfo=\"none\">/usr/local/repositories/project1</filename>, then a client would reach it via <uri>svn://host.example.com/usr/local/repositories/project1</uri>. To increase security, you can pass the <option>-r</option> option to <command moreinfo=\"none\">svnserve</command>, which restricts it to exporting only repositories below that path. For example:"
msgstr "一旦<command moreinfo=\"none\">svnserve</command>已经运行，它会将你系统中所有版本库发布到网络，一个客户端需要指定版本库在URL中的<emphasis>绝对</emphasis>路径，举个例子，如果一个版本库是位于<filename moreinfo=\"none\">/usr/local/repositories/project1</filename>，则一个客户端可以使用<systemitem class=\"url\" moreinfo=\"none\">svn://host.example.com/usr/local/repositories/project1 </systemitem>来进行访问，为了提高安全性，你可以使用<command moreinfo=\"none\">svnserve</command>的<option>-r</option>选项，这样会限制只输出指定路径下的版本库："

#: build/en/book.xml:13086(screen)
#, no-wrap
msgid ""
"\n"
"$ svnserve -d -r /usr/local/repositories\n"
"…\n"
msgstr ""
"\n"
"$ svnserve -d -r /usr/local/repositories\n"
"…\n"

#: build/en/book.xml:13091(para)
msgid "Using the <option>-r</option> option effectively modifies the location that the program treats as the root of the remote filesystem space. Clients then use URLs that have that path portion removed from them, leaving much shorter (and much less revealing) URLs:"
msgstr "使用<option>-r</option>可以有效地改变文件系统的根位置，客户端可以使用去掉前半部分的路径，留下的要短一些的（更加有提示性）URL："

#: build/en/book.xml:13097(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout svn://host.example.com/project1\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout svn://host.example.com/project1\n"
"…\n"

#: build/en/book.xml:13106(title)
msgid "<command moreinfo=\"none\">svnserve</command> via <command moreinfo=\"none\">inetd</command>"
msgstr "使用 <command moreinfo=\"none\">svnserve</command> 通过 <command moreinfo=\"none\">inetd</command>"

#: build/en/book.xml:13108(para)
#, fuzzy
msgid "If you want <command moreinfo=\"none\">inetd</command> launch the process, then you can pass the <option>-i</option> (<option>--inetd</option>) option:"
msgstr "还有一个<command moreinfo=\"none\">proplist</command>变种命令会列出所有属性的名称和值，只需要设置<option>--verbose</option>（<option>-v</option>）选项。"

#: build/en/book.xml:13112(screen)
#, no-wrap
msgid ""
"\n"
"$ svnserve -i\n"
"( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )\n"
msgstr ""
"\n"
"$ svnserve -i\n"
"( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )\n"

#: build/en/book.xml:13117(para)
msgid "When invoked with the <option>--inetd</option> option, <command moreinfo=\"none\">svnserve</command> attempts to speak with a Subversion client via <emphasis>stdin</emphasis> and <emphasis>stdout</emphasis> using a custom protocol. This is the standard behavior for a program being run via <command moreinfo=\"none\">inetd</command>. The IANA has reserved port 3690 for the Subversion protocol, so on a Unix-like system you can add lines to <filename moreinfo=\"none\">/etc/services</filename> like these (if they don't already exist):"
msgstr "当用参数<option>--inetd</option>调用时，<command moreinfo=\"none\">svnserve</command>会尝试使用自定义协议通过<emphasis>stdin</emphasis>和<emphasis>stdout</emphasis>来与Subversion客户端通话，这是使用<command moreinfo=\"none\">inetd</command>工作的标准方式，IANA为Subversion协议保留3690端口，所以在类Unix系统你可以在<filename moreinfo=\"none\">/etc/services</filename>添加如下的几行（如果他们还不存在）："

#: build/en/book.xml:13127(screen)
#, no-wrap
msgid ""
"\n"
"svn           3690/tcp   # Subversion\n"
"svn           3690/udp   # Subversion\n"
msgstr ""
"\n"
"svn           3690/tcp   # Subversion\n"
"svn           3690/udp   # Subversion\n"

#: build/en/book.xml:13132(para)
msgid "And if your system is using a classic Unix-like <command moreinfo=\"none\">inetd</command> daemon, you can add this line to <filename moreinfo=\"none\">/etc/inetd.conf</filename>:"
msgstr "如果系统是使用经典的类Unix的<command moreinfo=\"none\">inetd</command>守护进程，你可以在<filename moreinfo=\"none\">/etc/inetd.conf</filename>添加这几行："

#: build/en/book.xml:13136(screen)
#, no-wrap
msgid ""
"\n"
"svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i\n"
msgstr ""
"\n"
"svn stream tcp nowait svnowner /usr/bin/svnserve svnserve -i\n"

#: build/en/book.xml:13140(para)
#, fuzzy
msgid "Make sure <quote>svnowner</quote> is a user which has appropriate permissions to access your repositories. Now, when a client connection comes into your server on port 3690, <command moreinfo=\"none\">inetd</command> will spawn an <command moreinfo=\"none\">svnserve</command> process to service it. Of course, you may also want to add <option>-r</option> to the configuration line as well, to restrict which repositories are exported."
msgstr "确定<quote>svnowner</quote>用户拥有访问版本库的适当权限，现在如果一个客户连接来到你的服务器的端口3690，<command moreinfo=\"none\">inetd</command>会产生一个<command moreinfo=\"none\">svnserve</command>进程来做服务。"

#: build/en/book.xml:13153(title)
msgid "<command moreinfo=\"none\">svnserve</command> over a Tunnel"
msgstr "通过隧道 <command moreinfo=\"none\">svnserve</command>"

#: build/en/book.xml:13155(para)
#, fuzzy
msgid "A third way to invoke <command moreinfo=\"none\">svnserve</command> is in <quote>tunnel mode</quote>, with the <option>-t</option> option. This mode assumes that a remote-service program such as <command moreinfo=\"none\">RSH</command> or <command moreinfo=\"none\">SSH</command> has successfully authenticated a user and is now invoking a private <command moreinfo=\"none\">svnserve</command> process <emphasis>as that user</emphasis>. The <command moreinfo=\"none\">svnserve</command> program behaves normally (communicating via <emphasis>stdin</emphasis> and <emphasis>stdout</emphasis>), and assumes that the traffic is being automatically redirected over some sort of tunnel back to the client. When <command moreinfo=\"none\">svnserve</command> is invoked by a tunnel agent like this, be sure that the authenticated user has full read and write access to the repository database files. It's essentially the same as a local user accessing the repository via <literal moreinfo=\"none\">file://</literal> URLs."
msgstr "也一直有第三种方式，使用<option>-t</option>选项的<quote>管道模式</quote>，这个模式假定一个分布式服务程序如<command moreinfo=\"none\">RSH</command>或<command moreinfo=\"none\">SSH</command>已经验证了一个用户，并且<emphasis>以这个用户</emphasis>调用了一个私有<command moreinfo=\"none\">svnserve</command>进程，<command moreinfo=\"none\">svnserve</command>运作如常（通过<emphasis>stdin</emphasis>和<emphasis>stdout</emphasis>通讯），并且可以设想通讯是自动转向到一种通道传递回客户端，当<command moreinfo=\"none\">svnserve</command>被这样的通道代理调用，确定认证用户对版本数据库有完全的读写权限，（见<xref linkend=\"svn.serverconfig.svnserve.invoking.sb-1\"/>。）这与本地用户通过<literal moreinfo=\"none\">file:///</literal>URl访问版本库同样重要。"

#: build/en/book.xml:13172(para)
msgid "This option is described in much more detail in <xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>."
msgstr ""

#: build/en/book.xml:13179(title)
msgid "<command moreinfo=\"none\">svnserve</command> as Windows Service"
msgstr "<command moreinfo=\"none\">svnserve</command> 作为 Windows 服务"

#: build/en/book.xml:13181(para)
msgid "If your Windows system is a descendant of Windows NT (2000, 2003, XP, Vista), then you can run <command moreinfo=\"none\">svnserve</command> as a standard Windows service. This is typically a much nicer experience than running it as a standalone daemon with the <option>--daemon (-d)</option> option. Using daemon-mode requires launching a console, typing a command, and then leaving the console window running indefinitely. A Windows service, however, runs in the background, can start at boot time automatically, and can be started and stopped using the same consistent administration interface as other Windows services."
msgstr ""

#: build/en/book.xml:13194(para)
msgid "You'll need to define the new service using the command-line tool <command moreinfo=\"none\">SC.EXE</command>. Much like the <command moreinfo=\"none\">inetd</command> configuration line, you must specify an exact invocation of <command moreinfo=\"none\">svnserve</command> for Windows to run at start-up time:"
msgstr ""

#: build/en/book.xml:13200(screen)
#, no-wrap
msgid ""
"\n"
"C:\\&gt; sc create svn\n"
"        binpath= \"C:\\svn\\bin\\svnserve.exe --service -r C:\\repos\"\n"
"        displayname= \"Subversion Server\"\n"
"        depend= Tcpip\n"
"        start= auto\n"
msgstr ""
"\n"
"C:\\&gt; sc create svn\n"
"        binpath= \"C:\\svn\\bin\\svnserve.exe --service -r C:\\repos\"\n"
"        displayname= \"Subversion Server\"\n"
"        depend= Tcpip\n"
"        start= auto\n"

#: build/en/book.xml:13208(para)
msgid "This defines a new Windows service named <quote>svn</quote>, and which executes a particular <command moreinfo=\"none\">svnserve.exe</command> command when started (in this case, rooted at <filename moreinfo=\"none\">C:\\repos</filename>.) There are a number of caveats in the prior example, however."
msgstr ""

#: build/en/book.xml:13215(para)
msgid "First, notice that the <command moreinfo=\"none\">svnserve.exe</command> program must always be invoked with the <option>--service</option> option. Any other options to <command moreinfo=\"none\">svnserve</command> must then be specified on the same line, but you cannot add conflicting options such as <option>--daemon (-d)</option>, <option>--tunnel</option>, or <option>--inetd (-i)</option>. Options such as <option>-r</option> or <option>--listen-port</option> are fine, though. Second, be careful about spaces when invoking the <command moreinfo=\"none\">SC.EXE</command> command: the <literal moreinfo=\"none\">key= value</literal> patterns must have no spaces between <literal moreinfo=\"none\">key=</literal> and exactly one space before the <literal moreinfo=\"none\">value</literal>. Lastly, be careful about spaces in your command-line to be invoked. If a directory name contains spaces (or other characters that need escaping), place the entire inner value of <literal moreinfo=\"none\">binpath</literal> in double-quotes, by escaping them:"
msgstr ""

#: build/en/book.xml:13235(screen)
#, no-wrap
msgid ""
"\n"
"C:\\&gt; sc create svn\n"
"        binpath= \"\\\"C:\\program files\\svn\\bin\\svnserve.exe\\\" --service -r C:\\repos\"\n"
"        displayname= \"Subversion Server\"\n"
"        depend= Tcpip\n"
"        start= auto\n"
msgstr ""
"\n"
"C:\\&gt; sc create svn\n"
"        binpath= \"\\\"C:\\program files\\svn\\bin\\svnserve.exe\\\" --service -r C:\\repos\"\n"
"        displayname= \"Subversion Server\"\n"
"        depend= Tcpip\n"
"        start= auto\n"

#: build/en/book.xml:13243(para)
msgid "Once the service is defined, it can stopped, started, or queried using standard GUI tools (The Services administrative control panel), or at the command line as well:"
msgstr ""

#: build/en/book.xml:13248(screen)
#, no-wrap
msgid ""
"\n"
"C:\\&gt; net stop svn\n"
"C:\\&gt; net start svn\n"
msgstr ""
"\n"
"C:\\&gt; net stop svn\n"
"C:\\&gt; net start svn\n"

#: build/en/book.xml:13253(para)
msgid "The service can also be uninstalled (i.e. undefined) by deleting its definition: <literal moreinfo=\"none\">sc delete svn</literal>. Just be sure to stop the service first! The <command moreinfo=\"none\">SC.EXE</command> program has many other subcommands and options, run <literal moreinfo=\"none\">sc /?</literal> to learn more about it."
msgstr ""

#: build/en/book.xml:13266(title)
msgid "Built-in authentication and authorization"
msgstr "内置的认证和授权"

#: build/en/book.xml:13268(para)
msgid "When a client connects to an <command moreinfo=\"none\">svnserve</command> process, the following things happen:"
msgstr "如果一个客户端连接到<command moreinfo=\"none\">svnserve</command>进程，如下事情会发生："

#: build/en/book.xml:13272(para)
msgid "The client selects a specific repository."
msgstr "客户端选择特定的版本库。"

#: build/en/book.xml:13275(para)
msgid "The server processes the repository's <filename moreinfo=\"none\">conf/svnserve.conf</filename> file, and begins to enforce any authentication and authorization policies defined therein."
msgstr "服务器处理版本库的<filename moreinfo=\"none\">conf/svnserve.conf</filename>文件，并且执行里面定义的所有认证和授权政策。"

#: build/en/book.xml:13280(para)
msgid "Depending on the situation and authorization policies,"
msgstr "依赖于位置和授权政策，"

#: build/en/book.xml:13284(para)
msgid "the client may be allowed to make requests anonymously, without ever receiving an authentication challenge, OR"
msgstr "如果没有收到认证请求，客户端可能被允许匿名访问，或者"

#: build/en/book.xml:13288(para)
msgid "the client may be challenged for authentication at any time, OR"
msgstr "客户端收到认证请求，或者"

#: build/en/book.xml:13291(para)
msgid "if operating in <quote>tunnel mode</quote>, the client will declare itself to be already externally authenticated."
msgstr "如果操作在<quote>通道模式</quote>，客户端会宣布自己已经在外部得到认证。"

#: build/en/book.xml:13300(para)
msgid "See RFC 2195."
msgstr "见RFC 2195。"

#: build/en/book.xml:13299(para)
#, fuzzy
msgid "At the time of writing, the server only knows how to send a CRAM-MD5 <placeholder-1/> authentication challenge. In essence, the server sends a small amount of data to the client. The client uses the MD5 hash algorithm to create a fingerprint of the data and password combined, then sends the fingerprint as a response. The server performs the same computation with the stored password to verify that the result is identical. <emphasis>At no point does the actual password travel over the network.</emphasis>"
msgstr "在撰写本文时，服务器还只知道怎样发送CRAM-MD5<placeholder-1/>认证请求，本质上讲，就是服务器发送一些数据到客户端，客户端使用MD5哈希算法创建这些数据组合密码的指纹，然后返回指纹，服务器执行同样的计算并且来计算结果的一致性，<emphasis>真正的密码并没有在互联网上传递。</emphasis>"

#: build/en/book.xml:13310(para)
msgid "It's also possible, of course, for the client to be externally authenticated via a tunnel agent, such as <command moreinfo=\"none\">SSH</command>. In that case, the server simply examines the user it's running as, and uses it as the authenticated username. For more on this, see <xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>."
msgstr "当然也有可能，如果客户端在外部通过通道代理认证，如<command moreinfo=\"none\">SSH</command>，在那种情况下，服务器简单的检验作为那个用户的运行，然后使用它作为认证用户名，更多信息请看<xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>。"

#: build/en/book.xml:13316(para)
msgid "As you've already guessed, a repository's <filename moreinfo=\"none\">svnserve.conf</filename> file is the central mechanism for controlling authentication and authorization policies. The file has the same format as other configuration files (see <xref linkend=\"svn.advanced.confarea\"/>): section names are marked by square brackets (<literal moreinfo=\"none\">[</literal> and <literal moreinfo=\"none\">]</literal>), comments begin with hashes (<literal moreinfo=\"none\">#</literal>), and each section contains specific variables that can be set (<literal moreinfo=\"none\">variable = value</literal>). Let's walk through this file and learn how to use them."
msgstr "像你已经猜测到的，版本库的<filename moreinfo=\"none\">svnserve.conf</filename>文件是控制认证和授权政策的中央机构，这文件与其它配置文件格式相同（见<xref linkend=\"svn.advanced.confarea\"/>）：小节名称使用方括号标记（<literal moreinfo=\"none\">[</literal>和<literal moreinfo=\"none\">]</literal>），注释以井号（<literal moreinfo=\"none\">#</literal>）开始，每一小节都有一些参数可以设置（<literal moreinfo=\"none\">variable = value</literal>），让我们浏览这个文件并且学习怎样使用它们。"

#: build/en/book.xml:13330(title)
msgid "Create a 'users' file and realm"
msgstr "创建一个用户文件和认证域"

#: build/en/book.xml:13332(para)
msgid "For now, the <literal moreinfo=\"none\">[general]</literal> section of the <filename moreinfo=\"none\">svnserve.conf</filename> has all the variables you need. Begin by defining a file which contains usernames and passwords, and an authentication realm:"
msgstr "此时，<filename moreinfo=\"none\">svnserve.conf</filename>文件的<literal moreinfo=\"none\">[general]</literal>部分包括所有你需要的变量，开始先定义一个保存用户名和密码的文件和一个认证域："

#: build/en/book.xml:13337(screen)
#, no-wrap
msgid ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
msgstr ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"

#: build/en/book.xml:13343(para)
msgid "The <literal moreinfo=\"none\">realm</literal> is a name that you define. It tells clients which sort of <quote>authentication namespace</quote> they're connecting to; the Subversion client displays it in the authentication prompt, and uses it as a key (along with the server's hostname and port) for caching credentials on disk (see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>). The <literal moreinfo=\"none\">password-db</literal> variable points to a separate file that contains a list of usernames and passwords, using the same familiar format. For example:"
msgstr "<literal moreinfo=\"none\">realm</literal>是你定义的名称，这告诉客户端连接的<quote>认证命名空间</quote>，Subversion会在认证提示里显示，并且作为凭证缓存（见<xref linkend=\"svn.serverconfig.netmodel.credcache\"/>。）的关键字（还有服务器的主机名和端口），<literal moreinfo=\"none\">password-db</literal>参数指出了保存用户和密码列表文件，这个文件使用同样熟悉的格式，举个例子："

#: build/en/book.xml:13353(screen)
#, no-wrap
msgid ""
"\n"
"[users]\n"
"harry = foopassword\n"
"sally = barpassword\n"
msgstr ""
"\n"
"[users]\n"
"harry = foopassword\n"
"sally = barpassword\n"

#: build/en/book.xml:13359(para)
msgid "The value of <literal moreinfo=\"none\">password-db</literal> can be an absolute or relative path to the users file. For many admins, it's easy to keep the file right in the <filename moreinfo=\"none\">conf/</filename> area of the repository, alongside <filename moreinfo=\"none\">svnserve.conf</filename>. On the other hand, it's possible you may want to have two or more repositories share the same users file; in that case, the file should probably live in a more public place. The repositories sharing the users file should also be configured to have the same realm, since the list of users essentially defines an authentication realm. Wherever the file lives, be sure to set the file's read and write permissions appropriately. If you know which user(s) <command moreinfo=\"none\">svnserve</command> will run as, restrict read access to the user file as necessary."
msgstr "<literal moreinfo=\"none\">password-db</literal>的值可以是用户文件的绝对或相对路径，对许多管理员来说，把文件保存在版本库<filename moreinfo=\"none\">conf/</filename>下的<filename moreinfo=\"none\">svnserve.conf</filename>旁边是一个简单的方法。另一方面，可能你的多个版本库使用同一个用户文件，此时，这个文件应该在更公开的地方，版本库分享用户文件时必须配置为相同的域，因为用户列表本质上定义了一个认证域，无论这个文件在哪里，必须设置好文件的读写权限，如果你知道运行<command moreinfo=\"none\">svnserve</command>的用户，限定这个用户对这个文件有读权限是必须的。"

#: build/en/book.xml:13378(title)
msgid "Set access controls"
msgstr "设置访问控制"

#: build/en/book.xml:13380(para)
msgid "There are two more variables to set in the <filename moreinfo=\"none\">svnserve.conf</filename> file: they determine what unauthenticated (anonymous) and authenticated users are allowed to do. The variables <literal moreinfo=\"none\">anon-access</literal> and <literal moreinfo=\"none\">auth-access</literal> can be set to the values <literal moreinfo=\"none\">none</literal>, <literal moreinfo=\"none\">read</literal>, or <literal moreinfo=\"none\">write</literal>. Setting the value to <literal moreinfo=\"none\">none</literal> restricts all access of any kind; <literal moreinfo=\"none\">read</literal> allows read-only access to the repository, and <literal moreinfo=\"none\">write</literal> allows complete read/write access to the repository. For example:"
msgstr "<filename moreinfo=\"none\">svnserve.conf</filename>有两个或多个参数需要设置：它们确定未认证（匿名）和认证用户可以做的事情，参数<literal moreinfo=\"none\">anon-access</literal>和<literal moreinfo=\"none\">auth-access</literal>可以设置为<literal moreinfo=\"none\">none</literal>、<literal moreinfo=\"none\">read</literal>或者<literal moreinfo=\"none\">write</literal>，设置为<literal moreinfo=\"none\">none</literal>会限制所有方式的访问，<literal moreinfo=\"none\">read</literal>允许只读访问，而<literal moreinfo=\"none\">write</literal>允许对版本库完全的读/写权限："

#: build/en/book.xml:13392(screen)
#, no-wrap
msgid ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# anonymous users can only read the repository\n"
"anon-access = read\n"
"\n"
"# authenticated users can both read and write\n"
"auth-access = write\n"
msgstr ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# anonymous users can only read the repository\n"
"anon-access = read\n"
"\n"
"# authenticated users can both read and write\n"
"auth-access = write\n"

#: build/en/book.xml:13404(para)
msgid "The example settings are, in fact, the default values of the variables, should you forget to define them. If you want to be even more conservative, you can block anonymous access completely:"
msgstr "实例中的设置实际上是参数的缺省值，你一定不要忘了设置它们，如果你希望更保守一点，你可以完全封锁匿名访问："

#: build/en/book.xml:13409(screen)
#, no-wrap
msgid ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# anonymous users aren't allowed\n"
"anon-access = none\n"
"\n"
"# authenticated users can both read and write\n"
"auth-access = write\n"
msgstr ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# anonymous users aren't allowed\n"
"anon-access = none\n"
"\n"
"# authenticated users can both read and write\n"
"auth-access = write\n"

#: build/en/book.xml:13421(para)
msgid "The server process not only understands these <quote>blanket</quote> access controls to the repository, but also finer-grained access restrictions placed on specific files and directories within the repository. To make use of this feature, you need to define a file containing more detailed rules, and then set the <literal moreinfo=\"none\">authz-db</literal> variable to point to it:"
msgstr ""

#: build/en/book.xml:13429(screen)
#, no-wrap
msgid ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# Specific access rules for specific locations\n"
"authz-db = authzfile\n"
msgstr ""
"\n"
"[general]\n"
"password-db = userfile\n"
"realm = example realm\n"
"\n"
"# Specific access rules for specific locations\n"
"authz-db = authzfile\n"

#: build/en/book.xml:13438(para)
msgid "The syntax of the <filename moreinfo=\"none\">authzfile</filename> file is discussed in detail in <xref linkend=\"svn.serverconfig.pathbasedauthz\"/>. Note that the <literal moreinfo=\"none\">authz-db</literal> variable isn't mutually exclusive with the <literal moreinfo=\"none\">anon-access</literal> and <literal moreinfo=\"none\">auth-access</literal> variables; if all the variables are defined at once, then <emphasis>all</emphasis> of the rules must be satisfied before access is allowed."
msgstr ""

#: build/en/book.xml:13452(title)
msgid "Tunneling over SSH"
msgstr "SSH 隧道"

#: build/en/book.xml:13454(para)
msgid "<command moreinfo=\"none\">svnserve</command>'s built-in authentication can be very handy, because it avoids the need to create real system accounts. On the other hand, some administrators already have well-established SSH authentication frameworks in place. In these situations, all of the project's users already have system accounts and the ability to <quote>SSH into</quote> the server machine."
msgstr "<command moreinfo=\"none\">svnserve</command>的内置认证会非常容易得到，因为它避免了创建真实的系统帐号，另一方面，一些管理员已经创建好了SSH认证框架，在这种情况下，所有的项目用户已经拥有了系统帐号和有能力<quote>SSH到</quote>服务器。"

#: build/en/book.xml:13462(para)
msgid "It's easy to use SSH in conjunction with <command moreinfo=\"none\">svnserve</command>. The client simply uses the <literal moreinfo=\"none\">svn+ssh://</literal> URL schema to connect:"
msgstr "SSH与<command moreinfo=\"none\">svnserve</command>结合很简单，客户端只需要使用<literal moreinfo=\"none\">svn+ssh://</literal>的URL模式来连接："

#: build/en/book.xml:13466(screen)
#, no-wrap
msgid ""
"\n"
"$ whoami\n"
"harry\n"
"\n"
"$ svn list svn+ssh://host.example.com/repos/project\n"
"harry@host.example.com's password:  *****\n"
"\n"
"foo\n"
"bar\n"
"baz\n"
"…\n"
msgstr ""
"\n"
"$ whoami\n"
"harry\n"
"\n"
"$ svn list svn+ssh://host.example.com/repos/project\n"
"harry@host.example.com's password:  *****\n"
"\n"
"foo\n"
"bar\n"
"baz\n"
"…\n"

#: build/en/book.xml:13479(para)
msgid "In this example, the Subversion client is invoking a local <command moreinfo=\"none\">ssh</command> process, connecting to <literal moreinfo=\"none\">host.example.com</literal>, authenticating as the user <literal moreinfo=\"none\">harry</literal>, then spawning a private <command moreinfo=\"none\">svnserve</command> process on the remote machine running as the user <literal moreinfo=\"none\">harry</literal>. The <command moreinfo=\"none\">svnserve</command> command is being invoked in tunnel mode (<option>-t</option>) and its network protocol is being <quote>tunneled</quote> over the encrypted connection by <command moreinfo=\"none\">ssh</command>, the tunnel-agent. <command moreinfo=\"none\">svnserve</command> is aware that it's running as the user <literal moreinfo=\"none\">harry</literal>, and if the client performs a commit, the authenticated username will be attributed as the author of the new revision."
msgstr "在这个例子里，Subversion客户端会调用一个<command moreinfo=\"none\">ssh</command>进程，连接到<literal moreinfo=\"none\">host.example.com</literal>，使用用户<literal moreinfo=\"none\">harry</literal>认证，然后会有一个<command moreinfo=\"none\">svnserve</command>私有进程以用户<literal moreinfo=\"none\">harry</literal>运行。<command moreinfo=\"none\">svnserve</command>是以管道模式调用的（<option>-t</option>），它的网络协议是通过<command moreinfo=\"none\">ssh</command><quote>封装的</quote>，被管道代理的<command moreinfo=\"none\">svnserve</command>会知道程序是以用户<literal moreinfo=\"none\">harry</literal>运行的，如果客户执行一个提交，认证的用户名会作为版本的参数保存到新的修订本。"

#: build/en/book.xml:13494(para)
msgid "The important thing to understand here is that the Subversion client is <emphasis>not</emphasis> connecting to a running <command moreinfo=\"none\">svnserve</command> daemon. This method of access doesn't require a daemon, nor does it notice one if present. It relies wholly on the ability of <command moreinfo=\"none\">ssh</command> to spawn a temporary <command moreinfo=\"none\">svnserve</command> process, which then terminates when the network connection is closed."
msgstr "这里要理解的最重要的事情是Subversion客户端<emphasis>不</emphasis>是连接到运行中的<command moreinfo=\"none\">svnserve</command>守护进程，这种访问方法不需要一个运行的守护进程，也不需要在必要时唤醒一个，它依赖于<command moreinfo=\"none\">ssh</command>来发起一个<command moreinfo=\"none\">svnserve</command>进程，然后网络断开后终止进程。"

#: build/en/book.xml:13503(para)
msgid "When using <literal moreinfo=\"none\">svn+ssh://</literal> URLs to access a repository, remember that it's the <command moreinfo=\"none\">ssh</command> program prompting for authentication, and <emphasis>not</emphasis> the <command moreinfo=\"none\">svn</command> client program. That means there's no automatic password caching going on (see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>). The Subversion client often makes multiple connections to the repository, though users don't normally notice this due to the password caching feature. When using <literal moreinfo=\"none\">svn+ssh://</literal> URLs, however, users may be annoyed by <command moreinfo=\"none\">ssh</command> repeatedly asking for a password for every outbound connection. The solution is to use a separate SSH password-caching tool like <command moreinfo=\"none\">ssh-agent</command> on a Unix-like system, or <command moreinfo=\"none\">pageant</command> on Windows."
msgstr "当使用<literal moreinfo=\"none\">svn+ssh://</literal>的URL访问版本库时，记住是<command moreinfo=\"none\">ssh</command>提示请求认证，而<emphasis>不</emphasis>是<command moreinfo=\"none\">svn</command>客户端程序。这意味着密码不会有自动缓存（见<xref linkend=\"svn.serverconfig.netmodel.credcache\"/>），Subversion客户端通常会建立多个版本库的连接，但用户通常会因为密码缓存特性而没有注意到这一点，当使用<literal moreinfo=\"none\">svn+ssh://</literal>的URL时，用户会为<command moreinfo=\"none\">ssh</command>在每次建立连接时重复的询问密码感到讨厌，解决方案是用一个独立的SSH密码缓存工具，像类Unix系统的<command moreinfo=\"none\">ssh-agent</command>或者是Windows下的<command moreinfo=\"none\">pageant</command>。"

#: build/en/book.xml:13532(para)
#, fuzzy
msgid "Note that using any sort of <command moreinfo=\"none\">svnserve</command>-enforced access control at all is a bit pointless; the user already has direct access to the repository database."
msgstr "常规的系统用户连接使用SSH调用的访问版本库的<command moreinfo=\"none\">svnserve</command>进程（以它们自己运行）；"

#: build/en/book.xml:13519(para)
#, fuzzy
msgid "When running over a tunnel, authorization is primarily controlled by operating system permissions to the repository's database files; it's very much the same as if Harry were accessing the repository directly via a <literal moreinfo=\"none\">file://</literal> URL. If multiple system users are going to be accessing the repository directly, you may want to place them into a common group, and you'll need to be careful about umasks. (Be sure to read <xref linkend=\"svn.serverconfig.multimethod\"/>.) But even in the case of tunneling, the <filename moreinfo=\"none\">svnserve.conf</filename> file can still be used to block access, by simply setting <literal moreinfo=\"none\">auth-access = read</literal> or <literal moreinfo=\"none\">auth-access = none</literal>. <placeholder-1/>"
msgstr "当在一个管道上运行时，认证通常是基于操作系统对版本库数据库文件的访问控制，这同Harry直接通过<literal moreinfo=\"none\">file:///</literal>的URL直接访问版本库非常类似，如果有多个系统用户要直接访问版本库，你会希望将他们放到一个常见的组里，你应该小心的使用umasks。（确定要阅读<xref linkend=\"svn.serverconfig.multimethod\"/>）但是即使是在管道模式时，文件<filename moreinfo=\"none\">svnserve.conf</filename>还是可以阻止用户访问，如<literal moreinfo=\"none\">auth-access = read</literal>或者<literal moreinfo=\"none\">auth-access = none</literal>。"

#: build/en/book.xml:13539(para)
msgid "You'd think that the story of SSH tunneling would end here, but it doesn't. Subversion allows you to create custom tunnel behaviors in your run-time <filename moreinfo=\"none\">config</filename> file (see <xref linkend=\"svn.advanced.confarea\"/>). For example, suppose you want to use RSH instead of SSH. In the <literal moreinfo=\"none\">[tunnels]</literal> section of your <filename moreinfo=\"none\">config</filename> file, simply define it like this:"
msgstr "你会认为SSH管道的故事该结束了，但还不是，Subversion允许你在运行配置文件<filename moreinfo=\"none\">config</filename>（见<xref linkend=\"svn.advanced.confarea\"/>）创建一个自定义的管道行为方式，举个例子，假定你希望使用RSH而不是SSH，在<filename moreinfo=\"none\">config</filename>文件的<literal moreinfo=\"none\">[tunnels]</literal>部分作如下定义："

#: build/en/book.xml:13548(screen)
#, no-wrap
msgid ""
"\n"
"[tunnels]\n"
"rsh = rsh\n"
msgstr ""
"\n"
"[tunnels]\n"
"rsh = rsh\n"

#: build/en/book.xml:13553(para)
msgid "And now, you can use this new tunnel definition by using a URL schema that matches the name of your new variable: <literal moreinfo=\"none\">svn+rsh://host/path</literal>. When using the new URL schema, the Subversion client will actually be running the command <command moreinfo=\"none\">rsh host svnserve -t</command> behind the scenes. If you include a username in the URL (for example, <literal moreinfo=\"none\">svn+rsh://username@host/path</literal>) the client will also include that in its command (<command moreinfo=\"none\">rsh username@host svnserve -t</command>). But you can define new tunneling schemes to be much more clever than that:"
msgstr "现在你可以通过指定与定义匹配的URL模式来使用新的管道定义：<literal moreinfo=\"none\">svn+rsh://host/path</literal>。当使用新的URL模式时，Subversion客户端实际上会在后台运行<command moreinfo=\"none\">rsh host svnserve -t</command>这个命令，如果你在URL中包括一个用户名（例如，<literal moreinfo=\"none\">svn+rsh://username@host/path</literal>），客户端也会在自己的命令中包含这部分（<command moreinfo=\"none\">rsh username@host svnserve -t</command>），但是你可以定义比这个更加智能的新的管道模式："

#: build/en/book.xml:13564(screen)
#, no-wrap
msgid ""
"\n"
"[tunnels]\n"
"joessh = $JOESSH /opt/alternate/ssh -p 29934\n"
msgstr ""
"\n"
"[tunnels]\n"
"joessh = $JOESSH /opt/alternate/ssh -p 29934\n"

#: build/en/book.xml:13569(para)
msgid "This example demonstrates a couple of things. First, it shows how to make the Subversion client launch a very specific tunneling binary (the one located at <filename moreinfo=\"none\">/opt/alternate/ssh</filename>) with specific options. In this case, accessing a <literal moreinfo=\"none\">svn+joessh://</literal> URL would invoke the particular SSH binary with <option>-p 29934</option> as arguments—useful if you want the tunnel program to connect to a non-standard port."
msgstr "这个例子里论证了一些事情，首先，它展现了如何让Subversion客户端启动一个特定的管道程序（这个在<filename moreinfo=\"none\">/opt/alternate/ssh</filename>），在这个例子里，使用<literal moreinfo=\"none\">svn+joessh://</literal>的URL会以<option>-p 29934</option>参数调用特定的SSH程序—对连接到非标准端口的程序非常有用。"

#: build/en/book.xml:13579(para)
msgid "Second, it shows how to define a custom environment variable that can override the name of the tunneling program. Setting the <literal moreinfo=\"none\">SVN_SSH</literal> environment variable is a convenient way to override the default SSH tunnel agent. But if you need to have several different overrides for different servers, each perhaps contacting a different port or passing a different set of options to SSH, you can use the mechanism demonstrated in this example. Now if we were to set the <literal moreinfo=\"none\">JOESSH</literal> environment variable, its value would override the entire value of the tunnel variable—<command moreinfo=\"none\">$JOESSH</command> would be executed instead of <command moreinfo=\"none\">/opt/alternate/ssh -p 29934</command>."
msgstr "第二点，它展示了怎样定义一个自定义的环境变量来覆盖管道程序中的名字，设置<literal moreinfo=\"none\">SVN_SSH</literal>环境变量是覆盖缺省的SSH管道的一种简便方法，但是如果你需要为多个服务器做出多个不同的覆盖，或许每一个都联系不同的端口或传递不同的SSH选项，你可以使用本例论述的机制。现在如果我们设置<literal moreinfo=\"none\">JOESSH</literal>环境变量，它的值会覆盖管道中的变量值—会执行<command moreinfo=\"none\">$JOESSH</command>而不是<command moreinfo=\"none\">/opt/alternate/ssh -p 29934</command>。"

#: build/en/book.xml:13597(title)
msgid "SSH configuration tricks"
msgstr "SSH 配置技巧"

#: build/en/book.xml:13599(para)
msgid "It's not only possible to control the way in which the client invokes <command moreinfo=\"none\">ssh</command>, but also to control the behavior of <command moreinfo=\"none\">sshd</command> on your server machine. In this section, we'll show how to control the exact <command moreinfo=\"none\">svnserve</command> command executed by <command moreinfo=\"none\">sshd</command>, as well as how to have multiple users share a single system account."
msgstr "不仅仅是可以控制客户端调用<command moreinfo=\"none\">ssh</command>方式，也可以控制服务器中的<command moreinfo=\"none\">sshd</command>的行为方式，在本小节，我们会展示怎样控制<command moreinfo=\"none\">sshd</command>执行<command moreinfo=\"none\">svnserve</command>，包括如何让多个用户分享同一个系统帐户。"

#: build/en/book.xml:13611(para)
msgid "To begin, locate the home directory of the account you'll be using to launch <command moreinfo=\"none\">svnserve</command>. Make sure the account has an SSH public/private keypair installed, and that the user can log in via public-key authentication. Password authentication will not work, since all of the following SSH tricks revolve around using the SSH <filename moreinfo=\"none\">authorized_keys</filename> file."
msgstr "作为开始，定位到你启动<command moreinfo=\"none\">svnserve</command>的帐号的主目录，确定这个账户已经安装了一套SSH公开/私有密钥对，用户可以通过公开密钥认证，因为所有如下的技巧围绕着使用SSH<filename moreinfo=\"none\">authorized_keys</filename>文件，密码认证在这里不会工作。"

#: build/en/book.xml:13619(para)
msgid "If it doesn't already exist, create the <filename moreinfo=\"none\">authorized_keys</filename> file (on Unix, typically <filename moreinfo=\"none\">~/.ssh/authorized_keys</filename>). Each line in this file describes a public key that is allowed to connect. The lines are typically of the form:"
msgstr "如果这个文件还不存在，创建一个<filename moreinfo=\"none\">authorized_keys</filename>文件（在UNIX下通常是<filename moreinfo=\"none\">~/.ssh/authorized_keys</filename>），这个文件的每一行描述了一个允许连接的公钥，这些行通常是下面的形式："

#: build/en/book.xml:13626(screen)
#, no-wrap
msgid ""
"\n"
"  ssh-dsa AAAABtce9euch… user@example.com\n"
msgstr ""
"\n"
"  ssh-dsa AAAABtce9euch.... user@example.com\n"

#: build/en/book.xml:13630(para)
msgid "The first field describes the type of key, the second field is the uuencoded key itself, and the third field is a comment. However, it's a lesser known fact that the entire line can be preceded by a <literal moreinfo=\"none\">command</literal> field:"
msgstr "第一个字段描述了密钥的类型，第二个字段是未加密的密钥本身，第三个字段是注释。然而，这是一个很少人知道的事实，可以使用一个<literal moreinfo=\"none\">command</literal>来处理整行："

#: build/en/book.xml:13636(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"program\" ssh-dsa AAAABtce9euch… user@example.com\n"
msgstr ""
"\n"
"  command=\"program\" ssh-dsa AAAABtce9euch.... user@example.com\n"

#: build/en/book.xml:13640(para)
msgid "When the <literal moreinfo=\"none\">command</literal> field is set, the SSH daemon will run the named program instead of the typical <command moreinfo=\"none\">svnserve -t</command> invocation that the Subversion client asks for. This opens the door to a number of server-side tricks. In the following examples, we abbreviate the lines of the file as:"
msgstr "当<literal moreinfo=\"none\">command</literal>字段设置后，SSH守护进程运行命名的程序而不是通常Subversion客户端询问的<command moreinfo=\"none\">svnserve -t</command>。这为实施许多服务器端技巧开启了大门，在下面的例子里，我们简写了文件的这些行："

#: build/en/book.xml:13647(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"program\" TYPE KEY COMMENT\n"
msgstr ""
"\n"
"  command=\"program\" TYPE KEY COMMENT\n"

#: build/en/book.xml:13655(title)
msgid "Controlling the invoked command"
msgstr "控制调用的命令"

#: build/en/book.xml:13657(para)
msgid "Because we can specify the executed server-side command, it's easy to name a specific <command moreinfo=\"none\">svnserve</command> binary to run and to pass it extra arguments:"
msgstr "因为我们可以指定服务器端执行的命令，我们很容易来选择运行一个特定的<command moreinfo=\"none\">svnserve</command>程序来并且传递给它额外的参数："

#: build/en/book.xml:13661(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"/path/to/svnserve -t -r /virtual/root\" TYPE KEY COMMENT\n"
msgstr ""
"\n"
"  command=\"/path/to/svnserve -t -r /virtual/root\" TYPE KEY COMMENT\n"

#: build/en/book.xml:13665(para)
msgid "In this example, <filename moreinfo=\"none\">/path/to/svnserve</filename> might be a custom wrapper script around <command moreinfo=\"none\">svnserve</command> which sets the umask (see <xref linkend=\"svn.serverconfig.multimethod\"/>). It also shows how to anchor <command moreinfo=\"none\">svnserve</command> in a virtual root directory, just as one often does when running <command moreinfo=\"none\">svnserve</command> as a daemon process. This might be done either to restrict access to parts of the system, or simply to relieve the user of having to type an absolute path in the <literal moreinfo=\"none\">svn+ssh://</literal> URL."
msgstr "在这个例子里，<filename moreinfo=\"none\">/path/to/svnserve</filename>也许会是一个<command moreinfo=\"none\">svnserve</command>程序的包裹脚本，会来设置umask（见<xref linkend=\"svn.serverconfig.multimethod\"/>）。它也展示了怎样在虚拟根目录定位一个<command moreinfo=\"none\">svnserve</command>，就像我们经常在使用守护进程模式下运行<command moreinfo=\"none\">svnserve</command>一样。这样做不仅可以把访问限制在系统的一部分，也可以使用户不需要在<literal moreinfo=\"none\">svn+ssh://</literal>URL里输入绝对路径。"

#: build/en/book.xml:13677(para)
msgid "It's also possible to have multiple users share a single account. Instead of creating a separate system account for each user, generate a public/private keypair for each person. Then place each public key into the <filename moreinfo=\"none\">authorized_users</filename> file, one per line, and use the <option>--tunnel-user</option> option:"
msgstr "多个用户也可以共享同一个帐号，作为为每个用户创建系统帐户的替代，我们创建一个公开/私有密钥对，然后在<filename moreinfo=\"none\">authorized_users</filename>文件里放置各自的公钥，一个用户一行，使用<option>--tunnel-user</option>选项："

#: build/en/book.xml:13685(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"svnserve -t --tunnel-user=harry\" TYPE1 KEY1 harry@example.com\n"
"  command=\"svnserve -t --tunnel-user=sally\" TYPE2 KEY2 sally@example.com\n"
msgstr ""
"\n"
"  command=\"svnserve -t --tunnel-user=harry\" TYPE1 KEY1 harry@example.com\n"
"  command=\"svnserve -t --tunnel-user=sally\" TYPE2 KEY2 sally@example.com\n"

#: build/en/book.xml:13690(para)
msgid "This example allows both Harry and Sally to connect to the same account via public-key authentication. Each of them has a custom command that will be executed; the <option>--tunnel-user</option> option tells <command moreinfo=\"none\">svnserve -t</command> to assume that the named argument is the authenticated user. Without <option>--tunnel-user</option>, it would appear as though all commits were coming from the one shared system account."
msgstr "这个例子允许Harry和Sally通过公钥认证连接同一个的账户，每个人自定义的命令将会执行。<option>--tunnel-user</option>选项告诉<command moreinfo=\"none\">svnserve -t</command>命令采用命名的参数作为经过认证的用户，如果没有<option>--tunnel-user</option>，所有的提交会作为共享的系统帐户提交。"

#: build/en/book.xml:13700(para)
msgid "A final word of caution: giving a user access to the server via public-key in a shared account might still allow other forms of SSH access, even if you've set the <literal moreinfo=\"none\">command</literal> value in <filename moreinfo=\"none\">authorized_keys</filename>. For example, the user may still get shell access through SSH, or be able to perform X11 or general port-forwarding through your server. To give the user as little permission as possible, you may want to specify a number of restrictive options immediately after the <literal moreinfo=\"none\">command</literal>:"
msgstr "最后要小心：设定通过公钥共享账户进行用户访问时还会允许其它形式的SSH访问，即使你设置了<filename moreinfo=\"none\">authorized_keys</filename>的<literal moreinfo=\"none\">command</literal>值，举个例子，用户仍然可以通过SSH得到shell访问，或者是通过服务器执行X11或者是端口转发。为了给用户尽可能少的访问权限，你或许希望在<literal moreinfo=\"none\">command</literal>命令之后指定一些限制选项："

#: build/en/book.xml:13711(screen)
#, no-wrap
msgid ""
"\n"
"  command=\"svnserve -t --tunnel-user=harry\",no-port-forwarding,\\\n"
"           no-agent-forwarding,no-X11-forwarding,no-pty \\\n"
"           TYPE1 KEY1 harry@example.com\n"
msgstr ""
"\n"
"  command=\"svnserve -t --tunnel-user=harry\",no-port-forwarding,\\\n"
"           no-agent-forwarding,no-X11-forwarding,no-pty \\\n"
"           TYPE1 KEY1 harry@example.com\n"

#: build/en/book.xml:13729(title)
msgid "httpd, the Apache HTTP server"
msgstr "httpd，Apache 的 HTTP 服务器"

#: build/en/book.xml:13745(para)
msgid "They really hate doing that."
msgstr "他们讨厌这样做。"

#: build/en/book.xml:13731(para)
#, fuzzy
msgid "The Apache HTTP Server is a <quote>heavy duty</quote> network server that Subversion can leverage. Via a custom module, <command moreinfo=\"none\">httpd</command> makes Subversion repositories available to clients via the WebDAV/DeltaV protocol, which is an extension to HTTP 1.1 (see <ulink url=\"http://www.webdav.org/\"/> for more information). This protocol takes the ubiquitous HTTP protocol that is the core of the World Wide Web, and adds writing—specifically, versioned writing—capabilities. The result is a standardized, robust system that is conveniently packaged as part of the Apache 2.0 software, is supported by numerous operating systems and third-party products, and doesn't require network administrators to open up yet another custom port. <placeholder-1/> While an Apache-Subversion server has more features than <command moreinfo=\"none\">svnserve</command>, it's also a bit more difficult to set up. With flexibility often comes more complexity."
msgstr "Apache的HTTP服务器是一个Subversion可以利用的<quote>重型</quote>网络服务器，通过一个自定义模块，<command moreinfo=\"none\">httpd</command>可以让Subversion版本库通过WebDAV/DeltaV协议在客户端前可见，WebDAV/DeltaV协议是HTTP 1.1的扩展（见<ulink url=\"http://www.webdav.org/\"/>来查看详细信息）。这个协议利用了无处不在的HTTP协议是广域网的核心这一点，添加了写能力—更明确一点，版本化的写—能力。结果就是这样一个标准化的健壮的系统，作为Apache 2.0软件的一部分打包，被许多操作系统和第三方产品支持，网络管理员也不需要打开另一个自定义端口。 <footnote><placeholder-1/></footnote>这样一个Apache-Subversion服务器具备了许多<command moreinfo=\"none\">svnserve</command>没有的特性，但是也有一点难于配置，灵活通常会带来复杂性。"

#: build/en/book.xml:13751(para)
msgid "Much of the following discussion includes references to Apache configuration directives. While some examples are given of the use of these directives, describing them in full is outside the scope of this chapter. The Apache team maintains excellent documentation, publicly available on their website at <ulink url=\"http://httpd.apache.org\"/>. For example, a general reference for the configuration directives is located at <ulink url=\"       http://httpd.apache.org/docs-2.0/mod/directives.html\"/>."
msgstr "下面的讨论包括了对Apache配置指示的引用，给了一些使用这些指示的例子，详细地描述不在本章的范围之内，Apache小组维护了完美的文档，公开存放在他们的站点<ulink url=\"http://httpd.apache.org\"/>。例如，一个一般的配置参考位于<ulink url=\"       http://httpd.apache.org/docs-2.0/mod/directives.html\"/>。"

#: build/en/book.xml:13759(para)
msgid "Also, as you make changes to your Apache setup, it is likely that somewhere along the way a mistake will be made. If you are not already familiar with Apache's logging subsystem, you should become aware of it. In your <filename moreinfo=\"none\">httpd.conf</filename> file are directives that specify the on-disk locations of the access and error logs generated by Apache (the <literal moreinfo=\"none\">CustomLog</literal> and <literal moreinfo=\"none\">ErrorLog</literal> directives, respectively). Subversion's mod_dav_svn uses Apache's error logging interface as well. You can always browse the contents of those files for information that might reveal the source of a problem that is not clearly noticeable otherwise."
msgstr "同样，当你修改你的Apache设置，很有可能会出现一些错误，如果你还不熟悉Apache的日志子系统，你一定需要认识到这一点。在你的文件<filename moreinfo=\"none\">httpd.conf</filename>里会指定Apache生成的访问和错误日志（<literal moreinfo=\"none\">CustomLog</literal>和<literal moreinfo=\"none\">ErrorLog</literal>指示）的磁盘位置。Subversion的mod_dav_svn使用Apache的错误日志接口，你可以浏览这个文件的内容查看信息来查找难于发现的问题根源。"

#: build/en/book.xml:13773(title)
msgid "Why Apache 2?"
msgstr "为什么是 Apache 2？"

#: build/en/book.xml:13775(para)
msgid "If you're a system administrator, it's very likely that you're already running the Apache web server and have some prior experience with it. At the time of writing, Apache 1.3 is by far the most popular version of Apache. The world has been somewhat slow to upgrade to the Apache 2.X series for various reasons: some people fear change, especially changing something as critical as a web server. Other people depend on plug-in modules that only work against the Apache 1.3 API, and are waiting for a 2.X port. Whatever the reason, many people begin to worry when they first discover that Subversion's Apache module is written specifically for the Apache 2 API."
msgstr "如果你系统管理员，很有可能是你已经运行了Apache服务器，并且有一些高级经验。写本文的时候，Apache 1.3是Apache最流行的版本，这个世界因为许多原因而放缓升级到2.X系列：如人们害怕改变，特别是像web服务器这种重要的变化，有些人需要一些在Apache 1.3 API下工作的插件模块，在等待2.X的版本。无论什么原因，许多人会在首次发现Subversion的Apache模块只是为Apache 2 API写的后开始担心。"

#: build/en/book.xml:13787(para)
msgid "The proper response to this problem is: don't worry about it. It's easy to run Apache 1.3 and Apache 2 side-by-side; simply install them to separate places, and use Apache 2 as a dedicated Subversion server that runs on a port other than 80. Clients can access the repository by placing the port number into the URL:"
msgstr "对此问题的适当反应是：不需要担心，同时运行Apache 1.3和Apache 2非常简单，只需要安装到不同的位置，用Apache 2作为Subversion的专用服务器，并且不使用80端口，客户端可以访问版本库时在URL里指定端口："

#: build/en/book.xml:13794(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://host.example.com:7382/repos/project\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout http://host.example.com:7382/repos/project\n"
"…\n"

#: build/en/book.xml:13803(title)
msgid "Prerequisites"
msgstr "先决条件"

#: build/en/book.xml:13805(para)
msgid "To network your repository over HTTP, you basically need four components, available in two packages. You'll need Apache <command moreinfo=\"none\">httpd</command> 2.0, the <command moreinfo=\"none\">mod_dav</command> DAV module that comes with it, Subversion, and the <command moreinfo=\"none\">mod_dav_svn</command> filesystem provider module distributed with Subversion. Once you have all of those components, the process of networking your repository is as simple as:"
msgstr "为了让你的版本库使用HTTP网络，你基本上需要两个包里的四个部分。你需要Apache <command moreinfo=\"none\">httpd</command> 2.0和包括的<command moreinfo=\"none\">mod_dav</command> DAV模块，Subversion和与之一同分发的<command moreinfo=\"none\">mod_dav_svn</command>文件系统提供者模块，如果你有了这些组件，网络化你的版本库将非常简单，如："

#: build/en/book.xml:13816(para)
msgid "getting httpd 2.0 up and running with the mod_dav module,"
msgstr "配置好httpd 2.0，并且使用mod_dav启动，"

#: build/en/book.xml:13820(para)
msgid "installing the mod_dav_svn plugin to mod_dav, which uses Subversion's libraries to access the repository, and"
msgstr "为mod_dav安装mod_dav_svn插件，它会使用Subversion的库访问版本库，并且"

#: build/en/book.xml:13825(para)
msgid "configuring your <filename moreinfo=\"none\">httpd.conf</filename> file to export (or expose) the repository."
msgstr "配置你的<filename moreinfo=\"none\">httpd.conf</filename>来输出（或者说暴露）版本库。"

#: build/en/book.xml:13830(para)
msgid "You can accomplish the first two items either by compiling <command moreinfo=\"none\">httpd</command> and Subversion from source code, or by installing pre-built binary packages of them on your system. For the most up-to-date information on how to compile Subversion for use with the Apache HTTP Server, as well as how to compile and configure Apache itself for this purpose, see the <filename moreinfo=\"none\">INSTALL</filename> file in the top level of the Subversion source code tree."
msgstr "你可以通过从源代码编译<command moreinfo=\"none\">httpd</command>和Subversion来完成前两个项目，也可以通过你的系统上的已经编译好的二进制包来安装。最新的使用Apache HTTP的Subversion的编译方法和Apache的配置方式可以看Subversion源代码树根目录的<filename moreinfo=\"none\">INSTALL</filename>文件。"

#: build/en/book.xml:13843(title)
msgid "Basic Apache Configuration"
msgstr "基本的 Apache 配置"

#: build/en/book.xml:13845(para)
msgid "Once you have all the necessary components installed on your system, all that remains is the configuration of Apache via its <filename moreinfo=\"none\">httpd.conf</filename> file. Instruct Apache to load the mod_dav_svn module using the <literal moreinfo=\"none\">LoadModule</literal> directive. This directive must precede any other Subversion-related configuration items. If your Apache was installed using the default layout, your <command moreinfo=\"none\">mod_dav_svn</command> module should have been installed in the <filename moreinfo=\"none\">modules</filename> subdirectory of the Apache install location (often <filename moreinfo=\"none\">/usr/local/apache2</filename>). The <literal moreinfo=\"none\">LoadModule</literal> directive has a simple syntax, mapping a named module to the location of a shared library on disk:"
msgstr "一旦你安装了必须的组件，剩下的工作就是在<filename moreinfo=\"none\">httpd.conf</filename>里配置Apache，使用<literal moreinfo=\"none\">LoadModule</literal>来加载mod_dav_svn模块，这个指示必须先与其它Subversion相关的其它配置出现，如果你的Apache使用缺省布局安装，你的<command moreinfo=\"none\">mod_dav_svn</command>模块一定在Apache安装目录（通常是在<filename moreinfo=\"none\">/usr/local/apache2</filename>）的<filename moreinfo=\"none\">modules</filename>子目录，<literal moreinfo=\"none\">LoadModule</literal>指示的语法很简单，影射一个名字到它的共享库的物理位置："

#: build/en/book.xml:13860(screen)
#, no-wrap
msgid ""
"\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"
msgstr ""
"\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"

#: build/en/book.xml:13864(para)
msgid "Note that if <command moreinfo=\"none\">mod_dav</command> was compiled as a shared object (instead of statically linked directly to the <command moreinfo=\"none\">httpd</command> binary), you'll need a similar <literal moreinfo=\"none\">LoadModule</literal> statement for it, too. Be sure that it comes before the <command moreinfo=\"none\">mod_dav_svn</command> line:"
msgstr "注意，如果<command moreinfo=\"none\">mod_dav</command>是作为共享对象编译（而不是静态链接到<command moreinfo=\"none\">httpd</command>程序），你需要为它使用使用<literal moreinfo=\"none\">LoadModule</literal>语句，一定确定它在<command moreinfo=\"none\">mod_dav_svn</command>之前："

#: build/en/book.xml:13870(screen)
#, no-wrap
msgid ""
"\n"
"LoadModule dav_module         modules/mod_dav.so\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"
msgstr ""
"\n"
"LoadModule dav_module         modules/mod_dav.so\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"

#: build/en/book.xml:13876(para)
msgid "At a later location in your configuration file, you now need to tell Apache where you keep your Subversion repository (or repositories). The <literal moreinfo=\"none\">Location</literal> directive has an XML-like notation, starting with an opening tag, and ending with a closing tag, with various other configuration directives in the middle. The purpose of the <literal moreinfo=\"none\">Location</literal> directive is to instruct Apache to do something special when handling requests that are directed at a given URL or one of its children. In the case of Subversion, you want Apache to simply hand off support for URLs that point at versioned resources to the DAV layer. You can instruct Apache to delegate the handling of all URLs whose path portions (the part of the URL that follows the server's name and the optional port number) begin with <filename moreinfo=\"none\">/repos/</filename> to a DAV provider whose repository is located at <filename moreinfo=\"none\">/absolute/path/to/repository</filename> using the following <filename moreinfo=\"none\">httpd.conf</filename> syntax:"
msgstr "在你的配置文件后面的位置，你需要告诉Apache你在什么地方保存Subversion版本库（也许是多个），<literal moreinfo=\"none\">位置</literal>指示有一个很像XML的符号，开始于一个开始标签，以一个结束标签结束，配合中间许多的其它配置。<literal moreinfo=\"none\">Location</literal>指示的目的是告诉Apache在特定的URL以及子URL下需要特殊的处理，如果是为Subversion准备的，你希望可以通过告诉Apache特定URL是指向版本化的资源，从而把支持转交给DAV层，你可以告诉Apache将所有路径部分（URL中服务器名称和端口之后的部分）以<filename moreinfo=\"none\">/repos/</filename>开头的URL交由DAV服务提供者处理。一个DAV服务提供者的版本库位于<filename moreinfo=\"none\">/absolute/path/to/repository</filename>，可以使用如下的<filename moreinfo=\"none\">httpd.conf</filename>语法："

#: build/en/book.xml:13895(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNPath /absolute/path/to/repository\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNPath /absolute/path/to/repository\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:13902(para)
#, fuzzy
msgid "If you plan to support multiple Subversion repositories that will reside in the same parent directory on your local disk, you can use an alternative directive, the <literal moreinfo=\"none\">SVNParentPath</literal> directive, to indicate that common parent directory. For example, if you know you will be creating multiple Subversion repositories in a directory <filename moreinfo=\"none\">/usr/local/svn</filename> that would be accessed via URLs like <uri>http://my.server.com/svn/repos1</uri>, <uri>http://my.server.com/svn/repos2</uri>, and so on, you could use the <filename moreinfo=\"none\">httpd.conf</filename> configuration syntax in the following example:"
msgstr "如果你计划支持多个具备相同父目录的Subversion版本库，你有另外的选择，<literal moreinfo=\"none\">SVNParentPath</literal>指示，来表示共同的父目录。举个例子，如果你知道你会在<filename moreinfo=\"none\">/usr/local/svn</filename>下创建多个Subversion版本库，并且通过类似<systemitem class=\"url\" moreinfo=\"none\">http://my.server.com/svn/repos1</systemitem>，<systemitem class=\"url\" moreinfo=\"none\">http://my.server.com/svn/repos2</systemitem>的URL访问，你可以用后面例子中的<filename moreinfo=\"none\">httpd.conf</filename>配置语法："

#: build/en/book.xml:13914(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"\n"
"  # any \"/svn/foo\" URL will map to a repository /usr/local/svn/foo\n"
"  SVNParentPath /usr/local/svn\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"\n"
"  # any \"/svn/foo\" URL will map to a repository /usr/local/svn/foo\n"
"  SVNParentPath /usr/local/svn\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:13923(para)
msgid "Using the previous syntax, Apache will delegate the handling of all URLs whose path portions begin with <filename moreinfo=\"none\">/svn/</filename> to the Subversion DAV provider, which will then assume that any items in the directory specified by the <literal moreinfo=\"none\">SVNParentPath</literal> directive are actually Subversion repositories. This is a particularly convenient syntax in that, unlike the use of the <literal moreinfo=\"none\">SVNPath</literal> directive, you don't have to restart Apache in order to create and network new repositories."
msgstr "使用上面的语法，Apache会代理所有URL路径部分为<filename moreinfo=\"none\">/svn/</filename>的请求到Subversion的DAV提供者，Subversion会认为<literal moreinfo=\"none\">SVNParentPath</literal>指定的目录下的所有项目是真实的Subversion版本库，这通常是一个便利的语法，不像是用<literal moreinfo=\"none\">SVNPath</literal>指示，我们在此不必为创建新的版本库而重启Apache。"

#: build/en/book.xml:13934(para)
#, fuzzy
msgid "Be sure that when you define your new <literal moreinfo=\"none\">Location</literal>, it doesn't overlap with other exported Locations. For example, if your main <literal moreinfo=\"none\">DocumentRoot</literal> is exported to <filename moreinfo=\"none\">/www</filename>, do not export a Subversion repository in <literal moreinfo=\"none\">&lt;Location /www/repos&gt;</literal>. If a request comes in for the URI <filename moreinfo=\"none\">/www/repos/foo.c</filename>, Apache won't know whether to look for a file <filename moreinfo=\"none\">repos/foo.c</filename> in the <literal moreinfo=\"none\">DocumentRoot</literal>, or whether to delegate <command moreinfo=\"none\">mod_dav_svn</command> to return <filename moreinfo=\"none\">foo.c</filename> from the Subversion repository."
msgstr "请确定当你定义新的<literal moreinfo=\"none\">位置</literal>，不会与其它输出的位置重叠，例如你的主要<literal moreinfo=\"none\">DocumentRoot</literal>是<filename moreinfo=\"none\">/www</filename>，不要把Subversion版本库输出到<literal moreinfo=\"none\">&lt;Location /www/repos&gt;</literal>，如果一个请求的URI是<filename moreinfo=\"none\">/www/repos/foo.c</filename>，Apache不知道是直接到<filename moreinfo=\"none\">repos/foo.c</filename>访问这个文件还是让<command moreinfo=\"none\">mod_dav_svn</command>代理从Subversion版本库返回<filename moreinfo=\"none\">foo.c</filename>。"

#: build/en/book.xml:13949(title)
msgid "Server Names and the COPY Request"
msgstr "服务器名称和复制请求"

#: build/en/book.xml:13951(para)
msgid "Subversion makes use of the <literal moreinfo=\"none\">COPY</literal> request type to perform server-side copies of files and directories. As part of the sanity checking done by the Apache modules, the source of the copy is expected to be located on the same machine as the destination of the copy. To satisfy this requirement, you might need to tell mod_dav the name you use as the hostname of your server. Generally, you can use the <literal moreinfo=\"none\">ServerName</literal> directive in <filename moreinfo=\"none\">httpd.conf</filename> to accomplish this."
msgstr "Subversion利用<literal moreinfo=\"none\">COPY</literal>请求类型来执行服务器端的文件和目录拷贝，作为一个健全的Apache模块的一部分，拷贝源和拷贝的目标通常坐落在同一个机器上，为了满足这个需求，你或许需要告诉mod_dav服务器主机的名称，通常你可以使用<filename moreinfo=\"none\">httpd.conf</filename>的<literal moreinfo=\"none\">ServerName</literal>指示来完成此目的。"

#: build/en/book.xml:13961(screen)
#, no-wrap
msgid ""
"\n"
"ServerName svn.example.com\n"
msgstr ""
"\n"
"ServerName svn.example.com\n"

#: build/en/book.xml:13965(para)
msgid "If you are using Apache's virtual hosting support via the <literal moreinfo=\"none\">NameVirtualHost</literal> directive, you may need to use the <literal moreinfo=\"none\">ServerAlias</literal> directive to specify additional names that your server is known by. Again, refer to the Apache documentation for full details."
msgstr "如果你通过<literal moreinfo=\"none\">NameVirtualHost</literal>指示使用Apache的虚拟主机，你或许需要<literal moreinfo=\"none\">ServerAlias</literal>指示来指定额外的名称，再说一次，可以查看Apache文档的来得到更多细节。"

#: build/en/book.xml:13973(para)
#, fuzzy
msgid "At this stage, you should strongly consider the question of permissions. If you've been running Apache for some time now as your regular web server, you probably already have a collection of content—web pages, scripts and such. These items have already been configured with a set of permissions that allows them to work with Apache, or more appropriately, that allows Apache to work with those files. Apache, when used as a Subversion server, will also need the correct permissions to read and write to your Subversion repository."
msgstr "在本阶段，你一定要考虑访问权限问题，如果你已经作为普通的web服务器运行过Apache，你一定有了一些内容—网页、脚本和其他。这些项目已经配置了许多在Apache下可以工作的访问许可，或者更准确一点，允许Apache与这些文件一起工作。Apache当作为Subversion服务器运行时，同样需要正确的访问许可来读写你的Subversion版本库。（见<xref linkend=\"svn.serverconfig.svnserve.invoking.sb-1\"/>。）"

#: build/en/book.xml:13984(para)
msgid "You will need to determine a permission system setup that satisfies Subversion's requirements without messing up any previously existing web page or script installations. This might mean changing the permissions on your Subversion repository to match those in use by other things that Apache serves for you, or it could mean using the <literal moreinfo=\"none\">User</literal> and <literal moreinfo=\"none\">Group</literal> directives in <filename moreinfo=\"none\">httpd.conf</filename> to specify that Apache should run as the user and group that owns your Subversion repository. There is no single correct way to set up your permissions, and each administrator will have different reasons for doing things a certain way. Just be aware that permission-related problems are perhaps the most common oversight when configuring a Subversion repository for use with Apache."
msgstr "你会需要检验权限系统的设置满足Subversion的需求，同时不会把以前的页面和脚本搞乱。这或许意味着修改Subversion的访问许可来配合Apache服务器已经使用的工具，或者可能意味着需要使用<filename moreinfo=\"none\">httpd.conf</filename>的<literal moreinfo=\"none\">User</literal>和<literal moreinfo=\"none\">Group</literal>指示来指定Apache作为运行的用户和Subversion版本库的组。并不是只有一条正确的方式来设置许可，每个管理员都有不同的原因来以特定的方式操作，只需要意识到许可关联的问题经常在为Apache配置Subversion版本库的过程中被疏忽。"

#: build/en/book.xml:14004(title)
msgid "Authentication Options"
msgstr "认证选项"

#: build/en/book.xml:14006(para)
msgid "At this point, if you configured <filename moreinfo=\"none\">httpd.conf</filename> to contain something like"
msgstr "此时，如果你配置的<filename moreinfo=\"none\">httpd.conf</filename>保存如下的内容"

#: build/en/book.xml:14009(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14016(para)
msgid "…then your repository is <quote>anonymously</quote> accessible to the world. Until you configure some authentication and authorization policies, the Subversion repositories you make available via the <literal moreinfo=\"none\">Location</literal> directive will be generally accessible to everyone. In other words,"
msgstr "这样你的版本库对全世界是可以<quote>匿名</quote>访问的，直到你配置了一些认证授权政策，你通过<literal moreinfo=\"none\">Location</literal>指示来使Subversion版本库可以被任何人访问，换句话说，"

#: build/en/book.xml:14025(para)
msgid "anyone can use their Subversion client to checkout a working copy of a repository URL (or any of its subdirectories),"
msgstr "任何人可以使用Subversion客户端来从版本库URL取出一个工作拷贝（或者是它的子目录），"

#: build/en/book.xml:14030(para)
msgid "anyone can interactively browse the repository's latest revision simply by pointing their web browser to the repository URL, and"
msgstr "任何人可以在浏览器输入版本库URL交互浏览的方式来查看版本库的最新修订版本，并且"

#: build/en/book.xml:14035(para)
msgid "anyone can commit to the repository."
msgstr "任何人可以提交到版本库。"

#: build/en/book.xml:14039(para)
msgid "Of course, you might have already set up a <filename moreinfo=\"none\">pre-commit</filename> hook script to prevent commits (see <xref linkend=\"svn.reposadmin.create.hooks\"/>). But as you read on, you'll see that it's also possible use Apache's built-in methods to restrict access in specific ways."
msgstr ""

#: build/en/book.xml:14048(title)
msgid "Basic HTTP Authentication"
msgstr "基本 HTTP 认证"

#: build/en/book.xml:14050(para)
msgid "The easiest way to authenticate a client is via the HTTP Basic authentication mechanism, which simply uses a username and password to verify that a user is who she says she is. Apache provides an <command moreinfo=\"none\">htpasswd</command> utility for managing the list of acceptable usernames and passwords, those to whom you wish to grant special access to your Subversion repository. Let's grant commit access to Sally and Harry. First, we need to add them to the password file."
msgstr "最简单的客户端认证方式是通过HTTP基本认证机制，简单的使用用户名和密码来验证一个用户所自称的身份，Apache提供了一个<command moreinfo=\"none\">htpasswd</command>工具来管理可接受的用户名和密码，这些就是你希望赋予Subversion特别权限的用户，让我们给Sally和Harry赋予提交权限，首先，我们需要添加他们到密码文件。"

#: build/en/book.xml:14060(screen)
#, no-wrap
msgid ""
"\n"
"$ ### First time: use -c to create the file\n"
"$ ### Use -m to use MD5 encryption of the password, which is more secure\n"
"$ htpasswd -cm /etc/svn-auth-file harry\n"
"New password: *****\n"
"Re-type new password: *****\n"
"Adding password for user harry\n"
"$ htpasswd -m /etc/svn-auth-file sally\n"
"New password: *******\n"
"Re-type new password: *******\n"
"Adding password for user sally\n"
"$\n"
msgstr ""
"\n"
"$ ### First time: use -c to create the file\n"
"$ ### Use -m to use MD5 encryption of the password, which is more secure\n"
"$ htpasswd -cm /etc/svn-auth-file harry\n"
"New password: *****\n"
"Re-type new password: *****\n"
"Adding password for user harry\n"
"$ htpasswd -m /etc/svn-auth-file sally\n"
"New password: *******\n"
"Re-type new password: *******\n"
"Adding password for user sally\n"
"$\n"

#: build/en/book.xml:14074(para)
msgid "Next, you need to add some more <filename moreinfo=\"none\">httpd.conf</filename> directives inside your <literal moreinfo=\"none\">Location</literal> block to tell Apache what to do with your new password file. The <literal moreinfo=\"none\">AuthType</literal> directive specifies the type of authentication system to use. In this case, we want to specify the <literal moreinfo=\"none\">Basic</literal> authentication system. <literal moreinfo=\"none\">AuthName</literal> is an arbitrary name that you give for the authentication domain. Most browsers will display this name in the pop-up dialog box when the browser is querying the user for his name and password. Finally, use the <literal moreinfo=\"none\">AuthUserFile</literal> directive to specify the location of the password file you created using <command moreinfo=\"none\">htpasswd</command>."
msgstr "下一步，你需要在<filename moreinfo=\"none\">httpd.conf</filename>的<literal moreinfo=\"none\">Location</literal>区里添加一些指示来告诉Apache如何来使用这些密码文件，<literal moreinfo=\"none\">AuthType</literal>指示指定系统使用的认证类型，这种情况下，我们需要指定<literal moreinfo=\"none\">Basic</literal>认证系统，<literal moreinfo=\"none\">AuthName</literal>是你提供给认证域一个任意名称，大多数浏览器会在向用户询问名称和密码的弹出窗口里显示这个名称，最终，使用<literal moreinfo=\"none\">AuthUserFile</literal>指示来指定使用<command moreinfo=\"none\">htpasswd</command>创建的密码文件的位置。"

#: build/en/book.xml:14089(para)
msgid "After adding these three directives, your <literal moreinfo=\"none\">&lt;Location&gt;</literal> block should look something like this:"
msgstr "添加完这三个指示，你的<literal moreinfo=\"none\">&lt;Location&gt;</literal>区块一定像这个样子："

#: build/en/book.xml:14093(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /etc/svn-auth-file\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /etc/svn-auth-file\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14103(para)
msgid "This <literal moreinfo=\"none\">&lt;Location&gt;</literal> block is not yet complete, and will not do anything useful. It's merely telling Apache that whenever authorization is required, Apache should harvest a username and password from the Subversion client. What's missing here, however, are directives that tell Apache <emphasis>which</emphasis> sorts of client requests require authorization. Wherever authorization is required, Apache will demand authentication as well. The simplest thing to do is protect all requests. Adding <literal moreinfo=\"none\">Require valid-user</literal> tells Apache that all requests require an authenticated user:"
msgstr "这个<literal moreinfo=\"none\">&lt;Location&gt;</literal>区块还没有结束，还不能做任何有用的事情，它只是告诉Apache当需要授权时，要去向Subversion客户端索要用户名和密码。我们这里遗漏的，是一些告诉Apache<emphasis>什么样</emphasis>客户端需要授权的指示。哪里需要授权，Apache就会在哪里要求认证，最简单的方式是保护所有的请求，添加<literal moreinfo=\"none\">Require valid-user</literal>来告诉Apache任何请求需要认证的用户："

#: build/en/book.xml:14116(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /etc/svn-auth-file\n"
"  Require valid-user\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /etc/svn-auth-file\n"
"  Require valid-user\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14127(para)
msgid "Be sure to read the next section (<xref linkend=\"svn.serverconfig.httpd.authz\"/>) for more detail on the <literal moreinfo=\"none\">Require</literal> directive and other ways to set authorization policies."
msgstr "一定要阅读后面的部分（<xref linkend=\"svn.serverconfig.httpd.authz\"/>）来得到<literal moreinfo=\"none\">Require</literal>的细节，和授权政策的其他设置方法。"

#: build/en/book.xml:14140(para)
msgid "While self-signed server certificates are still vulnerable to a <quote>man in the middle</quote> attack, such an attack is still much more difficult for a casual observer to pull off, compared to sniffing unprotected passwords."
msgstr "当使用自签名的服务器时仍会遭受<quote>中间人</quote>攻击，但是与偷取未保护的密码相比，这样的攻击比一个偶然的获取要艰难许多。"

#: build/en/book.xml:14131(para)
#, fuzzy
msgid "One word of warning: HTTP Basic Auth passwords pass in very nearly plain-text over the network, and thus are extremely insecure. If you're worried about password snooping, it may be best to use some sort of SSL encryption, so that clients authenticate via <literal moreinfo=\"none\">https://</literal> instead of <literal moreinfo=\"none\">http://</literal>; at a bare minimum, you can configure Apache to use a self-signed server certificate. <placeholder-1/> Consult Apache's documentation (and OpenSSL documentation) about how to do that."
msgstr "需要警惕：HTTP基本认证的密码是用明文传输，因此非常不可靠的，如果你担心密码偷窥，最好是使用某种SSL加密，所以客户端认证使用<literal moreinfo=\"none\">https://</literal>而不是<literal moreinfo=\"none\">http://</literal>，为了方便，你可以配置Apache为自签名认证。 <footnote><placeholder-1/></footnote> 参考Apache的文档（和OpenSSL文档）来查看怎样做。"

#: build/en/book.xml:14154(title)
msgid "SSL Certificate Management"
msgstr "SSL 证书管理"

#: build/en/book.xml:14156(para)
msgid "Businesses that need to expose their repositories for access outside the company firewall should be conscious of the possibility that unauthorized parties could be <quote>sniffing</quote> their network traffic. SSL makes that kind of unwanted attention less likely to result in sensitive data leaks."
msgstr "商业应用需要越过公司防火墙的版本库访问，防火墙需要小心的考虑非认证用户<quote>吸取</quote>他们的网络流量的情况，SSL让那种形式的关注更不容易导致敏感数据泄露。"

#: build/en/book.xml:14163(para)
msgid "If a Subversion client is compiled to use OpenSSL, then it gains the ability to speak to an Apache server via <literal moreinfo=\"none\">https://</literal> URLs. The Neon library used by the Subversion client is not only able to verify server certificates, but can also supply client certificates when challenged. When the client and server have exchanged SSL certificates and successfully authenticated one another, all further communication is encrypted via a session key."
msgstr "如果Subversion使用OpenSSL编译，它就会具备与Subversion服务器使用<literal moreinfo=\"none\">https://</literal>的URL通讯的能力，Subversion客户端使用的Neon库不仅仅可以用来验证服务器证书，也可以必要时提供客户端证书，如果客户端和服务器交换了SSL证书并且成功地互相认证，所有剩下的交流都会通过一个会话关键字加密。"

#: build/en/book.xml:14172(para)
msgid "It's beyond the scope of this book to describe how to generate client and server certificates, and how to configure Apache to use them. Many other books, including Apache's own documentation, describe this task. But what <emphasis>can</emphasis> be covered here is how to manage server and client certificates from an ordinary Subversion client."
msgstr "怎样产生客户端和服务器端证书以及怎样使用它们已经超出了本书的范围，许多书籍，包括Apache自己的文档，描述这个任务，现在我们<emphasis>可以</emphasis>覆盖的是普通的客户端怎样来管理服务器与客户端证书。"

#: build/en/book.xml:14180(para)
msgid "When speaking to Apache via <literal moreinfo=\"none\">https://</literal>, a Subversion client can receive two different types of information:"
msgstr "当通过<literal moreinfo=\"none\">https://</literal>与Apache通讯时，一个Subversion客户端可以接收两种类型的信息："

#: build/en/book.xml:14185(para)
msgid "a server certificate"
msgstr "一个服务器证书"

#: build/en/book.xml:14186(para)
msgid "a demand for a client certificate"
msgstr "一个客户端证书的要求"

#: build/en/book.xml:14189(para)
msgid "If the client receives a server certificate, it needs to verify that it trusts the certificate: is the server really who it claims to be? The OpenSSL library does this by examining the signer of the server certificate, or <firstterm>certifying authority</firstterm> (CA). If OpenSSL is unable to automatically trust the CA, or if some other problem occurs (such as an expired certificate or hostname mismatch), the Subversion command-line client will ask you whether you want to trust the server certificate anyway:"
msgstr "如果客户端接收了一个服务器证书，它需要去验证它是可以相信的：这个服务器是它自称的那一个吗？OpenSSL库会去检验服务器证书的签名人或者是<firstterm>核证机构</firstterm>（CA）。如果OpenSSL不可以自动信任这个CA，或者是一些其他的问题（如证书过期或者是主机名不匹配），Subversion命令行客户端会询问你是否愿意仍然信任这个证书："

#: build/en/book.xml:14200(screen)
#, no-wrap
msgid ""
"\n"
"$ svn list https://host.example.com/repos/project\n"
"\n"
"Error validating server certificate for 'https://host.example.com:443':\n"
" - The certificate is not issued by a trusted authority. Use the\n"
"   fingerprint to validate the certificate manually!\n"
"Certificate information:\n"
" - Hostname: host.example.com\n"
" - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT\n"
" - Issuer: CA, example.com, Sometown, California, US\n"
" - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b\n"
"\n"
"(R)eject, accept (t)emporarily or accept (p)ermanently?\n"
msgstr ""
"\n"
"$ svn list https://host.example.com/repos/project\n"
"\n"
"Error validating server certificate for 'https://host.example.com:443':\n"
" - The certificate is not issued by a trusted authority. Use the\n"
"   fingerprint to validate the certificate manually!\n"
"Certificate information:\n"
" - Hostname: host.example.com\n"
" - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT\n"
" - Issuer: CA, example.com, Sometown, California, US\n"
" - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b\n"
"\n"
"(R)eject, accept (t)emporarily or accept (p)ermanently?\n"

#: build/en/book.xml:14215(para)
msgid "This dialogue should look familiar; it's essentially the same question you've probably seen coming from your web browser (which is just another HTTP client like Subversion!). If you choose the (p)ermanent option, the server certificate will be cached in your private run-time <filename moreinfo=\"none\">auth/</filename> area in just the same way your username and password are cached (see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>). If cached, Subversion will automatically remember to trust this certificate in future negotiations."
msgstr "这个对话看起来很熟悉，这是你会在web浏览器（另一种HTTP客户端，就像Subversion）经常看到的问题，如果你选择(p)ermanent选项，服务器证书会存放在你存放那个用户名和密码缓存（见<xref linkend=\"svn.serverconfig.netmodel.credcache\"/>。）的私有运行区<filename moreinfo=\"none\">auth/</filename>中，缓存后，Subversion会自动记住在以后的交流中信任这个证书。"

#: build/en/book.xml:14225(para)
msgid "Your run-time <filename moreinfo=\"none\">servers</filename> file also gives you the ability to make your Subversion client automatically trust specific CAs, either globally or on a per-host basis. Simply set the <literal moreinfo=\"none\">ssl-authority-files</literal> variable to a semicolon-separated list of PEM-encoded CA certificates:"
msgstr "你的运行中<filename moreinfo=\"none\">servers</filename>文件也会给你能力可以让Subversion客户端自动信任特定的CA，包括全局的或是每主机为基础的，只需要设置<literal moreinfo=\"none\">ssl-authority-files</literal>为一组逗号隔开的PEM加密的CA证书列表："

#: build/en/book.xml:14232(screen)
#, no-wrap
msgid ""
"\n"
"[global]\n"
"ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem\n"
msgstr ""
"\n"
"[global]\n"
"ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem\n"

#: build/en/book.xml:14237(para)
msgid "Many OpenSSL installations also have a pre-defined set of <quote>default</quote> CAs that are nearly universally trusted. To make the Subversion client automatically trust these standard authorities, set the <literal moreinfo=\"none\">ssl-trust-default-ca</literal> variable to <literal moreinfo=\"none\">true</literal>."
msgstr "许多OpenSSL安装包括一些预先定义好的可以普遍信任的<quote>缺省的</quote>CA，为了让Subversion客户端自动信任这些标准权威，设置<literal moreinfo=\"none\">ssl-trust-default-ca</literal>为<literal moreinfo=\"none\">true</literal>。"

#: build/en/book.xml:14244(para)
msgid "When talking to Apache, a Subversion client might also receive a challenge for a client certificate. Apache is asking the client to identify itself: is the client really who it says it is? If all goes correctly, the Subversion client sends back a private certificate signed by a CA that Apache trusts. A client certificate is usually stored on disk in encrypted format, protected by a local password. When Subversion receives this challenge, it will ask you for both a path to the certificate and the password which protects it:"
msgstr "当与Apache通话时，Subversion客户端也会收到一个证书的要求，Apache是询问客户端来证明自己的身份：这个客户端是否是他所说的那一个？如果一切正常，Subversion客户端会发送回一个通过Apache信任的CA签名的私有证书，一个客户端证书通常会以加密方式存放在磁盘，使用本地密码保护，当Subversion收到这个要求，它会询问你证书的路径和保护用的密码："

#: build/en/book.xml:14255(screen)
#, no-wrap
msgid ""
"\n"
"$ svn list https://host.example.com/repos/project\n"
"\n"
"Authentication realm: https://host.example.com:443\n"
"Client certificate filename: /path/to/my/cert.p12\n"
"Passphrase for '/path/to/my/cert.p12':  ********\n"
"…\n"
msgstr ""
"\n"
"$ svn list https://host.example.com/repos/project\n"
"\n"
"Authentication realm: https://host.example.com:443\n"
"Client certificate filename: /path/to/my/cert.p12\n"
"Passphrase for '/path/to/my/cert.p12':  ********\n"
"…\n"

#: build/en/book.xml:14264(para)
msgid "Notice that the client certificate is a <quote>p12</quote> file. To use a client certificate with Subversion, it must be in PKCS#12 format, which is a portable standard. Most web browsers are already able to import and export certificates in that format. Another option is to use the OpenSSL command-line tools to convert existing certificates into PKCS#12."
msgstr "注意这个客户端证书是一个<quote>p12</quote>文件，为了让Subversion使用客户端证书，它必须是运输标准的PKCS#12格式，大多数浏览器可以导入和导出这种格式的证书，另一个选择是用OpenSSL命令行工具来转化存在的证书为PKCS#12格式。"

#: build/en/book.xml:14272(para)
msgid "Again, the runtime <filename moreinfo=\"none\">servers</filename> file allows you to automate this challenge on a per-host basis. Either or both pieces of information can be described in runtime variables:"
msgstr "再次，运行中<filename moreinfo=\"none\">servers</filename>文件允许你为每个主机自动响应这种要求，单个或两条信息可以用运行参数来描述："

#: build/en/book.xml:14277(screen)
#, no-wrap
msgid ""
"\n"
"[groups]\n"
"examplehost = host.example.com\n"
"\n"
"[examplehost]\n"
"ssl-client-cert-file = /path/to/my/cert.p12\n"
"ssl-client-cert-password = somepassword\n"
msgstr ""
"\n"
"[groups]\n"
"examplehost = host.example.com\n"
"\n"
"[examplehost]\n"
"ssl-client-cert-file = /path/to/my/cert.p12\n"
"ssl-client-cert-password = somepassword\n"

#: build/en/book.xml:14292(para)
msgid "More security-conscious folk might not want to store the client certificate password in the runtime <filename moreinfo=\"none\">servers</filename> file."
msgstr "更多有安全意识的人不会希望在运行中<filename moreinfo=\"none\">servers</filename>文件保存客户端证书密码。"

#: build/en/book.xml:14286(para)
#, fuzzy
msgid "Once you've set the <literal moreinfo=\"none\">ssl-client-cert-file</literal> and <literal moreinfo=\"none\">ssl-client-cert-password</literal> variables, the Subversion client can automatically respond to a client certificate challenge without prompting you. <placeholder-1/>"
msgstr "一旦你设置了<literal moreinfo=\"none\">ssl-client-cert-file</literal>和 <literal moreinfo=\"none\">ssl-client-cert-password</literal>参数，Subversion客户端可以自动响应客户端证书请求而不会打扰你。 <footnote><placeholder-1/></footnote>"

#: build/en/book.xml:14304(title)
msgid "Authorization Options"
msgstr "授权选项"

#: build/en/book.xml:14306(para)
msgid "At this point, you've configured authentication, but not authorization. Apache is able to challenge clients and confirm identities, but it has not been told how to allow or restrict access to the clients bearing those identities. This section describes two strategies for controlling access to your repositories."
msgstr "此刻，你已经配置了认证，但是没有配置授权，Apache可以要求用户认证并且确定身份，但是并没有说明这个身份的怎样允许和限制，这个部分描述了两种控制访问版本库的策略。"

#: build/en/book.xml:14315(title)
msgid "Blanket Access Control"
msgstr "整体访问控制"

#: build/en/book.xml:14317(para)
msgid "The simplest form of access control is to authorize certain users for either read-only access to a repository, or read/write access to a repository."
msgstr "最简单的访问控制形式是授权特定用户为只读版本库访问或者是读/写访问版本库。"

#: build/en/book.xml:14321(para)
msgid "You can restrict access on all repository operations by adding the <literal moreinfo=\"none\">Require valid-user</literal> directive to your <literal moreinfo=\"none\">&lt;Location&gt;</literal> block. Using our previous example, this would mean that only clients that claimed to be either <literal moreinfo=\"none\">harry</literal> or <literal moreinfo=\"none\">sally</literal>, and provided the correct password for their respective username, would be allowed to do anything with the Subversion repository:"
msgstr "你可以通过在<literal moreinfo=\"none\">&lt;Location&gt;</literal>区块添加<literal moreinfo=\"none\">Require valid-user</literal>指示来限制所有的版本库操作，使用我们前面的例子，这意味着只有客户端只可以是<literal moreinfo=\"none\">harry</literal>或者<literal moreinfo=\"none\">sally</literal>，而且他们必须提供正确的用户名及对应密码，这样允许对Subversion版本库做任何事："

#: build/en/book.xml:14330(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"\n"
"  # only authenticated users may access the repository\n"
"  Require valid-user\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"\n"
"  # only authenticated users may access the repository\n"
"  Require valid-user\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14345(para)
msgid "Sometimes you don't need to run such a tight ship. For example, Subversion's own source code repository at <ulink url=\"http://svn.collab.net/repos/svn\"/> allows anyone in the world to perform read-only repository tasks (like checking out working copies and browsing the repository with a web browser), but restricts all write operations to authenticated users. To do this type of selective restriction, you can use the <literal moreinfo=\"none\">Limit</literal> and <literal moreinfo=\"none\">LimitExcept</literal> configuration directives. Like the <literal moreinfo=\"none\">Location</literal> directive, these blocks have starting and ending tags, and you would nest them inside your <literal moreinfo=\"none\">&lt;Location&gt;</literal> block."
msgstr "有时候，你不需要这样严密，举个例子，Subversion自己在<ulink url=\"http://svn.collab.net/repos/svn\"/>的源代码允许全世界的人执行版本库的只读操作（例如检出我们的工作拷贝和使用浏览器浏览版本库），但是限定只有认证用户可以执行写操作。为了执行特定的限制，你可以使用<literal moreinfo=\"none\">Limit</literal>和<literal moreinfo=\"none\">LimitExcept</literal>配置指示，就像<literal moreinfo=\"none\">Location</literal>指示，这个区块有开始和结束标签，你需要在<literal moreinfo=\"none\">&lt;Location&gt;</literal>中添加这个指示。"

#: build/en/book.xml:14359(para)
msgid "The parameters present on the <literal moreinfo=\"none\">Limit</literal> and <literal moreinfo=\"none\">LimitExcept</literal> directives are HTTP request types that are affected by that block. For example, if you wanted to disallow all access to your repository except the currently supported read-only operations, you would use the <literal moreinfo=\"none\">LimitExcept</literal> directive, passing the <literal moreinfo=\"none\">GET</literal>, <literal moreinfo=\"none\">PROPFIND</literal>, <literal moreinfo=\"none\">OPTIONS</literal>, and <literal moreinfo=\"none\">REPORT</literal> request type parameters. Then the previously mentioned <literal moreinfo=\"none\">Require valid-user</literal> directive would be placed inside the <literal moreinfo=\"none\">&lt;LimitExcept&gt;</literal> block instead of just inside the <literal moreinfo=\"none\">&lt;Location&gt;</literal> block."
msgstr "在<literal moreinfo=\"none\">Limit</literal>和<literal moreinfo=\"none\">LimitExcept</literal>中使用的参数是可以被这个区块影响的HTTP请求类型，举个例子，如果你希望禁止所有的版本库访问，只是保留当前支持的只读操作，你可以使用<literal moreinfo=\"none\">LimitExcept</literal>指示，并且使用<literal moreinfo=\"none\">GET</literal>，<literal moreinfo=\"none\">PROPFIND</literal>，<literal moreinfo=\"none\">OPTIONS</literal>和<literal moreinfo=\"none\">REPORT</literal>请求类型参数，然后前面提到过的<literal moreinfo=\"none\">Require valid-user</literal>指示将会在<literal moreinfo=\"none\">&lt;LimitExcept&gt;</literal>区块中而不是在<literal moreinfo=\"none\">&lt;Location&gt;</literal>区块。"

#: build/en/book.xml:14373(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"\n"
"  # For any operations other than these, require an authenticated user.\n"
"  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;\n"
"    Require valid-user\n"
"  &lt;/LimitExcept&gt;\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"\n"
"  # For any operations other than these, require an authenticated user.\n"
"  &lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;\n"
"    Require valid-user\n"
"  &lt;/LimitExcept&gt;\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14390(para)
msgid "These are only a few simple examples. For more in-depth information about Apache access control and the <literal moreinfo=\"none\">Require</literal> directive, take a look at the <literal moreinfo=\"none\">Security</literal> section of the Apache documentation's tutorials collection at <ulink url=\"http://httpd.apache.org/docs-2.0/misc/tutorials.html\"/>."
msgstr "这里只是一些简单的例子，想看关于Apache访问控制<literal moreinfo=\"none\">Require</literal>指示的更深入信息，可以查看Apache文档中的教程集<ulink url=\"http://httpd.apache.org/docs-2.0/misc/tutorials.html\"/>中的<literal moreinfo=\"none\">Security</literal>部分。"

#: build/en/book.xml:14401(title)
msgid "Per-Directory Access Control"
msgstr "每目录访问控制"

#: build/en/book.xml:14403(para)
msgid "It's possible to set up finer-grained permissions using a second Apache httpd module, <command moreinfo=\"none\">mod_authz_svn</command>. This module grabs the various opaque URLs passing from client to server, asks <command moreinfo=\"none\">mod_dav_svn</command> to decode them, and then possibly vetoes requests based on access policies defined in a configuration file."
msgstr "也可以使用Apache的httpd模块<command moreinfo=\"none\">mod_authz_svn</command>更加细致的设置访问权限，这个模块收集客户端传递过来的不同的晦涩的URL信息，询问<command moreinfo=\"none\">mod_dav_svn</command>来解码，然后根据在配置文件定义的访问政策来裁决请求。"

#: build/en/book.xml:14411(para)
msgid "If you've built Subversion from source code, <command moreinfo=\"none\">mod_authz_svn</command> is automatically built and installed alongside <command moreinfo=\"none\">mod_dav_svn</command>. Many binary distributions install it automatically as well. To verify that it's installed correctly, make sure it comes right after <command moreinfo=\"none\">mod_dav_svn</command>'s <literal moreinfo=\"none\">LoadModule</literal> directive in <filename moreinfo=\"none\">httpd.conf</filename>:"
msgstr "如果你从源代码创建Subversion，<command moreinfo=\"none\">mod_authz_svn</command>会自动附加到<command moreinfo=\"none\">mod_dav_svn</command>，许多二进制分发版本也会自动安装，为了验证它是安装正确，确定它是在<filename moreinfo=\"none\">httpd.conf</filename>的<literal moreinfo=\"none\">LoadModule</literal>指示中的<command moreinfo=\"none\">mod_dav_svn</command>后面："

#: build/en/book.xml:14420(screen)
#, no-wrap
msgid ""
"\n"
"LoadModule dav_module         modules/mod_dav.so\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"
"LoadModule authz_svn_module   modules/mod_authz_svn.so\n"
msgstr ""
"\n"
"LoadModule dav_module         modules/mod_dav.so\n"
"LoadModule dav_svn_module     modules/mod_dav_svn.so\n"
"LoadModule authz_svn_module   modules/mod_authz_svn.so\n"

#: build/en/book.xml:14426(para)
msgid "To activate this module, you need to configure your <literal moreinfo=\"none\">Location</literal> block to use the <literal moreinfo=\"none\">AuthzSVNAccessFile</literal> directive, which specifies a file containing the permissions policy for paths within your repositories. (In a moment, we'll discuss the format of that file.)"
msgstr "为了激活这个模块，你需要配置你的<literal moreinfo=\"none\">Location</literal>区块的<literal moreinfo=\"none\">AuthzSVNAccessFile</literal>指示，指定保存路径中的版本库访问政策的文件。（一会儿我们将会讨论这个文件的格式。）"

#: build/en/book.xml:14433(para)
msgid "Apache is flexible, so you have the option to configure your block in one of three general patterns. To begin, choose one of these basic configuration patterns. (The examples below are very simple; look at Apache's own documentation for much more detail on Apache authentication and authorization options.)"
msgstr "Apache非常的灵活，你可以从三种模式里选择一种来配置你的区块，作为开始，你选择一种基本的配置模式。（下面的例子非常简单；见Apache自己的文档中的认证和授权选项来查看更多的细节。）"

#: build/en/book.xml:14440(para)
msgid "The simplest block is to allow open access to everyone. In this scenario, Apache never sends authentication challenges, so all users are treated as <quote>anonymous</quote>."
msgstr "最简单的区块是允许任何人可以访问，在这个场景里，Apache决不会发送认证请求，所有的用户作为<quote>匿名</quote>对待。"

#: build/en/book.xml:14446(title)
msgid "A sample configuration for anonymous access."
msgstr "匿名访问的配置实例。"

#: build/en/book.xml:14447(programlisting)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"&lt;/Location&gt;\n"
"          "
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"&lt;/Location&gt;\n"
"          "

#: build/en/book.xml:14458(para)
msgid "On the opposite end of the paranoia scale, you can configure your block to demand authentication from everyone. All clients must supply credentials to identify themselves. Your block unconditionally requires authentication via the <literal moreinfo=\"none\">Require valid-user</literal> directive, and defines a means to authenticate."
msgstr "在另一个极端，你可以配置为拒绝所有人的认证，所有客户端必须提供证明自己身份的证书，你通过<literal moreinfo=\"none\">Require valid-user</literal>指示来阻止无条件的认证，并且定义一种认证的手段。"

#: build/en/book.xml:14466(title)
msgid "A sample configuration for authenticated access."
msgstr "一个认证访问的配置实例。"

#: build/en/book.xml:14467(programlisting)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"\n"
"  # only authenticated users may access the repository\n"
"  Require valid-user\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"&lt;/Location&gt;\n"
"          "
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"\n"
"  # only authenticated users may access the repository\n"
"  Require valid-user\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"&lt;/Location&gt;\n"
"          "

#: build/en/book.xml:14486(para)
msgid "A third very popular pattern is to allow a combination of authenticated and anonymous access. For example, many administrators want to allow anonymous users to read certain repository directories, but want only authenticated users to read (or write) more sensitive areas. In this setup, all users start out accessing the repository anonymously. If your access control policy demands a real username at any point, Apache will demand authentication from the client. To do this, you use both the <literal moreinfo=\"none\">Satisfy Any</literal> and <literal moreinfo=\"none\">Require valid-user</literal> directives together."
msgstr "第三种流行的模式是允许认证和匿名用户的组合，举个例子，许多管理员希望允许匿名用户读取特定的版本库路径，但希望只有认证用户可以读（或者写）更多敏感的区域，在这个设置里，所有的用户开始时用匿名用户访问版本库，如果你的访问控制策略在任何时候要求一个真实的用户名，Apache将会要求认证客户端，为­¤，你可以同时使用<literal moreinfo=\"none\">Satisfy Any</literal>和<literal moreinfo=\"none\">Require valid-user</literal>指示。"

#: build/en/book.xml:14499(title)
msgid "A sample configuration for mixed authenticated/anonymous access."
msgstr "一个混合认证/匿名访问的配置实例。"

#: build/en/book.xml:14501(programlisting)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"\n"
"  # try anonymous access first, resort to real\n"
"  # authentication if necessary.\n"
"  Satisfy Any\n"
"  Require valid-user\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"&lt;/Location&gt;\n"
"          "
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  # our access control policy\n"
"  AuthzSVNAccessFile /path/to/access/file\n"
"\n"
"  # try anonymous access first, resort to real\n"
"  # authentication if necessary.\n"
"  Satisfy Any\n"
"  Require valid-user\n"
"\n"
"  # how to authenticate a user\n"
"  AuthType Basic\n"
"  AuthName \"Subversion repository\"\n"
"  AuthUserFile /path/to/users/file\n"
"&lt;/Location&gt;\n"
"          "

#: build/en/book.xml:14522(para)
msgid "Once you've settled on one of these three basic <filename moreinfo=\"none\">httpd.conf</filename> templates, you need to create your file containing access rules for particular paths within the repository. This is described in <xref linkend=\"svn.serverconfig.pathbasedauthz\"/>."
msgstr ""

#: build/en/book.xml:14532(title)
msgid "Disabling Path-based Checks"
msgstr "禁用基于路径的检查"

#: build/en/book.xml:14534(para)
msgid "The <command moreinfo=\"none\">mod_dav_svn</command> module goes through a lot of work to make sure that data you've marked <quote>unreadable</quote> doesn't get accidentally leaked. This means that it needs to closely monitor all of the paths and file-contents returned by commands like <command moreinfo=\"none\">svn checkout</command> or <command moreinfo=\"none\">svn update</command> commands. If these commands encounter a path that isn't readable according to some authorization policy, then the path is typically omitted altogether. In the case of history or rename tracing—e.g. running a command like <command moreinfo=\"none\">svn cat -r OLD foo.c</command> on a file that was renamed long ago—the rename tracking will simply halt if one of the object's former names is determined to be read-restricted."
msgstr "<command moreinfo=\"none\">mod_dav_svn</command>模块做了许多工作来确定你标记为<quote>不可读</quote>的数据不会因意外而泄露，这意味着需要紧密监控通过<command moreinfo=\"none\">svn checkout</command>或是<command moreinfo=\"none\">svn update</command>返回的路径和文件内容，如果这些命令遇到一些根据认证策略不是可读的路径，这个路径通常会被一起忽略，在历史或者重命名操作时—例如运行一个类似<command moreinfo=\"none\">svn cat -r OLD foo.c</command>的命令来操作一个很久以前改过名字的文件 — 如果一个对象的以前的名字检测到是只读的，重命令追踪就会终止。"

#: build/en/book.xml:14549(para)
#, fuzzy
msgid "All of this path-checking can sometimes be quite expensive, especially in the case of <command moreinfo=\"none\">svn log</command>. When retrieving a list of revisions, the server looks at every changed path in each revision and checks it for readability. If an unreadable path is discovered, then it's omitted from the list of the revision's changed paths (normally seen with the <option>--verbose</option> option), and the whole log message is suppressed. Needless to say, this can be time-consuming on revisions that affect a large number of files. This is the cost of security: even if you haven't configured a module like <command moreinfo=\"none\">mod_authz_svn</command> at all, the <command moreinfo=\"none\">mod_dav_svn</command> module is still asking Apache <command moreinfo=\"none\">httpd</command> to run authorization checks on every path. The <command moreinfo=\"none\">mod_dav_svn</command> module has no idea what authorization modules have been installed, so all it can do is ask Apache to invoke whatever might be present."
msgstr "所有的路径检查在有时会非常昂贵，特别是<command moreinfo=\"none\">svn log</command>的情况。当检索一列修订版本时，服务器会查看所有修订版本修改的路径，并且检查可读性，如果发现了一个不可读路径，它会从修订版本的修改路径中忽略（可以查看<option>--verbose</option>选项），并且整个的日志信息会被禁止，不必多说，这种影响大量文件修订版本的操作会非常耗时。这是安全的代价：即使你并没有配置<command moreinfo=\"none\">mod_authz_svn</command>模块，<command moreinfo=\"none\">mod_dav_svn</command>还是会询问<command moreinfo=\"none\">httpd</command>来对所有路径运行认证检查，<command moreinfo=\"none\">mod_dav_svn</command>模块没有办法知道那个认证模块被安装，所以只有询问Apache来调用所提供的模块。"

#: build/en/book.xml:14568(para)
msgid "On the other hand, there's also an escape-hatch of sorts, one which allows you to trade security features for speed. If you're not enforcing any sort of per-directory authorization (i.e. not using <command moreinfo=\"none\">mod_authz_svn</command> or similar module), then you can disable all of this path-checking. In your <filename moreinfo=\"none\">httpd.conf</filename> file, use the <literal moreinfo=\"none\">SVNPathAuthz</literal> directive:"
msgstr "在另一方面，也有一个安全舱门允许你用安全特性来交换速度，如果你不是坚持要求有每目录授权（如不使用 <command moreinfo=\"none\">mod_authz_svn</command>和类似的模块），你就可以关闭所有的路径检查，在你的<filename moreinfo=\"none\">httpd.conf</filename>文件，使用<literal moreinfo=\"none\">SVNPathAuthz</literal>指示："

#: build/en/book.xml:14578(title)
msgid "Disabling path checks altogether"
msgstr "禁用所有的路径检查"

#: build/en/book.xml:14579(programlisting)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  SVNPathAuthz off\n"
"&lt;/Location&gt;\n"
"          "
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"\n"
"  SVNPathAuthz off\n"
"&lt;/Location&gt;\n"
"          "

#: build/en/book.xml:14589(para)
msgid "The <literal moreinfo=\"none\">SVNPathAuthz</literal> directive is <quote>on</quote> by default. When set <quote>off</quote>, all path-based authorization checking is disabled; <command moreinfo=\"none\">mod_dav_svn</command> stops invoking authorization checks on every path it discovers."
msgstr "<literal moreinfo=\"none\">SVNPathAuthz</literal>指示缺省是<quote>on</quote>，当设置为<quote>off</quote>时，所有的路径为基础的授权都会关闭；<command moreinfo=\"none\">mod_dav_svn</command>停止对每个目录调用授权检查。"

#: build/en/book.xml:14601(title)
msgid "Extra Goodies"
msgstr "额外的糖果"

#: build/en/book.xml:14603(para)
msgid "We've covered most of the authentication and authorization options for Apache and mod_dav_svn. But there are a few other nice features that Apache provides."
msgstr "我们已经覆盖了关于认证和授权的Apache和mod_dav_svn的大多数选项，但是Apache还提供了许多很好的特性。"

#: build/en/book.xml:14609(title)
msgid "Repository Browsing"
msgstr "版本库浏览"

#: build/en/book.xml:14611(para)
#, fuzzy
msgid "One of the most useful benefits of an Apache/WebDAV configuration for your Subversion repository is that the youngest revisions of your versioned files and directories are immediately available for viewing via a regular web browser. Since Subversion uses URLs to identify versioned resources, those URLs used for HTTP-based repository access can be typed directly into a Web browser. Your browser will issue an HTTP <literal moreinfo=\"none\">GET</literal> request for that URL, and based on whether that URL represents a versioned directory or file, mod_dav_svn will respond with a directory listing or with file contents."
msgstr "一个非常有用的好处是使用Apache/WebDAV配置Subversion版本库时可以用普通的浏览器察看最新的版本库文件，因为Subversion使用URL来鉴别版本库版本化的资源，版本库使用的HTTP为基础的URL也可以直接输入到Web浏览器中，你的浏览器会发送一个<literal moreinfo=\"none\">GET</literal>请求到URL，根据访问的URL是指向一个版本化的目录还是文件，mod_dav_svn会负责列出目录列表或者是文件内容。"

#: build/en/book.xml:14623(para)
msgid "Since the URLs do not contain any information about which version of the resource you wish to see, mod_dav_svn will always answer with the youngest version. This functionality has the wonderful side-effect that you can pass around Subversion URLs to your peers as references to documents, and those URLs will always point at the latest manifestation of that document. Of course, you can even use the URLs as hyperlinks from other web sites, too."
msgstr "因为URL不能确定你所希望看到的资源的版本，mod_dav_svn会一直返回最新的版本，这样会有一些美妙的副作用，你可以直接把Subversion的URL传递给文档作为引用，这些URL会一直指向文档最新的材料，当然，你也可以在别的网站作为超链使用这些URL。"

#: build/en/book.xml:14633(title)
msgid "Can I view older revisions?"
msgstr "我可以看到老的修订版本吗？"

#: build/en/book.xml:14635(para)
msgid "With an ordinary web browser? In one word: nope. At least, not with <command moreinfo=\"none\">mod_dav_svn</command> as your only tool."
msgstr "通过一个普通的浏览器？一句话：不可以，至少是当你只使用<command moreinfo=\"none\">mod_dav_svn</command>作为唯一的工具时。"

#: build/en/book.xml:14639(para)
#, fuzzy
msgid "Your web browser only speaks ordinary HTTP. That means it only knows how to GET public URLs, which represent the latest versions of files and directories. According to the WebDAV/DeltaV specification, each server defines a private URL syntax for older versions of resources, and that syntax is opaque to clients. To find an older version of a file, a client must follow a specific procedure to <quote>discover</quote> the proper URL; the procedure involves issuing a series of WebDAV PROPFIND requests and understanding DeltaV concepts. This is something your web browser simply can't do."
msgstr "你的Web浏览器只会说普通的HTTP，也就是说它只会GET公共的URL，这个URL代表了最新版本的文件和目录，根据WebDAV/DeltaV规范，每种服务器定义了一种私有的URL语法来代表老的资源的版本，这个语法对客户端是不透明的，为了得到老的版本，一个客户端必须通过一种规范过程来<quote>发现</quote>正确的URL；这个过程包括执行一系列WebDAV PROPFIND请求和理解DeltaV概念，这些事情一般是你的web浏览器做不了的。"

#: build/en/book.xml:14662(para)
msgid "Back then, it was called <quote>ViewCVS</quote>."
msgstr "之前叫做<quote>ViewCVS</quote>。"

#: build/en/book.xml:14651(para)
#, fuzzy
msgid "So to answer the question, one obvious way to see older revisions of files and directories is by passing the <option>--revision (-r)</option> argument to the <command moreinfo=\"none\">svn list</command> and <command moreinfo=\"none\">svn cat</command> commands. To browse old revisions with your web browser, however, you can use third-party software. A good example of this is ViewVC (<ulink url=\"http://viewvc.tigris.org/\"/>). ViewVC was originally written to display CVS repositories through the web, <placeholder-1/> and the latest releases are able to understand Subversion repositories as well."
msgstr "为了回答这些问题，一个明显的看老版本文件和目录的方式是带<option>--revision</option>参数的<command moreinfo=\"none\">svn list</command>和<command moreinfo=\"none\">svn cat</command>命令，为了在浏览器里察看老版本，你可以使用第三方的软件，一个好的例子是ViewVC（<ulink url=\"http://viewvc.tigris.org/\"/>），ViewVC最初写出来是为了在web显示CVS版本库，<footnote><placeholder-1/></footnote>最新的带血的（此时正在编写）版本也已经可以理解Subversion版本库了。"

#: build/en/book.xml:14669(title)
msgid "Proper MIME Type"
msgstr "正确的文件类型"

#: build/en/book.xml:14671(para)
msgid "When browsing a Subversion repository, the web browser gets a clue about how to render a file's contents by looking at the <literal moreinfo=\"none\">Content-Type:</literal> header returned in Apache's response to the HTTP <literal moreinfo=\"none\">GET</literal> request. The value of this header is some sort of MIME type. By default, Apache will tell the web browsers that all repository files are of the <quote>default</quote> MIME type, typically <literal moreinfo=\"none\">text/plain</literal>. This can be frustrating, however, if a user wishes repository files to render as something more meaningful — for example, it might be nice to have a <filename moreinfo=\"none\">foo.html</filename> file in the repository actually render as HTML when browsing."
msgstr ""

#: build/en/book.xml:14686(para)
msgid "To make this happen, you only need to make sure that your files have the proper <literal moreinfo=\"none\">svn:mime-type</literal> set. This is discussed in more detail in <xref linkend=\"svn.advanced.props.special.mime-type\"/>, and you can even configure your client to automatically attach proper <literal moreinfo=\"none\">svn:mime-type</literal> properties to files entering the repository for the first time; see <xref linkend=\"svn.advanced.props.auto\"/>."
msgstr ""

#: build/en/book.xml:14696(para)
msgid "So in our example, if one were to set the <literal moreinfo=\"none\">svn:mime-type</literal> property to <literal moreinfo=\"none\">text/html</literal> on file <filename moreinfo=\"none\">foo.html</filename>, then Apache would properly tell your web browser to render the file as HTML. One could also attach proper <literal moreinfo=\"none\">image/*</literal> mime-type properties to images, and by doing this, ultimately get an entire web site to be viewable directly from a repository! There's generally no problem with doing this, as long as the website doesn't contain any dynamically-generated content."
msgstr ""

#: build/en/book.xml:14712(title)
msgid "Customizing the Look"
msgstr "定制外观"

#: build/en/book.xml:14714(para)
msgid "You generally will get more use out of URLs to versioned files—after all, that's where the interesting content tends to lie. But you might have occasion to browse a Subversion directory listing, where you'll quickly note that the generated HTML used to display that listing is very basic, and certainly not intended to be aesthetically pleasing (or even interesting). To enable customization of these directory displays, Subversion provides an XML index feature. A single <literal moreinfo=\"none\">SVNIndexXSLT</literal> directive in your repository's <literal moreinfo=\"none\">Location</literal> block of <filename moreinfo=\"none\">httpd.conf</filename> will instruct mod_dav_svn to generate XML output when displaying a directory listing, and to reference the XSLT stylesheet of your choice:"
msgstr "你通常会在版本化的文件的URL之外得到更多地用处—毕竟那里是有趣的内容存在的地方，但是你会偶尔浏览一个Subversion的目录列表，你会很快发现展示列表生成的HTML非常基本，并且一定没有在外观上（或者是有趣上）下功夫，为了自定义这些目录显示，Subversion提供了一个XML目录特性，一个单独的<literal moreinfo=\"none\">SVNIndexXSLT</literal>指示在你的<filename moreinfo=\"none\">httpd.conf</filename>文件版本库的<literal moreinfo=\"none\">Location</literal>块里，它将会指导mod_dav_svn在显示目录列表的时候生成XML输出，并且引用你选择的XSLT样式表文件："

#: build/en/book.xml:14730(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  SVNIndexXSLT \"/svnindex.xsl\"\n"
"  …\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  SVNIndexXSLT \"/svnindex.xsl\"\n"
"  …\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14739(para)
msgid "Using the <literal moreinfo=\"none\">SVNIndexXSLT</literal> directive and a creative XSLT stylesheet, you can make your directory listings match the color schemes and imagery used in other parts of your website. Or, if you'd prefer, you can use the sample stylesheets provided in the Subversion source distribution's <filename moreinfo=\"none\">tools/xslt/</filename> directory. Keep in mind that the path provided to the <literal moreinfo=\"none\">SVNIndexXSLT</literal> directory is actually a URL path—browsers need to be able to read your stylesheets in order to make use of them!"
msgstr "使用<literal moreinfo=\"none\">SVNIndexXSLT</literal>指示和创建一个XSLT样式表，你可以让你的目录列表的颜色模式与你的网站的其它部分匹配，否则，如果你愿意，你可以使用Subversion源分发版本中的<filename moreinfo=\"none\">tools/xslt/</filename>目录下的样例样式表。记住提供给<literal moreinfo=\"none\">SVNIndexXSLT</literal> 指示的路径是一个URL路径—浏览器需要阅读你的样式表来利用它们！"

#: build/en/book.xml:14753(title)
msgid "Listing Repositories"
msgstr "版本库列表"

#: build/en/book.xml:14755(para)
msgid "If you're serving a collection of repositories from a single URL via the <literal moreinfo=\"none\">SVNParentPath</literal> directive, then it's also possible to have Apache display all available repositories to a web browser. Just activate the <literal moreinfo=\"none\">SVNListParentPath</literal> directive:"
msgstr ""

#: build/en/book.xml:14762(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  SVNListParentPath on\n"
"  …\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  SVNParentPath /usr/local/svn\n"
"  SVNListParentPath on\n"
"  …\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:14771(para)
msgid "If a user now points her web browser to the URL <literal moreinfo=\"none\">http://host.example.com/svn/</literal>, she'll see list of all Subversion repositories sitting in <filename moreinfo=\"none\">/usr/local/svn</filename>. Obviously, this can be a security problem, so this feature is turned off by default."
msgstr ""

#: build/en/book.xml:14784(title)
msgid "Apache Logging"
msgstr "Apache 日志"

#: build/en/book.xml:14786(para)
msgid "Because Apache is an HTTP server at heart, it contains fantastically flexible logging feature. It's beyond the scope of this book to discuss all ways logging can be configured, but we should point out that even the most generic <filename moreinfo=\"none\">httpd.conf</filename> file will cause Apache to produce two logs: <filename moreinfo=\"none\">error_log</filename> and <filename moreinfo=\"none\">access_log</filename>. These logs may appear in different places, but are typically created in the logging area of your Apache installation. (On Unix, they often live in <filename moreinfo=\"none\">/usr/local/apache2/logs/</filename>.)"
msgstr ""

#: build/en/book.xml:14799(para)
msgid "The <filename moreinfo=\"none\">error_log</filename> describes any internal errors that Apache runs into as it works. The <filename moreinfo=\"none\">access_log</filename> file records every incoming HTTP request received by Apache. This makes it easy to see, for example, which IP addresses Subversion clients are coming from, how often particular clients use the server, which users are authenticating properly, and which requests succeed or fail."
msgstr ""

#: build/en/book.xml:14808(para)
msgid "Unfortunately, because HTTP is a stateless protocol, even the simplest Subversion client operation generates multiple network requests. It's very difficult to look at the <filename moreinfo=\"none\">access_log</filename> and deduce what the client was doing — most operations look like a series of cryptic <literal moreinfo=\"none\">PROPPATCH</literal>, <literal moreinfo=\"none\">GET</literal>, <literal moreinfo=\"none\">PUT</literal>, and <literal moreinfo=\"none\">REPORT</literal> requests. To make things worse, many client operations send nearly-identical series of requests, so it's even harder to tell them apart."
msgstr ""

#: build/en/book.xml:14819(para)
msgid "<literal moreinfo=\"none\">mod_dav_svn</literal>, however, can come to your aid. By activating an <quote>operational logging</quote> feature, you can ask <literal moreinfo=\"none\">mod_dav_svn</literal> to create a separate log file describing what sort of high-level operations your clients are performing."
msgstr ""

#: build/en/book.xml:14826(para)
msgid "To do this, you need to make use of Apache's <literal moreinfo=\"none\">CustomLog</literal> directive (which is explained in more detail in Apache's own documentation). Be sure to invoke this directive <emphasis>outside</emphasis> of your Subversion <literal moreinfo=\"none\">Location</literal> block:"
msgstr ""

#: build/en/book.xml:14833(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  …\n"
"&lt;/Location&gt;\n"
"\n"
"CustomLog logs/svn_logfile \"%t %u %{SVN-ACTION}e\" env=SVN-ACTION\n"
msgstr ""
"\n"
"&lt;Location /svn&gt;\n"
"  DAV svn\n"
"  …\n"
"&lt;/Location&gt;\n"
"\n"
"CustomLog logs/svn_logfile \"%t %u %{SVN-ACTION}e\" env=SVN-ACTION\n"

#: build/en/book.xml:14842(para)
msgid "In this example, we're asking Apache to create a special logfile <filename moreinfo=\"none\">svn_logfile</filename> in the standard Apache <filename moreinfo=\"none\">logs</filename> directory. The <literal moreinfo=\"none\">%t</literal> and <literal moreinfo=\"none\">%u</literal> variables are replaced by the time and username of the request, respectively. The really important part are the two instances of <literal moreinfo=\"none\">SVN-ACTION</literal>. When Apache sees that variable, it substitutes the value of the <literal moreinfo=\"none\">SVN-ACTION</literal> environment variable, which is automatically set by <literal moreinfo=\"none\">mod_dav_svn</literal> whenever it detects a high-level client action."
msgstr ""

#: build/en/book.xml:14854(para)
#, fuzzy
msgid "So instead of having to interpret a traditional <filename moreinfo=\"none\">access_log</filename> like this:"
msgstr "取出一个工作拷贝到<filename moreinfo=\"none\">mine</filename>："

#: build/en/book.xml:14858(screen)
#, no-wrap
msgid ""
"\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc/!svn/vcc/default HTTP/1.1\" 207 398\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc/!svn/bln/59 HTTP/1.1\" 207 449\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc HTTP/1.1\" 207 647\n"
"[26/Jan/2007:22:25:29 -0600] \"REPORT /svn/calc/!svn/vcc/default HTTP/1.1\" 200 607\n"
"[26/Jan/2007:22:25:31 -0600] \"OPTIONS /svn/calc HTTP/1.1\" 200 188\n"
"[26/Jan/2007:22:25:31 -0600] \"MKACTIVITY /svn/calc/!svn/act/e6035ef7-5df0-4ac0-b811-4be7c823f998 HTTP/1.1\" 201 227\n"
"…\n"
msgstr ""
"\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc/!svn/vcc/default HTTP/1.1\" 207 398\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc/!svn/bln/59 HTTP/1.1\" 207 449\n"
"[26/Jan/2007:22:25:29 -0600] \"PROPFIND /svn/calc HTTP/1.1\" 207 647\n"
"[26/Jan/2007:22:25:29 -0600] \"REPORT /svn/calc/!svn/vcc/default HTTP/1.1\" 200 607\n"
"[26/Jan/2007:22:25:31 -0600] \"OPTIONS /svn/calc HTTP/1.1\" 200 188\n"
"[26/Jan/2007:22:25:31 -0600] \"MKACTIVITY /svn/calc/!svn/act/e6035ef7-5df0-4ac0-b811-4be7c823f998 HTTP/1.1\" 201 227\n"
"…\n"

#: build/en/book.xml:14868(para)
#, fuzzy
msgid "… you can instead peruse a much more intelligible <filename moreinfo=\"none\">svn_logfile</filename> like this:"
msgstr "取出一个工作拷贝到<filename moreinfo=\"none\">mine</filename>："

#: build/en/book.xml:14871(screen)
#, no-wrap
msgid ""
"\n"
"[26/Jan/2007:22:24:20 -0600] - list-dir '/'\n"
"[26/Jan/2007:22:24:27 -0600] - update '/'\n"
"[26/Jan/2007:22:25:29 -0600] - remote-status '/'\n"
"[26/Jan/2007:22:25:31 -0600] sally commit r60\n"
msgstr ""
"\n"
"[26/Jan/2007:22:24:20 -0600] - list-dir '/'\n"
"[26/Jan/2007:22:24:27 -0600] - update '/'\n"
"[26/Jan/2007:22:25:29 -0600] - remote-status '/'\n"
"[26/Jan/2007:22:25:31 -0600] sally commit r60\n"

#: build/en/book.xml:14882(title)
msgid "Other Features"
msgstr "其它特性"

#: build/en/book.xml:14884(para)
#, fuzzy
msgid "Several of the features already provided by Apache in its role as a robust Web server can be leveraged for increased functionality or security in Subversion as well. Subversion communicates with Apache using Neon, which is a generic HTTP/WebDAV library with support for such mechanisms as SSL (the Secure Socket Layer, discussed earlier). If your Subversion client is built to support SSL, then it can access your Apache server using <literal moreinfo=\"none\">https://</literal>."
msgstr "Apache作为一个健壮的Web服务器的许多特性也可以用来增加Subversion的功能性和安全性，Subversion使用Neon与Apache通讯，这是一种一般的HTTP/WebDAV库，可以支持SSL和Deflate压缩（是<command moreinfo=\"none\">gzip</command>和<command moreinfo=\"none\">PKZIP</command>程序用来<quote>压缩</quote>文件为数据块的一样的算法）之类的机制。你只需要编译你希望Subversion和Apache需要的特性，并且正确的配置程序来使用这些特性。"

#: build/en/book.xml:14894(para)
#, fuzzy
msgid "Equally useful are other features of the Apache and Subversion relationship, such as the ability to specify a custom port (instead of the default HTTP port 80) or a virtual domain name by which the Subversion repository should be accessed, or the ability to access the repository through an HTTP proxy. These things are all supported by Neon, so Subversion gets that support for free."
msgstr "不怎么有趣，但同样重要，是Apache和Subversion关系的一些特性，像可以指定自定义的端口（而不是缺省的HTTP的80）或者是一个Subversion可以被访问的虚拟主机名，或者是通过代理服务器访问的能力，这些特性都是Neon所支持的，所以Subversion轻易得到这些支持。"

#: build/en/book.xml:14902(para)
#, fuzzy
msgid "Finally, because <command moreinfo=\"none\">mod_dav_svn</command> is speaking a subset of the WebDAV/DeltaV protocol, it's possible to access the repository via third-party DAV clients. Most modern operating systems (Win32, OS X, and Linux) have the built-in ability to mount a DAV server as a standard network share. This is a complicated topic; for details, read <xref linkend=\"svn.webdav\"/>."
msgstr "最后，因为<command moreinfo=\"none\">mod_dav_svn</command>是使用一个半完成的WebDAV/DeltaV方言，所以通过第三方的DAV客户端访问也是可能的，几乎所有的现代操作系统（Win32、OS X和Linux）都有把DAV服务器影射为普通的网络<quote>共享</quote>的内置能力，这是一个复杂的主题；察看<xref linkend=\"svn.webdav\"/>来得到更多细节。"

#: build/en/book.xml:14921(title)
msgid "Path-Based Authorization"
msgstr "基于路径的授权"

#: build/en/book.xml:14923(para)
msgid "Both Apache and <command moreinfo=\"none\">svnserve</command> are capable of granting (or denying) permissions to users. Typically this is done over the entire repository: a user can read the repository (or not), and she can write to the repository (or not). It's also possible, however, to define finer-grained access rules. One set of users may have permission to write to a certain directory in the repository, but not others; another directory might not even be readable by all but a few special people."
msgstr ""

#: build/en/book.xml:14933(para)
msgid "Both servers use a common file format to describe these path-based access rules. In the case of Apache, one needs to load the <command moreinfo=\"none\">mod_authz_svn</command> module and then add the <literal moreinfo=\"none\">AuthzSVNAccessFile</literal> directive (within the <filename moreinfo=\"none\">httpd.conf</filename> file) pointing to your own rules-file. (For a full explanation, see <xref linkend=\"svn.serverconfig.httpd.authz.perdir\"/>.) If you're using <command moreinfo=\"none\">svnserve</command>, then you need to make the <literal moreinfo=\"none\">authz-db</literal> variable (within <filename moreinfo=\"none\">svnserve.conf</filename>) point to your rules-file."
msgstr ""

#: build/en/book.xml:14946(title)
msgid "Do you really need path-based access control?"
msgstr "你真的需要基于路径的访问控制吗？"

#: build/en/book.xml:14948(para)
msgid "A lot of administrators setting up Subversion for the first time tend to jump into path-based access control without giving it a lot of thought. The administrator usually knows which teams of people are working on which projects, so it's easy to jump in and grant certain teams access to certain directories and not others. It seems like a natural thing, and it appeases the administrator's desire to maintain tight control of the repository."
msgstr ""

#: build/en/book.xml:14957(para)
msgid "Note, though, that there are often invisible (and visible!) costs associated with this feature. In the visible category, the server needs to do a lot more work to ensure that the user has the right to read or write each specific path; in certain situations, there's very noticeable performance loss. In the invisible category, consider the culture you're creating. Most of the time, while certain users <emphasis>shouldn't</emphasis> be committing changes to certain parts of the repository, that social contract doesn't need to be technologically enforced. Teams can sometimes spontaneously collaborate with each other; someone may want to help someone else out by committing to an area she doesn't normally work on. By preventing this sort of thing at the server level, you're setting up barriers to unexpected collaboration. You're also creating a bunch of rules that need to be maintained as projects develop, new users are added, and so on. It's a bunch of extra work to maintain."
msgstr ""

#: build/en/book.xml:14976(para)
msgid "Remember that this is a version control system! Even if somebody accidentally commits a change to something they shouldn't, it's easy to undo the change. And if a user commits to the wrong place with deliberate malice, then it's a social problem anyway, and that the problem needs to be dealt with outside of Subversion."
msgstr ""

#: build/en/book.xml:14989(para)
msgid "A common theme in this book!"
msgstr ""

#: build/en/book.xml:14983(para)
msgid "So before you begin restricting users' access rights, ask yourself if there's a real, honest need for this, or if it's just something that <quote>sounds good</quote> to an administrator. Decide whether it's worth sacrificing some server speed for, and remember that there's very little risk involved; it's bad to become dependent on technology as a crutch for social problems.<placeholder-1/>."
msgstr ""

#: build/en/book.xml:14992(para)
msgid "As an example to ponder, consider that the Subversion project itself has always had a notion of who is allowed to commit where, but it's always been enforced socially. This is a good model of community trust, especially for open-source projects. Of course, sometimes there <emphasis>are</emphasis> truly legitimate needs for path-based access control; within corporations, for example, certain types of data really can be sensitive, and access needs to be genuinely restricted to small groups of people."
msgstr ""

#: build/en/book.xml:15004(para)
msgid "Once your server knows where to find your rules-file, it's time to define the rules."
msgstr ""

#: build/en/book.xml:15007(para)
#, fuzzy
msgid "The syntax of the file is the same familiar one used by <command moreinfo=\"none\">svnserve.conf</command> and the runtime configuration files. Lines that start with a hash (<literal moreinfo=\"none\">#</literal>) are ignored. In its simplest form, each section names a repository and path within it, and the authenticated usernames are the option names within each section. The value of each option describes the user's level of access to the repository path: either <literal moreinfo=\"none\">r</literal> (read-only) or <literal moreinfo=\"none\">rw</literal> (read-write). If the user is not mentioned at all, no access is allowed."
msgstr "访问文件的语法与<command moreinfo=\"none\">svnserve.conf</command>和运行中配置文件非常相似，以（<literal moreinfo=\"none\">#</literal>）开头的行会被忽略，在它的简单形式里，每一小节命名一个版本库和一个里面的路径，认证用户名是在每个小节中的选项名，每个选项的值描述了用户访问版本库的级别：<literal moreinfo=\"none\">r</literal>（只读）或者<literal moreinfo=\"none\">rw</literal>（读写），如果用户没有提到，访问是不允许的。"

#: build/en/book.xml:15019(para)
msgid "To be more specific: the value of the section-names are either of the form <literal moreinfo=\"none\">[repos-name:path]</literal> or the form <literal moreinfo=\"none\">[path]</literal>. If you're using the <literal moreinfo=\"none\">SVNParentPath</literal> directive, then it's important to specify the repository names in your sections. If you omit them, then a section like <literal moreinfo=\"none\">[/some/dir]</literal> will match the path <filename moreinfo=\"none\">/some/dir</filename> in <emphasis>every</emphasis> repository. If you're using the <literal moreinfo=\"none\">SVNPath</literal> directive, however, then it's fine to only define paths in your sections—after all, there's only one repository."
msgstr "具体一点：这个小节的名称是<literal moreinfo=\"none\">[repos-name:path]</literal>或者<literal moreinfo=\"none\">[path]</literal>的形式，如果你使用<literal moreinfo=\"none\">SVNParentPath</literal>指示，指定版本库的名字是很重要的，如果你漏掉了他们，<literal moreinfo=\"none\">[/some/dir]</literal>部分就会与<filename moreinfo=\"none\">/some/dir</filename>的所有版本库匹配，如果你使用<literal moreinfo=\"none\">SVNPath</literal>指示，因此在你的小节中只是定义路径也很好—毕竟只有一个版本库。"

#: build/en/book.xml:15031(screen)
#, no-wrap
msgid ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
msgstr ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"

#: build/en/book.xml:15037(para)
msgid "In this first example, the user <literal moreinfo=\"none\">harry</literal> has full read and write access on the <filename moreinfo=\"none\">/branches/calc/bug-142</filename> directory in the <literal moreinfo=\"none\">calc</literal> repository, but the user <literal moreinfo=\"none\">sally</literal> has read-only access. Any other users are blocked from accessing this directory."
msgstr "在第一个例子里，用户<literal moreinfo=\"none\">harry</literal>对<literal moreinfo=\"none\">calc</literal>版本库中<filename moreinfo=\"none\">/branches/calc/bug-142</filename>具备完全的读写权利，但是用户<literal moreinfo=\"none\">sally</literal>只有读权利，任何其他用户禁止访问这个目录。"

#: build/en/book.xml:15044(para)
msgid "Of course, permissions are inherited from parent to child directory. That means that we can specify a subdirectory with a different access policy for Sally:"
msgstr "当然，访问控制是父目录传递给子目录的，这意味着我们可以为Sally指定一个子目录的不同访问策略："

#: build/en/book.xml:15048(screen)
#, no-wrap
msgid ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
"\n"
"# give sally write access only to the 'testing' subdir\n"
"[calc:/branches/calc/bug-142/testing]\n"
"sally = rw\n"
msgstr ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
"\n"
"# give sally write access only to the 'testing' subdir\n"
"[calc:/branches/calc/bug-142/testing]\n"
"sally = rw\n"

#: build/en/book.xml:15058(para)
msgid "Now Sally can write to the <filename moreinfo=\"none\">testing</filename> subdirectory of the branch, but can still only read other parts. Harry, meanwhile, continues to have complete read-write access to the whole branch."
msgstr "现在Sally可以读取分支的<filename moreinfo=\"none\">testing</filename>子目录，但对其他部分还是只可以读，同时，Harry对整个分支还继续有完全的读写权限。"

#: build/en/book.xml:15063(para)
msgid "It's also possible to explicitly deny permission to someone via inheritance rules, by setting the username variable to nothing:"
msgstr "也可以通过继承规则明确的的拒绝某人的访问，只需要设置用户名参数为空："

#: build/en/book.xml:15067(screen)
#, no-wrap
msgid ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
"\n"
"[calc:/branches/calc/bug-142/secret]\n"
"harry =\n"
msgstr ""
"\n"
"[calc:/branches/calc/bug-142]\n"
"harry = rw\n"
"sally = r\n"
"\n"
"[calc:/branches/calc/bug-142/secret]\n"
"harry =\n"

#: build/en/book.xml:15076(para)
msgid "In this example, Harry has read-write access to the entire <filename moreinfo=\"none\">bug-142</filename> tree, but has absolutely no access at all to the <filename moreinfo=\"none\">secret</filename> subdirectory within it."
msgstr "在这个例子里，Harry对<filename moreinfo=\"none\">bug-142</filename>目录树有完全的读写权限，但是对<filename moreinfo=\"none\">secret</filename>子目录没有任何访问权利。"

#: build/en/book.xml:15081(para)
#, fuzzy
msgid "The thing to remember is that the most specific path always matches first. The server tries to match the path itself, and then the parent of the path, then the parent of that, and so on. The net effect is that mentioning a specific path in the accessfile will always override any permissions inherited from parent directories."
msgstr "有一件事需要记住的是需要找到最匹配的目录，<command moreinfo=\"none\">mod_authz_svn</command>模块首先找到匹配自己的目录，然后父目录，然后父目录的父目录，就这样继续下去，更具体的路径控制会覆盖所有继承下来的访问控制。"

#: build/en/book.xml:15088(para)
msgid "By default, nobody has any access to the repository at all. That means that if you're starting with an empty file, you'll probably want to give at least read permission to all users at the root of the repository. You can do this by using the asterisk variable (<literal moreinfo=\"none\">*</literal>), which means <quote>all users</quote>:"
msgstr "缺省情况下，没有人对版本库有任何访问，这意味着如果你已经从一个空文件开始，你会希望给所有用户对版本库根目录具备读权限，你可以使用<literal moreinfo=\"none\">*</literal>实现，用来代表<quote>所有用户</quote>："

#: build/en/book.xml:15095(screen)
#, no-wrap
msgid ""
"\n"
"[/]\n"
"* = r\n"
msgstr ""
"\n"
"[/]\n"
"* = r\n"

#: build/en/book.xml:15100(para)
#, fuzzy
msgid "This is a common setup; notice that there's no repository name mentioned in the section name. This makes all repositories world readable to all users. Once all users have read-access to the repositories, you can give explicit <literal moreinfo=\"none\">rw</literal> permission to certain users on specific subdirectories within specific repositories."
msgstr "这是一个普通的设置；注意在小节名中没有提到版本库名称，这让所有版本库对所有的用户可读，不管你是使用<literal moreinfo=\"none\">SVNPath</literal>或是<literal moreinfo=\"none\">SVNParentPath</literal>。当所有用户对版本库有了读权利，你可以赋予特定用户对特定子目录的<literal moreinfo=\"none\">rw</literal>权限。"

#: build/en/book.xml:15107(para)
#, fuzzy
msgid "The asterisk variable (<literal moreinfo=\"none\">*</literal>) is also worth special mention here: it's the <emphasis>only</emphasis> pattern which matches an anonymous user. If you've configured your server block to allow a mixture of anonymous and authenticated access, all users start out accessing anonymously. The server looks for a <literal moreinfo=\"none\">*</literal> value defined for the path being accessed; if it can't find one, then it demands real authentication from the client."
msgstr "星号（<literal moreinfo=\"none\">*</literal>）参数需要在这里详细强调：这是匹配匿名用户的<emphasis>唯一</emphasis>模式，如果你已经配置了你的<literal moreinfo=\"none\">Location</literal>区块允许匿名和认证用户的混合访问，所有用户作为Apache匿名用户开始访问，<command moreinfo=\"none\">mod_authz_svn</command>会在要访问路径的定义中查找<literal moreinfo=\"none\">*</literal>值；如果找不到，Apache就会要求真实的客户端认证。"

#: build/en/book.xml:15117(para)
msgid "The access file also allows you to define whole groups of users, much like the Unix <filename moreinfo=\"none\">/etc/group</filename> file:"
msgstr "访问文件也允许你定义一组的用户，很像Unix的<filename moreinfo=\"none\">/etc/group</filename>文件："

#: build/en/book.xml:15121(screen)
#, no-wrap
msgid ""
"\n"
"[groups]\n"
"calc-developers = harry, sally, joe\n"
"paint-developers = frank, sally, jane\n"
"everyone = harry, sally, joe, frank, sally, jane\n"
msgstr ""
"\n"
"[groups]\n"
"calc-developers = harry, sally, joe\n"
"paint-developers = frank, sally, jane\n"
"everyone = harry, sally, joe, frank, sally, jane\n"

#: build/en/book.xml:15128(para)
msgid "Groups can be granted access control just like users. Distinguish them with an <quote>at</quote> (<literal moreinfo=\"none\">@</literal>) prefix:"
msgstr "组可以被赋予通用户一样的访问权限，使用<quote>at</quote>（<literal moreinfo=\"none\">@</literal>）前缀来加以区别："

#: build/en/book.xml:15132(screen)
#, no-wrap
msgid ""
"\n"
"[calc:/projects/calc]\n"
"@calc-developers = rw\n"
"\n"
"[paint:/projects/paint]\n"
"@paint-developers = rw\n"
"jane = r\n"
msgstr ""
"\n"
"[calc:/projects/calc]\n"
"@calc-developers = rw\n"
"\n"
"[paint:/projects/paint]\n"
"@paint-developers = rw\n"
"jane = r\n"

#: build/en/book.xml:15141(para)
msgid "Groups can also be defined to contain other groups:"
msgstr "组中也可以定义为包含其它的组："

#: build/en/book.xml:15143(screen)
#, no-wrap
msgid ""
"\n"
"[groups]\n"
"calc-developers = harry, sally, joe\n"
"paint-developers = frank, sally, jane\n"
"everyone = @calc-developers, @paint-developers\n"
msgstr ""
"\n"
"[groups]\n"
"calc-developers = harry, sally, joe\n"
"paint-developers = frank, sally, jane\n"
"everyone = @calc-developers, @paint-developers\n"

#: build/en/book.xml:15158(title)
msgid "Supporting Multiple Repository Access Methods"
msgstr "支持多种版本库访问方法"

#: build/en/book.xml:15160(para)
msgid "You've seen how a repository can be accessed in many different ways. But is it possible—or safe—for your repository to be accessed by multiple methods simultaneously? The answer is yes, provided you use a bit of foresight."
msgstr "你已经看到了一个版本库可以用多种方式访问，但是可以—或者说安全的—用几种方式同时并行的访问你的版本库吗？回答是可以，倘若你有一些深谋远虑的使用。"

#: build/en/book.xml:15165(para)
msgid "At any given time, these processes may require read and write access to your repository:"
msgstr "在任何给定的时间，这些进程会要求读或者写访问你的版本库："

#: build/en/book.xml:15170(para)
#, fuzzy
msgid "regular system users using a Subversion client (as themselves) to access the repository directly via <literal moreinfo=\"none\">file://</literal> URLs;"
msgstr "常规的系统用户使用Subversion客户端（客户端程序本身）通过<literal moreinfo=\"none\">file:///</literal>URL直接访问版本库；"

#: build/en/book.xml:15175(para)
msgid "regular system users connecting to SSH-spawned private <command moreinfo=\"none\">svnserve</command> processes (running as themselves) which access the repository;"
msgstr "常规的系统用户连接使用SSH调用的访问版本库的<command moreinfo=\"none\">svnserve</command>进程（以它们自己运行）；"

#: build/en/book.xml:15180(para)
msgid "an <command moreinfo=\"none\">svnserve</command> process—either a daemon or one launched by <command moreinfo=\"none\">inetd</command>—running as a particular fixed user;"
msgstr "一个<command moreinfo=\"none\">svnserve</command>进程—是一个守护进程或是通过<command moreinfo=\"none\">inetd</command>启动的—作为一个固定的用户运行；"

#: build/en/book.xml:15186(para)
msgid "an Apache <command moreinfo=\"none\">httpd</command> process, running as a particular fixed user."
msgstr "一个Apache <command moreinfo=\"none\">httpd</command>进程，以一个固定用户运行。"

#: build/en/book.xml:15191(para)
msgid "The most common problem administrators run into is repository ownership and permissions. Does every process (or user) in the previous list have the rights to read and write the Berkeley DB files? Assuming you have a Unix-like operating system, a straightforward approach might be to place every potential repository user into a new <literal moreinfo=\"none\">svn</literal> group, and make the repository wholly owned by that group. But even that's not enough, because a process may write to the database files using an unfriendly umask—one that prevents access by other users."
msgstr "最通常的一个问题是管理进入到版本库的所有权和访问许可，是前面例子的所有进程 （或者说是用户）都有读写Berkeley DB的权限？假定你有一个类Unix的操作系统，一个直接的办法是在新的<literal moreinfo=\"none\">svn</literal>组添加所有潜在的用户，然后让这个组完全拥有版本库，但这样还不足够，因为一个进程会使用不友好的umask来写数据库文件—用来防止别的用户的访问。"

#: build/en/book.xml:15202(para)
msgid "So the next step beyond setting up a common group for repository users is to force every repository-accessing process to use a sane umask. For users accessing the repository directly, you can make the <command moreinfo=\"none\">svn</command> program into a wrapper script that first sets <command moreinfo=\"none\">umask 002</command> and then runs the real <command moreinfo=\"none\">svn</command> client program. You can write a similar wrapper script for the <command moreinfo=\"none\">svnserve</command> program, and add a <command moreinfo=\"none\">umask 002</command> command to Apache's own startup script, <filename moreinfo=\"none\">apachectl</filename>. For example:"
msgstr "所以下一步我们不选择为每个版本库用户设置一个共同的组的方法，而是强制每个版本库访问进程使用一个健全的umask。对直接访问版本库的用户，你可以使用<command moreinfo=\"none\">svn</command>的包裹脚本来首先设置<command moreinfo=\"none\">umask 002</command>，然后运行真实的<command moreinfo=\"none\">svn</command>客户端程序，你可以为<command moreinfo=\"none\">svnserve</command>写相同的脚本，并且增加<command moreinfo=\"none\">umask 002</command>命令到Apache自己的启动脚本<filename moreinfo=\"none\">apachectl</filename>中。例如："

#: build/en/book.xml:15213(screen)
#, no-wrap
msgid ""
"\n"
"$ cat /usr/bin/svn\n"
"\n"
"#!/bin/sh\n"
"\n"
"umask 002\n"
"/usr/bin/svn-real \"$@\"\n"
"\n"
msgstr ""
"\n"
"$ cat /usr/bin/svn\n"
"\n"
"#!/bin/sh\n"
"\n"
"umask 002\n"
"/usr/bin/svn-real \"$@\"\n"
"\n"

#: build/en/book.xml:15223(para)
msgid "Another common problem is often encountered on Unix-like systems. As a repository is used, Berkeley DB occasionally creates new log files to journal its actions. Even if the repository is wholly owned by the <command moreinfo=\"none\">svn</command> group, these newly created files won't necessarily be owned by that same group, which then creates more permissions problems for your users. A good workaround is to set the group SUID bit on the repository's <filename moreinfo=\"none\">db</filename> directory. This causes all newly-created log files to have the same group owner as the parent directory."
msgstr "另一个在类Unix系统下常见的问题是，当版本库在使用时，BerkeleyDB有时候创建一个新的日志文件来记录它的东西，即使这个版本库是完全由<command moreinfo=\"none\">svn</command>组拥有，这个新创建的文件不是必须被同一个组拥有，这给你的用户造成了更多地许可问题。一个好的工作区应该设置组的SUID字节到版本库的<filename moreinfo=\"none\">db</filename>目录，这会导致所有新创建的日志文件拥有同父目录相同的组拥有者。"

#: build/en/book.xml:15234(para)
msgid "Once you've jumped through these hoops, your repository should be accessible by all the necessary processes. It may seem a bit messy and complicated, but the problems of having multiple users sharing write-access to common files are classic ones that are not often elegantly solved."
msgstr "一旦你跳过了这些障碍，你的版本库一定是可以通过各种可能的手段访问了，这看起来有点凌乱和复杂，但是这个让多个用户分享对一个文件的写权限的问题是一个经典问题，并且经常是没有优雅的解决。"

#: build/en/book.xml:15240(para)
msgid "Fortunately, most repository administrators will never <emphasis>need</emphasis> to have such a complex configuration. Users who wish to access repositories that live on the same machine are not limited to using <literal moreinfo=\"none\">file://</literal> access URLs—they can typically contact the Apache HTTP server or <command moreinfo=\"none\">svnserve</command> using <literal moreinfo=\"none\">localhost</literal> for the server name in their <literal moreinfo=\"none\">http://</literal> or <literal moreinfo=\"none\">svn://</literal> URLs. And to maintain multiple server processes for your Subversion repositories is likely to be more of a headache than necessary. We recommend you choose the server that best meets your needs and stick with it!"
msgstr "幸运的是，大多数版本库管理员不<emphasis>需要</emphasis>这样复杂的配置，用户如果希望访问本机的版本库，并不是一定要通过<literal moreinfo=\"none\">file://</literal>的URL—他们可以用<literal moreinfo=\"none\">localhost</literal>机器名联系Apache的HTTP服务器或者是<command moreinfo=\"none\">svnserve</command>，协议分别是<literal moreinfo=\"none\">http://</literal>或<literal moreinfo=\"none\">svn://</literal>。为你的Subversion版本库维护多个服务器进程，版本库会变得超出需要的头痛，我们建议你选择最符合你的需要的版本库，并且坚持使用！"

#: build/en/book.xml:15254(title)
msgid "The svn+ssh:// server checklist"
msgstr "svn+ssh 服务器检查列表"

#: build/en/book.xml:15256(para)
msgid "It can be quite tricky to get a bunch of users with existing SSH accounts to share a repository without permissions problems. If you're confused about all the things that you (as an administrator) need to do on a Unix-like system, here's a quick checklist that resummarizes some of things discussed in this section:"
msgstr "让一些用户通过存在的SSH帐户来共享版本库而没有访问许可问题是一件很有技巧的事情，如果你为自己需要在（作为一个管理员）类Unix系统上做的事情感到迷惑，这里是一些快速的检查列表，总结了本小节讨论的事情："

#: build/en/book.xml:15265(para)
msgid "All of your SSH users need to be able to read and write to the repository. Put all the SSH users into a single group. Make the repository wholly owned by that group, and set the group permissions to read/write."
msgstr "所有的SSH用户需要能够读写版本库，把所有的SSH用户放到同一个组里，让版本库完全属于这个组，设置组的权限是读/写。"

#: build/en/book.xml:15272(para)
msgid "Your users need to use a sane umask when accessing the repository. Make sure that <command moreinfo=\"none\">svnserve</command> (<filename moreinfo=\"none\">/usr/bin/svnserve</filename>, or wherever it lives in <literal moreinfo=\"none\">$PATH</literal>) is actually a wrapper script which sets <command moreinfo=\"none\">umask 002</command> and executes the real <command moreinfo=\"none\">svnserve</command> binary. Take similar measures when using <command moreinfo=\"none\">svnlook</command> and <command moreinfo=\"none\">svnadmin</command>. Either run them with a sane umask, or wrap them as described above."
msgstr "你的用户在访问版本库时需要使用一个健全的umask，确定<command moreinfo=\"none\">svnserve</command>（<filename moreinfo=\"none\">/usr/bin/svnserve</filename>或者是任何一个<literal moreinfo=\"none\">$PATH</literal>说明的位置）是一个设置了<command moreinfo=\"none\">umask 002</command>和执行真正的<command moreinfo=\"none\">svnserve</command>程序的包裹脚本，对<command moreinfo=\"none\">svnlook</command>和<command moreinfo=\"none\">svnadmin</command>使用相同的措施，或者是使用一个健全的umask运行或者是使用上面说明的包裹。"

#: build/en/book.xml:15301(title)
msgid "Customizing Your Subversion Experience"
msgstr "定制你的 Subversion 用法"

#: build/en/book.xml:15303(para)
msgid "### TODO: Chapter opening ###"
msgstr ""

#: build/en/book.xml:15305(para)
msgid "### TODO: Gut the runtime config stuff like I did the property stuff, making larger topical sections to which the runtime config stuff generally refers. Like already exists for external diff/diff3, add, for example, a section on external editors. ###"
msgstr ""

#: build/en/book.xml:15315(title)
msgid "Runtime Configuration Area"
msgstr "运行配置区"

#: build/en/book.xml:15317(para)
msgid "Subversion provides many optional behaviors that can be controlled by the user. Many of these options are of the kind that a user would wish to apply to all Subversion operations. So, rather than forcing users to remember command-line arguments for specifying these options, and to use them for each and every operation they perform, Subversion uses configuration files, segregated into a Subversion configuration area."
msgstr "Subversion提供了许多用户可以控制的可选行为方式，许多是用户希望添加到所有的Subversion操作中的选项，为了避免强制用户记住命令行参数并且在每个命令中使用，Subversion使用配置文件，并且将配置文件保存在独立的Subversion配置区。"

#: build/en/book.xml:15325(para)
msgid "The Subversion <firstterm>configuration area</firstterm> is a two-tiered hierarchy of option names and their values. Usually, this boils down to a special directory that contains <firstterm>configuration files</firstterm> (the first tier), which are just text files in standard INI format (with <quote>sections</quote> providing the second tier). These files can be easily edited using your favorite text editor (such as Emacs or vi), and contain directives read by the client to determine which of several optional behaviors the user prefers."
msgstr "Subversion<firstterm>配置区</firstterm>是一个双层结构，保存了可选项的名称和值。通常，Subversion配置区是一个保存<firstterm>配置文件</firstterm>的特殊目录（第一层结构），目录中保存了一些标准INI格式的文本文件（文件中的<quote>section</quote>形成第二层结构）。这些文件可以简单用你喜欢的文本编辑器编辑（如Emacs或vi），而且保存了客户端可以读取的指示，用来指导用户的一些行为选项。"

#: build/en/book.xml:15338(title)
msgid "Configuration Area Layout"
msgstr "配置区布局"

#: build/en/book.xml:15352(para)
msgid "The <literal moreinfo=\"none\">APPDATA</literal> environment variable points to the <filename moreinfo=\"none\">Application Data</filename> area, so you can always refer to this folder as <filename moreinfo=\"none\">%APPDATA%\\Subversion</filename>."
msgstr "<literal moreinfo=\"none\">APPDATA</literal>环境变量指向<filename moreinfo=\"none\">Application Data</filename>目录，所以你可以通过<filename moreinfo=\"none\">%APPDATA%\\Subversion</filename>引用用户配置区目录。"

#: build/en/book.xml:15340(para)
#, fuzzy
msgid "The first time that the <command moreinfo=\"none\">svn</command> command-line client is executed, it creates a per-user configuration area. On Unix-like systems, this area appears as a directory named <filename moreinfo=\"none\">.subversion</filename> in the user's home directory. On Win32 systems, Subversion creates a folder named <filename moreinfo=\"none\">Subversion</filename>, typically inside the <filename moreinfo=\"none\">Application Data</filename> area of the user's profile directory (which, by the way, is usually a hidden directory). However, on this platform the exact location differs from system to system, and is dictated by the Windows registry. <placeholder-1/> We will refer to the per-user configuration area using its Unix name, <filename moreinfo=\"none\">.subversion</filename>."
msgstr "<command moreinfo=\"none\">svn</command>命令行客户端第一次执行时，会创建一个用户配置区，在类Unix系统中，配置区位于用户主目录中，名为<filename moreinfo=\"none\">.subversion</filename>。在Win32系统，Subversion创建一个名为<filename moreinfo=\"none\">Subversion</filename>的目录，这个目录通常位于用户配置目录（顺便说一句，通常是一个隐藏目录）的<filename moreinfo=\"none\">Application Data</filename>子目录下。然而，在Win32平台上，此目录的具体位置在不同的系统上是不一样的，由Windows注册表决定。 <footnote><placeholder-1/></footnote> 我们以Unix下的名字<filename moreinfo=\"none\">.subversion</filename>来表示用户配置区。"

#: build/en/book.xml:15360(para)
msgid "In addition to the per-user configuration area, Subversion also recognizes the existence of a system-wide configuration area. This gives system administrators the ability to establish defaults for all users on a given machine. Note that the system-wide configuration area does not alone dictate mandatory policy—the settings in the per-user configuration area override those in the system-wide one, and command-line arguments supplied to the <command moreinfo=\"none\">svn</command> program have the final word on behavior. On Unix-like platforms, the system-wide configuration area is expected to be the <filename moreinfo=\"none\">/etc/subversion</filename> directory; on Windows machines, it looks for a <filename moreinfo=\"none\">Subversion</filename> directory inside the common <filename moreinfo=\"none\">Application Data</filename> location (again, as specified by the Windows Registry). Unlike the per-user case, the <command moreinfo=\"none\">svn</command> program does not attempt to create the system-wide configuration area."
msgstr "除了用户配置区，Subversion也提供了系统配置区，通过系统配置区，系统管理员可以为某个机器的所有用户建立缺省配置值。注意系统配置区不会规定强制性的策略—每个用户配置区都可以覆盖系统配置区中的配置项，而<command moreinfo=\"none\">svn</command>的命令行参数决定了最后的行为。在类Unix的平台上，系统配置区位于<filename moreinfo=\"none\">/etc/subversion</filename>目录下，在Windows平台上，系统配置区位于<filename moreinfo=\"none\">Application Data</filename>（再说一次，是由Windows注册表决定的）的<filename moreinfo=\"none\">Subversion</filename>目录中。与用户配置区不同，<command moreinfo=\"none\">svn</command>不会试图创建系统配置区。"

#: build/en/book.xml:15378(para)
#, fuzzy
msgid "The per-user configuration area currently contains three files—two configuration files (<filename moreinfo=\"none\">config</filename> and <filename moreinfo=\"none\">servers</filename>), and a <filename moreinfo=\"none\">README.txt</filename> file which describes the INI format. At the time of their creation, the files contain default values for each of the supported Subversion options, mostly commented out and grouped with textual descriptions about how the values for the key affect Subversion's behavior. To change a certain behavior, you need only to load the appropriate configuration file into a text editor, and modify the desired option's value. If at any time you wish to have the default configuration settings restored, you can simply remove (or rename) your configuration directory and then run some innocuous <command moreinfo=\"none\">svn</command> command, such as <command moreinfo=\"none\">svn --version</command>. A new configuration directory with the default contents will be created."
msgstr "目前，Subversion的配置区包含三个文件—两个配置文件（<filename moreinfo=\"none\">config</filename>和<filename moreinfo=\"none\">servers</filename>），和一个INI文件格式的<filename moreinfo=\"none\">README.txt</filename>描述文件。配置文件创建的时候，Subversion的选项都设置为默认值。配置文件中的选项都按功能划分成组，大多数选项还有详细的文字描述注释，说明这些选项的值对Subversion的主要影响。要修改选项，只需用文本编辑器打开并编辑配置文件。如果想要恢复缺省的配置，可以直接删除（或者重命名）配置目录，并且运行一些如<command moreinfo=\"none\">svn --version</command>之类的无关紧要的<command moreinfo=\"none\">svn</command>命令，一个包含缺省值的新配置目录就会创建起来。"

#: build/en/book.xml:15395(para)
msgid "The per-user configuration area also contains a cache of authentication data. The <filename moreinfo=\"none\">auth</filename> directory holds a set of subdirectories that contain pieces of cached information used by Subversion's various supported authentication methods. This directory is created in such a way that only the user herself has permission to read its contents."
msgstr "用户配置区也缓存了认证信息，<filename moreinfo=\"none\">auth</filename>目录下的子目录中缓存了一些Subversion支持的各种认证方法的信息，这个目录需要相应的用户权限才可以访问。"

#: build/en/book.xml:15407(title)
msgid "Configuration and the Windows Registry"
msgstr "配置和 Windows 注册表"

#: build/en/book.xml:15409(para)
msgid "In addition to the usual INI-based configuration area, Subversion clients running on Windows platforms may also use the Windows registry to hold the configuration data. The option names and their values are the same as in the INI files. The <quote>file/section</quote> hierarchy is preserved as well, though addressed in a slightly different fashion—in this schema, files and sections are just levels in the registry key tree."
msgstr "除了基于INI文件的配置区，运行在Windows平台的Subversion客户端也可以使用Windows注册表来保存配置数据。注册表中保存的选项名称和值的含义与INI文件中相同，<quote>file/section</quote>在注册表中表现为注册表键树的层级，使得双层结构得以保留下来。"

#: build/en/book.xml:15418(para)
msgid "Subversion looks for system-wide configuration values under the <literal moreinfo=\"none\">HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion</literal> key. For example, the <literal moreinfo=\"none\">global-ignores</literal> option, which is in the <literal moreinfo=\"none\">miscellany</literal> section of the <filename moreinfo=\"none\">config</filename> file, would be found at <literal moreinfo=\"none\">HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Config\\Miscellany\\global-ignores</literal>. Per-user configuration values should be stored under <literal moreinfo=\"none\">HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion</literal>."
msgstr "Subversion的系统配置值保存在键<literal moreinfo=\"none\">HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion</literal>下。举个例子，<literal moreinfo=\"none\">global-ignores</literal>选项位于<filename moreinfo=\"none\">config</filename>文件的<literal moreinfo=\"none\">miscellany</literal>小节，在Windows注册表中，则位于<literal moreinfo=\"none\">HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Config\\Miscellany\\global-ignores</literal>。用户配置值存放在<literal moreinfo=\"none\">HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion</literal>下。"

#: build/en/book.xml:15429(para)
msgid "Registry-based configuration options are parsed <emphasis>before</emphasis> their file-based counterparts, so are overridden by values found in the configuration files. In other words, configuration priority is granted in the following order on a Windows system:"
msgstr "基于注册表的配置项在基于文件的配置项<emphasis>之前</emphasis>解析，所以其配置项的值会被配置文件中相同配置项的值覆盖，换句话说，在Windows系统下配置项的优先级是："

#: build/en/book.xml:15437(para)
msgid "Command-line options"
msgstr "命令行选项"

#: build/en/book.xml:15440(para)
msgid "The per-user INI files"
msgstr "用户INI配置文件"

#: build/en/book.xml:15443(para)
msgid "The per-user Registry values"
msgstr "用户注册表值"

#: build/en/book.xml:15446(para)
msgid "The system-wide INI files"
msgstr "系统INI配置文件"

#: build/en/book.xml:15449(para)
msgid "The system-wide Registry values"
msgstr "系统注册表值"

#: build/en/book.xml:15453(para)
msgid "Also, the Windows Registry doesn't really support the notion of something being <quote>commented out</quote>. However, Subversion will ignore any option key whose name begins with a hash (<literal moreinfo=\"none\">#</literal>) character. This allows you to effectively comment out a Subversion option without deleting the entire key from the Registry, obviously simplifying the process of restoring that option."
msgstr "此外，虽然Windows注册表不支持<quote>注释掉</quote>这种概念，但是Subversion会忽略所有以井号（<literal moreinfo=\"none\">#</literal>）开始的字符，这允许你快速的取消一个选项而不需要删除整个注册表键，明显简化了恢复选项的过程。"

#: build/en/book.xml:15461(para)
msgid "The <command moreinfo=\"none\">svn</command> command-line client never attempts to write to the Windows Registry, and will not attempt to create a default configuration area there. You can create the keys you need using the <command moreinfo=\"none\">REGEDIT</command> program. Alternatively, you can create a <filename moreinfo=\"none\">.reg</filename> file, and then double-click on that file from the Explorer shell, which will cause the data to be merged into your registry."
msgstr "<command moreinfo=\"none\">svn</command>命令行客户端不会尝试写Windows注册表，也不会在注册表中创建默认配置区。不过可以使用<command moreinfo=\"none\">REGEDIT</command>创建所需的键。此外，还可以创建一个<filename moreinfo=\"none\">.reg</filename>文件，并在文件浏览器中双击这个文件，文件中的数据就会合并到注册表中。"

#: build/en/book.xml:15471(title)
msgid "Sample Registration Entries (.reg) File."
msgstr "注册表条目(.reg)样本文件。"

#: build/en/book.xml:15473(programlisting)
#, no-wrap
msgid ""
"\n"
"REGEDIT4\n"
"\n"
"[HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Servers\\groups]\n"
"\n"
"[HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Servers\\global]\n"
"\"#http-proxy-host\"=\"\"\n"
"\"#http-proxy-port\"=\"\"\n"
"\"#http-proxy-username\"=\"\"\n"
"\"#http-proxy-password\"=\"\"\n"
"\"#http-proxy-exceptions\"=\"\"\n"
"\"#http-timeout\"=\"0\"\n"
"\"#http-compression\"=\"yes\"\n"
"\"#neon-debug-mask\"=\"\"\n"
"\"#ssl-authority-files\"=\"\"\n"
"\"#ssl-trust-default-ca\"=\"\"\n"
"\"#ssl-client-cert-file\"=\"\"\n"
"\"#ssl-client-cert-password\"=\"\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\auth]\n"
"\"#store-passwords\"=\"yes\"\n"
"\"#store-auth-creds\"=\"yes\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\helpers]\n"
"\"#editor-cmd\"=\"notepad\"\n"
"\"#diff-cmd\"=\"\"\n"
"\"#diff3-cmd\"=\"\"\n"
"\"#diff3-has-program-arg\"=\"\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\tunnels]\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\miscellany]\n"
"\"#global-ignores\"=\"*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store\"\n"
"\"#log-encoding\"=\"\"\n"
"\"#use-commit-times\"=\"\"\n"
"\"#no-unlock\"=\"\"\n"
"\"#enable-auto-props\"=\"\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\auto-props]\n"
"\n"
msgstr ""
"\n"
"REGEDIT4\n"
"\n"
"[HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Servers\\groups]\n"
"\n"
"[HKEY_LOCAL_MACHINE\\Software\\Tigris.org\\Subversion\\Servers\\global]\n"
"\"#http-proxy-host\"=\"\"\n"
"\"#http-proxy-port\"=\"\"\n"
"\"#http-proxy-username\"=\"\"\n"
"\"#http-proxy-password\"=\"\"\n"
"\"#http-proxy-exceptions\"=\"\"\n"
"\"#http-timeout\"=\"0\"\n"
"\"#http-compression\"=\"yes\"\n"
"\"#neon-debug-mask\"=\"\"\n"
"\"#ssl-authority-files\"=\"\"\n"
"\"#ssl-trust-default-ca\"=\"\"\n"
"\"#ssl-client-cert-file\"=\"\"\n"
"\"#ssl-client-cert-password\"=\"\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\auth]\n"
"\"#store-passwords\"=\"yes\"\n"
"\"#store-auth-creds\"=\"yes\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\helpers]\n"
"\"#editor-cmd\"=\"notepad\"\n"
"\"#diff-cmd\"=\"\"\n"
"\"#diff3-cmd\"=\"\"\n"
"\"#diff3-has-program-arg\"=\"\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\tunnels]\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\miscellany]\n"
"\"#global-ignores\"=\"*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store\"\n"
"\"#log-encoding\"=\"\"\n"
"\"#use-commit-times\"=\"\"\n"
"\"#no-unlock\"=\"\"\n"
"\"#enable-auto-props\"=\"\"\n"
"\n"
"[HKEY_CURRENT_USER\\Software\\Tigris.org\\Subversion\\Config\\auto-props]\n"
"\n"

#: build/en/book.xml:15516(para)
msgid "The previous example shows the contents of a <filename moreinfo=\"none\">.reg</filename> file which contains some of the most commonly used configuration options and their default values. Note the presence of both system-wide (for network proxy-related options) and per-user settings (editor programs and password storage, among others). Also note that all the options are effectively commented out. You need only to remove the hash (<literal moreinfo=\"none\">#</literal>) character from the beginning of the option names, and set the values as you desire."
msgstr "上面例子里显示的<filename moreinfo=\"none\">.reg</filename>文件中，包含了一些最常用的配置选项和它们的缺省值。注意，上面的例子中不仅包含了系统设置（关于网络代理相关的选项），也包含了用户设置（指定的编辑器程序，是否保存密码，以及其它选项）。同时要注意的是，所有选项都注释掉了，要启用其中的选项，只需删除该选项名称前面的井号（<literal moreinfo=\"none\">#</literal>），然后设置相应的值就可以了。"

#: build/en/book.xml:15531(title)
msgid "Configuration Options"
msgstr "配置选项"

#: build/en/book.xml:15533(para)
msgid "### TODO: Rework and move this section to the Reference ###"
msgstr ""

#: build/en/book.xml:15535(para)
msgid "In this section, we will discuss the specific run-time configuration options that are currently supported by Subversion."
msgstr "本节我们会详细讨论Subversion目前支持的运行配置选项。"

#: build/en/book.xml:15541(title)
msgid "Servers"
msgstr "服务器"

#: build/en/book.xml:15543(para)
msgid "The <filename moreinfo=\"none\">servers</filename> file contains Subversion configuration options related to the network layers. There are two special section names in this file—<literal moreinfo=\"none\">groups</literal> and <literal moreinfo=\"none\">global</literal>. The <literal moreinfo=\"none\">groups</literal> section is essentially a cross-reference table. The keys in this section are the names of other sections in the file; their values are <firstterm>globs</firstterm>—textual tokens which possibly contain wildcard characters—that are compared against the hostnames of the machine to which Subversion requests are sent."
msgstr "<filename moreinfo=\"none\">servers</filename>文件保存了Subversion关于网络层的配置选项，这个文件有两个特别的小节：<literal moreinfo=\"none\">groups</literal> 和<literal moreinfo=\"none\">global</literal>。<literal moreinfo=\"none\">groups</literal>小节是一个交叉引用表，其中的关键字是<filename moreinfo=\"none\">servers</filename>文件中其它小节的名字，值则是一个可以包含通配符的字符序列，对应于接收Subversion请求的主机名，称为glob。"

#: build/en/book.xml:15555(programlisting)
#, no-wrap
msgid ""
"\n"
"[groups]\n"
"beanie-babies = *.red-bean.com\n"
"collabnet = svn.collab.net\n"
"\n"
"[beanie-babies]\n"
"…\n"
"\n"
"[collabnet]\n"
"…\n"
msgstr ""
"\n"
"[groups]\n"
"beanie-babies = *.red-bean.com\n"
"collabnet = svn.collab.net\n"
"\n"
"[beanie-babies]\n"
"…\n"
"\n"
"[collabnet]\n"
"…\n"

#: build/en/book.xml:15567(para)
msgid "When Subversion is used over a network, it attempts to match the name of the server it is trying to reach with a group name under the <literal moreinfo=\"none\">groups</literal> section. If a match is made, Subversion then looks for a section in the <filename moreinfo=\"none\">servers</filename> file whose name is the matched group's name. From that section it reads the actual network configuration settings."
msgstr "当通过网络访问Subversion服务器时，客户端会设法匹配正在尝试连接的服务器名字和<literal moreinfo=\"none\">groups</literal>小节中的glob名称，如果发现匹配，Subversion会在<filename moreinfo=\"none\">servers</filename>文件中查找对应于这个glob名称的小节，并从该小节中去读取真实的网络配置设置。"

#: build/en/book.xml:15575(para)
msgid "The <literal moreinfo=\"none\">global</literal> section contains the settings that are meant for all of the servers not matched by one of the globs under the <literal moreinfo=\"none\">groups</literal> section. The options available in this section are exactly the same as those valid for the other server sections in the file (except, of course, the special <literal moreinfo=\"none\">groups</literal> section), and are as follows:"
msgstr "如果没有能够匹配到<literal moreinfo=\"none\">groups</literal>中的glob名称，<literal moreinfo=\"none\">global</literal>小节中的选项就会发生作用。<literal moreinfo=\"none\">global</literal>小节中的选项与其他小节一样（当然是除了<literal moreinfo=\"none\">groups</literal>小节），这些选项是："

#: build/en/book.xml:15586(literal)
msgid "http-proxy-host"
msgstr "http-proxy-host"

#: build/en/book.xml:15588(para)
msgid "This specifies the hostname of the proxy computer through which your HTTP-based Subversion requests must pass. It defaults to an empty value, which means that Subversion will not attempt to route HTTP requests through a proxy computer, and will instead attempt to contact the destination machine directly."
msgstr "代理服务器的详细主机名，是HTTP为基础的Subversion请求必须通过的，缺省值为空，意味着Subversion不会尝试通过代理服务器进行HTTP请求，而会尝试直接连接目标机器。"

#: build/en/book.xml:15597(literal)
msgid "http-proxy-port"
msgstr "http-proxy-port"

#: build/en/book.xml:15599(para)
msgid "This specifies the port number on the proxy host to use. It defaults to an empty value."
msgstr "代理服务器的详细端口，缺省值为空。"

#: build/en/book.xml:15604(literal)
msgid "http-proxy-username"
msgstr "http-proxy-username"

#: build/en/book.xml:15606(para)
msgid "This specifies the username to supply to the proxy machine. It defaults to an empty value."
msgstr "代理服务器的用户名，缺省值为空。"

#: build/en/book.xml:15611(literal)
msgid "http-proxy-password"
msgstr "http-proxy-password"

#: build/en/book.xml:15613(para)
msgid "This specifies the password to supply to the proxy machine. It defaults to an empty value."
msgstr "代理服务器的密码，缺省为空。"

#: build/en/book.xml:15618(literal)
msgid "http-timeout"
msgstr "http-timeout"

#: build/en/book.xml:15620(para)
msgid "This specifies the amount of time, in seconds, to wait for a server response. If you experience problems with a slow network connection causing Subversion operations to timeout, you should increase the value of this option. The default value is <literal moreinfo=\"none\">0</literal>, which instructs the underlying HTTP library, Neon, to use its default timeout setting."
msgstr "等待服务器响应的时间，以秒为单位，如果你的网络速度较慢，导致Subversion的操作超时，你可以加大这个数值，缺省值是<literal moreinfo=\"none\">0</literal>，意思是让HTTP库Neon使用自己的缺省值。"

#: build/en/book.xml:15631(literal)
msgid "http-compression"
msgstr "http-compression"

#: build/en/book.xml:15633(para)
msgid "This specifies whether or not Subversion should attempt to compress network requests made to DAV-ready servers. The default value is <literal moreinfo=\"none\">yes</literal> (though compression will only occur if that capability is compiled into the network layer). Set this to <literal moreinfo=\"none\">no</literal> to disable compression, such as when debugging network transmissions."
msgstr "这说明是否在与设置好DAV的服务器通讯时使用网络压缩请求，缺省值是<literal moreinfo=\"none\">yes</literal>（尽管只有在这个功能编译到网络层时压缩才会有效），设置<literal moreinfo=\"none\">no</literal>来关闭压缩，如调试网络传输时。"

#: build/en/book.xml:15643(literal)
msgid "neon-debug-mask"
msgstr "neon-debug-mask"

#: build/en/book.xml:15645(para)
msgid "This is an integer mask that the underlying HTTP library, Neon, uses for choosing what type of debugging output to yield. The default value is <literal moreinfo=\"none\">0</literal>, which will silence all debugging output. For more information about how Subversion makes use of Neon, see <xref linkend=\"svn.developer\"/>."
msgstr "只是一个整形的掩码，底层的HTTP库Neon用来选择产生调试的输出，缺省值是<literal moreinfo=\"none\">0</literal>，意思是关闭所有的调试输出，关于Subversion使用Neon的详细信息，见<xref linkend=\"svn.developer\"/>。"

#: build/en/book.xml:15654(literal)
msgid "ssl-authority-files"
msgstr "ssl-authority-files"

#: build/en/book.xml:15656(para)
msgid "This is a semicolon-delimited list of paths to files containing certificates of the certificate authorities (or CAs) that are accepted by the Subversion client when accessing the repository over HTTPS."
msgstr "这是一个分号分割的路径和文件列表，这些文件包含了Subversion客户端在用HTTPS访问时可以接受的认证授权（或者CA）证书。"

#: build/en/book.xml:15664(literal)
msgid "ssl-trust-default-ca"
msgstr "ssl-trust-default-ca"

#: build/en/book.xml:15666(para)
msgid "Set this variable to <literal moreinfo=\"none\">yes</literal> if you want Subversion to automatically trust the set of default CAs that ship with OpenSSL."
msgstr "如果你希望Subversion可以自动相信OpenSSL携带的缺省的CA，可以设置为<literal moreinfo=\"none\">yes</literal>。"

#: build/en/book.xml:15672(literal)
msgid "ssl-client-cert-file"
msgstr "ssl-client-cert-file"

#: build/en/book.xml:15674(para)
msgid "If a host (or set of hosts) requires an SSL client certificate, you'll normally be prompted for a path to your certificate. By setting this variable to that same path, Subversion will be able to find your client certificate automatically without prompting you. There's no standard place to store your certificate on disk; Subversion will grab it from any path you specify."
msgstr "如果一个主机（或是一些主机）需要一个SSL客户端证书，你会收到一个提示说需要证书的路径。通过设置这个路径你的Subversion客户端可以自动找到你的证书而不会打扰你。没有标准的存放位置；Subversion会从任何你指定的路径得到这个文件。"

#: build/en/book.xml:15685(literal)
msgid "ssl-client-cert-password"
msgstr "ssl-client-cert-password"

#: build/en/book.xml:15687(para)
msgid "If your SSL client certificate file is encrypted by a passphrase, Subversion will prompt you for the passphrase whenever the certificate is used. If you find this annoying (and don't mind storing the password in the <filename moreinfo=\"none\">servers</filename> file), then you can set this variable to the certificate's passphrase. You won't be prompted anymore."
msgstr "如果你的SSL客户端证书文件是用密码加密的，Subversion会在每次使用证书时请你输入密码，如果你发现这很讨厌（并且不介意把密码存放在<filename moreinfo=\"none\">servers</filename>文件中），你可以设置这个参数为证书的密码，这样就不会再收到密码输入提示了。"

#: build/en/book.xml:15702(title)
msgid "Config"
msgstr "配置"

#: build/en/book.xml:15704(para)
msgid "The <filename moreinfo=\"none\">config</filename> file contains the rest of the currently available Subversion run-time options, those not related to networking. There are only a few options in use at this time, but they are again grouped into sections in expectation of future additions."
msgstr "其它的Subversion运行选项保存在<filename moreinfo=\"none\">config</filename>文件中，这些运行选项与网络连接无关，只是一些正在使用的选项，但是为了应对未来的扩展，也按小节划分成组。"

#: build/en/book.xml:15710(para)
msgid "The <literal moreinfo=\"none\">auth</literal> section contains settings related to Subversion's authentication and authorization against the repository. It contains:"
msgstr "<literal moreinfo=\"none\">auth</literal>小节保存了Subversion相关的认证和授权的设置，它包括："

#: build/en/book.xml:15716(literal)
msgid "store-passwords"
msgstr "store-passwords"

#: build/en/book.xml:15718(para)
msgid "This instructs Subversion to cache, or not to cache, passwords that are supplied by the user in response to server authentication challenges. The default value is <literal moreinfo=\"none\">yes</literal>. Set this to <literal moreinfo=\"none\">no</literal> to disable this on-disk password caching. You can override this option for a single instance of the <command moreinfo=\"none\">svn</command> command using the <option>--no-auth-cache</option> command-line parameter (for those subcommands that support it). For more information, see <xref linkend=\"svn.serverconfig.netmodel.credcache\"/>."
msgstr "这告诉Subversion是否缓存服务器认证要求时用户提供的密码，缺省值是<literal moreinfo=\"none\">yes</literal>。设置为<literal moreinfo=\"none\">no</literal>可以关闭在存盘的密码缓存，你可以通过<command moreinfo=\"none\">svn</command>的<option>--no-auth-cache</option>命令行参数（那些支持这个参数的子命令）来覆盖这个设置，详细信息请见<xref linkend=\"svn.serverconfig.netmodel.credcache\"/>。"

#: build/en/book.xml:15731(literal)
msgid "store-auth-creds"
msgstr "store-auth-creds"

#: build/en/book.xml:15733(para)
msgid "This setting is the same as <literal moreinfo=\"none\">store-passwords</literal>, except that it enables or disables disk-caching of <emphasis>all</emphasis> authentication information: usernames, passwords, server certificates, and any other types of cacheable credentials."
msgstr "这个设置与<literal moreinfo=\"none\">store-passwords</literal>相似，不过设置了这个选项将会保存<emphasis>所有</emphasis>认证信息，如用户名、密码、服务器证书，以及其他任何类型的可以缓存的凭证。"

#: build/en/book.xml:15743(para)
msgid "The <literal moreinfo=\"none\">helpers</literal> section controls which external applications Subversion uses to accomplish its tasks. Valid options in this section are:"
msgstr "<literal moreinfo=\"none\">helpers</literal>小节控制完成Subversion任务的外部程序，正确的选项包括："

#: build/en/book.xml:15749(literal)
msgid "editor-cmd"
msgstr "editor-cmd"

#: build/en/book.xml:15751(para)
msgid "This specifies the program Subversion will use to query the user for a log message during a commit operation, such as when using <command moreinfo=\"none\">svn commit</command> without either the <option>--message</option> (<option>-m</option>) or <option>--file</option> (<option>-F</option>) options. This program is also used with the <command moreinfo=\"none\">svn propedit</command> command—a temporary file is populated with the current value of the property the user wishes to edit, and the edits take place right in the editor program (see <xref linkend=\"svn.advanced.props\"/>). This option's default value is empty. The order of priority for determining the editor command is:"
msgstr "Subversion在提交操作时用来询问用户日志信息的程序，例如使用<command moreinfo=\"none\">svn commit</command>而没有指定<option>--message</option>（<option>-m</option>）或者<option>--file</option>（<option>-F</option>）选项。这个程序也会与<command moreinfo=\"none\">svn propedit</command>一起使用—一个临时文件跳出来包含已经存在的用户希望编辑的属性，然后用户可以对这个属性进行编辑（见<xref linkend=\"svn.advanced.props\"/>），这个选项的缺省值为空，检测编辑器的顺序如下："

#: build/en/book.xml:15766(para)
msgid "Command-line option <literal moreinfo=\"none\">--editor-cmd</literal>"
msgstr "命令行选项<literal moreinfo=\"none\">--editor-cmd</literal>"

#: build/en/book.xml:15769(para)
msgid "Environment variable <literal moreinfo=\"none\">SVN_EDITOR</literal>"
msgstr "环境变量<literal moreinfo=\"none\">SVN_EDITOR</literal>"

#: build/en/book.xml:15772(para)
msgid "Configuration option <literal moreinfo=\"none\">editor-cmd</literal>"
msgstr "配置选项<literal moreinfo=\"none\">editor-cmd</literal>"

#: build/en/book.xml:15775(para)
msgid "Environment variable <literal moreinfo=\"none\">VISUAL</literal>"
msgstr "环境变量<literal moreinfo=\"none\">VISUAL</literal>"

#: build/en/book.xml:15778(para)
msgid "Environment variable <literal moreinfo=\"none\">EDITOR</literal>"
msgstr "环境变量<literal moreinfo=\"none\">EDITOR</literal>"

#: build/en/book.xml:15781(para)
msgid "Possibly, a default value built in to Subversion (not present in the official builds)"
msgstr "也有可能Subversion会有一个内置的缺省值（官方编译版本不是如此）"

#: build/en/book.xml:15785(para)
msgid "The value of any of these options or variables is (unlike <literal moreinfo=\"none\">diff-cmd</literal>) the beginning of a command line to be executed by the shell. Subversion appends a space and the pathname of the temporary file to be edited. The editor should modify the temporary file and return a zero exit code to indicate success."
msgstr "所有这些选项和变量（不像<literal moreinfo=\"none\">diff-cmd</literal>）的值的开头都是shell中要执行的命令行，Subversion会追加一个空格和一个需要编辑的临时文件，编辑器必须修改临时文件，并且返回一个0来表明成功。"

#: build/en/book.xml:15794(literal)
msgid "diff-cmd"
msgstr "diff-cmd"

#: build/en/book.xml:15796(para)
msgid "This specifies the absolute path of a differencing program, used when Subversion generates <quote>diff</quote> output (such as when using the <command moreinfo=\"none\">svn diff</command> command). By default Subversion uses an internal differencing library—setting this option will cause it to perform this task using an external program. See <xref linkend=\"svn.advanced.externaldifftools\"/> for more details on using such programs."
msgstr "这个命令是比较程序的绝对路径，当Subversion生成了<quote>diff</quote>输出时（例如当使用<command moreinfo=\"none\">svn diff</command>命令）就会使用，缺省Subversion会使用一个内置的比较库—设置这个参数会强制它使用外部程序执行这个任务，此类程序的更多信息见<xref linkend=\"svn.advanced.externaldifftools\"/>。"

#: build/en/book.xml:15808(literal)
msgid "diff3-cmd"
msgstr "diff3-cmd"

#: build/en/book.xml:15810(para)
msgid "This specifies the absolute path of a three-way differencing program. Subversion uses this program to merge changes made by the user with those received from the repository. By default Subversion uses an internal differencing library—setting this option will cause it to perform this task using an external program. See <xref linkend=\"svn.advanced.externaldifftools\"/> for more details on using such programs."
msgstr "这指定了一个三向的比较程序，Subversion使用这个程序来合并用户和从版本库接受的修改，缺省Subversion会使用一个内置的比较库—设置这个参数会导致它会使用外部程序执行这个任务，此类程序的更多信息见<xref linkend=\"svn.advanced.externaldifftools\"/>。"

#: build/en/book.xml:15821(literal)
msgid "diff3-has-program-arg"
msgstr "diff3-has-program-arg"

#: build/en/book.xml:15823(para)
msgid "This flag should be set to <literal moreinfo=\"none\">true</literal> if the program specified by the <literal moreinfo=\"none\">diff3-cmd</literal> option accepts a <option>--diff-program</option> command-line parameter."
msgstr "如果<literal moreinfo=\"none\">diff3-cmd</literal>选项设置的程序接受一个<option>--diff-program</option>命令行参数，这个标记必须设置为<literal moreinfo=\"none\">true</literal>。"

#: build/en/book.xml:15832(para)
msgid "The <literal moreinfo=\"none\">tunnels</literal> section allows you to define new tunnel schemes for use with <command moreinfo=\"none\">svnserve</command> and <literal moreinfo=\"none\">svn://</literal> client connections. For more details, see <xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>."
msgstr "<literal moreinfo=\"none\">tunnels</literal>小节允许你定义一个<command moreinfo=\"none\">svnserve</command>和<literal moreinfo=\"none\">svn://</literal>客户端连接使用的管道模式，更多细节见<xref linkend=\"svn.serverconfig.svnserve.sshauth\"/>。"

#: build/en/book.xml:15840(para)
msgid "Anyone for potluck dinner?"
msgstr "就是一个大杂烩？"

#: build/en/book.xml:15837(para)
#, fuzzy
msgid "The <literal moreinfo=\"none\">miscellany</literal> section is where everything that doesn't belong elsewhere winds up. <placeholder-1/> In this section, you can find:"
msgstr "<literal moreinfo=\"none\">miscellany</literal>小节是一些没法归到别处的选项。 <footnote><placeholder-1/></footnote> 在本小节，你会找到："

#: build/en/book.xml:15846(literal)
msgid "global-ignores"
msgstr "global-ignores"

#: build/en/book.xml:15848(para)
msgid "When running the <command moreinfo=\"none\">svn status</command> command, Subversion lists unversioned files and directories along with the versioned ones, annotating them with a <literal moreinfo=\"none\">?</literal> character (see <xref linkend=\"svn.tour.cycle.examine.status\"/>). Sometimes, it can be annoying to see uninteresting, unversioned items—for example, object files that result from a program's compilation—in this display. The <literal moreinfo=\"none\">global-ignores</literal> option is a list of whitespace-delimited globs which describe the names of files and directories that Subversion should not display unless they are versioned. The default value is <literal moreinfo=\"none\">*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store</literal>."
msgstr "当运行<command moreinfo=\"none\">svn status</command>命令时，Subversion会和版本化的文件一样列出未版本化的文件和目录，并使用<literal moreinfo=\"none\">?</literal>字符（见see <xref linkend=\"svn.tour.cycle.examine.status\"/>）标记，有时候察看无关的未版本化文件会很讨厌—比如程序编译产生的对象文件—的显示出来。<literal moreinfo=\"none\">global-ignores</literal>选项是一个空格分隔的列表，用来描述Subversion在它们版本化之前不想显示的文件和目录，缺省值是<literal moreinfo=\"none\">*.o *.lo *.la #*# .*.rej *.rej .*~ *~ .#* .DS_Store</literal>。"

#: build/en/book.xml:15862(para)
msgid "As well as <command moreinfo=\"none\">svn status</command>, the <command moreinfo=\"none\">svn add</command> and <command moreinfo=\"none\">svn import</command> commands also ignore files that match the list when they are scanning a directory. You can override this behaviour for a single instance of any of these commands by explicitly specifying the file name, or by using the <option>--no-ignore</option> command-line flag."
msgstr "就像<command moreinfo=\"none\">svn status</command>，<command moreinfo=\"none\">svn add</command>和<command moreinfo=\"none\">svn import</command>命令也会忽略匹配这个列表的文件，你可以用单个的<option>--no-ignore</option>命令行参数来覆盖这个选项，关于更加细致的控制忽略的项目，见<xref linkend=\"svn.advanced.props.special.ignore\"/>。"

#: build/en/book.xml:15870(para)
msgid "For information on more fine-grained control of ignored items, see <xref linkend=\"svn.advanced.props.special.ignore\"/>."
msgstr "For information on more fine-grained control of ignored items, see <xref linkend=\"svn.advanced.props.special.ignore\"/>."

#: build/en/book.xml:15876(literal)
msgid "enable-auto-props"
msgstr "enable-auto-props"

#: build/en/book.xml:15878(para)
msgid "This instructs Subversion to automatically set properties on newly added or imported files. The default value is <literal moreinfo=\"none\">no</literal>, so set this to <literal moreinfo=\"none\">yes</literal> to enable Auto-props. The <literal moreinfo=\"none\">auto-props</literal> section of this file specifies which properties are to be set on which files."
msgstr "这里指示Subversion自动对新加的或者导入的文件设置属性，缺省值是<literal moreinfo=\"none\">no</literal>，可以设置为<literal moreinfo=\"none\">yes</literal>来开启自动添加属性，这个文件的<literal moreinfo=\"none\">auto-props</literal>小节会说明哪些属性会被设置到哪些文件。"

#: build/en/book.xml:15888(literal)
msgid "log-encoding"
msgstr "log-encoding"

#: build/en/book.xml:15890(para)
msgid "This variable sets the default character set encoding for commit log messages. It's a permanent form of the <option>--encoding</option> option (see <xref linkend=\"svn.ref.svn.sw\"/>). The Subversion repository stores log messages in UTF-8, and assumes that your log message is written using your operating system's native locale. You should specify a different encoding if your commit messages are written in any other encoding."
msgstr "这个变量设置提交日志缺省的字符集，是<option>--encoding</option>选项（见<xref linkend=\"svn.ref.svn.sw\"/>）的永久形式，Subversion版本库保存了一些UTF-8的日志信息，并且假定你的日志信息是用操作系统的本地编码，如果你提交的信息使用别的编码方式，你一定要指定不同的编码。"

#: build/en/book.xml:15903(literal)
msgid "use-commit-times"
msgstr "use-commit-times"

#: build/en/book.xml:15905(para)
msgid "Normally your working copy files have timestamps that reflect the last time they were touched by any process, whether that be your own editor or by some <command moreinfo=\"none\">svn</command> subcommand. This is generally convenient for people developing software, because build systems often look at timestamps as a way of deciding which files need to be recompiled."
msgstr "通常你的工作拷贝文件会有最后一次被进程访问的时间戳，不管是你自己的编辑器还是用<command moreinfo=\"none\">svn</command>子命令。这通常对人们开发软件提供了便利，因为编译系统通常会通过查看时间戳来决定那些文件需要重新编译。"

#: build/en/book.xml:15913(para)
msgid "In other situations, however, it's sometimes nice for the working copy files to have timestamps that reflect the last time they were changed in the repository. The <command moreinfo=\"none\">svn export</command> command always places these <quote>last-commit timestamps</quote> on trees that it produces. By setting this config variable to <literal moreinfo=\"none\">yes</literal>, the <command moreinfo=\"none\">svn checkout</command>, <command moreinfo=\"none\">svn update</command>, <command moreinfo=\"none\">svn switch</command>, and <command moreinfo=\"none\">svn revert</command> commands will also set last-commit timestamps on files that they touch."
msgstr "在其他情形，有时候如果工作拷贝的文件时间戳反映了上一次在版本库中更改的时间会非常好，<command moreinfo=\"none\">svn export</command>命令会一直放置这些<quote>上次提交的时间戳</quote>放到它创建的目录树。通过设置这个config参数为<literal moreinfo=\"none\">yes</literal>，<command moreinfo=\"none\">svn checkout</command>、<command moreinfo=\"none\">svn update</command>、 <command moreinfo=\"none\">svn switch</command>和<command moreinfo=\"none\">svn revert</command>命令也会为它们操作的文件设置上次提交的时间戳。"

#: build/en/book.xml:15932(para)
msgid "The <literal moreinfo=\"none\">auto-props</literal> section controls the Subversion client's ability to automatically set properties on files when they are added or imported. It contains any number of key-value pairs in the format <literal moreinfo=\"none\">PATTERN = PROPNAME=PROPVALUE</literal> where <literal moreinfo=\"none\">PATTERN</literal> is a file pattern that matches a set of filenames and the rest of the line is the property and its value. Multiple matches on a file will result in multiple propsets for that file; however, there is no guarantee that auto-props will be applied in the order in which they are listed in the config file, so you can't have one rule <quote>override</quote> another. You can find several examples of auto-props usage in the <filename moreinfo=\"none\">config</filename> file. Lastly, don't forget to set <literal moreinfo=\"none\">enable-auto-props</literal> to <literal moreinfo=\"none\">yes</literal> in the <literal moreinfo=\"none\">miscellany</literal> section if you want to enable auto-props."
msgstr "<literal moreinfo=\"none\">auto-props</literal>小节控制Subversion客户端自动设置提交和导入的文件的属性的能力，它可以包含任意数量的键-值对，格式是<literal moreinfo=\"none\">PATTERN = PROPNAME=PROPVALUE</literal>，其中<literal moreinfo=\"none\">PATTERN</literal>是一个文件模式，匹配一系列文件名，此行其它两项为属性和值。如果一个文件匹配多次，会导致有多个属性集；然而，没有手段保障自动属性不会按照配置文件中的顺序应用，所以你可以一个规则<quote>覆盖</quote>另一个。你可以在<filename moreinfo=\"none\">config</filename>文件找到许多自动属性的用法实例。最后，如果你希望开启自动属性，不要忘了设置<literal moreinfo=\"none\">miscellany</literal>小节的<literal moreinfo=\"none\">enable-auto-props</literal>为<literal moreinfo=\"none\">yes</literal>。"

#: build/en/book.xml:15960(title)
msgid "Localization"
msgstr "本地化"

#: build/en/book.xml:15962(para)
msgid "<firstterm>Localization</firstterm> is the act of making programs behave in a region-specific way. When a program formats numbers or dates in a way specific to your part of the world, or prints messages (or accepts input) in your native language, the program is said to be <firstterm>localized</firstterm>. This section describes steps Subversion has made towards localization."
msgstr "<firstterm>本地化</firstterm>是让程序按照地区特定方式运行的行为，如果一个程序的格式、数字或者是日期是你的本地方式，或者是打印的信息（或者是接受的输入）是你本地的语言，这个程序被叫做已经<firstterm>本地化了</firstterm>，这部分描述了针对本地化的Subversion的步骤。"

#: build/en/book.xml:15972(title)
msgid "Understanding locales"
msgstr "理解地区"

#: build/en/book.xml:15974(para)
msgid "Most modern operating systems have a notion of the <quote>current locale</quote>—that is, the region or country whose localization conventions are honored. These conventions—typically chosen by some runtime configuration mechanism on the computer—affect the way in which programs present data to the user, as well as the way in which they accept user input."
msgstr "许多现代操作系统都有一个<quote>当前地区</quote>的概念—也就是本地化习惯服务的国家和地区。这些习惯—通常是被一些运行配置机制选择—影响程序展现数据的方式，也有接受用户输入的方式。"

#: build/en/book.xml:15982(para)
msgid "On Unix-like systems, you can check the values of the locale-related runtime configuration options by running the <command moreinfo=\"none\">locale</command> command:"
msgstr "在类Unix的系统，你可以运行<command moreinfo=\"none\">locale</command>命令来检查本地关联的运行配置的选项值："

#: build/en/book.xml:15986(screen)
#, no-wrap
msgid ""
"\n"
"$ locale\n"
"LANG=\n"
"LC_COLLATE=\"C\"\n"
"LC_CTYPE=\"C\"\n"
"LC_MESSAGES=\"C\"\n"
"LC_MONETARY=\"C\"\n"
"LC_NUMERIC=\"C\"\n"
"LC_TIME=\"C\"\n"
"LC_ALL=\"C\"\n"
msgstr ""
"\n"
"$ locale\n"
"LANG=\n"
"LC_COLLATE=\"C\"\n"
"LC_CTYPE=\"C\"\n"
"LC_MESSAGES=\"C\"\n"
"LC_MONETARY=\"C\"\n"
"LC_NUMERIC=\"C\"\n"
"LC_TIME=\"C\"\n"
"LC_ALL=\"C\"\n"

#: build/en/book.xml:15998(para)
msgid "The output is a list of locale-related environment variables and their current values. In this example, the variables are all set to the default <literal moreinfo=\"none\">C</literal> locale, but users can set these variables to specific country/language code combinations. For example, if one were to set the <literal moreinfo=\"none\">LC_TIME</literal> variable to <literal moreinfo=\"none\">fr_CA</literal>, then programs would know to present time and date information formatted according a French-speaking Canadian's expectations. And if one were to set the <literal moreinfo=\"none\">LC_MESSAGES</literal> variable to <literal moreinfo=\"none\">zh_TW</literal>, then programs would know to present human-readable messages in Traditional Chinese. Setting the <literal moreinfo=\"none\">LC_ALL</literal> variable has the effect of changing every locale variable to the same value. The value of <literal moreinfo=\"none\">LANG</literal> is used as a default value for any locale variable that is unset. To see the list of available locales on a Unix system, run the command <command moreinfo=\"none\">locale -a</command>."
msgstr "输出是一个本地相关的环境变量和它们的值，在这个例子里，所有的变量设置为缺省的<literal moreinfo=\"none\">C</literal>地区，但是用户可以设置这些变量为特定的国家/语言代码组合。举个例子，如果有人设置<literal moreinfo=\"none\">LC_TIME</literal>变量为<literal moreinfo=\"none\">fr_CA</literal>，然后程序会知道使用讲法语的加拿大期望的格式来显示时间和日期信息。如果一个人会设置<literal moreinfo=\"none\">LC_MESSAGES</literal>变量为<literal moreinfo=\"none\">zh_TW</literal>，程序会知道使用繁体中文显示可读信息。如果设置<literal moreinfo=\"none\">LC_ALL</literal>的效果同分别设置所有的位置变量为同一个值有相同的效果。<literal moreinfo=\"none\">LANG</literal>用来作为没有设置地区变量的缺省值，为了查看Unix系统所有的地区列表，运行<command moreinfo=\"none\">locale -a</command>命令。"

#: build/en/book.xml:16017(para)
msgid "On Windows, locale configuration is done via the <quote>Regional and Language Options</quote> control panel item. There you can view and select the values of individual settings from the available locales, and even customize (at a sickening level of detail) several of the display formatting conventions."
msgstr "在Windows，地区配置是通过<quote>地区和语言选项</quote>控制面板管理的，可以从已存在的地区查看选择，甚至可以自定义（会是个很讨厌的复杂事情）许多显示格式习惯。"

#: build/en/book.xml:16028(title)
msgid "Subversion's use of locales"
msgstr "Subversion 对地区的支持"

#: build/en/book.xml:16030(para)
msgid "The Subversion client, <command moreinfo=\"none\">svn</command>, honors the current locale configuration in two ways. First, it notices the value of the <literal moreinfo=\"none\">LC_MESSAGES</literal> variable and attempts to print all messages in the specified language. For example:"
msgstr "Subversion客户端，<command moreinfo=\"none\">svn</command>通过两种方式支持当前的地区配置。首先，它会注意<literal moreinfo=\"none\">LC_MESSAGES</literal>的值，然后尝试使用特定的语言打印所有的信息，例如："

#: build/en/book.xml:16036(screen)
#, no-wrap
msgid ""
"\n"
"$ export LC_MESSAGES=de_DE\n"
"$ svn help cat\n"
"cat: Gibt den Inhalt der angegebenen Dateien oder URLs aus.\n"
"Aufruf: cat ZIEL[@REV]...\n"
"…\n"
msgstr ""
"\n"
"$ export LC_MESSAGES=de_DE\n"
"$ svn help cat\n"
"cat: Gibt den Inhalt der angegebenen Dateien oder URLs aus.\n"
"Aufruf: cat ZIEL[@REV]...\n"
"…\n"

#: build/en/book.xml:16044(para)
msgid "This behavior works identically on both Unix and Windows systems. Note, though, that while your operating system might have support for a certain locale, the Subversion client still may not be able to speak the particular language. In order to produce localized messages, human volunteers must provide translations for each language. The translations are written using the GNU gettext package, which results in translation modules that end with the <filename moreinfo=\"none\">.mo</filename> filename extension. For example, the German translation file is named <filename moreinfo=\"none\">de.mo</filename>. These translation files are installed somewhere on your system. On Unix, they typically live in <filename moreinfo=\"none\">/usr/share/locale/</filename>, while on Windows they're often found in the <filename moreinfo=\"none\">\\share\\locale\\</filename> folder in Subversion's installation area. Once installed, a module is named after the program it provides translations for. For example, the <filename moreinfo=\"none\">de.mo</filename> file may ultimately end up installed as <filename moreinfo=\"none\">/usr/share/locale/de/LC_MESSAGES/subversion.mo</filename>. By browsing the installed <filename moreinfo=\"none\">.mo</filename> files, you can see which languages the Subversion client is able to speak."
msgstr "这个行为在Unix和Windows上同样工作，注意，尽管有时你的操作系统支持某个地区，Subversion客户端可能不能讲特定的语言。为了制作本地化信息，志愿者可以提供各种语言的翻译。翻译使用GNU gettext包编写，相关的翻译模块使用<filename moreinfo=\"none\">.mo</filename>作为后缀名。举个例子，德国翻译文件为<filename moreinfo=\"none\">de.mo</filename>。翻译文件安装到你的系统的某个位置，在Unix它们会在<filename moreinfo=\"none\">/usr/share/locale/</filename>，而在Windows它们通常会在Subversion安装的<filename moreinfo=\"none\">\\share\\locale\\</filename>目录。一旦安装，一个命名在程序后面的模块会为此提供翻译。举个例子，<filename moreinfo=\"none\">de.mo</filename>会最终安装到<filename moreinfo=\"none\">/usr/share/locale/de/LC_MESSAGES/subversion.mo</filename>，通过查看安装的<filename moreinfo=\"none\">.mo</filename>文件，我们可以看到Subversion支持的语言。"

#: build/en/book.xml:16067(para)
msgid "The second way in which the locale is honored involves how <command moreinfo=\"none\">svn</command> interprets your input. The repository stores all paths, filenames, and log messages in Unicode, encoded as UTF-8. In that sense, the repository is <firstterm>internationalized</firstterm>—that is, the repository is ready to accept input in any human language. This means, however, that the Subversion client is responsible for sending only UTF-8 filenames and log messages into the repository. In order to do this, it must convert the data from the native locale into UTF-8."
msgstr "第二种支持地区设置的方式包括<command moreinfo=\"none\">svn</command>怎样解释你的输入，版本库使用UTF-8保存了所有的路径，文件名和日志信息。在这种情况下，版本库是<firstterm>国际化的</firstterm>—也就是版本库准备接受任何人类的语言。这意味着，无论如何Subversion客户端要负责发送UTF-8的文件名和日志信息到版本库，为此，必须将数据从本地位置转化为UTF-8。"

#: build/en/book.xml:16078(para)
#, fuzzy
msgid "For example, suppose you create a file named <filename moreinfo=\"none\">caffè.txt</filename>, and then when committing the file, you write the log message as <quote>Adesso il caffè è più forte</quote>. Both the filename and log message contain non-ASCII characters, but because your locale is set to <literal moreinfo=\"none\">it_IT</literal>, the Subversion client knows to interpret them as Italian. It uses an Italian character set to convert the data to UTF-8 before sending them off to the repository."
msgstr "举个例子，你创建了一个文件叫做<filename moreinfo=\"none\">caffè.txt</filename>，然后提交了这个文件，你写的日志信息是<quote>Adesso il caffè è più forte</quote>，文件名和日志信息都包含非ASCII字符，但是因为你的位置设置为<literal moreinfo=\"none\">it_IT</literal>，Subversion知道把它们作为意大利语解释，在发送到版本库之前，它用一个意大利字符集转化数据为UTF-8。"

#: build/en/book.xml:16088(para)
msgid "Note that while the repository demands UTF-8 filenames and log messages, it <emphasis>does not</emphasis> pay attention to file contents. Subversion treats file contents as opaque strings of bytes, and neither client nor server makes an attempt to understand the character set or encoding of the contents."
msgstr "注意当版本库要求UTF-8文件名和日志信息时，它<emphasis>不会</emphasis>注意到文件的内容，Subversion会把文件内容看作字节串，没有任何客户端和服务器会尝试理解或是编码这些内容。"

#: build/en/book.xml:16096(title)
msgid "Character set conversion errors"
msgstr "字符集转换错误"

#: build/en/book.xml:16098(para)
msgid "While using Subversion, you might get hit with an error related to character set conversions:"
msgstr "当使用Subversion，你或许会碰到一个字符集转化关联的错误："

#: build/en/book.xml:16101(screen)
#, no-wrap
msgid ""
"\n"
"svn: Can't convert string from native encoding to 'UTF-8':\n"
"…\n"
"svn: Can't convert string from 'UTF-8' to native encoding:\n"
"…\n"
msgstr ""
"\n"
"svn: Can't convert string from native encoding to 'UTF-8':\n"
"…\n"
"svn: Can't convert string from 'UTF-8' to native encoding:\n"
"…\n"

#: build/en/book.xml:16108(para)
msgid "Errors like this typically occur when the Subversion client has received a UTF-8 string from the repository, but not all of the characters in that string can be represented using the encoding of the current locale. For example, if your locale is <literal moreinfo=\"none\">en_US</literal> but a collaborator has committed a Japanese filename, you're likely to see this error when you receive the file during an <command moreinfo=\"none\">svn update</command>."
msgstr "这个错误信息通常会发生在Subversion客户端从版本库接收到一个UTF-8串，但字符不能转化为当前的地区文字时，举个例子，如果你的地区设置是<literal moreinfo=\"none\">en_US</literal>，但是一个写作者使用日本文件名提交，你会在<command moreinfo=\"none\">svn update</command>接受文件时会看到这个错误。"

#: build/en/book.xml:16117(para)
msgid "The solution is either to set your locale to something which <emphasis>can</emphasis> represent the incoming UTF-8 data, or to change the filename or log message in the repository. (And don't forget to slap your collaborator's hand—projects should decide on common languages ahead of time, so that all participants are using the same locale.)"
msgstr "解决方案或者是设置你的地区为<emphasis>可以</emphasis>表示即将到来的UTF-8数据，或者是修改版本库的文件名或信息。（不要忘记和你的合作者拍拍手—项目必须首先决定通用的语言，这样所有的参与者会使用相同的地区设置。）"

#: build/en/book.xml:16134(title)
msgid "Using External Differencing Tools"
msgstr "使用外置比较工具"

#: build/en/book.xml:16136(para)
msgid "The presence of <option>--diff-cmd</option> and <option>--diff3-cmd</option> options, and similarly named runtime configuration parameters (see <xref linkend=\"svn.advanced.confarea.opts.config\"/>), can lead to a false notion of how easy it is to use external differencing (or <quote>diff</quote>) and merge tools with Subversion. While Subversion can use most of popular such tools available, the effort invested in setting this up often turns out to be non-trivial."
msgstr "选项<option>--diff-cmd</option>和<option>--diff3-cmd</option>的形式相似，也有类似名称的运行配置参数（见<xref linkend=\"svn.advanced.confarea.opts.config\"/>），这会导致一个错误的观念，也就是在Subversion中使用外置的比较（或<quote>diff</quote>）和合并工具会非常的容易，虽然Subversion可以使用大多数类似的工具，但是设置这些工具绝非易事。"

#: build/en/book.xml:16156(para)
msgid "Subversion developers are good, but even the best make mistakes."
msgstr "Subversion的开发者很好，但最好的也会发生错误。"

#: build/en/book.xml:16145(para)
#, fuzzy
msgid "The interface between Subversion and external diff and merge tools harkens back to a time when Subversion's only contextual differencing capabilities were built around invocations of the GNU diffutils toolchain, specifically the <command moreinfo=\"none\">diff</command> and <command moreinfo=\"none\">diff3</command> utilities. To get the kind of behavior Subversion needed, it called these utilities with more than a handful of options and parameters, most of which were quite specific to the utilities. Some time later, Subversion grew its own internal differencing library, and as a failover mechanism, <placeholder-1/> the <option>--diff-cmd</option> and <option>--diff3-cmd</option> options were added to the Subversion command-line client so users could more easily indicate that they preferred to use the GNU diff and diff3 utilities instead of the newfangled internal diff library. If those options were used, Subversion would simply ignore the internal diff library, and fall back to running those external programs, lengthy argument lists and all. And that's where things remain today."
msgstr "Subversion和外置比较和合并工具的接口可以追溯到很久以前，当时Subversion的唯一文本比较能力是建立在GNU的工具链之上，特别是<command moreinfo=\"none\">diff</command>和<command moreinfo=\"none\">diff3</command>工具，为了得到Subversion需要的方式，它使用非常复杂的选项和参数调用这些工具，而这些选项和参数都是工具特定的，渐渐的，Subversion发展了自己的比较区别库作为备份机制。<placeholder-1/><option>--diff-cmd</option>和<option>--diff3-cmd</option>选项是添加到Subversion的命令行客户端，所以用户可以更加容易的指明他们最喜欢的使用的GNU diff和diff3工具，而不是新奇的内置比较库，如果使用了这些选项，Subversion会忽略内置的比较库，转而使用外置程序，使用冗长的参数列表。现在还是这样。"

#: build/en/book.xml:16168(para)
msgid "It didn't take long for folks to realize that having such easy configuration mechanisms for specifying that Subversion should use the external GNU diff and diff3 utilities located at a particular place on the system could be applied toward the use of other diff and merge tools, too. After all, Subversion didn't actually verify that the things it was being told to run were members of the GNU diffutils toolchain. But the only configurable aspect of using those external tools is their location on the system—not the option set, parameter order, etc. Subversion continues throwing all those GNU utility options at your external diff tool regardless of whether or not that program can understand those options. And that's where things get unintuitive for most users."
msgstr "人们很快意识到使用简单的配置机制必须使Subversion使用位于特定位置的GNU diff和diff3工具，毕竟，Subversion并不验证其被告之要执行的程序是否是GNU的工具链的比较工具。唯一可以配置的方面是外置工具在系统的位置—而不是选项集，参数顺序等等。Subversion一直将这些GNU工具选项发给你的外置比较工具，而不管程序是否可以理解那些选项，那不是所有用户直觉的方式。"

#: build/en/book.xml:16182(para)
msgid "The key to using external diff and merge tools (other than GNU diff and diff3, of course) with Subversion is to use wrapper scripts which convert the input from Subversion into something that your differencing tool can understand, and then to convert the output of your tool back into a format which Subversion expects—the format that the GNU tools would have used. The following sections cover the specifics of those expectations."
msgstr "使用外置比较和合并工具的关键是使用包裹脚本将Subversion的输出转化为你的脚本程序可以理解的形式，然后将这些比较工具的输出转化为你的Subversion期望的格式—GNU工具可能使用的格式，下面的小节覆盖了那些期望格式的细节。"

#: build/en/book.xml:16192(para)
msgid "The decision on when to fire off a contextual diff or merge as part of a larger Subversion operation is made entirely by Subversion, and is affected by, among other things, whether or not the files being operated on are human-readable as determined by their <literal moreinfo=\"none\">svn:mime-type</literal> property. This means, for example, that even if you had the niftiest Microsoft Word-aware differencing or merging tool in the Universe, it would never be invoked by Subversion so long as your versioned Word documents had a configured MIME type that denoted that they were not human-readable (such as <literal moreinfo=\"none\">application/msword</literal>). For more about MIME type settings, see <xref linkend=\"svn.advanced.props.special.mime-type\"/>"
msgstr "何时启动文本比较或合并的决定完全是Subversion的决定，而这个决定是根据文件的<literal moreinfo=\"none\">svn:mime-type</literal>属性作出的，这意味着，例如，即使你有一个可以识别Microsoft Word格式的比较或合并工具，当你对一个Word文件设置为非人工可读（例如<literal moreinfo=\"none\">application/msword</literal>）时，依然不会调用这个识别Word的工具。关于MIME type的设定，可以见<xref linkend=\"svn.advanced.props.special.mime-type\"/>。"

#: build/en/book.xml:16209(title)
msgid "External diff"
msgstr "外置 diff"

#: build/en/book.xml:16226(para)
msgid "The GNU diff manual page puts it this way: <quote>An exit status of 0 means no differences were found, 1 means some differences were found, and 2 means trouble.</quote>"
msgstr "GNU的diff手册这样说的：<quote>返回0意味着没有区别，1是有有区别，其它值意味着出现问题。</quote>"

#: build/en/book.xml:16211(para)
#, fuzzy
msgid "Subversion calls external diff programs with parameters suitable for the GNU diff utility, and expects only that the external program return with a successful error code. For most alternative diff program, only the sixth and seventh arguments, the paths of the files which represent the left and right sides of the diff, respectively, are of interest. Note that Subversion runs the diff program once per modified file covered by the Subversion operation, so if your program runs in an asynchronous fashion (or <quote>backgrounded</quote>), you might have several instances of it all running simultaneously. Finally, Subversion expects that your program return an errorcode of 1 if your program detected differences, or 0 if it did not—any other errorcode is considered a fatal error. <placeholder-1/>"
msgstr "Subversion可以调用适合GNU参数的diff工具，并期望外置程序能够返回成功的错误代码。对于大多数可用的diff程序，只有第6、7参数，diff两边文件的路径。需要注意Subversion对于每个修改的文件都要以异步方式（或<quote>后台</quote>）运行diff程序，你会得到许多并行的实例。最后，Subversion期望你的程序在发现区别时返回错误代码0，没有区别则返回1—任何其他的返回值都被认为是严重错误。 <footnote><placeholder-1/></footnote>"

#: build/en/book.xml:16232(para)
msgid "<xref linkend=\"svn.advanced.externaldifftools.diff.ex-1\"/> and <xref linkend=\"svn.advanced.externaldifftools.diff.ex-2\"/> are templates for external diff tool wrappers in the Bourne shell and Windows batch scripting languages, respectively."
msgstr "<xref linkend=\"svn.advanced.externaldifftools.diff.ex-1\"/>和<xref linkend=\"svn.advanced.externaldifftools.diff.ex-2\"/>分别是Bourne shell和Windows批处理外置diff工具的包裹器模版。"

#: build/en/book.xml:16239(title)
msgid "diffwrap.sh"
msgstr "diffwrap.sh"

#: build/en/book.xml:16240(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh\n"
"\n"
"# Configure your favorite diff program here.\n"
"DIFF=\"/usr/local/bin/my-diff-tool\"\n"
"\n"
"# Subversion provides the paths we need as the sixth and seventh \n"
"# parameters.\n"
"LEFT=${6}\n"
"RIGHT=${7}\n"
"\n"
"# Call the diff command (change the following line to make sense for\n"
"# your merge program).\n"
"$DIFF --left $LEFT --right $RIGHT\n"
"\n"
"# Return an errorcode of 0 if no differences were detected, 1 if some were.\n"
"# Any other errorcode will be treated as fatal.\n"
msgstr ""
"\n"
"#!/bin/sh\n"
"\n"
"# Configure your favorite diff program here.\n"
"DIFF=\"/usr/local/bin/my-diff-tool\"\n"
"\n"
"# Subversion provides the paths we need as the sixth and seventh \n"
"# parameters.\n"
"LEFT=${6}\n"
"RIGHT=${7}\n"
"\n"
"# Call the diff command (change the following line to make sense for\n"
"# your merge program).\n"
"$DIFF --left $LEFT --right $RIGHT\n"
"\n"
"# Return an errorcode of 0 if no differences were detected, 1 if some were.\n"
"# Any other errorcode will be treated as fatal.\n"

#: build/en/book.xml:16261(title)
msgid "diffwrap.bat"
msgstr "diffwrap.bat"

#: build/en/book.xml:16262(programlisting)
#, no-wrap
msgid ""
"\n"
"@ECHO OFF\n"
"\n"
"REM Configure your favorite diff program here.\n"
"SET DIFF=\"C:\\Program Files\\Funky Stuff\\My Diff Tool.exe\"\n"
"\n"
"REM Subversion provides the paths we need as the sixth and seventh \n"
"REM parameters.\n"
"SET LEFT=%6\n"
"SET RIGHT=%7\n"
"\n"
"REM Call the diff command (change the following line to make sense for\n"
"REM your merge program).\n"
"%DIFF% --left %LEFT% --right %RIGHT%\n"
"\n"
"REM Return an errorcode of 0 if no differences were detected, 1 if some were.\n"
"REM Any other errorcode will be treated as fatal.\n"
msgstr ""
"\n"
"@ECHO OFF\n"
"\n"
"REM Configure your favorite diff program here.\n"
"SET DIFF=\"C:\\Program Files\\Funky Stuff\\My Diff Tool.exe\"\n"
"\n"
"REM Subversion provides the paths we need as the sixth and seventh \n"
"REM parameters.\n"
"SET LEFT=%6\n"
"SET RIGHT=%7\n"
"\n"
"REM Call the diff command (change the following line to make sense for\n"
"REM your merge program).\n"
"%DIFF% --left %LEFT% --right %RIGHT%\n"
"\n"
"REM Return an errorcode of 0 if no differences were detected, 1 if some were.\n"
"REM Any other errorcode will be treated as fatal.\n"

#: build/en/book.xml:16285(title)
msgid "External diff3"
msgstr "外置 diff3"

#: build/en/book.xml:16287(para)
msgid "Subversion calls external merge programs with parameters suitable for the GNU diff3 utility, expecting that the external program return with a successful error code and that the full file contents which result from the completed merge operation are printed on the standard output stream (so that Subversion can redirect them into the appropriate version controlled file). For most alternative merge programs, only the ninth, tenth, and eleventh arguments, the paths of the files which represent the <quote>mine</quote>, <quote>older</quote>, and <quote>yours</quote> inputs, respectively, are of interest. Note that because Subversion depends on the output of your merge program, you wrapper script must not exit before that output has been delivered to Subversion. When it finally does exit, it should return an errorcode of 0 if the merge was successful, or 1 if unresolved conflicts remain in the output—any other errorcode is considered a fatal error."
msgstr "Subversion按照符合GNU的diff3的参数调用合并程序，期望外置程序会返回成功的错误代码，并且完整合并的文件结果打印到标准输出（这样Subversion可以重定向这些东西到适当的版本控制下的文件）。对于大多数可选的合并程序，只有第9、10和11参数，分别代表<quote>mine</quote>、<quote>older</quote>和<quote>yours</quote>的路径。需要注意，因为Subversion依赖于你的合并程序的输出，你的包裹脚本在输出发送到Subversion之前不要退出。当最终退出，如果合并成功返回0，如果有为解决的冲突则返回1—其它返回值都是严重错误。"

#: build/en/book.xml:16305(para)
msgid "<xref linkend=\"svn.advanced.externaldifftools.diff3.ex-1\"/> and <xref linkend=\"svn.advanced.externaldifftools.diff3.ex-2\"/> are templates for external merge tool wrappers in the Bourne shell and Windows batch scripting languages, respectively."
msgstr "<xref linkend=\"svn.advanced.externaldifftools.diff3.ex-1\"/>和<xref linkend=\"svn.advanced.externaldifftools.diff3.ex-2\"/>分别是Bourne shell和Windows批处理外置diff工具的包裹器模版。"

#: build/en/book.xml:16311(title)
msgid "diff3wrap.sh"
msgstr "diff3wrap.sh"

#: build/en/book.xml:16312(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/bin/sh\n"
"\n"
"# Configure your favorite diff3/merge program here.\n"
"DIFF3=\"/usr/local/bin/my-merge-tool\"\n"
"\n"
"# Subversion provides the paths we need as the ninth, tenth, and eleventh \n"
"# parameters.\n"
"MINE=${9}\n"
"OLDER=${10}\n"
"YOURS=${11}\n"
"\n"
"# Call the merge command (change the following line to make sense for\n"
"# your merge program).\n"
"$DIFF3 --older $OLDER --mine $MINE --yours $YOURS\n"
"\n"
"# After performing the merge, this script needs to print the contents\n"
"# of the merged file to stdout.  Do that in whatever way you see fit.\n"
"# Return an errorcode of 0 on successful merge, 1 if unresolved conflicts\n"
"# remain in the result.  Any other errorcode will be treated as fatal.\n"
msgstr ""
"\n"
"#!/bin/sh\n"
"\n"
"# Configure your favorite diff3/merge program here.\n"
"DIFF3=\"/usr/local/bin/my-merge-tool\"\n"
"\n"
"# Subversion provides the paths we need as the ninth, tenth, and eleventh \n"
"# parameters.\n"
"MINE=${9}\n"
"OLDER=${10}\n"
"YOURS=${11}\n"
"\n"
"# Call the merge command (change the following line to make sense for\n"
"# your merge program).\n"
"$DIFF3 --older $OLDER --mine $MINE --yours $YOURS\n"
"\n"
"# After performing the merge, this script needs to print the contents\n"
"# of the merged file to stdout.  Do that in whatever way you see fit.\n"
"# Return an errorcode of 0 on successful merge, 1 if unresolved conflicts\n"
"# remain in the result.  Any other errorcode will be treated as fatal.\n"

#: build/en/book.xml:16336(title)
msgid "diff3wrap.bat"
msgstr "diff3wrap.bat"

#: build/en/book.xml:16337(programlisting)
#, no-wrap
msgid ""
"\n"
"@ECHO OFF\n"
"\n"
"REM Configure your favorite diff3/merge program here.\n"
"SET DIFF3=\"C:\\Program Files\\Funky Stuff\\My Merge Tool.exe\"\n"
"\n"
"REM Subversion provides the paths we need as the ninth, tenth, and eleventh \n"
"REM parameters.  But we only have access to nine parameters at a time, so we\n"
"REM shift our nine-parameter window twice to let us get to what we need.\n"
"SHIFT\n"
"SHIFT\n"
"SET MINE=%7\n"
"SET OLDER=%8\n"
"SET YOURS=%9\n"
"\n"
"REM Call the merge command (change the following line to make sense for\n"
"REM your merge program).\n"
"%DIFF3% --older %OLDER% --mine %MINE% --yours %YOURS%\n"
"\n"
"REM After performing the merge, this script needs to print the contents\n"
"REM of the merged file to stdout.  Do that in whatever way you see fit.\n"
"REM Return an errorcode of 0 on successful merge, 1 if unresolved conflicts\n"
"REM remain in the result.  Any other errorcode will be treated as fatal.\n"
msgstr ""
"\n"
"@ECHO OFF\n"
"\n"
"REM Configure your favorite diff3/merge program here.\n"
"SET DIFF3=\"C:\\Program Files\\Funky Stuff\\My Merge Tool.exe\"\n"
"\n"
"REM Subversion provides the paths we need as the ninth, tenth, and eleventh \n"
"REM parameters.  But we only have access to nine parameters at a time, so we\n"
"REM shift our nine-parameter window twice to let us get to what we need.\n"
"SHIFT\n"
"SHIFT\n"
"SET MINE=%7\n"
"SET OLDER=%8\n"
"SET YOURS=%9\n"
"\n"
"REM Call the merge command (change the following line to make sense for\n"
"REM your merge program).\n"
"%DIFF3% --older %OLDER% --mine %MINE% --yours %YOURS%\n"
"\n"
"REM After performing the merge, this script needs to print the contents\n"
"REM of the merged file to stdout.  Do that in whatever way you see fit.\n"
"REM Return an errorcode of 0 on successful merge, 1 if unresolved conflicts\n"
"REM remain in the result.  Any other errorcode will be treated as fatal.\n"

#: build/en/book.xml:16375(title)
msgid "Embedding Subversion"
msgstr "嵌入 Subversion"

#: build/en/book.xml:16377(para)
msgid "Subversion has a modular design, written in C and implemented as a collection of libraries. Each library has a well-defined purpose and Application Programming Interface (API), and that interface is available not only for Subversion itself to use, but for any software that wishes to embed or otherwise programmatically control Subversion. Additionally, Subversion's API is available not only to other C programs, but also to programs written in higher-level languages such as Python, Perl, Java, or Ruby."
msgstr ""

#: build/en/book.xml:16387(para)
#, fuzzy
msgid "This chapter is for those who wish to interact with Subversion through its public API or its various language bindings. If you wish to write robust wrapper scripts around Subversion functionality to simplify your own life, are trying to develop more complex integrations between Subversion and other pieces of software, or just have an interest in Subversion's various library modules and what they offer, this chapter is for you. If, however, you don't foresee yourself participating with Subversion at such a level, feel free to skip this chapter with the confidence that your experience as a Subversion user will not be affected."
msgstr "本章是为那些希望实际参与源代码编写来帮助Subversion不断进步的人们准备的。我们要知道，在这里我们会涉及到许多软件内在的细节，在开发Subversion本身—或利用Subversion库开发全新工具时—所用到的许多核心技术。如果你无法预测你是否会以这种层级参与到这个软件中来，那么也可以随意跳过这一章，而你作为一个Subversion用户的体验不会受到任何影响。"

#: build/en/book.xml:16403(title)
msgid "Layered Library Design"
msgstr "分层的库设计"

#: build/en/book.xml:16405(para)
#, fuzzy
msgid "Each of Subversion's core libraries can be said to exist in one of three main layers—the Repository Layer, the Repository Access (RA) Layer, or the Client Layer. We will examine these layers shortly, but first, let's briefly summarize Subversion's various libraries. For the sake of consistency, we will refer to the libraries by their extensionless Unix library names (libsvn_fs, libsvn_wc, mod_dav_svn, etc.)."
msgstr "Subversion有一个模块化的设计，通过一套C库来实现。每一个库都有一套定义良好的目标与接口，据称，大部分模块都属于三层中的某一层—版本库层、版本库访问（RA）层或是客户端层。我们很快就会考察这些层，但首先让我们看一下<xref linkend=\"svn.developer.layerlib.tbl-1\"/>中的有关于Subversion库的摘要目录，为了一致性，我们将通过它们的无扩展Unix库名（例如libsvn_fs、libsvn_wc和mod_dav_svn）来引用它们。"

#: build/en/book.xml:16415(term)
msgid "libsvn_client"
msgstr "libsvn_client"

#: build/en/book.xml:16416(para)
msgid "Primary interface for client programs"
msgstr "客户端程序的主要接口"

#: build/en/book.xml:16420(term)
msgid "libsvn_delta"
msgstr "libsvn_delta"

#: build/en/book.xml:16421(para)
msgid "Tree and byte-stream differencing routines"
msgstr "目录树和文本区别程序"

#: build/en/book.xml:16425(term)
msgid "libsvn_diff"
msgstr "libsvn_diff"

#: build/en/book.xml:16426(para)
msgid "Contextual differencing and merging routines"
msgstr "上下文区别和合并例程"

#: build/en/book.xml:16430(term)
msgid "libsvn_fs"
msgstr "libsvn_fs"

#: build/en/book.xml:16431(para)
msgid "Filesystem commons and module loader"
msgstr "Subversion文件系统库和模块加载器"

#: build/en/book.xml:16435(term)
msgid "libsvn_fs_base"
msgstr "libsvn_fs_base"

#: build/en/book.xml:16436(para)
msgid "The Berkeley DB filesystem back-end"
msgstr "Berkeley DB文件系统后端"

#: build/en/book.xml:16440(term)
msgid "libsvn_fs_fs"
msgstr "libsvn_fs_fs"

#: build/en/book.xml:16441(para)
msgid "The native filesystem (FSFS) back-end"
msgstr "本地文件系统（FSFS）后端"

#: build/en/book.xml:16445(term)
msgid "libsvn_ra"
msgstr "libsvn_ra"

#: build/en/book.xml:16446(para)
msgid "Repository Access commons and module loader"
msgstr "版本库访问通用组件和模块装载器"

#: build/en/book.xml:16450(term)
msgid "libsvn_ra_dav"
msgstr "libsvn_ra_dav"

#: build/en/book.xml:16451(para)
msgid "The WebDAV Repository Access module"
msgstr "WebDAV版本库访问模块"

#: build/en/book.xml:16455(term)
msgid "libsvn_ra_local"
msgstr "libsvn_ra_local"

#: build/en/book.xml:16456(para)
msgid "The local Repository Access module"
msgstr "本地版本库访问模块"

#: build/en/book.xml:16460(term)
msgid "libsvn_ra_serf"
msgstr "libsvn_ra_serf"

#: build/en/book.xml:16461(para)
msgid "Another (experimental) WebDAV Repository Access module"
msgstr "另一个(实验性的) WebDAV 版本库访问模块"

#: build/en/book.xml:16465(term)
msgid "libsvn_ra_svn"
msgstr "libsvn_ra_svn"

#: build/en/book.xml:16466(para)
msgid "The custom protocol Repository Access module"
msgstr "一个自定义版本库访问模块"

#: build/en/book.xml:16470(term)
msgid "libsvn_repos"
msgstr "libsvn_repos"

#: build/en/book.xml:16471(para)
msgid "Repository interface"
msgstr "版本库接口"

#: build/en/book.xml:16474(term)
msgid "libsvn_subr"
msgstr "libsvn_subr"

#: build/en/book.xml:16475(para)
msgid "Miscellaneous helpful subroutines"
msgstr "各色各样的有用的子程序"

#: build/en/book.xml:16479(term)
msgid "libsvn_wc"
msgstr "libsvn_wc"

#: build/en/book.xml:16480(para)
msgid "The working copy management library"
msgstr "工作拷贝管理库"

#: build/en/book.xml:16484(term)
msgid "mod_authz_svn"
msgstr "mod_authz_svn"

#: build/en/book.xml:16485(para)
msgid "Apache authorization module for Subversion repositories access via WebDAV"
msgstr "使用WebDAV访问Subversion版本库的Apache授权模块"

#: build/en/book.xml:16490(para)
msgid "Apache module for mapping WebDAV operations to Subversion ones"
msgstr "影射WebDAV操作为Subversion操作的Apache模块"

#: build/en/book.xml:16495(para)
#, fuzzy
msgid "The fact that the word <quote>miscellaneous</quote> only appears once in the previous list is a good sign. The Subversion development team is serious about making sure that functionality lives in the right layer and libraries. Perhaps the greatest advantage of the modular design is its lack of complexity from a developer's point of view. As a developer, you can quickly formulate that kind of <quote>big picture</quote> that allows you to pinpoint the location of certain pieces of functionality with relative ease."
msgstr "单词<quote>各色各样的</quote>只在列表<xref linkend=\"svn.developer.layerlib.tbl-1\"/>中出现过一次是一个好的迹象。Subversion开发团队非常注意将功能归入合适的层和库，或许模块化设计最大的好处就是从开发者的角度看减少了复杂性。作为一个开发者，你可以很快就描画出一副<quote>大图像</quote>，以便于你更精确地，也相对容易地找出某一功能所在的位置。"

#: build/en/book.xml:16505(para)
#, fuzzy
msgid "Another benefit of modularity is the ability to replace a given module with a whole new library that implements the same API without affecting the rest of the code base. In some sense, this happens within Subversion already. The libsvn_ra_dav, libsvn_ra_local, libsvn_ra_serf, and libsvn_ra_svn libraries each implement the same interface, all working as plugins to libsvn_ra. And all four communicate with the Repository Layer—libsvn_ra_local connects to the repository directly; the other three do so over a network. The libsvn_fs_base and libsvn_fs_fs libraries are another pair of libraries that implement the same functionality in different ways—both are plugins to the common libsvn_fs library."
msgstr "模块化的另一个好处是我们有能力去构造一个全新的，能够完全实现相同API功能的库，以替换整个给定的模块，而又不会影响基础代码。在某种意义上，Subversion已经这样做了。libsvn_ra_dav、libsvn_ra_local和libsvn_ra_svn all都实现了相同的接口，三者均与版本库层进行通讯—libsvn_ra_dav和libsvn_ra_svn通过网络，而libsvn_ra_local则是直接连接，libsvn_fs_base和libsvn_fs_fs是另外两个例子。"

#: build/en/book.xml:16518(para)
msgid "The client itself also highlights the benefits of modularity in the Subversion design. Subversion's libsvn_client library is a one-stop shop for most of the functionality necessary for designing a working Subversion client (see <xref linkend=\"svn.developer.layerlib.client\"/>). So while the Subversion distribution provides only the <command moreinfo=\"none\">svn</command> command-line client program, there are several third-party programs which provide various forms of graphical client UI. These GUIs use the same APIs that the stock command-line client does. This type of modularity has played a large role in the proliferation of available Subversion clients and IDE integrations and, by extension, to the tremendous adoption rate of Subversion itself."
msgstr ""

#: build/en/book.xml:16533(title)
msgid "Repository Layer"
msgstr "版本库层"

#: build/en/book.xml:16535(para)
#, fuzzy
msgid "When referring to Subversion's Repository Layer, we're generally talking about two basic concepts—the versioned filesystem implementation (accessed via libsvn_fs, and supported by its libsvn_fs_base and libsvn_fs_fs plugins), and the repository logic that wraps it (as implemented in libsvn_repos). These libraries provide the storage and reporting mechanisms for the various revisions of your version-controlled data. This layer is connected to the Client Layer via the Repository Access Layer, and is, from the perspective of the Subversion user, the stuff at the <quote>other end of the line.</quote>"
msgstr "当提到Subversion版本库层时，我们通常会讨论两个库—版本库（函数）库和文件系统（函数）库。这两个库为你的版本控制数据的各个修订版本提供了存储和报告机制，该层通过版本库访问层连接到客户层，而且，从Subversion用户的角度看，这是资料存储过程中的<quote>链接的另一端</quote>。"

#: build/en/book.xml:16547(para)
#, fuzzy
msgid "The Subversion Filesystem is not a kernel-level filesystem that one would install in an operating system (like the Linux ext2 or NTFS), but a virtual filesystem. Rather than storing <quote>files</quote> and <quote>directories</quote> as real files and directories (as in, the kind you can navigate through using your favorite shell program), it uses one of two available abstract storage backends—either a Berkeley DB database environment, or a flat-file representation. (To learn more about the two repository back-ends, see <xref linkend=\"svn.reposadmin.basics.backends\"/>.) There has even been considerable interest by the development community in giving future releases of Subversion the ability to use other back-end database systems, perhaps through a mechanism such as Open Database Connectivity (ODBC). In fact, Google did something similar to this before launching the Google Code Project Hosting service, announcing in mid-2006 that members of its Open Source team had written a new proprietary Subversion filesystem plugin which used their ultra-scalable Bigtable database for its storage."
msgstr "Subversion文件系统通过libsvn_fs API来访问，它并不是一个安装在操作系统之上的内核级的文件系统（例如Linux ext2或NTFS），而是一个虚拟文件系统。它并未将<quote>文件</quote>和<quote>目录</quote>保存为真实的文件和目录（也就是用你熟知的shell程序可以浏览的那种），而是采用了一种抽象的后端存储方式，这个后端存储方式有两种—一个是Berkeley DB数据库环境，另一个是普通文件表示。（要了解更多关于版本库后端的信息，请看<xref linkend=\"svn.reposadmin.basics.backends\"/>）。除此之外，开发社区也非常有兴趣考虑在Subversion的未来版本 中提供某种使用其它后端数据库系统的能力，也许是开放式数据库连接（ODBC）的机制。"

#: build/en/book.xml:16566(para)
#, fuzzy
msgid "The filesystem API exported by libsvn_fs contains the kinds of functionality you would expect from any other filesystem API—you can create and remove files and directories, copy and move them around, modify file contents, and so on. It also has features that are not quite as common, such as the ability to add, modify, and remove metadata (<quote>properties</quote>) on each file or directory. Furthermore, the Subversion Filesystem is a versioning filesystem, which means that as you make changes to your directory tree, Subversion remembers what your tree looked like before those changes. And before the previous changes. And the previous ones. And so on, all the way back through versioning time to (and just beyond) the moment you first started adding things to the filesystem."
msgstr "libsvn_fs支持的文件系统API包含了所有其他文件系统的功能：你可以创建和删除文件和目录、拷贝和移动、修改文件内容等等。它也包含了一些不太常用的特性，如对任意文件和目录添加、修改和删除元数据（<quote>properties</quote>）的能力。此外，Subversion文件系统是一个版本化的文件系统，意味着你修改你的目录树时，Subversion会记住修改以前的样子。等等，可以回到所有初始化版本库之后（且仅仅之后）的版本。"

#: build/en/book.xml:16581(para)
#, fuzzy
msgid "All the modifications you make to your tree are done within the context of a Subversion commit transaction. The following is a simplified general routine for modifying your filesystem:"
msgstr "所有你对目录树的修改包含在Subversion事务的上下文中，下面描述了修改文件系统的例程："

#: build/en/book.xml:16588(para)
msgid "Begin a Subversion commit transaction."
msgstr "开始 Subversion 的提交事务。"

#: build/en/book.xml:16591(para)
msgid "Make your changes (adds, deletes, property modifications, etc.)."
msgstr "作出修改（添加、删除、属性修改等等。）。"

#: build/en/book.xml:16595(para)
msgid "Commit your transaction."
msgstr "提交事务。"

#: build/en/book.xml:16599(para)
msgid "Once you have committed your transaction, your filesystem modifications are permanently stored as historical artifacts. Each of these cycles generates a single new revision of your tree, and each revision is forever accessible as an immutable snapshot of <quote>the way things were.</quote>"
msgstr "一旦你提交了你的事务，你的文件系统修改就会永久的作为历史保存起来，每个这样的周期会产生一个新的树，所有的修订版本都是永远可以访问的一个不变的快照。"

#: build/en/book.xml:16606(title)
msgid "The Transaction Distraction"
msgstr "事务的其它信息"

#: build/en/book.xml:16608(para)
#, fuzzy
msgid "The notion of a Subversion transaction can become easily confused with the transaction support provided by the underlying database itself, especially given the former's close proximity to the Berkeley DB database code in libsvn_fs_base. Both types of transaction exist to provide atomicity and isolation. In other words, transactions give you the ability to perform a set of actions in an all-or-nothing fashion—either all the actions in the set complete with success, or they all get treated as if <emphasis>none</emphasis> of them ever happened—and in a way that does not interfere with other processes acting on the data."
msgstr "Subversion的事务概念，特别是在libsvn_fs中的数据库附近的代码，很容易与低层提供支持的数据库事务混淆。两种类型事务都提供了原子和隔离操作，换句话说，事务给你能力可以用<quote>全部或者没有</quote>样式执行一系列的动作—所有的动作都完全成功，或者是所有的<emphasis>没有</emphasis>发生—而且不会干扰别人操作数据。"

#: build/en/book.xml:16621(para)
#, fuzzy
msgid "Database transactions generally encompass small operations related specifically to the modification of data in the database itself (such as changing the contents of a table row). Subversion transactions are larger in scope, encompassing higher-level operations like making modifications to a set of files and directories which are intended to be stored as the next revision of the filesystem tree. If that isn't confusing enough, consider the fact that Subversion uses a database transaction during the creation of a Subversion transaction (so that if the creation of Subversion transaction fails, the database will look as if we had never attempted that creation in the first place)!"
msgstr "数据库事务通常围绕着一些对数据库本身的数据修改相关的小操作（如修改表行的内容），Subversion是更大范围的事务，围绕着一些高一级的操作，如下一个修订版本文件系统的一组文件和目录的修改。如果这还不是很混乱，考虑这个：Subversion在创建Subversion事务（所以如果Subversion创建事务失败，数据库会看起来我们从来没有尝试创建）时会使用一个数据库事务！"

#: build/en/book.xml:16635(para)
msgid "Fortunately for users of the filesystem API, the transaction support provided by the database system itself is hidden almost entirely from view (as should be expected from a properly modularized library scheme). It is only when you start digging into the implementation of the filesystem itself that such things become visible (or interesting)."
msgstr "很幸运的是用户的文件系统API，数据库提供的事务支持本身几乎完全从外表隐藏（也是一个完全模块化的模式所应该的）。只有当你开始研究文件系统本身的实现时，这些事情才可见（或者是开始感兴趣）。"

#: build/en/book.xml:16645(para)
#, fuzzy
msgid "Most of the functionality provided by the filesystem interface is the result of an action that occurs on a filesystem path. That is, from outside of the filesystem, the primary mechanism for describing and accessing the individual revisions of files and directories comes through the use of path strings like <filename moreinfo=\"none\">/foo/bar</filename>, just as if you were addressing files and directories through your favorite shell program. You add new files and directories by passing their paths-to-be to the right API functions. You query for information about them by the same mechanism."
msgstr "大多数文件系统接口提供的功能作为一个动作发生在一个文件系统路径上，也就是，从文件系统的外部，描述和访问文件和目录独立版本的主要机制是经过如<filename moreinfo=\"none\">/foo/bar</filename>的路径，就像你在喜欢的shell程序中定位文件和目录。你通过传递它们的路径到相应的API功能来添加新的文件和目录，查询这些信息也是同样的机制。"

#: build/en/book.xml:16656(para)
msgid "Unlike most filesystems, though, a path alone is not enough information to identify a file or directory in Subversion. Think of a directory tree as a two-dimensional system, where a node's siblings represent a sort of left-and-right motion, and descending into subdirectories a downward motion. <xref linkend=\"svn.developer.layerlib.repos.dia-1\"/> shows a typical representation of a tree as exactly that."
msgstr "然而，不像大多数文件系统，一个单独的路径不足以在Subversion定位一个文件或目录，可以把目录树看作一个二维的系统，一个节点的兄弟代表了一种从左到右的动作，并且递减到子目录是一个向下的动作，<xref linkend=\"svn.developer.layerlib.repos.dia-1\"/>展示了一个典型的树的形式。"

#: build/en/book.xml:16665(title)
msgid "Files and directories in two dimensions"
msgstr "二维的文件和目录"

#: build/en/book.xml:16673(para)
msgid "We understand that this may come as a shock to sci-fi fans who have long been under the impression that Time was actually the <emphasis>fourth</emphasis> dimension, and we apologize for any emotional trauma induced by our assertion of a different theory."
msgstr "我们理解这一定会给科幻小说迷带来一个震撼，他们认为时间是<emphasis>第四</emphasis>维的，我们要为提出这样一个不同理论的断言而伤害了他们的作出道歉。"

#: build/en/book.xml:16669(para)
#, fuzzy
msgid "The different here is that the Subversion filesystem has a nifty third dimension that most filesystems do not have—Time! <placeholder-1/> In the filesystem interface, nearly every function that has a <parameter moreinfo=\"none\">path</parameter> argument also expects a <parameter moreinfo=\"none\">root</parameter> argument. This <structname>svn_fs_root_t</structname> argument describes either a revision or a Subversion transaction (which is simply a revision-in-the-making), and provides that third-dimensional context needed to understand the difference between <filename moreinfo=\"none\">/foo/bar</filename> in revision 32, and the same path as it exists in revision 98. <xref linkend=\"svn.developer.layerlib.repos.dia-2\"/> shows revision history as an added dimension to the Subversion filesystem universe."
msgstr "当然，Subversion文件系统有一个其它文件系统所没有的第三维—时间！ <footnote><placeholder-1/></footnote> 在一个文件系统接口，几乎所有的功能都有个<parameter moreinfo=\"none\">路径</parameter>参数，也期望一个<parameter moreinfo=\"none\">root</parameter>参数。<structname>svn_fs_root_t</structname>参数不仅描述了一个修订版本或一个Subversion事务（通常正好是一个修订版本），而且提供了用来区分修订版本32的<filename moreinfo=\"none\">/foo/bar</filename>和修订版本98在同样路径的三维上下文环境。<xref linkend=\"svn.developer.layerlib.repos.dia-2\"/>展示了修订版本历史作为添加的纬度进入到Subversion文件系统领域。"

#: build/en/book.xml:16692(title)
msgid "Versioning time—the third dimension!"
msgstr "版本时间—第三维！"

#: build/en/book.xml:16696(para)
msgid "As we mentioned earlier, the libsvn_fs API looks and feels like any other filesystem, except that it has this wonderful versioning capability. It was designed to be usable by any program interested in a versioning filesystem. Not coincidentally, Subversion itself is interested in that functionality. But while the filesystem API should be sufficient for basic file and directory versioning support, Subversion wants more—and that is where libsvn_repos comes in."
msgstr "像之前我们提到的，libsvn_fs的API感觉像是其它文件系统，只是有一个美妙的版本化能力。它设计为为所有对版本化的文件系统有兴趣的程序使用，不是巧合，Subversion本身也对这个功能很有兴趣。但是虽然文件系统API一定必须对基本的文件和目录版本化提供足够的支持，Subversion需要的更多—这是libsvn_repos到来的地方。"

#: build/en/book.xml:16706(para)
#, fuzzy
msgid "The Subversion repository library (libsvn_repos) sits (logically speaking) atop the libsvn_fs API, providing additional functionality beyond that of the underlying versioned filesystem logic. It does not completely wrap each and every filesystem function—only certain major steps in the general cycle of filesystem activity are wrapped by the repository interface. Some of these include the creation and commit of Subversion transactions, and the modification of revision properties. These particular events are wrapped by the repository layer because they have hooks associated with them. A repository hook system is not strictly related to implementing a versioning filesystem, so it lives in the repository wrapper library."
msgstr "希望使用libsvn_repos的API的开发者会发现它不是文件系统的一个完全包裹，只有文件系统常规周期中的主要事件使用版本库接口包裹，如包括Subversion事务的创建和提交，修订版本属性的修改。这些特别的事件使用版本库库包裹是因为它们有一些关联的钩子，在将来，别的事件也将会使用版本库API包裹。所有其它的文件系统交互会直接通过libsvn_fs的API发生。"

#: build/en/book.xml:16720(para)
#, fuzzy
msgid "The hooks mechanism is but one of the reasons for the abstraction of a separate repository library from the rest of the filesystem code. The libsvn_repos API provides several other important utilities to Subversion. These include the abilities to:"
msgstr "钩子机制需求是从文件系统代码的其它部分中抽象出单独的版本库库的一个原因，libsvn_repos的API提供了许多其他有用的工具，它们可以做到："

#: build/en/book.xml:16728(para)
msgid "create, open, destroy, and perform recovery steps on a Subversion repository and the filesystem included in that repository."
msgstr "在Subversion版本库和版本库包括的文件系统的上创建、打开、销毁和执行恢复步骤。"

#: build/en/book.xml:16733(para)
msgid "describe the differences between two filesystem trees."
msgstr "描述两个文件系统树的区别。"

#: build/en/book.xml:16737(para)
msgid "query for the commit log messages associated with all (or some) of the revisions in which a set of files was modified in the filesystem."
msgstr "关于所有（或者部分）修订版本中的文件系统中的一组文件的提交日志信息的查询"

#: build/en/book.xml:16742(para)
msgid "generate a human-readable <quote>dump</quote> of the filesystem, a complete representation of the revisions in the filesystem."
msgstr "产生可读的文件系统<quote>导出</quote>，一个文件系统修订版本的完整展现。"

#: build/en/book.xml:16747(para)
msgid "parse that dump format, loading the dumped revisions into a different Subversion repository."
msgstr "解析导出格式，加载导出的版本到一个不同的Subversion版本库。"

#: build/en/book.xml:16752(para)
msgid "As Subversion continues to evolve, the repository library will grow with the filesystem library to offer increased functionality and configurable option support."
msgstr "伴随着Subversion的发展，版本库库会随着文件系统提供更多的功能和配置选项而不断成长。"

#: build/en/book.xml:16760(title)
msgid "Repository Access Layer"
msgstr "版本库访问层"

#: build/en/book.xml:16762(para)
#, fuzzy
msgid "If the Subversion Repository Layer is at <quote>the other end of the line</quote>, the Repository Access (RA) Layer is the line itself. Charged with marshaling data between the client libraries and the repository, this layer includes the libsvn_ra module loader library, the RA modules themselves (which currently includes libsvn_ra_dav, libsvn_ra_local, libsvn_ra_serf, and libsvn_ra_svn), and any additional libraries needed by one or more of those RA modules, such as the mod_dav_svn Apache module with which libsvn_ra_dav communicates or libsvn_ra_svn's server, <command moreinfo=\"none\">svnserve</command>."
msgstr "如果说Subversion版本库层是在<quote>这条线的另一端</quote>，那版本库访问层就是这条线。负责在客户端库和版本库之间编码数据，这一层包括libsvn_ra模块加载模块，RA模块本身（现在包括了libsvn_ra_dav、libsvn_ra_local和libsvn_ra_svn），和所有一个或多个RA模块需要的附加库，例如与Apache模块mod_dav_svn通讯的libsvn_ra_dav或者是libsvn_ra_svn的服务器，<command moreinfo=\"none\">svnserve</command>。"

#: build/en/book.xml:16774(para)
#, fuzzy
msgid "Since Subversion uses URLs to identify its repository resources, the protocol portion of the URL schema (usually <literal moreinfo=\"none\">file://</literal>, <literal moreinfo=\"none\">http://</literal>, <literal moreinfo=\"none\">https://</literal>, or <literal moreinfo=\"none\">svn://</literal>) is used to determine which RA module will handle the communications. Each module registers a list of the protocols it knows how to <quote>speak</quote> so that the RA loader can, at runtime, determine which module to use for the task at hand. You can determine which RA modules are available to the Subversion command-line client, and what protocols they claim to support, by running <command moreinfo=\"none\">svn --version</command>:"
msgstr "因为Subversion使用URL来识别版本库资源，URL模式的协议部分（通常是<literal moreinfo=\"none\">file:</literal>、<literal moreinfo=\"none\">http:</literal>、<literal moreinfo=\"none\">https:</literal>或<literal moreinfo=\"none\">svn:</literal>）用来监测那个RA模块用来处理通讯。每个模块注册一组它们知道如何<quote>说话</quote>的协议，所以RA加载器可以在运行中监测在手边的任务中使用哪个模块。通过运行<command moreinfo=\"none\">svn --version</command>，你可以监测Subversion命令行客户端所支持的RA模块和它们声明支持的协议："

#: build/en/book.xml:16786(screen)
#, no-wrap
msgid ""
"\n"
"$ svn --version\n"
"svn, version 1.4.3 (r23084)\n"
"   compiled Jan 18 2007, 07:47:40\n"
"\n"
"Copyright (C) 2000-2006 CollabNet.\n"
"Subversion is open source software, see http://subversion.tigris.org/\n"
"This product includes software developed by CollabNet (http://www.Collab.Net/).\n"
"\n"
"The following repository access (RA) modules are available:\n"
"\n"
"* ra_dav : Module for accessing a repository via WebDAV (DeltaV) protocol.\n"
"  - handles 'http' scheme\n"
"  - handles 'https' scheme\n"
"* ra_svn : Module for accessing a repository using the svn network protocol.\n"
"  - handles 'svn' scheme\n"
"* ra_local : Module for accessing a repository on local disk.\n"
"  - handles 'file' scheme\n"
"\n"
"$\n"
msgstr ""
"\n"
"$ svn --version\n"
"svn, version 1.4.3 (r23084)\n"
"   compiled Jan 18 2007, 07:47:40\n"
"\n"
"Copyright (C) 2000-2006 CollabNet.\n"
"Subversion is open source software, see http://subversion.tigris.org/\n"
"This product includes software developed by CollabNet (http://www.Collab.Net/).\n"
"\n"
"The following repository access (RA) modules are available:\n"
"\n"
"* ra_dav : Module for accessing a repository via WebDAV (DeltaV) protocol.\n"
"  - handles 'http' scheme\n"
"  - handles 'https' scheme\n"
"* ra_svn : Module for accessing a repository using the svn network protocol.\n"
"  - handles 'svn' scheme\n"
"* ra_local : Module for accessing a repository on local disk.\n"
"  - handles 'file' scheme\n"
"\n"
"$\n"

#: build/en/book.xml:16808(para)
msgid "The public API exported by the RA Layer contains functionality necessary for sending and receiving versioned data to and from the repository. And each of the available RA plugins is able to perform that task using a specific protocol—libsvn_ra_dav speaks HTTP/WebDAV (optionally using SSL encryption) with an Apache HTTP Server that is running the mod_dav_svn Subversion server module; libsvn_ra_svn speaks a custom network protocol with the <command moreinfo=\"none\">svnserve</command> program; and so on."
msgstr ""

#: build/en/book.xml:16818(para)
#, fuzzy
msgid "And for those who wish to access a Subversion repository using still another protocol, that is precisely why the Repository Access Layer is modularized! Developers can simply write a new library that implements the RA interface on one side and communicates with the repository on the other. Your new library can use existing network protocols, or you can invent your own. You could use inter-process communication (IPC) calls, or—let's get crazy, shall we?—you could even implement an email-based protocol. Subversion supplies the APIs; you supply the creativity."
msgstr "对那些一直希望使用另一个协议来访问Subversion版本库的人，正好是为什么版本库访问层是模块化的！开发者可以简单的编写一个新的库来在一侧实现RA接口并且与另一侧的版本库通讯。你的新库可以使用存在的网络协议，或者发明你自己的。你可以使用进程间的通讯调用，或者—让我们发狂，我们会吗？—你甚至可以实现一个电子邮件为基础的协议，Subversion提供了API，你提供创造性。"

#: build/en/book.xml:16833(title)
msgid "Client Layer"
msgstr "客户端层"

#: build/en/book.xml:16835(para)
msgid "On the client side, the Subversion working copy is where all the action takes place. The bulk of functionality implemented by the client-side libraries exists for the sole purpose of managing working copies—directories full of files and other subdirectories which serve as a sort of local, editable <quote>reflection</quote> of one or more repository locations—and propagating changes to and from the Repository Access layer."
msgstr "在客户端这一面，Subversion工作拷贝是所有动作发生的地方。大多数客户端库实现的功能是为了管理工作拷贝的目的实现的—满是文件子目录的目录是一个或多个版本库位置的可编辑的本地<quote>影射</quote>—从版本库访问层来回传递修改。"

#: build/en/book.xml:16844(para)
msgid "Subversion's working copy library, libsvn_wc, is directly responsible for managing the data in the working copies. To accomplish this, the library stores administrative information about each working copy directory within a special subdirectory. This subdirectory, named <filename moreinfo=\"none\">.svn</filename>, is present in each working copy directory and contains various other files and directories which record state and provide a private workspace for administrative action. For those familiar with CVS, this <filename moreinfo=\"none\">.svn</filename> subdirectory is similar in purpose to the <filename moreinfo=\"none\">CVS</filename> administrative directories found in CVS working copies. For more information about the <filename moreinfo=\"none\">.svn</filename> administrative area, see <xref linkend=\"svn.developer.insidewc\"/>in this chapter."
msgstr "Subversion的工作拷贝库，libsvn_wc直接负责管理工作拷贝的数据，为了完成这一点，库会在工作拷贝的每个目录的特殊子目录中保存关于工作拷贝的管理性信息。这个子目录叫做<filename moreinfo=\"none\">.svn</filename>，出现在所有工作拷贝目录里，保存了各种记录了状态和用来在私有工作区工作的文件和目录。对那些熟悉CVS的用户，<filename moreinfo=\"none\">.svn</filename>子目录与<filename moreinfo=\"none\">CVS</filename>工作拷贝管理目录的作用类似，关于<filename moreinfo=\"none\">.svn</filename>管理区域的更多信息，见本章的<xref linkend=\"svn.developer.insidewc\"/>。"

#: build/en/book.xml:16858(para)
msgid "The Subversion client library, libsvn_client, has the broadest responsibility; its job is to mingle the functionality of the working copy library with that of the Repository Access Layer, and then to provide the highest-level API to any application that wishes to perform general revision control actions. For example, the function <function moreinfo=\"none\">svn_client_checkout()</function> takes a URL as an argument. It passes this URL to the RA layer and opens an authenticated session with a particular repository. It then asks the repository for a certain tree, and sends this tree into the working copy library, which then writes a full working copy to disk (<filename moreinfo=\"none\">.svn</filename> directories and all)."
msgstr "Subversion客户端库libsvn_client具备最广泛的职责；它的工作是结合工作拷贝库和版本库访问库的功能，然后为希望普通版本控制的应用提供最高级的API。举个例子，<function moreinfo=\"none\">svn_client_checkout()</function>方法是用一个URL作为参数，传递这个URL到RA层然后在特定版本库打开一个会话。然后向版本库要求一个特定的目录树，然后把目录树发送给工作拷贝库，然后把完全的工作拷贝写到磁盘（<filename moreinfo=\"none\">.svn</filename>目录和一切）。"

#: build/en/book.xml:16872(para)
#, fuzzy
msgid "The client library is designed to be used by any application. While the Subversion source code includes a standard command-line client, it should be very easy to write any number of GUI clients on top of the client library. New GUIs (or any new client, really) for Subversion need not be clunky wrappers around the included command-line client—they have full access via the libsvn_client API to same functionality, data, and callback mechanisms that the command-line client uses. In fact, the Subversion source code tree contains a small C program (which can be found at <filename moreinfo=\"none\">tools/examples/minimal_client.c</filename> that exemplifies how to wield the Subversion API to create a simple client program"
msgstr "客户端库是为任何程序使用设计的，尽管Subversion的源代码包括了一个标准的命令行客户端，用客户端库编写GUI客户端也是很简单，Subversion新的GUI（或者任何新的客户端，真的）不需要紧密围绕包含的命令行客户端—他们对具有相同功能、数据和回调机制的libsvn_client的API有完全的访问权利。"

#: build/en/book.xml:16887(title)
msgid "Binding Directly—A Word About Correctness"
msgstr "直接绑定—关于正确性"

#: build/en/book.xml:16889(para)
msgid "Why should your GUI program bind directly with a libsvn_client instead of acting as a wrapper around a command-line program? Besides simply being more efficient, this can address potential correctness issues as well. A command-line program (like the one supplied with Subversion) that binds to the client library needs to effectively translate feedback and requested data bits from C types to some form of human-readable output. This type of translation can be lossy. That is, the program may not display all of the information harvested from the API, or may combine bits of information for compact representation."
msgstr "为什么GUI程序要直接访问libsvn_client而不以命令行客户端的包裹运行？除了效率以外，这也关系到潜在的正确性问题。一个命令行客户端程序（如Subversion提供的）如果绑定了客户端库，需要将反馈和请求数据字节从C翻译为可读的输出，这种翻译是有损耗的，程序不能得到API所提供的所有信息，或者是得到紧凑的信息。"

#: build/en/book.xml:16901(para)
msgid "If you wrap such a command-line program with yet another program, the second program has access only to already-interpreted (and as we mentioned, likely incomplete) information, which it must <emphasis>again</emphasis> translate into <emphasis>its</emphasis> representation format. With each layer of wrapping, the integrity of the original data is potentially tainted more and more, much like the result of making a copy of a copy (of a copy …) of a favorite audio or video cassette."
msgstr "如果你已经包裹了这样一个命令行程序，第二个程序只能访问已经经过解释的（如我们提到的，不完全）信息，需要<emphasis>再次</emphasis>转化为<emphasis>它本身的</emphasis>展示格式。由于各层的包裹，原始数据的完整性越来越难以保证，结果很像对喜欢的录音带或录像带反复的拷贝（一个拷贝…）。"

#: build/en/book.xml:16911(para)
msgid "But the most compelling argument for binding directly to the APIs instead of wrapping other programs is that the Subversion project makes compatibility promises regarding its APIs. Across minor versions of those APIs (such as between 1.3 and 1.4), no function's prototype will change. In other words, you aren't forced to update your program's source code simply because you've upgraded to a new version of Subversion. Certain functions might be deprecated, but they still work, and this gives you a buffer of time to eventually embrace the newer APIs. These kinds of compatibility promises do not exist for Subversion command-line program output, which is subject to change from release to release."
msgstr ""

#: build/en/book.xml:16934(title)
msgid "Inside the Working Copy Administration Area"
msgstr "进入工作拷贝的管理区"

#: build/en/book.xml:16936(para)
msgid "As we mentioned earlier, each directory of a Subversion working copy contains a special subdirectory called <filename moreinfo=\"none\">.svn</filename> which houses administrative data about that working copy directory. Subversion uses the information in <filename moreinfo=\"none\">.svn</filename> to keep track of things like:"
msgstr "像我们前面提到的，每个Subversion工作拷贝包含了一个特别的子目录叫做<filename moreinfo=\"none\">.svn</filename>，这个目录包含了关于工作拷贝目录的管理数据，Subversion使用<filename moreinfo=\"none\">.svn</filename>中的信息来追踪如下的数据："

#: build/en/book.xml:16944(para)
msgid "Which repository location(s) are represented by the files and subdirectories in the working copy directory."
msgstr "工作拷贝中展示的目录和文件在版本库中的位置。"

#: build/en/book.xml:16949(para)
msgid "What revision of each of those files and directories are currently present in the working copy."
msgstr "工作拷贝中当前展示的文件和目录的修订版本。"

#: build/en/book.xml:16953(para)
msgid "Any user-defined properties that might be attached to those files and directories."
msgstr "所有附加在文件和目录上的用户定义属性。"

#: build/en/book.xml:16957(para)
msgid "Pristine (un-edited) copies of the working copy files."
msgstr "初始（未编辑）的工作拷贝文件的拷贝。"

#: build/en/book.xml:16962(para)
msgid "The Subversion working copy administration area's layout and contents are considered implementation details not really intended for human consumption. Developers are encouraged to use Subversion's public APIs or provided tools to access and manipulate the working copy data, as opposed to directly reading or modifying the files of which the working copy administrative area is comprised. The file formats employed by the working copy library for its administrative data do change from time to time—a fact that the public APIs do a great job of successfully hiding from the average user. In this section, we expose some of these implementation details sheerly to appease your overwhelming curiosity."
msgstr ""

#: build/en/book.xml:16977(title)
msgid "The Entries File"
msgstr "条目文件"

#: build/en/book.xml:16979(para)
#, fuzzy
msgid "Perhaps the single most important file in the <filename moreinfo=\"none\">.svn</filename> directory is the <filename moreinfo=\"none\">entries</filename> file. The entries file is a single file which contains the bulk of the administrative information about a versioned item in a working copy directory. It is this one file which tracks the repository URLs, pristine revision, file checksums, pristine text and property timestamps, scheduling and conflict state information, last-known commit information (author, revision, timestamp), local copy history—practically everything that a Subversion client is interested in knowing about a versioned (or to-be-versioned) resource!"
msgstr "或许<filename moreinfo=\"none\">.svn</filename>目录中最重要的单个文件就是<filename moreinfo=\"none\">entries</filename>了，这个条目文件是一个XML文档，包含了关于工作拷贝中的版本化的资源的大多数管理性信息，这个文件保留了版本库URL、原始修订版本、可知的最后提交信息（作者、修订版本和时间戳）和本地拷贝历史—实际上是Subversion客户端关于一个版本化（或者是将要版本化的）资源的所有感兴趣的信息！"

#: build/en/book.xml:16992(para)
#, fuzzy
msgid "Folks familiar with CVS's administrative directories will have recognized at this point that Subversion's <filename moreinfo=\"none\">.svn/entries</filename> file serves the purposes of, among other things, CVS's <filename moreinfo=\"none\">CVS/Entries</filename>, <filename moreinfo=\"none\">CVS/Root</filename>, and <filename moreinfo=\"none\">CVS/Repository</filename> files combined."
msgstr "扫视一下典型的<filename moreinfo=\"none\">.svn</filename>目录会发现比CVS在<filename moreinfo=\"none\">CVS</filename>目录中的内容多一些，<filename moreinfo=\"none\">entries</filename>文件包含的XML描述了工作拷贝目录的当前状态，而且基本上合并了CVS的<filename moreinfo=\"none\">Entries</filename>、<filename moreinfo=\"none\">Root</filename>和<filename moreinfo=\"none\">Repository</filename>的功能。"

#: build/en/book.xml:16999(para)
msgid "The format of the <filename moreinfo=\"none\">.svn/entries</filename> file has changed over time. Originally an XML file, it now uses a custom—though still human-readable—file format. While XML was a great choice for early developers of Subversion who were frequently debugging the file's contents (and Subversion's behavior in light of them), the need for easy developer debugging has diminished as Subversion has matured, and has been replaced by the user's need for snappier performance. Of course, Subversion's working copy library makes upgrading from one working copy format to another a breeze—it reads the old formats, and writes the new."
msgstr ""

#: build/en/book.xml:17016(title)
msgid "Pristine Copies and Property Files"
msgstr "原始拷贝和属性文件"

#: build/en/book.xml:17018(para)
msgid "As mentioned before, the <filename moreinfo=\"none\">.svn</filename> directory also holds the pristine <quote>text-base</quote> versions of files. Those can be found in <filename moreinfo=\"none\">.svn/text-base</filename>. The benefits of these pristine copies are multiple—network-free checks for local modifications and difference reporting, network-free reversion of modified or missing files, smaller transmission of changes to the server—but comes at the cost of having each versioned file stored at least twice on disk. These days, this seems to be a negligible penalty for most files. However, the situation gets uglier as the size of your versioned files grows. Some attention is being given to making the presence of the <quote>text-base</quote> an option. Ironically though, it is as your versioned files' sizes get larger that the existence of the <quote>text-base</quote> becomes more crucial—who wants to transmit a huge file across a network just because they want to commit a tiny change to it?"
msgstr "如我们前面提到的，<filename moreinfo=\"none\">.svn</filename>也包含了一些原始的<quote>text-base</quote>文件版本，可以在<filename moreinfo=\"none\">.svn/text-base</filename>看到。这些原始文件的好处是多方面的—察看本地修改和区别不需要经过网络访问，减少传递修改时的数据—但是随之而来的代价是每个版本化的文件都在磁盘至少保存两次，现在看来这是对大多数文件可以忽略不计的一个惩罚。但是，当你版本控制的文件增多之后形势会变得很严峻，我们已经注意到了应该可以选择使用<quote>text-base</quote>，但是具有讽刺意味的是，当版本化文件增大时，<quote>text-base</quote>文件的存在会更加重要—谁会希望在提交一个小修改时在网络上传递一个大文件？"

#: build/en/book.xml:17037(para)
msgid "Similar in purpose to the <quote>text-base</quote> files are the property files and their pristine <quote>prop-base</quote> copies, located in <filename moreinfo=\"none\">.svn/props</filename> and <filename moreinfo=\"none\">.svn/prop-base</filename> respectively. Since directories can have properties, too, there are also <filename moreinfo=\"none\">.svn/dir-props</filename> and <filename moreinfo=\"none\">.svn/dir-prop-base</filename> files. Each of these property files (<quote>working</quote> and <quote>base</quote> versions) uses a simple <quote>hash-on-disk</quote> file format for storing the property names and values."
msgstr "同<quote>text-base</quote>文件的用途一样的还有属性文件和它们的<quote>prop-base</quote>拷贝，分别位于<filename moreinfo=\"none\">.svn/props</filename>和<filename moreinfo=\"none\">.svn/prop-base</filename>。因为目录也有属性，所以也有<filename moreinfo=\"none\">.svn/dir-props</filename>和<filename moreinfo=\"none\">.svn/dir-prop-base</filename>文件。所有的属性文件（<quote>working</quote>和<quote>base</quote>版本）都使用同样的<quote>hash-on-disk</quote>文件格式来排序属性名称和值。"

#: build/en/book.xml:17057(title)
msgid "Using the APIs"
msgstr "使用 API"

#: build/en/book.xml:17059(para)
#, fuzzy
msgid "Developing applications against the Subversion library APIs is fairly straightforward. All of the public header files live in the <filename moreinfo=\"none\">subversion/include</filename> directory of the source tree. These headers are copied into your system locations when you build and install Subversion itself from source. These headers represent the entirety of the functions and types meant to be accessible by users of the Subversion libraries. The Subversion developer community is meticulous about ensuring that the public API is well-documented—refer directly to the header files for that documentation."
msgstr "使用Subversion库API开发应用看起来相当的直接，所有的公共头文件放在源文件的<filename moreinfo=\"none\">subversion/include</filename>目录，从源代码编译和安装Subversion本身，需要这些头文件拷贝到系统位置。这些头文件包括了所有用户可以访问的功能和类型。"

#: build/en/book.xml:17071(para)
#, fuzzy
msgid "When examining the public header files, the first thing you might notice is that Subversion's datatypes and functions are namespace protected. Every public Subversion symbol name begins with <literal moreinfo=\"none\">svn_</literal>, followed by a short code for the library in which the symbol is defined (such as <literal moreinfo=\"none\">wc</literal>, <literal moreinfo=\"none\">client</literal>, <literal moreinfo=\"none\">fs</literal>, etc.), followed by a single underscore (<literal moreinfo=\"none\">_</literal>) and then the rest of the symbol name. Semi-public functions (used among source files of a given library but not by code outside that library, and found inside the library directories themselves) differ from this naming scheme in that instead of a single underscore after the library code, they use a double underscore (<literal moreinfo=\"none\">__</literal>). Functions that are private to a given source file have no special prefixing, and are declared <literal moreinfo=\"none\">static</literal>. Of course, a compiler isn't interested in these naming conventions, but they help to clarify the scope of a given function or datatype."
msgstr "你首先应该注意Subversion的数据类型和方法是命名空间保护的，每一个公共Subversion对象名以<literal moreinfo=\"none\">svn_</literal>开头，然后紧跟一个这个对象定义（如<literal moreinfo=\"none\">wc</literal>、<literal moreinfo=\"none\">client</literal>和<literal moreinfo=\"none\">fs</literal>其他）所在的库的简短编码，然后是一个下划线（<literal moreinfo=\"none\">_</literal>）和后面的对象名称。半公开的方法（库使用，但是但库之外代码不可以使用并且只可以在库自己的目录看到）与这个命名模式不同，并不是库代码之后紧跟一个下划线，他们是用两个下划线（<literal moreinfo=\"none\">__</literal>）。给定源文件的私有方法没有特殊前缀，使用<literal moreinfo=\"none\">static</literal>声明。当然，一个编译器不会关心命名习惯，只是用来区分给定方法或数据类型。"

#: build/en/book.xml:17098(para)
msgid "After all, Subversion uses Subversion's APIs, too."
msgstr ""

#: build/en/book.xml:17090(para)
msgid "Another good source of information about programming against the Subversion APIs is the project's own hacking guidelines, which can be found at <ulink url=\"http://subversion.tigris.org/hacking.html\"/>. This document contains useful information which, while aimed at developers and would-be developers of Subversion itself, is equally applicable to folks developing against Subversion as a set of third-party libraries. <placeholder-1/>"
msgstr ""

#: build/en/book.xml:17105(title)
msgid "The Apache Portable Runtime Library"
msgstr "Apache 可移植运行库"

#: build/en/book.xml:17107(para)
msgid "Along with Subversion's own datatypes, you will see many references to datatypes that begin with <literal moreinfo=\"none\">apr_</literal>—symbols from the Apache Portable Runtime (APR) library. APR is Apache's portability library, originally carved out of its server code as an attempt to separate the OS-specific bits from the OS-independent portions of the code. The result was a library that provides a generic API for performing operations that differ mildly—or wildly—from OS to OS. While the Apache HTTP Server was obviously the first user of the APR library, the Subversion developers immediately recognized the value of using APR as well. This means that there are practically no OS-specific code portions in Subversion itself. Also, it means that the Subversion client compiles and runs anywhere that the server does. Currently this list includes all flavors of Unix, Win32, BeOS, OS/2, and Mac OS X."
msgstr "伴随Subversion自己的数据类型，你会看到许多<literal moreinfo=\"none\">apr</literal>开头的数据类型引用—来自Apache可移植运行库（APR）的对象。APR是Apache可移植运行库，源自为了服务器代码的多平台性，尝试将不同的操作系统特定字节与操作系统无关代码隔离。结果就提供了一个基础API的库，只有一些适度区别—或者是广泛的—来自各个操作系统。Apache HTTP服务器很明显是APR库的第一个用户，Subversion开发者立刻发现了使用APR库的价值。意味着Subversion没有操作系统特定的代码，也意味着Subversion客户端可以在Server存在的平台编译和运行。当前这个列表包括，各种类型的Unix、Win32、OS/2和Mac OS X。"

#: build/en/book.xml:17127(para)
msgid "Subversion uses ANSI system calls and datatypes as much as possible."
msgstr "Subversion使用尽可能多ANSI系统调用和数据类型。"

#: build/en/book.xml:17140(para)
msgid "Neon and Berkeley DB are examples of such libraries."
msgstr "Neon和Berkeley DB就是这种库的例子。"

#: build/en/book.xml:17124(para)
#, fuzzy
msgid "In addition to providing consistent implementations of system calls that differ across operating systems, <placeholder-1/> APR gives Subversion immediate access to many custom datatypes, such as dynamic arrays and hash tables. Subversion uses these types extensively throughout the codebase. But perhaps the most pervasive APR datatype, found in nearly every Subversion API prototype, is the <structname>apr_pool_t</structname>—the APR memory pool. Subversion uses pools internally for all its memory allocation needs (unless an external library requires a different memory management schema for data passed through its API), <placeholder-2/> and while a person coding against the Subversion APIs is not required to do the same, they are required to provide pools to the API functions that need them. This means that users of the Subversion API must also link against APR, must call <function moreinfo=\"none\">apr_initialize()</function> to initialize the APR subsystem, and then must create and manage pools for use with Subversion API calls, typically by using <function moreinfo=\"none\">svn_pool_create()</function>, <function moreinfo=\"none\">svn_pool_clear()</function>, and <function moreinfo=\"none\">svn_pool_destroy()</function>."
msgstr "除了提供了跨平台一致的系统调用， <footnote><placeholder-1/></footnote> APR给Subversion对多种数据类型有快速的访问，如动态数组和哈希表。Subversion在代码中广泛使用这些类型，但是或许大多数普遍深入的APR数据类型可以在所有的Subversion的API原型中发现，是<structname>apr_pool_t</structname>—APR内存池，Subversion使用内部缓冲池用来进行内存分配（除非外部库在API传递参数时需要一个不同的内存管理模式）， <footnote><placeholder-2/></footnote> 而且一个人如果针对Subversion的API编码不需要做同样的事情，他们可以在需要时给API提供缓冲池，这意味着Subversion的API使用者也必须链接到APR，必须调用<function moreinfo=\"none\">apr_initialize()</function>来初始化APR字系统，然后必须得到一个缓冲池用来进行Subversion的API调用。详情见<xref linkend=\"svn.developer.pools\"/>。"

#: build/en/book.xml:17154(title)
msgid "Programming with Memory Pools"
msgstr "使用内存池编程"

#: build/en/book.xml:17156(para)
#, fuzzy
msgid "Almost every developer who has used the C programming language has at some point sighed at the daunting task of managing memory usage. Allocating enough memory to use, keeping track of those allocations, freeing the memory when you no longer need it—these tasks can be quite complex. And of course, failure to do those things properly can result in a program that crashes itself, or worse, crashes the computer."
msgstr "几乎每一个使用过C语言的开发者曾经感叹令人畏缩的内存管理，分配足够的内存，并且追踪内存的分配，在不需要时释放内存—这个任务会非常复杂。当然，如果没有正确地做到这一点会导致程序毁掉自己，或者更加严重一点，把电脑搞瘫。幸运的是，Subversion所依赖的APR库为了移植性提供了<structname>apr_pool_t</structname>类型，代表了应用可以分配内存的池。"

#: build/en/book.xml:17168(para)
msgid "Or at least make it something you only toy with when doing extremely tight program optimization."
msgstr ""

#: build/en/book.xml:17165(para)
msgid "Higher-level languages, on the other hand, take the job of memory management away from the developer completely. <placeholder-1/> Languages like Java and Python use <firstterm>garbage collection</firstterm> principles, allocating memory for objects when needed, and automatically freeing that memory when the object is no longer in use."
msgstr ""

#: build/en/book.xml:17176(para)
msgid "APR provides a middle-ground approach called pool-based memory management. It allows the developer to control memory usage at a lower resolution—per chunk (or <quote>pool</quote>) of memory, instead of per allocated object. Rather than using <function moreinfo=\"none\">malloc()</function> and friends to allocate enough memory for a given object, you ask APR to allocate the memory from a memory pool. When you're finished using the objects you've created in the pool, you destroy the pool, effectively de-allocating the memory consumed by the objects you allocated from it. Rather than keeping track of individual objects which need to be de-allocated, your program simply considers the general lifetimes of those objects, and allocates the objects in a pool whose lifetime (the time between the pool's creation and its deletion) matches the object's needs."
msgstr ""

#: build/en/book.xml:17198(title)
msgid "URL and Path Requirements"
msgstr "URL 和路径需求"

#: build/en/book.xml:17200(para)
msgid "With remote version control operation as the whole point of Subversion's existence, it makes sense that some attention has been paid to internationalization (i18n) support. After all, while <quote>remote</quote> might mean <quote>across the office</quote>, it could just as well mean <quote>across the globe.</quote> To facilitate this, all of Subversion's public interfaces that accept path arguments expect those paths to be canonicalized, and encoded in UTF-8. This means, for example, that any new client binary that drives the libsvn_client interface needs to first convert paths from the locale-specific encoding to UTF-8 before passing those paths to the Subversion libraries, and then re-convert any resultant output paths from Subversion back into the locale's encoding before using those paths for non-Subversion purposes. Fortunately, Subversion provides a suite of functions (see <filename moreinfo=\"none\">subversion/include/svn_utf.h</filename>) that can be used by any program to do these conversions."
msgstr "因为分布式版本控制操作是Subversion存在的重点，有意义来关注一下国际化（i18n）支持。毕竟，当<quote>分布式</quote>或许意味着<quote>横跨办公室</quote>，它也意味着<quote>横跨全球</quote>。为了更容易一点，Subversion的所有公共接口只接受路径参数,这些参数是传统的，使用UTF-8编码。这意味着，举个例子，任何新的使用libsvn_client接口客户端库，在把这些参数传递给Subversion库前，需要首先将路径从本地代码转化为UTF-8代码，然后将Subversion传递回来的路径转换为本地代码，很幸运，Subversion提供了一组任何程序可以使用的转化方法（见<filename moreinfo=\"none\">subversion/include/svn_utf.h</filename>）。"

#: build/en/book.xml:17218(para)
#, fuzzy
msgid "Also, Subversion APIs require all URL parameters to be properly URI-encoded. So, instead of passing <uri>file:///home/username/My File.txt</uri> as the URL of a file named <literal moreinfo=\"none\">My File.txt</literal>, you need to pass <uri>file:///home/username/My%20File.txt</uri>. Again, Subversion supplies helper functions that your application can use—<function moreinfo=\"none\">svn_path_uri_encode()</function> and <function moreinfo=\"none\">svn_path_uri_decode()</function>, for URI encoding and decoding, respectively."
msgstr "同样，Subversion的API需要所有的URL参数是正确的URI编码，所以，我们不会传递<systemitem class=\"url\" moreinfo=\"none\">file:///home/username/My File.txt</systemitem>作为<literal moreinfo=\"none\">My File.txt</literal>的URL，而会传递<systemitem class=\"url\" moreinfo=\"none\">file:///home/username/My%20File.txt</systemitem>。再次，Subversion提供了一些你可以使用的助手方法—<function moreinfo=\"none\">svn_path_uri_encode()</function>和<function moreinfo=\"none\">svn_path_uri_decode()</function>，分别用来URI的编码和解码。"

#: build/en/book.xml:17230(title)
msgid "Using Languages Other than C and C++"
msgstr "使用 C 和 C++ 以外的语言"

#: build/en/book.xml:17232(para)
msgid "If you are interested in using the Subversion libraries in conjunction with something other than a C program—say a Python or Perl script—Subversion has some support for this via the Simplified Wrapper and Interface Generator (SWIG). The SWIG bindings for Subversion are located in <filename moreinfo=\"none\">subversion/bindings/swig</filename> and whilst still maturing, they are in a usable state. These bindings allow you to call Subversion API functions indirectly, using wrappers that translate the datatypes native to your scripting language into the datatypes needed by Subversion's C libraries."
msgstr "除C语言以外，如果你对使用其他语言结合Subversion库感兴趣—如Python脚本或是Java应用—Subversion通过简单包裹生成器（SWIG）提供了最初的支持。Subversion的SWIG绑定位于<filename moreinfo=\"none\">subversion/bindings/swig</filename>，并且慢慢的走向成熟进入可用状态。这个绑定允许你直接调用Subversion的API方法，使用包裹器会把脚本数据类型转化为Subversion需要的C语言库类型。"

#: build/en/book.xml:17243(para)
msgid "There is an obvious benefit to accessing the Subversion APIs via a language binding—simplicity. Generally speaking, languages such as Python and Perl are much more flexible and easy to use than C or C++. The sort of high-level datatypes and context-driven type checking provided by these languages are often better at handling information that comes from users. As you know, humans are proficient at botching up input to a program, and scripting languages tend to handle that misinformation more gracefully. Of course, often that flexibility comes at the cost of performance. That is why using a tightly-optimized, C-based interface and library suite, combined with a powerful, flexible binding language, is so appealing."
msgstr "通过语言绑定访问Subversion的API有一个明显的好处—简单性。通常来讲，Python和Perl之类的语言比C和C++更加的灵活和简单，这些语言的高级数据类型和上下文驱动类型更加易于处理用户提供的信息，就像你知道的，人们精于把程序搞坏，脚本语言可以更优雅的处理这些错误信息，当然，灵活性经常带来性能的损失，这就是为什么使用紧密优化的，C基础的接口和库组件，然后与一种高效的、灵活的绑定语言，是这样的吸引人。"

#: build/en/book.xml:17257(para)
#, fuzzy
msgid "Unfortunately, Subversion's language bindings tend to lack the level of developer attention given to the core Subversion modules. However, there have been significant efforts towards creating functional bindings for Python, Perl, and Ruby. To some extent, the work done preparing the SWIG interface files for these languages is reusable in efforts to generate bindings for other languages supported by SWIG (which include versions of C#, Guile, Java, MzScheme, OCaml, PHP, and Tcl, among others). However, some extra programming is required to compensate for complex APIs that SWIG needs some help translating between languages. For more information on SWIG itself, see the project's website at <ulink url=\"http://www.swig.org/\"/>."
msgstr "非常不幸，Subversion的语言绑定缺乏对核心Subversion模块的关注，但是，花了很多力气处理创建针对Python、Perl和Ruby的绑定，在一定程度上，在这些接口上的工作量可以在其他语言的SWIG（包括C#、Guile、Java、MzScheme、OCaml、PHP、Tcl等等）接口上得到重用。然而，一些接口仍然需要额外的编程工作，关于SWIG本身的更多信息可以看项目的网站<ulink url=\"http://www.swig.org/\"/>。"

#: build/en/book.xml:17274(title)
msgid "Code Samples"
msgstr "代码样例"

#: build/en/book.xml:17276(para)
msgid "<xref linkend=\"svn.developer.layerlib.repos.ex-1\"/> contains a code segment (written in C) that illustrates some of the concepts we've been discussing. It uses both the repository and filesystem interfaces (as can be determined by the prefixes <literal moreinfo=\"none\">svn_repos_</literal> and <literal moreinfo=\"none\">svn_fs_</literal> of the function names, respectively) to create a new revision in which a directory is added. You can see the use of an APR pool, which is passed around for memory allocation purposes. Also, the code reveals a somewhat obscure fact about Subversion error handling—all Subversion errors must be explicitly handled to avoid memory leakage (and in some cases, application failure)."
msgstr ""

#: build/en/book.xml:17291(title)
msgid "Using the Repository Layer"
msgstr "使用版本库层"

#: build/en/book.xml:17293(programlisting)
#, no-wrap
msgid ""
"\n"
"/* Convert a Subversion error into a simple boolean error code.\n"
" *\n"
" * NOTE:  Subversion errors must be consumed because they are allocated\n"
" *        from the global pool, else memory leaking occurs.\n"
" */\n"
"#define INT_ERR(expr)                           \\\n"
"  do {                                          \\\n"
"    svn_error_t *__temperr = (expr);            \\\n"
"    if (__temperr)                              \\\n"
"      {                                         \\\n"
"        svn_error_clear(__temperr);             \\\n"
"        return 1;                               \\\n"
"      }                                         \\\n"
"    return 0;                                   \\\n"
"  } while (0)\n"
"\n"
"/* Create a new directory at the path NEW_DIRECTORY in the Subversion\n"
" * repository located at REPOS_PATH.  Perform all memory allocation in\n"
" * POOL.  This function will create a new revision for the addition of\n"
" * NEW_DIRECTORY.  Return zero if the operation completes\n"
" * successfully, non-zero otherwise.\n"
" */\n"
"static int\n"
"make_new_directory(const char *repos_path,\n"
"                   const char *new_directory,\n"
"                   apr_pool_t *pool)\n"
"{\n"
"  svn_error_t *err;\n"
"  svn_repos_t *repos;\n"
"  svn_fs_t *fs;\n"
"  svn_revnum_t youngest_rev;\n"
"  svn_fs_txn_t *txn;\n"
"  svn_fs_root_t *txn_root;\n"
"  const char *conflict_str;\n"
"\n"
"  /* Open the repository located at REPOS_PATH. \n"
"   */\n"
"  INT_ERR(svn_repos_open(&amp;repos, repos_path, pool));\n"
"\n"
"  /* Get a pointer to the filesystem object that is stored in REPOS. \n"
"   */\n"
"  fs = svn_repos_fs(repos);\n"
"\n"
"  /* Ask the filesystem to tell us the youngest revision that\n"
"   * currently exists. \n"
"   */\n"
"  INT_ERR(svn_fs_youngest_rev(&amp;youngest_rev, fs, pool));\n"
"\n"
"  /* Begin a new transaction that is based on YOUNGEST_REV.  We are\n"
"   * less likely to have our later commit rejected as conflicting if we\n"
"   * always try to make our changes against a copy of the latest snapshot\n"
"   * of the filesystem tree. \n"
"   */\n"
"  INT_ERR(svn_fs_begin_txn(&amp;txn, fs, youngest_rev, pool));\n"
"\n"
"  /* Now that we have started a new Subversion transaction, get a root\n"
"   * object that represents that transaction. \n"
"   */\n"
"  INT_ERR(svn_fs_txn_root(&amp;txn_root, txn, pool));\n"
"  \n"
"  /* Create our new directory under the transaction root, at the path\n"
"   * NEW_DIRECTORY. \n"
"   */\n"
"  INT_ERR(svn_fs_make_dir(txn_root, new_directory, pool));\n"
"\n"
"  /* Commit the transaction, creating a new revision of the filesystem\n"
"   * which includes our added directory path.\n"
"   */\n"
"  err = svn_repos_fs_commit_txn(&amp;conflict_str, repos, \n"
"                                &amp;youngest_rev, txn, pool);\n"
"  if (! err)\n"
"    {\n"
"      /* No error?  Excellent!  Print a brief report of our success.\n"
"       */\n"
"      printf(\"Directory '%s' was successfully added as new revision \"\n"
"             \"'%ld'.\\n\", new_directory, youngest_rev);\n"
"    }\n"
"  else if (err-&gt;apr_err == SVN_ERR_FS_CONFLICT)\n"
"    {\n"
"      /* Uh-oh.  Our commit failed as the result of a conflict\n"
"       * (someone else seems to have made changes to the same area \n"
"       * of the filesystem that we tried to modify).  Print an error\n"
"       * message.\n"
"       */\n"
"      printf(\"A conflict occurred at path '%s' while attempting \"\n"
"             \"to add directory '%s' to the repository at '%s'.\\n\", \n"
"             conflict_str, new_directory, repos_path);\n"
"    }\n"
"  else\n"
"    {\n"
"      /* Some other error has occurred.  Print an error message.\n"
"       */\n"
"      printf(\"An error occurred while attempting to add directory '%s' \"\n"
"             \"to the repository at '%s'.\\n\", \n"
"             new_directory, repos_path);\n"
"    }\n"
"\n"
"  INT_ERR(err);\n"
"} \n"
msgstr ""
"\n"
"/* Convert a Subversion error into a simple boolean error code.\n"
" *\n"
" * NOTE:  Subversion errors must be consumed because they are allocated\n"
" *        from the global pool, else memory leaking occurs.\n"
" */\n"
"#define INT_ERR(expr)                           \\\n"
"  do {                                          \\\n"
"    svn_error_t *__temperr = (expr);            \\\n"
"    if (__temperr)                              \\\n"
"      {                                         \\\n"
"        svn_error_clear(__temperr);             \\\n"
"        return 1;                               \\\n"
"      }                                         \\\n"
"    return 0;                                   \\\n"
"  } while (0)\n"
"\n"
"/* Create a new directory at the path NEW_DIRECTORY in the Subversion\n"
" * repository located at REPOS_PATH.  Perform all memory allocation in\n"
" * POOL.  This function will create a new revision for the addition of\n"
" * NEW_DIRECTORY.  Return zero if the operation completes\n"
" * successfully, non-zero otherwise.\n"
" */\n"
"static int\n"
"make_new_directory(const char *repos_path,\n"
"                   const char *new_directory,\n"
"                   apr_pool_t *pool)\n"
"{\n"
"  svn_error_t *err;\n"
"  svn_repos_t *repos;\n"
"  svn_fs_t *fs;\n"
"  svn_revnum_t youngest_rev;\n"
"  svn_fs_txn_t *txn;\n"
"  svn_fs_root_t *txn_root;\n"
"  const char *conflict_str;\n"
"\n"
"  /* Open the repository located at REPOS_PATH. \n"
"   */\n"
"  INT_ERR(svn_repos_open(&amp;repos, repos_path, pool));\n"
"\n"
"  /* Get a pointer to the filesystem object that is stored in REPOS. \n"
"   */\n"
"  fs = svn_repos_fs(repos);\n"
"\n"
"  /* Ask the filesystem to tell us the youngest revision that\n"
"   * currently exists. \n"
"   */\n"
"  INT_ERR(svn_fs_youngest_rev(&amp;youngest_rev, fs, pool));\n"
"\n"
"  /* Begin a new transaction that is based on YOUNGEST_REV.  We are\n"
"   * less likely to have our later commit rejected as conflicting if we\n"
"   * always try to make our changes against a copy of the latest snapshot\n"
"   * of the filesystem tree. \n"
"   */\n"
"  INT_ERR(svn_fs_begin_txn(&amp;txn, fs, youngest_rev, pool));\n"
"\n"
"  /* Now that we have started a new Subversion transaction, get a root\n"
"   * object that represents that transaction. \n"
"   */\n"
"  INT_ERR(svn_fs_txn_root(&amp;txn_root, txn, pool));\n"
"  \n"
"  /* Create our new directory under the transaction root, at the path\n"
"   * NEW_DIRECTORY. \n"
"   */\n"
"  INT_ERR(svn_fs_make_dir(txn_root, new_directory, pool));\n"
"\n"
"  /* Commit the transaction, creating a new revision of the filesystem\n"
"   * which includes our added directory path.\n"
"   */\n"
"  err = svn_repos_fs_commit_txn(&amp;conflict_str, repos, \n"
"                                &amp;youngest_rev, txn, pool);\n"
"  if (! err)\n"
"    {\n"
"      /* No error?  Excellent!  Print a brief report of our success.\n"
"       */\n"
"      printf(\"Directory '%s' was successfully added as new revision \"\n"
"             \"'%ld'.\\n\", new_directory, youngest_rev);\n"
"    }\n"
"  else if (err-&gt;apr_err == SVN_ERR_FS_CONFLICT)\n"
"    {\n"
"      /* Uh-oh.  Our commit failed as the result of a conflict\n"
"       * (someone else seems to have made changes to the same area \n"
"       * of the filesystem that we tried to modify).  Print an error\n"
"       * message.\n"
"       */\n"
"      printf(\"A conflict occurred at path '%s' while attempting \"\n"
"             \"to add directory '%s' to the repository at '%s'.\\n\", \n"
"             conflict_str, new_directory, repos_path);\n"
"    }\n"
"  else\n"
"    {\n"
"      /* Some other error has occurred.  Print an error message.\n"
"       */\n"
"      printf(\"An error occurred while attempting to add directory '%s' \"\n"
"             \"to the repository at '%s'.\\n\", \n"
"             new_directory, repos_path);\n"
"    }\n"
"\n"
"  INT_ERR(err);\n"
"} \n"

#: build/en/book.xml:17396(para)
#, fuzzy
msgid "Note that in <xref linkend=\"svn.developer.layerlib.repos.ex-1\"/>, the code could just as easily have committed the transaction using <function moreinfo=\"none\">svn_fs_commit_txn()</function>. But the filesystem API knows nothing about the repository library's hook mechanism. If you want your Subversion repository to automatically perform some set of non-Subversion tasks every time you commit a transaction (like, for example, sending an email that describes all the changes made in that transaction to your developer mailing list), you need to use the libsvn_repos-wrapped version of that function was adds the hook triggering functionality—in this case, <function moreinfo=\"none\">svn_repos_fs_commit_txn()</function>. (For more information regarding Subversion's repository hooks, see <xref linkend=\"svn.reposadmin.create.hooks\"/>.)"
msgstr "在前面的代码片断中，同时调用了版本库和文件系统接口，我们可以正像这样简单的用<function moreinfo=\"none\">svn_fs_commit_txn()</function>提交事务。但是文件系统的API对版本库库的钩子一无所知，如果你希望你的Subversion版本库在每次提交一个事务时自动执行一些非Subversion的任务（例如，给开发者邮件组发送一个描述事务修改的邮件），你需要使用libsvn_repos包裹的功能版本—<function moreinfo=\"none\">svn_repos_fs_commit_txn()</function>。这个功能会实际上首先运行一个如果存在的<literal moreinfo=\"none\">pre-commit</literal>钩子脚本，然后提交事务，最后会运行一个<literal moreinfo=\"none\">post-commit</literal>钩子脚本。钩子提供了一种特别的报告机制，不是真的属于核心文件系统库本身。（关于Subversion版本库钩子的更多信息，见<xref linkend=\"svn.reposadmin.create.hooks\"/>。）"

#: build/en/book.xml:17410(para)
#, fuzzy
msgid "Now let's switch languages. <xref linkend=\"svn.developer.usingapi.otherlangs.ex-1\"/> is a sample program that uses Subversion's SWIG Python bindings to recursively crawl the youngest repository revision, and print the various paths reached during the crawl."
msgstr "让我们看看Subversion的Python SWIG绑定的实例，这个例子迭代遍历最新的修订版本，并且打印遍历到的路径。"

#: build/en/book.xml:17416(title)
msgid "Using the Repository Layer with Python"
msgstr "使用 Python 处理版本库层"

#: build/en/book.xml:17418(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/usr/bin/python\n"
"\n"
"\"\"\"Crawl a repository, printing versioned object path names.\"\"\"\n"
"\n"
"import sys\n"
"import os.path\n"
"import svn.fs, svn.core, svn.repos\n"
"\n"
"def crawl_filesystem_dir(root, directory):\n"
"    \"\"\"Recursively crawl DIRECTORY under ROOT in the filesystem, and return\n"
"    a list of all the paths at or below DIRECTORY.\"\"\"\n"
"\n"
"    # Print the name of this path.\n"
"    print directory + \"/\"\n"
"    \n"
"    # Get the directory entries for DIRECTORY.\n"
"    entries = svn.fs.svn_fs_dir_entries(root, directory)\n"
"\n"
"    # Loop over the entries.\n"
"    names = entries.keys()\n"
"    for name in names:\n"
"        # Calculate the entry's full path.\n"
"        full_path = directory + '/' + name\n"
"\n"
"        # If the entry is a directory, recurse.  The recursion will return\n"
"        # a list with the entry and all its children, which we will add to\n"
"        # our running list of paths.\n"
"        if svn.fs.svn_fs_is_dir(root, full_path):\n"
"            crawl_filesystem_dir(root, full_path)\n"
"        else:\n"
"            # Else it's a file, so print its path here.\n"
"            print full_path\n"
"\n"
"def crawl_youngest(repos_path):\n"
"    \"\"\"Open the repository at REPOS_PATH, and recursively crawl its\n"
"    youngest revision.\"\"\"\n"
"    \n"
"    # Open the repository at REPOS_PATH, and get a reference to its\n"
"    # versioning filesystem.\n"
"    repos_obj = svn.repos.svn_repos_open(repos_path)\n"
"    fs_obj = svn.repos.svn_repos_fs(repos_obj)\n"
"\n"
"    # Query the current youngest revision.\n"
"    youngest_rev = svn.fs.svn_fs_youngest_rev(fs_obj)\n"
"    \n"
"    # Open a root object representing the youngest (HEAD) revision.\n"
"    root_obj = svn.fs.svn_fs_revision_root(fs_obj, youngest_rev)\n"
"\n"
"    # Do the recursive crawl.\n"
"    crawl_filesystem_dir(root_obj, \"\")\n"
"    \n"
"if __name__ == \"__main__\":\n"
"    # Check for sane usage.\n"
"    if len(sys.argv) != 2:\n"
"        sys.stderr.write(\"Usage: %s REPOS_PATH\\n\"\n"
"                         % (os.path.basename(sys.argv[0])))\n"
"        sys.exit(1)\n"
"\n"
"    # Canonicalize the repository path.\n"
"    repos_path = svn.core.svn_path_canonicalize(sys.argv[1])\n"
"\n"
"    # Do the real work.\n"
"    crawl_youngest(repos_path)\n"
msgstr ""
"\n"
"#!/usr/bin/python\n"
"\n"
"\"\"\"Crawl a repository, printing versioned object path names.\"\"\"\n"
"\n"
"import sys\n"
"import os.path\n"
"import svn.fs, svn.core, svn.repos\n"
"\n"
"def crawl_filesystem_dir(root, directory):\n"
"    \"\"\"Recursively crawl DIRECTORY under ROOT in the filesystem, and return\n"
"    a list of all the paths at or below DIRECTORY.\"\"\"\n"
"\n"
"    # Print the name of this path.\n"
"    print directory + \"/\"\n"
"    \n"
"    # Get the directory entries for DIRECTORY.\n"
"    entries = svn.fs.svn_fs_dir_entries(root, directory)\n"
"\n"
"    # Loop over the entries.\n"
"    names = entries.keys()\n"
"    for name in names:\n"
"        # Calculate the entry's full path.\n"
"        full_path = directory + '/' + name\n"
"\n"
"        # If the entry is a directory, recurse.  The recursion will return\n"
"        # a list with the entry and all its children, which we will add to\n"
"        # our running list of paths.\n"
"        if svn.fs.svn_fs_is_dir(root, full_path):\n"
"            crawl_filesystem_dir(root, full_path)\n"
"        else:\n"
"            # Else it's a file, so print its path here.\n"
"            print full_path\n"
"\n"
"def crawl_youngest(repos_path):\n"
"    \"\"\"Open the repository at REPOS_PATH, and recursively crawl its\n"
"    youngest revision.\"\"\"\n"
"    \n"
"    # Open the repository at REPOS_PATH, and get a reference to its\n"
"    # versioning filesystem.\n"
"    repos_obj = svn.repos.svn_repos_open(repos_path)\n"
"    fs_obj = svn.repos.svn_repos_fs(repos_obj)\n"
"\n"
"    # Query the current youngest revision.\n"
"    youngest_rev = svn.fs.svn_fs_youngest_rev(fs_obj)\n"
"    \n"
"    # Open a root object representing the youngest (HEAD) revision.\n"
"    root_obj = svn.fs.svn_fs_revision_root(fs_obj, youngest_rev)\n"
"\n"
"    # Do the recursive crawl.\n"
"    crawl_filesystem_dir(root_obj, \"\")\n"
"    \n"
"if __name__ == \"__main__\":\n"
"    # Check for sane usage.\n"
"    if len(sys.argv) != 2:\n"
"        sys.stderr.write(\"Usage: %s REPOS_PATH\\n\"\n"
"                         % (os.path.basename(sys.argv[0])))\n"
"        sys.exit(1)\n"
"\n"
"    # Canonicalize the repository path.\n"
"    repos_path = svn.core.svn_path_canonicalize(sys.argv[1])\n"
"\n"
"    # Do the real work.\n"
"    crawl_youngest(repos_path)\n"

#: build/en/book.xml:17485(para)
#, fuzzy
msgid "This same program in C would need to deal with APR's memory pool system. But Python handles memory usage automatically, and Subversion's Python bindings adhere to that convention. In C, you'd be working with custom datatypes (such as those provided by the APR library) for representing the hash of entries and the list of paths, but Python has hashes (called <quote>dictionaries</quote>) and lists as built-in datatypes, and provides a rich collection of functions for operating on those types. So SWIG (with the help of some customizations in Subversion's language bindings layer) takes care of mapping those custom datatypes into the native datatypes of the target language. This provides a more intuitive interface for users of that language."
msgstr "同样的C程序为表示路径和条目的hash需要处理自定义的数据类型（例如APR提供的库），但是Python有hash（叫做<quote>dictionaries</quote>），并且是内置数据类型，而且还提供了一系列操作这些类型的函数，所以SWIG（通过Subversion的语言绑定层的自定义帮助）要小心的将这些自定义数据类型映射到目标语言的数据类型，这为目标语言的用户提供了一个更加直观的接口。"

#: build/en/book.xml:17499(para)
#, fuzzy
msgid "The Subversion Python bindings can be used for working copy operations, too. In the previous section of this chapter, we mentioned the <filename moreinfo=\"none\">libsvn_client</filename> interface, and how it exists for the sole purpose of simplifying the process of writing a Subversion client. <xref linkend=\"svn.developer.usingapi.otherlangs.ex-2\"/> is a brief example of how that library can be accessed via the SWIG Python bindings to recreate a scaled-down version of the <command moreinfo=\"none\">svn status</command> command."
msgstr "Subversion的Python绑定也可以用来进行工作拷贝的操作，在本章前面的小节中，我们提到过<filename moreinfo=\"none\">libsvn_client</filename>接口，它存在的目的就是简化编写Subversion客户端的难度，下面是一个例子，讲的是如何使用SWIG绑定创建一个扩展的<command moreinfo=\"none\">svn status</command>命令。"

#: build/en/book.xml:17509(title)
msgid "A Python Status Crawler"
msgstr "A Python Status Crawler"

#: build/en/book.xml:17511(programlisting)
#, no-wrap
msgid ""
"\n"
"#!/usr/bin/env python\n"
"\n"
"\"\"\"Crawl a working copy directory, printing status information.\"\"\"\n"
"\n"
"import sys\n"
"import os.path\n"
"import getopt\n"
"import svn.core, svn.client, svn.wc\n"
"\n"
"def generate_status_code(status):\n"
"    \"\"\"Translate a status value into a single-character status code,\n"
"    using the same logic as the Subversion command-line client.\"\"\"\n"
"    code_map = { svn.wc.svn_wc_status_none        : ' ',\n"
"                 svn.wc.svn_wc_status_normal      : ' ',\n"
"                 svn.wc.svn_wc_status_added       : 'A',\n"
"                 svn.wc.svn_wc_status_missing     : '!',\n"
"                 svn.wc.svn_wc_status_incomplete  : '!',\n"
"                 svn.wc.svn_wc_status_deleted     : 'D',\n"
"                 svn.wc.svn_wc_status_replaced    : 'R',\n"
"                 svn.wc.svn_wc_status_modified    : 'M',\n"
"                 svn.wc.svn_wc_status_merged      : 'G',\n"
"                 svn.wc.svn_wc_status_conflicted  : 'C',\n"
"                 svn.wc.svn_wc_status_obstructed  : '~',\n"
"                 svn.wc.svn_wc_status_ignored     : 'I',\n"
"                 svn.wc.svn_wc_status_external    : 'X',\n"
"                 svn.wc.svn_wc_status_unversioned : '?',\n"
"               }\n"
"    return code_map.get(status, '?')\n"
"\n"
"def do_status(wc_path, verbose):\n"
"    # Calculate the length of the input working copy path.\n"
"    wc_path_len = len(wc_path)\n"
"\n"
"    # Build a client context baton.\n"
"    ctx = svn.client.svn_client_ctx_t()\n"
"\n"
"    def _status_callback(path, status, root_path_len=wc_path_len):\n"
"        \"\"\"A callback function for svn_client_status.\"\"\"\n"
"\n"
"        # Print the path, minus the bit that overlaps with the root of\n"
"        # the status crawl\n"
"        text_status = generate_status_code(status.text_status)\n"
"        prop_status = generate_status_code(status.prop_status)\n"
"        print '%s%s  %s' % (text_status, prop_status, path[wc_path_len + 1:])\n"
"        \n"
"    # Do the status crawl, using _status_callback() as our callback function.\n"
"    svn.client.svn_client_status(wc_path, None, _status_callback,\n"
"                                 1, verbose, 0, 0, ctx)\n"
"\n"
"def usage_and_exit(errorcode):\n"
"    \"\"\"Print usage message, and exit with ERRORCODE.\"\"\"\n"
"    stream = errorcode and sys.stderr or sys.stdout\n"
"    stream.write(\"\"\"Usage: %s OPTIONS WC-PATH\n"
"Options:\n"
"  --help, -h    : Show this usage message\n"
"  --verbose, -v : Show all statuses, even uninteresting ones\n"
"\"\"\" % (os.path.basename(sys.argv[0])))\n"
"    sys.exit(errorcode)\n"
"    \n"
"if __name__ == '__main__':\n"
"    # Parse command-line options.\n"
"    try:\n"
"        opts, args = getopt.getopt(sys.argv[1:], \"hv\", [\"help\", \"verbose\"])\n"
"    except getopt.GetoptError:\n"
"        usage_and_exit(1)\n"
"    verbose = 0\n"
"    for opt, arg in opts:\n"
"        if opt in (\"-h\", \"--help\"):\n"
"            usage_and_exit(0)\n"
"        if opt in (\"-v\", \"--verbose\"):\n"
"            verbose = 1\n"
"    if len(args) != 1:\n"
"        usage_and_exit(2)\n"
"            \n"
"    # Canonicalize the repository path.\n"
"    wc_path = svn.core.svn_path_canonicalize(args[0])\n"
"\n"
"    # Do the real work.\n"
"    try:\n"
"        do_status(wc_path, verbose)\n"
"    except svn.core.SubversionException, e:\n"
"        sys.stderr.write(\"Error (%d): %s\\n\" % (e[1], e[0]))\n"
"        sys.exit(1)\n"
msgstr ""
"\n"
"#!/usr/bin/env python\n"
"\n"
"\"\"\"Crawl a working copy directory, printing status information.\"\"\"\n"
"\n"
"import sys\n"
"import os.path\n"
"import getopt\n"
"import svn.core, svn.client, svn.wc\n"
"\n"
"def generate_status_code(status):\n"
"    \"\"\"Translate a status value into a single-character status code,\n"
"    using the same logic as the Subversion command-line client.\"\"\"\n"
"    code_map = { svn.wc.svn_wc_status_none        : ' ',\n"
"                 svn.wc.svn_wc_status_normal      : ' ',\n"
"                 svn.wc.svn_wc_status_added       : 'A',\n"
"                 svn.wc.svn_wc_status_missing     : '!',\n"
"                 svn.wc.svn_wc_status_incomplete  : '!',\n"
"                 svn.wc.svn_wc_status_deleted     : 'D',\n"
"                 svn.wc.svn_wc_status_replaced    : 'R',\n"
"                 svn.wc.svn_wc_status_modified    : 'M',\n"
"                 svn.wc.svn_wc_status_merged      : 'G',\n"
"                 svn.wc.svn_wc_status_conflicted  : 'C',\n"
"                 svn.wc.svn_wc_status_obstructed  : '~',\n"
"                 svn.wc.svn_wc_status_ignored     : 'I',\n"
"                 svn.wc.svn_wc_status_external    : 'X',\n"
"                 svn.wc.svn_wc_status_unversioned : '?',\n"
"               }\n"
"    return code_map.get(status, '?')\n"
"\n"
"def do_status(wc_path, verbose):\n"
"    # Calculate the length of the input working copy path.\n"
"    wc_path_len = len(wc_path)\n"
"\n"
"    # Build a client context baton.\n"
"    ctx = svn.client.svn_client_ctx_t()\n"
"\n"
"    def _status_callback(path, status, root_path_len=wc_path_len):\n"
"        \"\"\"A callback function for svn_client_status.\"\"\"\n"
"\n"
"        # Print the path, minus the bit that overlaps with the root of\n"
"        # the status crawl\n"
"        text_status = generate_status_code(status.text_status)\n"
"        prop_status = generate_status_code(status.prop_status)\n"
"        print '%s%s  %s' % (text_status, prop_status, path[wc_path_len + 1:])\n"
"        \n"
"    # Do the status crawl, using _status_callback() as our callback function.\n"
"    svn.client.svn_client_status(wc_path, None, _status_callback,\n"
"                                 1, verbose, 0, 0, ctx)\n"
"\n"
"def usage_and_exit(errorcode):\n"
"    \"\"\"Print usage message, and exit with ERRORCODE.\"\"\"\n"
"    stream = errorcode and sys.stderr or sys.stdout\n"
"    stream.write(\"\"\"Usage: %s OPTIONS WC-PATH\n"
"Options:\n"
"  --help, -h    : Show this usage message\n"
"  --verbose, -v : Show all statuses, even uninteresting ones\n"
"\"\"\" % (os.path.basename(sys.argv[0])))\n"
"    sys.exit(errorcode)\n"
"    \n"
"if __name__ == '__main__':\n"
"    # Parse command-line options.\n"
"    try:\n"
"        opts, args = getopt.getopt(sys.argv[1:], \"hv\", [\"help\", \"verbose\"])\n"
"    except getopt.GetoptError:\n"
"        usage_and_exit(1)\n"
"    verbose = 0\n"
"    for opt, arg in opts:\n"
"        if opt in (\"-h\", \"--help\"):\n"
"            usage_and_exit(0)\n"
"        if opt in (\"-v\", \"--verbose\"):\n"
"            verbose = 1\n"
"    if len(args) != 1:\n"
"        usage_and_exit(2)\n"
"            \n"
"    # Canonicalize the repository path.\n"
"    wc_path = svn.core.svn_path_canonicalize(args[0])\n"
"\n"
"    # Do the real work.\n"
"    try:\n"
"        do_status(wc_path, verbose)\n"
"    except svn.core.SubversionException, e:\n"
"        sys.stderr.write(\"Error (%d): %s\\n\" % (e[1], e[0]))\n"
"        sys.exit(1)\n"

#: build/en/book.xml:17598(para)
msgid "As was the case in <xref linkend=\"svn.developer.usingapi.otherlangs.ex-1\"/>, this program is pool-free and uses, for the most part, normal Python data types. The call to <function moreinfo=\"none\">svn_client_ctx_t()</function> is deceiving because the public Subversion API has no such function—this just happens to be a case where SWIG's automatic language generation bleeds through a little bit (the function is a sort of factory function for Python's version of the corresponding complex C structure). Also note that the path passed to this program (like the last one) gets run through <function moreinfo=\"none\">svn_path_canonicalize()</function>, because to <emphasis>not</emphasis> do so runs the risk of triggering the underlying Subversion C library's assertions about such things, which translate into rather immediate and unceremonious program abortion."
msgstr ""

#: build/en/book.xml:17626(title)
msgid "Subversion Complete Reference"
msgstr "Subversion 完全参考"

#: build/en/book.xml:17628(para)
msgid "This chapter is intended to be a complete reference to using Subversion. This includes the command line client (<command moreinfo=\"none\">svn</command>) and all its subcommands, as well as the repository administration programs (<command moreinfo=\"none\">svnadmin</command> and <command moreinfo=\"none\">svnlook</command>) and their respective subcommands."
msgstr "本章是使用Subversion的一个完全手册，包括了命令行客户端（<command moreinfo=\"none\">svn</command>）和它的所有子命令，也有版本库管理程序（<command moreinfo=\"none\">svnadmin</command>和<command moreinfo=\"none\">svnlook</command>）和它们各自的子命令。"

#: build/en/book.xml:17640(title)
msgid "The Subversion Command Line Client: <command moreinfo=\"none\">svn</command>"
msgstr "Subversion 命令行客户端：<command moreinfo=\"none\">svn</command>"

#: build/en/book.xml:17644(para)
msgid "Yes, yes, you don't need a subcommand to use the <option>--version</option> switch, but we'll get to that in just a minute."
msgstr "是的，使用<option>--version</option>选项不需要子命令，几分钟后我们会到达那个部分。"

#: build/en/book.xml:17642(para)
msgid "To use the command line client, you type <command moreinfo=\"none\">svn</command>, the subcommand you wish to use <placeholder-1/>, and any switches or targets that you wish to operate on—there is no specific order that the subcommand and the switches must appear in. For example, all of the following are valid ways to use <command moreinfo=\"none\">svn status</command>:"
msgstr "为了使用命令行客户端，只需要输入<command moreinfo=\"none\">svn</command>和它的子命令<footnote><placeholder-1/></footnote>以及相关的选项或操作的对象—输入的子命令和选项没有特定的顺序，下面使用<command moreinfo=\"none\">svn status</command>的方式都是合法的："

#: build/en/book.xml:17652(screen)
#, no-wrap
msgid ""
"\n"
"$ svn -v status\n"
"$ svn status -v \n"
"$ svn status -v myfile\n"
msgstr ""
"\n"
"$ svn -v status\n"
"$ svn status -v \n"
"$ svn status -v myfile\n"

#: build/en/book.xml:17658(para)
msgid "You can find many more examples of how to use most client commands in <xref linkend=\"svn.tour\"/> and commands for managing properties in <xref linkend=\"svn.advanced.props\"/>."
msgstr "你可以在<xref linkend=\"svn.tour\"/>发现更多使用客户端命令的例子，以及<xref linkend=\"svn.advanced.props\"/>中的管理属性的命令。"

#: build/en/book.xml:17664(title)
msgid "<command moreinfo=\"none\">svn</command> Switches"
msgstr "<command moreinfo=\"none\">svn</command> 选项"

#: build/en/book.xml:17666(para)
msgid "While Subversion has different switches for its subcommands, all switches are global—that is, each switch is guaranteed to mean the same thing regardless of the subcommand you use it with. For example, <option>--verbose</option> (<option>-v</option>) always means <quote>verbose output</quote>, regardless of the subcommand you use it with."
msgstr "虽然Subversion的子命令有一些不同的选项，但有的选项是全局的—也就是说，每个选项保证是表示同样的事情，而不管是哪个子命令使用的。举个例子，<option>--verbose</option>（<option>-v</option>）一直意味着<quote>冗长输出</quote>，而不管使用它的命令是什么。"

#: build/en/book.xml:17677(option)
msgid "--auto-props"
msgstr "--auto-props"

#: build/en/book.xml:17679(para)
msgid "Enables auto-props, overriding the <literal moreinfo=\"none\">enable-auto-props</literal> directive in the <filename moreinfo=\"none\">config</filename> file."
msgstr "开启auto-props，覆盖<filename moreinfo=\"none\">config</filename>文件中的<literal moreinfo=\"none\">enable-auto-props</literal>指示。"

#: build/en/book.xml:17686(option)
msgid "--config-dir"
msgstr "--config-dir"

#: build/en/book.xml:17687(replaceable) build/en/book.xml:22054(replaceable)
msgid "DIR"
msgstr "DIR"

#: build/en/book.xml:17689(para)
msgid "Instructs Subversion to read configuration information from the specified directory instead of the default location (<filename moreinfo=\"none\">.subversion</filename> in the user's home directory)."
msgstr "指导Subversion从指定目录而不是默认位置（用户主目录的<filename moreinfo=\"none\">.subversion</filename>）读取配置信息。"

#: build/en/book.xml:17697(option)
msgid "--diff-cmd"
msgstr "--diff-cmd"

#: build/en/book.xml:17698(replaceable) build/en/book.xml:17713(replaceable)
#: build/en/book.xml:17730(replaceable)
msgid "CMD"
msgstr "CMD"

#: build/en/book.xml:17700(para)
msgid "Specifies an external program to use to show differences between files. When <command moreinfo=\"none\">svn diff</command> is invoked, it uses Subversion's internal diff engine, which provides unified diffs by default. If you want to use an external diff program, use <option>--diff-cmd</option>. You can pass switches to the diff program with the <option>--extensions</option> switch (more on that later in this section)."
msgstr "指定用来表示文件区别的外部程序，当<command moreinfo=\"none\">svn diff</command>调用时，会使用Subversion的内置区别引擎，默认会提供统一区别输出，如果你希望使用一个外置区别程序，使用<option>--diff-cmd</option>。你可以通过<option>--extensions</option>（本小节后面有更多介绍）把选项传递到区别程序。"

#: build/en/book.xml:17712(option)
msgid "--diff3-cmd"
msgstr "--diff3-cmd"

#: build/en/book.xml:17715(para)
msgid "Specifies an external program to use to merge files."
msgstr "指定一个外置程序用来合并文件。"

#: build/en/book.xml:17720(option)
msgid "--dry-run"
msgstr "--dry-run"

#: build/en/book.xml:17722(para)
msgid "Goes through all the motions of running a command, but makes no actual changes—either on disk or in the repository."
msgstr "检验运行一个命令的效果，但没有实际的修改—可以用在磁盘和版本库。"

#: build/en/book.xml:17729(option)
msgid "--editor-cmd"
msgstr "--editor-cmd"

#: build/en/book.xml:17732(para)
msgid "Specifies an external program to use to edit a log message or a property value. See the <literal moreinfo=\"none\">editor-cmd</literal> section in <xref linkend=\"svn.advanced.confarea.opts.config\"/> for ways to specify a default editor."
msgstr "指定一个外部程序来编辑日志信息或是属性值。如何设定缺省编辑器见<xref linkend=\"svn.advanced.confarea.opts.config\"/>的<literal moreinfo=\"none\">editor-cmd</literal>小节。"

#: build/en/book.xml:17740(option)
msgid "--encoding"
msgstr "--encoding"

#: build/en/book.xml:17740(replaceable)
msgid "ENC"
msgstr "ENC"

#: build/en/book.xml:17742(para)
msgid "Tells Subversion that your commit message is encoded in the charset provided. The default is your operating system's native locale, and you should specify the encoding if your commit message is in any other encoding."
msgstr "告诉Subversion你的提交日志信息是通过提供的字符集编码的，缺省时是你的操作系统的本地编码，如果你的提交信息使用其它编码，你一定要指定这个值。"

#: build/en/book.xml:17751(term)
msgid "<option>--extensions</option> (<option>-x</option>) <replaceable>ARGS</replaceable>"
msgstr "<option>--extensions</option> (<option>-x</option>) <replaceable>ARGS</replaceable>"

#: build/en/book.xml:17754(para)
msgid "Specifies an argument or arguments that Subversion should pass to an external diff command when providing differences between files. If you wish to pass multiple arguments, you must enclose all of them in quotes (for example, <command moreinfo=\"none\">svn diff --diff-cmd /usr/bin/diff -x \"-b -E\"</command>). This switch can <emphasis>only</emphasis> be used if you also pass the <option>--diff-cmd</option> switch."
msgstr "指定一个或多个Subversion传递给提供文件区别的外部区别程序的参数，如果你要传递多个参数，你一定能够要用引号（例如，<command moreinfo=\"none\">svn diff --diff-cmd /usr/bin/diff -x \"-b -E\"</command>）括起所有的参数。这个选项<emphasis>只有</emphasis>在使用<option>--diff-cmd</option>选项时使用。"

#: build/en/book.xml:17766(term)
msgid "<option>--file</option> (<option>-F</option>) <replaceable>FILENAME</replaceable>"
msgstr "<option>--file</option> (<option>-F</option>) <replaceable>FILENAME</replaceable>"

#: build/en/book.xml:17770(para)
msgid "Uses the contents of the file passed as an argument to this switch for the specified subcommand."
msgstr "使用传递的文件内容作为特定子命令的选项。"

#: build/en/book.xml:17776(option)
msgid "--force"
msgstr "--force"

#: build/en/book.xml:17778(para)
msgid "Forces a particular command or operation to run. There are some operations that Subversion will prevent you from doing in normal usage, but you can pass the force switch to tell Subversion <quote>I know what I'm doing as well as the possible repercussions of doing it, so let me at 'em</quote>. This switch is the programmatic equivalent of doing your own electrical work with the power on—if you don't know what you're doing, you're likely to get a nasty shock."
msgstr "强制一个特定的命令或操作运行。Subversion有一些操作防止你做普通的使用，但是你可以传递force选项告诉Subversion<quote>我知道我做的事情，也知道这样的结果，所以让我做吧</quote>。这个选项在程序上等同于在打开电源的情况下做你自己的电子工作—如果你不知道你在做什么，你很有可能会得到一个威胁的警告。"

#: build/en/book.xml:17791(option)
msgid "--force-log"
msgstr "--force-log"

#: build/en/book.xml:17793(para)
msgid "Forces a suspicious parameter passed to the <option>--message</option> (<option>-m</option>) or <option>--file</option> (<option>-F</option>) options to be accepted as valid. By default, Subversion will produce an error if parameters to these options look like they might instead be targets of the subcommand. For example, if you pass a versioned file's path to the <option>--file</option> (<option>-F</option>) option, Subversion will assume you've made a mistake, that the path was instead intended as the target of the operation, and that you simply failed to provide some other—unversioned—file as the source of your log message. To assert your intent and override these types of errors, pass the <option>--force-log</option> option to subcommands that accept log messages."
msgstr "将传递给<option>--message</option>（<option>-m</option>）或者<option>--file</option>（<option>-F</option>）的可疑参数指定为有效可接受。缺省情况下，如果选项的参数看起来会成为子命令的目标，Subversion会提出一个错误，例如，你传递一个版本化的文件路径给<option>--file</option>（<option>-F</option>）选项，Subversion会认为出了点错误，认为你将目标对象当成了参数，而你并没有提供其它的—未版本化的文件作为日志信息的文件。为了确认你的意图并且不考虑这类错误，传递<option>--force-log</option>选项给命令来接受它作为日志信息。"

#: build/en/book.xml:17812(term)
msgid "<option>--help</option> (<option>-h</option> or <option>-?</option>)"
msgstr "<option>--help</option> (<option>-h</option>或<option>-?</option>)"

#: build/en/book.xml:17816(para)
msgid "If used with one or more subcommands, shows the built-in help text for each subcommand. If used alone, it displays the general client help text."
msgstr "如果同一个或多个子命令一起使用，会显示每个子命令内置的帮助文本，如果单独使用，它会显示常规的客户端帮助文本。"

#: build/en/book.xml:17823(option)
msgid "--ignore-ancestry"
msgstr "--ignore-ancestry"

#: build/en/book.xml:17825(para)
msgid "Tells Subversion to ignore ancestry when calculating differences (rely on path contents alone)."
msgstr "告诉Subversion在计算区别（只依赖于路径内容）时忽略祖先。"

#: build/en/book.xml:17831(option)
msgid "--ignore-externals"
msgstr "--ignore-externals"

#: build/en/book.xml:17833(para)
msgid "Tells Subversion to ignore external definitions and the external working copies managed by them."
msgstr "告诉Subversion忽略外部定义和外部定义管理的工作拷贝。"

#: build/en/book.xml:17839(option) build/en/book.xml:22044(option)
msgid "--incremental"
msgstr "--incremental"

#: build/en/book.xml:17841(para)
msgid "Prints output in a format suitable for concatenation."
msgstr "打印适合串联的输出格式。"

#: build/en/book.xml:17847(option)
msgid "--limit"
msgstr "--limit"

#: build/en/book.xml:17848(replaceable)
msgid "NUM"
msgstr "NUM"

#: build/en/book.xml:17850(para)
msgid "Show only the first <replaceable>NUM</replaceable> log messages."
msgstr "只显示第一个<replaceable>NUM</replaceable>日志信息。"

#: build/en/book.xml:17856(term)
msgid "<option>--message</option> (<option>-m</option>) <replaceable>MESSAGE</replaceable>"
msgstr "<option>--message</option> (<option>-m</option>) <replaceable>MESSAGE</replaceable>"

#: build/en/book.xml:17860(para)
msgid "Indicates that you will specify a commit message on the command line, following this switch. For example:"
msgstr "表示你会在命令行中指定日志信息，紧跟这个开关，例如："

#: build/en/book.xml:17864(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit -m \"They don't make Sunday.\"\n"
msgstr ""
"\n"
"$ svn commit -m \"They don't make Sunday.\"\n"

#: build/en/book.xml:17871(option)
msgid "--new"
msgstr "--new"

#: build/en/book.xml:17871(replaceable) build/en/book.xml:17971(replaceable)
msgid "ARG"
msgstr "ARG"

#: build/en/book.xml:17873(para)
msgid "Uses <replaceable>ARG</replaceable> as the newer target."
msgstr "使用<replaceable>ARG</replaceable>作为新的目标。"

#: build/en/book.xml:17879(option)
msgid "--no-auth-cache"
msgstr "--no-auth-cache"

#: build/en/book.xml:17881(para)
msgid "Prevents caching of authentication information (e.g. username and password) in the Subversion administrative directories."
msgstr "阻止在Subversion管理区缓存认证信息（如用户名密码）。"

#: build/en/book.xml:17888(option)
msgid "--no-auto-props"
msgstr "--no-auto-props"

#: build/en/book.xml:17890(para)
msgid "Disables auto-props, overriding the <literal moreinfo=\"none\">enable-auto-props</literal> directive in the <filename moreinfo=\"none\">config</filename> file."
msgstr "关闭auto-props，覆盖<filename moreinfo=\"none\">config</filename>文件中的<literal moreinfo=\"none\">enable-auto-props</literal>指示。"

#: build/en/book.xml:17897(option)
msgid "--no-diff-added"
msgstr "--no-diff-added"

#: build/en/book.xml:17899(para)
msgid "Prevents Subversion from printing differences for added files. The default behavior when you add a file is for <command moreinfo=\"none\">svn diff</command> to print the same differences that you would see if you had added the entire contents of an existing (empty) file."
msgstr "防止Subversion打印添加文件的区别。缺省的行为方式是，当添加一个文件时，<command moreinfo=\"none\">svn diff</command>打印的信息和比较一个空白文件相同。"

#: build/en/book.xml:17908(option) build/en/book.xml:22946(option)
msgid "--no-diff-deleted"
msgstr "--no-diff-deleted"

#: build/en/book.xml:17910(para)
msgid "Prevents Subversion from printing differences for deleted files. The default behavior when you remove a file is for <command moreinfo=\"none\">svn diff</command> to print the same differences that you would see if you had left the file but removed all the content."
msgstr "防止Subversion打印删除文件的区别信息，缺省的行为方式是当你删除了一个文件后运行<command moreinfo=\"none\">svn diff</command>打印的区别与删除文件所有的内容得到的结果一样。"

#: build/en/book.xml:17919(option)
msgid "--no-ignore"
msgstr "--no-ignore"

#: build/en/book.xml:17921(para)
msgid "Shows files in the status listing that would normally be omitted since they match a pattern in the <literal moreinfo=\"none\">global-ignores</literal> configuration option or the <literal moreinfo=\"none\">svn:ignore</literal> property. See <xref linkend=\"svn.advanced.confarea.opts.config\"/> and <xref linkend=\"svn.advanced.props.special.ignore\"/> for more information."
msgstr "在状态列表中显示<literal moreinfo=\"none\">global-ignores</literal>配置选项或者是<literal moreinfo=\"none\">svn:ignore</literal>属性忽略的文件。见<xref linkend=\"svn.advanced.confarea.opts.config\"/>和<xref linkend=\"svn.advanced.props.special.ignore\"/>查看详情。"

#: build/en/book.xml:17930(option)
msgid "--no-unlock"
msgstr "--no-unlock"

#: build/en/book.xml:17932(para)
msgid "Don't automatically unlock files (the default commit behavior is to unlock all files listed as part of the commit). See <xref linkend=\"svn.advanced.locking\"/> for more information."
msgstr "不自动解锁文件（缺省的提交行为是解锁提交列出的所有文件），更多信息见<xref linkend=\"svn.advanced.locking\"/>。"

#: build/en/book.xml:17940(option)
msgid "--non-interactive"
msgstr "--non-interactive"

#: build/en/book.xml:17942(para)
msgid "In the case of an authentication failure, or insufficient credentials, prevents prompting for credentials (e.g. username or password). This is useful if you're running Subversion inside of an automated script and it's more appropriate to have Subversion fail than to prompt for more information."
msgstr "如果认证失败，或者是不充分的凭证时，防止出现要求凭证的提示（例如用户名和密码）。这在运行自动脚本时非常有用，只是让Subversion失败而不是提示更多的信息。"

#: build/en/book.xml:17952(term)
msgid "<option>--non-recursive</option> (<option>-N</option>)"
msgstr "<option>--non-recursive</option> (<option>-N</option>)"

#: build/en/book.xml:17954(para)
msgid "Stops a subcommand from recursing into subdirectories. Most subcommands recurse by default, but some subcommands—usually those that have the potential to remove or undo your local modifications—do not."
msgstr "防止子命令迭代到子目录，大多数子命令缺省是迭代的，但是一些子命令—通常是那些潜在的删除或者是取消本地修改的命令—不是。"

#: build/en/book.xml:17963(option)
msgid "--notice-ancestry"
msgstr "--notice-ancestry"

#: build/en/book.xml:17965(para)
msgid "Pay attention to ancestry when calculating differences."
msgstr "在计算区别时关注祖先。"

#: build/en/book.xml:17971(option)
msgid "--old"
msgstr "--old"

#: build/en/book.xml:17973(para)
msgid "Uses <replaceable>ARG</replaceable> as the older target."
msgstr "使用<replaceable>ARG</replaceable>作为旧的目标。"

#: build/en/book.xml:17979(option)
msgid "--password"
msgstr "--password"

#: build/en/book.xml:17980(replaceable)
msgid "PASS"
msgstr "PASS"

#: build/en/book.xml:17982(para)
msgid "Indicates that you are providing your password for authentication on the command line—otherwise, if it is needed, Subversion will prompt you for it."
msgstr "指出在命令行中提供你的密码—另外，如果它是需要的，Subversion会提示你输入。"

#: build/en/book.xml:17990(term)
msgid "<option>--quiet</option> (<option>-q</option>)"
msgstr "<option>--quiet</option> (<option>-q</option>)"

#: build/en/book.xml:17992(para)
msgid "Requests that the client print only essential information while performing an operation."
msgstr "请求客户端在执行操作时只显示重要信息。"

#: build/en/book.xml:17998(term)
msgid "<option>--recursive</option> (<option>-R</option>)"
msgstr "<option>--recursive</option> (<option>-R</option>)"

#: build/en/book.xml:18000(para)
msgid "Makes a subcommand recurse into subdirectories. Most subcommands recurse by default."
msgstr "让子命令迭代到子目录，大多数子命令缺省是迭代的。"

#: build/en/book.xml:18006(option)
msgid "--relocate"
msgstr "--relocate"

#: build/en/book.xml:18006(replaceable)
msgid "FROM TO [PATH...]"
msgstr "目的路径[PATH...]"

#: build/en/book.xml:18009(para)
msgid "Used with the <command moreinfo=\"none\">svn switch</command> subcommand, changes the location of the repository that your working copy references. This is useful if the location of your repository changes and you have an existing working copy that you'd like to continue to use. See <command moreinfo=\"none\">svn switch</command> for an example."
msgstr "<command moreinfo=\"none\">svn switch</command>子命令中使用，用来修改你的工作拷贝所引用的版本库位置。当版本库的位置修改了，而你有一个工作拷贝，希望继续使用时非常有用。见<command moreinfo=\"none\">svn switch</command>的例子。"

#: build/en/book.xml:18020(term)
msgid "<option>--revision</option> (<option>-r</option>) <replaceable>REV</replaceable>"
msgstr "<option>--revision</option> (<option>-r</option>) <replaceable>REV</replaceable>"

#: build/en/book.xml:18024(para)
msgid "Indicates that you're going to supply a revision (or range of revisions) for a particular operation. You can provide revision numbers, revision keywords or dates (in curly braces), as arguments to the revision switch. If you wish to provide a range of revisions, you can provide two revisions separated by a colon. For example:"
msgstr "指出你将为特定操作提供一个修订版本（或修订版本的范围），你可以提供修订版本号，修订版本关键字或日期（在华括号中）作为修订版本开关的参数。如果你希望提供一个修订版本范围，你可以提供用冒号隔开的两个修订版本，举个例子："

#: build/en/book.xml:18032(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log -r 1729\n"
"$ svn log -r 1729:HEAD\n"
"$ svn log -r 1729:1744\n"
"$ svn log -r {2001-12-04}:{2002-02-17}\n"
"$ svn log -r 1729:{2002-02-17}\n"
msgstr ""
"\n"
"$ svn log -r 1729\n"
"$ svn log -r 1729:HEAD\n"
"$ svn log -r 1729:1744\n"
"$ svn log -r {2001-12-04}:{2002-02-17}\n"
"$ svn log -r 1729:{2002-02-17}\n"

#: build/en/book.xml:18040(para)
msgid "See <xref linkend=\"svn.tour.revs.keywords\"/> for more information."
msgstr "见<xref linkend=\"svn.tour.revs.keywords\"/>查看更多信息。"

#: build/en/book.xml:18046(option) build/en/book.xml:22966(option)
msgid "--revprop"
msgstr "--revprop"

#: build/en/book.xml:18048(para) build/en/book.xml:22968(para)
#, fuzzy
msgid "Operates on a revision property instead of a property specific to a file or directory. This switch requires that you also pass a revision with the <option>--revision</option> (<option>-r</option>) switch."
msgstr "操作针对修订版本属性，而不是Subversion文件或目录的属性。这个选项需要你传递<option>--revision</option> (<option>-r</option>)选项，更多关于未版本化属性的细节见<xref linkend=\"svn.reposadmin.basics.revprops\"/>"

#: build/en/book.xml:18057(term)
msgid "<option>--show-updates</option> (<option>-u</option>)"
msgstr "<option>--show-updates</option> (<option>-u</option>)"

#: build/en/book.xml:18059(para)
msgid "Causes the client to display information about which files in your working copy are out-of-date. This doesn't actually update any of your files—it just shows you which files will be updated if you run <command moreinfo=\"none\">svn update</command>."
msgstr "导致客户端显示本地拷贝哪些文件已经过期，这不会实际更新你的任何文件—只是显示了如果你运行<command moreinfo=\"none\">svn update</command>时更新的文件。"

#: build/en/book.xml:18069(option)
msgid "--stop-on-copy"
msgstr "--stop-on-copy"

#: build/en/book.xml:18071(para)
msgid "Causes a Subversion subcommand which is traversing the history of a versioned resource to stop harvesting that historical information when a copy—that is, a location in history where that resource was copied from another location in the repository—is encountered."
msgstr "导致Subversion子命令在传递历史时会在版本化资源拷贝时停止收集历史信息—也就是历史中资源从另一个位置拷贝过来时。"

#: build/en/book.xml:18081(option)
msgid "--strict"
msgstr "--strict"

#: build/en/book.xml:18083(para)
msgid "Causes Subversion to use strict semantics, a notion which is rather vague unless talking about specific subcommands."
msgstr "导致Subversion使用严格的语法，也就是选择含糊，除非谈论特定的子命令。"

#: build/en/book.xml:18090(option)
msgid "--targets"
msgstr "--targets"

#: build/en/book.xml:18091(replaceable)
msgid "FILENAME"
msgstr "FILENAME"

#: build/en/book.xml:18093(para)
msgid "Tells Subversion to get the list of files that you wish to operate on from the filename you provide instead of listing all the files on the command line."
msgstr "告诉Subversion从你提供的文件中得到希望操作的文件列表，而不是在命令行列出所有的文件。"

#: build/en/book.xml:18101(option)
msgid "--username"
msgstr "--username"

#: build/en/book.xml:18102(replaceable)
msgid "NAME"
msgstr "NAME"

#: build/en/book.xml:18104(para)
msgid "Indicates that you are providing your username for authentication on the command line—otherwise, if it is needed, Subversion will prompt you for it."
msgstr "表示你要在命令行提供认证的用户名—否则如果需要，Subversion会提示你这一点。"

#: build/en/book.xml:18112(term)
msgid "<option>--verbose</option> (<option>-v</option>)"
msgstr "<option>--verbose</option> (<option>-v</option>)"

#: build/en/book.xml:18114(para)
msgid "Requests that the client print out as much information as it can while running any subcommand. This may result in Subversion printing out additional fields, detailed information about every file, or additional information regarding its actions."
msgstr "请求客户端在运行子命令打印尽量多的信息，会导致Subversion打印额外的字段，每个文件的细节信息或者是关于动作的附加信息。"

#: build/en/book.xml:18123(option) build/en/book.xml:23953(option)
#: build/en/book.xml:24102(option)
msgid "--version"
msgstr "--version"

#: build/en/book.xml:18125(para)
msgid "Prints the client version info. This information not only includes the version number of the client, but also a listing of all repository access modules that the client can use to access a Subversion repository. With <option>--quiet</option> (<option>-q</option>) it prints only the version number in a compact form."
msgstr "打印客户端版本信息，这个信息不仅仅包括客户端的版本号，也有所有客户端可以用来访问Subversion版本库的版本库访问模块列表。"

#: build/en/book.xml:18136(option)
msgid "--xml"
msgstr "--xml"

#: build/en/book.xml:18138(para)
msgid "Prints output in XML format."
msgstr "使用XML格式打印输出。"

#: build/en/book.xml:18148(title)
msgid "<command moreinfo=\"none\">svn</command> Subcommands"
msgstr "<command moreinfo=\"none\">svn</command> 子命令"

#: build/en/book.xml:18154(secondary) build/en/book.xml:18260(secondary)
#: build/en/book.xml:18330(secondary) build/en/book.xml:18415(secondary)
#: build/en/book.xml:18552(secondary) build/en/book.xml:18630(secondary)
#: build/en/book.xml:18768(secondary) build/en/book.xml:18943(secondary)
#: build/en/book.xml:19056(secondary) build/en/book.xml:19308(secondary)
#: build/en/book.xml:19422(secondary) build/en/book.xml:19474(secondary)
#: build/en/book.xml:19576(secondary) build/en/book.xml:19737(secondary)
#: build/en/book.xml:19849(secondary) build/en/book.xml:19949(secondary)
#: build/en/book.xml:20193(secondary) build/en/book.xml:20314(secondary)
#: build/en/book.xml:20400(secondary) build/en/book.xml:20514(secondary)
#: build/en/book.xml:20592(secondary) build/en/book.xml:20668(secondary)
#: build/en/book.xml:20750(secondary) build/en/book.xml:20837(secondary)
#: build/en/book.xml:20972(secondary) build/en/book.xml:21061(secondary)
#: build/en/book.xml:21165(secondary) build/en/book.xml:21570(secondary)
#: build/en/book.xml:21730(secondary) build/en/book.xml:21823(secondary)
#: build/en/book.xml:22109(secondary) build/en/book.xml:22172(secondary)
#: build/en/book.xml:22212(secondary) build/en/book.xml:22322(secondary)
#: build/en/book.xml:22354(secondary) build/en/book.xml:22396(secondary)
#: build/en/book.xml:22428(secondary) build/en/book.xml:22476(secondary)
#: build/en/book.xml:22542(secondary) build/en/book.xml:22590(secondary)
#: build/en/book.xml:22630(secondary) build/en/book.xml:22712(secondary)
#: build/en/book.xml:22758(secondary) build/en/book.xml:22812(secondary)
#: build/en/book.xml:22872(secondary) build/en/book.xml:23005(secondary)
#: build/en/book.xml:23051(secondary) build/en/book.xml:23109(secondary)
#: build/en/book.xml:23208(secondary) build/en/book.xml:23254(secondary)
#: build/en/book.xml:23325(secondary) build/en/book.xml:23372(secondary)
#: build/en/book.xml:23403(secondary) build/en/book.xml:23468(secondary)
#: build/en/book.xml:23519(secondary) build/en/book.xml:23571(secondary)
#: build/en/book.xml:23616(secondary) build/en/book.xml:23671(secondary)
#: build/en/book.xml:23737(secondary) build/en/book.xml:23791(secondary)
#: build/en/book.xml:23830(secondary)
msgid "subcommands"
msgstr "子命令"

#: build/en/book.xml:18155(tertiary)
msgid "add"
msgstr "add"

#: build/en/book.xml:18160(refpurpose)
msgid "Add files, directories, or symbolic links."
msgstr "添加文件、目录或符号链。"

#: build/en/book.xml:18164(title) build/en/book.xml:18270(title)
#: build/en/book.xml:18340(title) build/en/book.xml:18424(title)
#: build/en/book.xml:18561(title) build/en/book.xml:18639(title)
#: build/en/book.xml:18779(title) build/en/book.xml:18953(title)
#: build/en/book.xml:19065(title) build/en/book.xml:19317(title)
#: build/en/book.xml:19431(title) build/en/book.xml:19484(title)
#: build/en/book.xml:19586(title) build/en/book.xml:19746(title)
#: build/en/book.xml:19860(title) build/en/book.xml:19958(title)
#: build/en/book.xml:20203(title) build/en/book.xml:20323(title)
#: build/en/book.xml:20409(title) build/en/book.xml:20523(title)
#: build/en/book.xml:20602(title) build/en/book.xml:20677(title)
#: build/en/book.xml:20759(title) build/en/book.xml:20846(title)
#: build/en/book.xml:20982(title) build/en/book.xml:21070(title)
#: build/en/book.xml:21174(title) build/en/book.xml:21579(title)
#: build/en/book.xml:21739(title) build/en/book.xml:21832(title)
#: build/en/book.xml:22118(title) build/en/book.xml:22181(title)
#: build/en/book.xml:22221(title) build/en/book.xml:22330(title)
#: build/en/book.xml:22363(title) build/en/book.xml:22407(title)
#: build/en/book.xml:22439(title) build/en/book.xml:22486(title)
#: build/en/book.xml:22551(title) build/en/book.xml:22599(title)
#: build/en/book.xml:22645(title) build/en/book.xml:22722(title)
#: build/en/book.xml:22767(title) build/en/book.xml:22821(title)
#: build/en/book.xml:22881(title) build/en/book.xml:23014(title)
#: build/en/book.xml:23060(title) build/en/book.xml:23118(title)
#: build/en/book.xml:23217(title) build/en/book.xml:23263(title)
#: build/en/book.xml:23334(title) build/en/book.xml:23380(title)
#: build/en/book.xml:23414(title) build/en/book.xml:23478(title)
#: build/en/book.xml:23529(title) build/en/book.xml:23580(title)
#: build/en/book.xml:23626(title) build/en/book.xml:23681(title)
#: build/en/book.xml:23746(title) build/en/book.xml:23801(title)
#: build/en/book.xml:23839(title) build/en/book.xml:24045(title)
msgid "Synopsis"
msgstr "概要"

#: build/en/book.xml:18165(programlisting)
#, no-wrap
msgid "svn add PATH..."
msgstr "svn add PATH..."

#: build/en/book.xml:18168(title) build/en/book.xml:18274(title)
#: build/en/book.xml:18344(title) build/en/book.xml:18428(title)
#: build/en/book.xml:18565(title) build/en/book.xml:18643(title)
#: build/en/book.xml:18784(title) build/en/book.xml:18958(title)
#: build/en/book.xml:19071(title) build/en/book.xml:19322(title)
#: build/en/book.xml:19435(title) build/en/book.xml:19488(title)
#: build/en/book.xml:19590(title) build/en/book.xml:19750(title)
#: build/en/book.xml:19864(title) build/en/book.xml:19963(title)
#: build/en/book.xml:20209(title) build/en/book.xml:20328(title)
#: build/en/book.xml:20413(title) build/en/book.xml:20528(title)
#: build/en/book.xml:20607(title) build/en/book.xml:20682(title)
#: build/en/book.xml:20764(title) build/en/book.xml:20852(title)
#: build/en/book.xml:20986(title) build/en/book.xml:21074(title)
#: build/en/book.xml:21178(title) build/en/book.xml:21587(title)
#: build/en/book.xml:21743(title) build/en/book.xml:21836(title)
#: build/en/book.xml:22122(title) build/en/book.xml:22185(title)
#: build/en/book.xml:22225(title) build/en/book.xml:22335(title)
#: build/en/book.xml:22368(title) build/en/book.xml:22411(title)
#: build/en/book.xml:22443(title) build/en/book.xml:22490(title)
#: build/en/book.xml:22555(title) build/en/book.xml:22603(title)
#: build/en/book.xml:22649(title) build/en/book.xml:22726(title)
#: build/en/book.xml:22771(title) build/en/book.xml:22825(title)
#: build/en/book.xml:22885(title) build/en/book.xml:23018(title)
#: build/en/book.xml:23064(title) build/en/book.xml:23122(title)
#: build/en/book.xml:23221(title) build/en/book.xml:23267(title)
#: build/en/book.xml:23338(title) build/en/book.xml:23384(title)
#: build/en/book.xml:23418(title) build/en/book.xml:23482(title)
#: build/en/book.xml:23533(title) build/en/book.xml:23584(title)
#: build/en/book.xml:23630(title) build/en/book.xml:23685(title)
#: build/en/book.xml:23750(title) build/en/book.xml:23805(title)
#: build/en/book.xml:23843(title) build/en/book.xml:24050(title)
#: build/en/book.xml:24197(title) build/en/book.xml:24522(title)
#: build/en/book.xml:24574(title) build/en/book.xml:24629(title)
#: build/en/book.xml:24682(title) build/en/book.xml:24753(title)
#: build/en/book.xml:24822(title) build/en/book.xml:24879(title)
#: build/en/book.xml:24933(title) build/en/book.xml:24992(title)
#: build/en/book.xml:26104(entry)
msgid "Description"
msgstr "描述"

#: build/en/book.xml:18170(para)
msgid "Add files, directories, or symbolic links to your working copy and schedule them for addition to the repository. They will be uploaded and added to the repository on your next commit. If you add something and change your mind before committing, you can unschedule the addition using <command moreinfo=\"none\">svn revert</command>."
msgstr "添加文件、目录或符号链到你的工作拷贝并且预定添加到版本库。它们会在下次提交上传并添加到版本库，如果你在提交之前改变了主意，你可以使用<command moreinfo=\"none\">svn revert</command>取消预定。"

#: build/en/book.xml:18179(title) build/en/book.xml:18283(title)
#: build/en/book.xml:18352(title) build/en/book.xml:18441(title)
#: build/en/book.xml:18585(title) build/en/book.xml:18673(title)
#: build/en/book.xml:18834(title) build/en/book.xml:18974(title)
#: build/en/book.xml:19174(title) build/en/book.xml:19342(title)
#: build/en/book.xml:19442(title) build/en/book.xml:19500(title)
#: build/en/book.xml:19631(title) build/en/book.xml:19782(title)
#: build/en/book.xml:19876(title) build/en/book.xml:19995(title)
#: build/en/book.xml:20241(title) build/en/book.xml:20342(title)
#: build/en/book.xml:20452(title) build/en/book.xml:20537(title)
#: build/en/book.xml:20616(title) build/en/book.xml:20693(title)
#: build/en/book.xml:20773(title) build/en/book.xml:20869(title)
#: build/en/book.xml:20998(title) build/en/book.xml:21087(title)
#: build/en/book.xml:21477(title) build/en/book.xml:21598(title)
#: build/en/book.xml:21756(title) build/en/book.xml:21897(title)
#: build/en/book.xml:22344(title) build/en/book.xml:23393(title)
#: build/en/book.xml:23638(title) build/en/book.xml:23693(title)
msgid "Alternate Names"
msgstr "别名"

#: build/en/book.xml:18180(para) build/en/book.xml:18353(para)
#: build/en/book.xml:18586(para) build/en/book.xml:19343(para)
#: build/en/book.xml:19501(para) build/en/book.xml:19632(para)
#: build/en/book.xml:19877(para) build/en/book.xml:19996(para)
#: build/en/book.xml:20242(para) build/en/book.xml:20343(para)
#: build/en/book.xml:20999(para) build/en/book.xml:21088(para)
#: build/en/book.xml:21757(para) build/en/book.xml:22563(para)
#: build/en/book.xml:22734(para) build/en/book.xml:23544(para)
msgid "None"
msgstr "无"

#: build/en/book.xml:18184(title) build/en/book.xml:18288(title)
#: build/en/book.xml:18357(title) build/en/book.xml:18446(title)
#: build/en/book.xml:18590(title) build/en/book.xml:18680(title)
#: build/en/book.xml:18839(title) build/en/book.xml:18979(title)
#: build/en/book.xml:19179(title) build/en/book.xml:19347(title)
#: build/en/book.xml:19450(title) build/en/book.xml:19505(title)
#: build/en/book.xml:19636(title) build/en/book.xml:19787(title)
#: build/en/book.xml:19881(title) build/en/book.xml:20000(title)
#: build/en/book.xml:20246(title) build/en/book.xml:20347(title)
#: build/en/book.xml:20457(title) build/en/book.xml:20542(title)
#: build/en/book.xml:20621(title) build/en/book.xml:20698(title)
#: build/en/book.xml:20778(title) build/en/book.xml:20874(title)
#: build/en/book.xml:21003(title) build/en/book.xml:21092(title)
#: build/en/book.xml:21482(title) build/en/book.xml:21603(title)
#: build/en/book.xml:21761(title) build/en/book.xml:21902(title)
msgid "Changes"
msgstr "改变"

#: build/en/book.xml:18185(para)
msgid "Working Copy"
msgstr "工作拷贝"

#: build/en/book.xml:18189(title) build/en/book.xml:18293(title)
#: build/en/book.xml:18362(title) build/en/book.xml:18451(title)
#: build/en/book.xml:18595(title) build/en/book.xml:18685(title)
#: build/en/book.xml:18845(title) build/en/book.xml:18985(title)
#: build/en/book.xml:19184(title) build/en/book.xml:19352(title)
#: build/en/book.xml:19455(title) build/en/book.xml:19510(title)
#: build/en/book.xml:19641(title) build/en/book.xml:19792(title)
#: build/en/book.xml:19886(title) build/en/book.xml:20005(title)
#: build/en/book.xml:20251(title) build/en/book.xml:20352(title)
#: build/en/book.xml:20462(title) build/en/book.xml:20547(title)
#: build/en/book.xml:20626(title) build/en/book.xml:20703(title)
#: build/en/book.xml:20783(title) build/en/book.xml:20879(title)
#: build/en/book.xml:21008(title) build/en/book.xml:21097(title)
#: build/en/book.xml:21487(title) build/en/book.xml:21608(title)
#: build/en/book.xml:21766(title) build/en/book.xml:21907(title)
msgid "Accesses Repository"
msgstr "是否访问版本库"

#: build/en/book.xml:18190(para) build/en/book.xml:18596(para)
#: build/en/book.xml:19456(para) build/en/book.xml:21009(para)
#: build/en/book.xml:21098(para)
msgid "No"
msgstr "否"

#: build/en/book.xml:18194(title) build/en/book.xml:18298(title)
#: build/en/book.xml:18367(title) build/en/book.xml:18456(title)
#: build/en/book.xml:18600(title) build/en/book.xml:18690(title)
#: build/en/book.xml:18851(title) build/en/book.xml:18990(title)
#: build/en/book.xml:19190(title) build/en/book.xml:19357(title)
#: build/en/book.xml:19460(title) build/en/book.xml:19515(title)
#: build/en/book.xml:19646(title) build/en/book.xml:19797(title)
#: build/en/book.xml:19891(title) build/en/book.xml:20010(title)
#: build/en/book.xml:20256(title) build/en/book.xml:20357(title)
#: build/en/book.xml:20467(title) build/en/book.xml:20552(title)
#: build/en/book.xml:20631(title) build/en/book.xml:20708(title)
#: build/en/book.xml:20788(title) build/en/book.xml:20884(title)
#: build/en/book.xml:21013(title) build/en/book.xml:21102(title)
#: build/en/book.xml:21492(title) build/en/book.xml:21613(title)
#: build/en/book.xml:21771(title) build/en/book.xml:21912(title)
#: build/en/book.xml:22136(title) build/en/book.xml:22199(title)
#: build/en/book.xml:22277(title) build/en/book.xml:22383(title)
#: build/en/book.xml:22498(title) build/en/book.xml:22561(title)
#: build/en/book.xml:22655(title) build/en/book.xml:22732(title)
#: build/en/book.xml:22778(title) build/en/book.xml:22847(title)
#: build/en/book.xml:23025(title) build/en/book.xml:23071(title)
#: build/en/book.xml:23175(title) build/en/book.xml:23228(title)
#: build/en/book.xml:23274(title) build/en/book.xml:23346(title)
#: build/en/book.xml:23426(title) build/en/book.xml:23489(title)
#: build/en/book.xml:23542(title) build/en/book.xml:23590(title)
#: build/en/book.xml:23643(title) build/en/book.xml:23698(title)
#: build/en/book.xml:23758(title) build/en/book.xml:24071(title)
msgid "Switches"
msgstr "选项"

#: build/en/book.xml:18196(screen)
#, no-wrap
msgid ""
"\n"
"--targets FILENAME\n"
"--non-recursive (-N)\n"
"--quiet (-q)\n"
"--config-dir DIR\n"
"--auto-props\n"
"--no-auto-props\n"
"--force\n"
msgstr ""
"\n"
"--targets FILENAME\n"
"--non-recursive (-N)\n"
"--quiet (-q)\n"
"--config-dir DIR\n"
"--auto-props\n"
"--no-auto-props\n"
"--force\n"

#: build/en/book.xml:18208(title) build/en/book.xml:18312(title)
#: build/en/book.xml:18380(title) build/en/book.xml:18472(title)
#: build/en/book.xml:18610(title) build/en/book.xml:18710(title)
#: build/en/book.xml:18870(title) build/en/book.xml:19010(title)
#: build/en/book.xml:19210(title) build/en/book.xml:19375(title)
#: build/en/book.xml:19537(title) build/en/book.xml:19663(title)
#: build/en/book.xml:19814(title) build/en/book.xml:19909(title)
#: build/en/book.xml:20030(title) build/en/book.xml:20275(title)
#: build/en/book.xml:20375(title) build/en/book.xml:20487(title)
#: build/en/book.xml:20568(title) build/en/book.xml:20647(title)
#: build/en/book.xml:20724(title) build/en/book.xml:20805(title)
#: build/en/book.xml:20904(title) build/en/book.xml:21024(title)
#: build/en/book.xml:21113(title) build/en/book.xml:21510(title)
#: build/en/book.xml:21630(title) build/en/book.xml:21785(title)
#: build/en/book.xml:21929(title) build/en/book.xml:22147(title)
#: build/en/book.xml:22288(title) build/en/book.xml:22455(title)
#: build/en/book.xml:22612(title) build/en/book.xml:22661(title)
#: build/en/book.xml:22786(title) build/en/book.xml:22856(title)
#: build/en/book.xml:22894(title) build/en/book.xml:23034(title)
#: build/en/book.xml:23080(title) build/en/book.xml:23184(title)
#: build/en/book.xml:23237(title) build/en/book.xml:23285(title)
#: build/en/book.xml:23355(title) build/en/book.xml:23435(title)
#: build/en/book.xml:23498(title) build/en/book.xml:23548(title)
#: build/en/book.xml:23599(title) build/en/book.xml:23653(title)
#: build/en/book.xml:23709(title) build/en/book.xml:23768(title)
#: build/en/book.xml:23816(title) build/en/book.xml:23849(title)
#: build/en/book.xml:24113(title)
msgid "Examples"
msgstr "例子"

#: build/en/book.xml:18210(para)
msgid "To add a file to your working copy:"
msgstr "添加一个文件到工作拷贝："

#: build/en/book.xml:18212(screen)
#, no-wrap
msgid ""
"\n"
"$ svn add foo.c \n"
"A         foo.c\n"
msgstr ""
"\n"
"$ svn add foo.c \n"
"A         foo.c\n"

#: build/en/book.xml:18217(para)
msgid "When adding a directory, the default behavior of <command moreinfo=\"none\">svn add</command> is to recurse:"
msgstr "当添加一个目录，<command moreinfo=\"none\">svn add</command>缺省的行为方式是递归的："

#: build/en/book.xml:18220(screen)
#, no-wrap
msgid ""
"\n"
"$ svn add testdir\n"
"A         testdir\n"
"A         testdir/a\n"
"A         testdir/b\n"
"A         testdir/c\n"
"A         testdir/d\n"
msgstr ""
"\n"
"$ svn add testdir\n"
"A         testdir\n"
"A         testdir/a\n"
"A         testdir/b\n"
"A         testdir/c\n"
"A         testdir/d\n"

#: build/en/book.xml:18229(para)
msgid "You can add a directory without adding its contents:"
msgstr "你可以只添加一个目录而不包括其内容："

#: build/en/book.xml:18232(screen)
#, no-wrap
msgid ""
"\n"
"$ svn add --non-recursive otherdir\n"
"A         otherdir\n"
msgstr ""
"\n"
"$ svn add --non-recursive otherdir\n"
"A         otherdir\n"

#: build/en/book.xml:18237(para)
msgid "Normally, the command <command moreinfo=\"none\">svn add *</command> will skip over any directories that are already under version control. Sometimes, however, you may want to add every unversioned object in your working copy, including those hiding deeper down. Passing the <option>--force</option> option makes <command moreinfo=\"none\">svn add</command> recurse into versioned directories:"
msgstr "通常情况下，命令<command moreinfo=\"none\">svn add *</command>会忽略所有已经在版本控制之下的目录，有时候，你会希望添加所有工作拷贝的未版本化文件，包括那些隐藏在深处的文件，可以使用<command moreinfo=\"none\">svn add</command>的<option>--force</option>递归到版本化的目录下："

#: build/en/book.xml:18245(screen)
#, no-wrap
msgid ""
"\n"
"$ svn add * --force\n"
"A         foo.c\n"
"A         somedir/bar.c\n"
"A         otherdir/docs/baz.doc\n"
"…\n"
msgstr ""
"\n"
"$ svn add * --force\n"
"A         foo.c\n"
"A         somedir/bar.c\n"
"A         otherdir/docs/baz.doc\n"
"…\n"

#: build/en/book.xml:18261(tertiary)
msgid "blame"
msgstr "blame"

#: build/en/book.xml:18265(refname)
msgid "svn blame"
msgstr "svn blame"

#: build/en/book.xml:18266(refpurpose)
msgid "Show author and revision information in-line for the specified files or URLs."
msgstr "显示特定文件和URL内嵌的作者和修订版本信息。"

#: build/en/book.xml:18271(programlisting)
#, no-wrap
msgid "svn blame TARGET[@REV]..."
msgstr "svn blame TARGET[@REV]..."

#: build/en/book.xml:18276(para)
msgid "Show author and revision information in-line for the specified files or URLs. Each line of text is annotated at the beginning with the author (username) and the revision number for the last change to that line."
msgstr "显示特定文件和URL内嵌的作者和修订版本信息。每一行文本在开头都放了最后修改的作者（用户名）和修订版本号。"

#: build/en/book.xml:18284(para)
msgid "praise, annotate, ann"
msgstr "praise、annotate、ann"

#: build/en/book.xml:18289(para) build/en/book.xml:18358(para)
#: build/en/book.xml:19180(para) build/en/book.xml:19451(para)
#: build/en/book.xml:19637(para) build/en/book.xml:19788(para)
#: build/en/book.xml:20001(para) build/en/book.xml:21483(para)
msgid "Nothing"
msgstr "无2"

#: build/en/book.xml:18294(para) build/en/book.xml:18363(para)
#: build/en/book.xml:18452(para) build/en/book.xml:18686(para)
#: build/en/book.xml:19511(para) build/en/book.xml:19793(para)
#: build/en/book.xml:19887(para) build/en/book.xml:20006(para)
#: build/en/book.xml:21609(para) build/en/book.xml:21767(para)
#: build/en/book.xml:21908(para)
msgid "Yes"
msgstr "是"

#: build/en/book.xml:18300(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
"--verbose (-v)\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
"--verbose (-v)\n"

#: build/en/book.xml:18314(para)
msgid "If you want to see blame annotated source for <filename moreinfo=\"none\">readme.txt</filename> in your test repository:"
msgstr "如果你希望在测试版本库看到blame标记的<filename moreinfo=\"none\">readme.txt</filename>源代码："

#: build/en/book.xml:18317(screen)
#, no-wrap
msgid ""
"\n"
"$ svn blame http://svn.red-bean.com/repos/test/readme.txt\n"
"     3      sally This is a README file.\n"
"     5      harry You should read this.\n"
msgstr ""
"\n"
"$ svn blame http://svn.red-bean.com/repos/test/readme.txt\n"
"     3      sally This is a README file.\n"
"     5      harry You should read this.\n"

#: build/en/book.xml:18331(tertiary) build/en/book.xml:23052(tertiary)
msgid "cat"
msgstr "cat"

#: build/en/book.xml:18336(refpurpose)
msgid "Output the contents of the specified files or URLs."
msgstr "输出特定文件或URL的内容。"

#: build/en/book.xml:18341(programlisting)
#, no-wrap
msgid "svn cat TARGET[@REV]..."
msgstr "svn cat TARGET[@REV]..."

#: build/en/book.xml:18346(para)
msgid "Output the contents of the specified files or URLs. For listing the contents of directories, see <command moreinfo=\"none\">svn list</command>."
msgstr "输出特定文件或URL的内容。列出目录的内容可以使用<command moreinfo=\"none\">svn list</command>。"

#: build/en/book.xml:18369(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"

#: build/en/book.xml:18382(para)
msgid "If you want to view readme.txt in your repository without checking it out:"
msgstr "如果你希望不检出而察看版本库的readme.txt的内容："

#: build/en/book.xml:18384(screen)
#, no-wrap
msgid ""
"\n"
"$ svn cat http://svn.red-bean.com/repos/test/readme.txt\n"
"This is a README file.\n"
"You should read this.\n"
msgstr ""
"\n"
"$ svn cat http://svn.red-bean.com/repos/test/readme.txt\n"
"This is a README file.\n"
"You should read this.\n"

#: build/en/book.xml:18391(para)
msgid "If your working copy is out of date (or you have local modifications) and you want to see the <literal moreinfo=\"none\">HEAD</literal> revision of a file in your working copy, <command moreinfo=\"none\">svn cat</command> will automatically fetch the <literal moreinfo=\"none\">HEAD</literal> revision when you give it a path:"
msgstr "如果你的工作拷贝已经过期（或者你有本地修改），并且希望察看工作拷贝的<literal moreinfo=\"none\">HEAD</literal>修订版本的一个文件，如果你给定一个路径，<command moreinfo=\"none\">svn cat</command>会自动取得<literal moreinfo=\"none\">HEAD</literal>的修订版本："

#: build/en/book.xml:18399(screen)
#, no-wrap
msgid ""
"\n"
"$ cat foo.c\n"
"This file is in my local working copy \n"
"and has changes that I've made.\n"
"\n"
"$ svn cat foo.c\n"
"Latest revision fresh from the repository!\n"
msgstr ""
"\n"
"$ cat foo.c\n"
"This file is in my local working copy \n"
"and has changes that I've made.\n"
"\n"
"$ svn cat foo.c\n"
"Latest revision fresh from the repository!\n"

#: build/en/book.xml:18416(tertiary)
msgid "checkout"
msgstr "checkout"

#: build/en/book.xml:18420(refname)
msgid "svn checkout"
msgstr "svn checkout"

#: build/en/book.xml:18421(refpurpose)
msgid "Check out a working copy from a repository."
msgstr "从版本库取出一个工作拷贝。"

#: build/en/book.xml:18425(programlisting)
#, no-wrap
msgid "svn checkout URL[@REV]... [PATH]"
msgstr "svn checkout URL[@REV]... [PATH]"

#: build/en/book.xml:18430(para)
msgid "Check out a working copy from a repository. If <replaceable>PATH</replaceable> is omitted, the basename of the URL will be used as the destination. If multiple URLs are given each will be checked out into a subdirectory of <replaceable>PATH</replaceable>, with the name of the subdirectory being the basename of the URL."
msgstr "从版本库取出一个工作拷贝，如果省略<replaceable>PATH</replaceable>，URL的基名称会作为目标，如果给定多个URL，每一个都会检出到<replaceable>PATH</replaceable>的子目录，使用URL基名称的子目录名称。"

#: build/en/book.xml:18442(para)
msgid "co"
msgstr "co"

#: build/en/book.xml:18447(para)
msgid "Creates a working copy."
msgstr "创建一个工作拷贝。"

#: build/en/book.xml:18458(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--quiet (-q)\n"
"--non-recursive (-N)\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--ignore-externals\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--quiet (-q)\n"
"--non-recursive (-N)\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--ignore-externals\n"
"--config-dir DIR\n"

#: build/en/book.xml:18474(para)
msgid "Check out a working copy into a directory called <filename moreinfo=\"none\">mine</filename>:"
msgstr "取出一个工作拷贝到<filename moreinfo=\"none\">mine</filename>："

#: build/en/book.xml:18477(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout file:///tmp/repos/test mine\n"
"A  mine/a\n"
"A  mine/b\n"
"Checked out revision 2.\n"
"$ ls\n"
"mine\n"
msgstr ""
"\n"
"$ svn checkout file:///tmp/repos/test mine\n"
"A  mine/a\n"
"A  mine/b\n"
"Checked out revision 2.\n"
"$ ls\n"
"mine\n"

#: build/en/book.xml:18486(para)
msgid "Check out 2 different directories into two separate working copies:"
msgstr "检出两个目录到两个单独的工作拷贝："

#: build/en/book.xml:18489(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz\n"
"A  test/a\n"
"A  test/b\n"
"Checked out revision 2.\n"
"A  quiz/l\n"
"A  quiz/m\n"
"Checked out revision 2.\n"
"$ ls\n"
"quiz  test\n"
msgstr ""
"\n"
"$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz\n"
"A  test/a\n"
"A  test/b\n"
"Checked out revision 2.\n"
"A  quiz/l\n"
"A  quiz/m\n"
"Checked out revision 2.\n"
"$ ls\n"
"quiz  test\n"

#: build/en/book.xml:18501(para)
msgid "Check out 2 different directories into two separate working copies, but place both into a directory called <filename moreinfo=\"none\">working-copies</filename>:"
msgstr "检出两个目录到两个单独的工作拷贝，但是将两个目录都放到<filename moreinfo=\"none\">working-copies</filename>："

#: build/en/book.xml:18505(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz working-copies\n"
"A  working-copies/test/a\n"
"A  working-copies/test/b\n"
"Checked out revision 2.\n"
"A  working-copies/quiz/l\n"
"A  working-copies/quiz/m\n"
"Checked out revision 2.\n"
"$ ls\n"
"working-copies\n"
msgstr ""
"\n"
"$ svn checkout file:///tmp/repos/test  file:///tmp/repos/quiz working-copies\n"
"A  working-copies/test/a\n"
"A  working-copies/test/b\n"
"Checked out revision 2.\n"
"A  working-copies/quiz/l\n"
"A  working-copies/quiz/m\n"
"Checked out revision 2.\n"
"$ ls\n"
"working-copies\n"

#: build/en/book.xml:18517(para)
msgid "If you interrupt a checkout (or something else interrupts your checkout like loss of connectivity, etc.), you can restart it either by issuing the identical checkout command again, or by updating the incomplete working copy:"
msgstr "如果你打断一个检出（或其它打断检出的事情，如连接失败。），你可以使用同样的命令重新开始或者是更新不完整的工作拷贝："

#: build/en/book.xml:18523(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout file:///tmp/repos/test test\n"
"A  test/a\n"
"A  test/b\n"
"^C\n"
"svn: The operation was interrupted\n"
"svn: caught SIGINT\n"
"\n"
"$ svn checkout file:///tmp/repos/test test\n"
"A  test/c\n"
"A  test/d\n"
"^C\n"
"svn: The operation was interrupted\n"
"svn: caught SIGINT\n"
"\n"
"$ cd test\n"
"$ svn update\n"
"A  test/e\n"
"A  test/f\n"
"Updated to revision 3.\n"
msgstr ""
"\n"
"$ svn checkout file:///tmp/repos/test test\n"
"A  test/a\n"
"A  test/b\n"
"^C\n"
"svn: The operation was interrupted\n"
"svn: caught SIGINT\n"
"\n"
"$ svn checkout file:///tmp/repos/test test\n"
"A  test/c\n"
"A  test/d\n"
"^C\n"
"svn: The operation was interrupted\n"
"svn: caught SIGINT\n"
"\n"
"$ cd test\n"
"$ svn update\n"
"A  test/e\n"
"A  test/f\n"
"Updated to revision 3.\n"

#: build/en/book.xml:18553(tertiary)
msgid "cleanup"
msgstr "cleanup"

#: build/en/book.xml:18557(refname)
msgid "svn cleanup"
msgstr "svn cleanup"

#: build/en/book.xml:18558(refpurpose)
msgid "Recursively clean up the working copy."
msgstr "递归清理工作拷贝。"

#: build/en/book.xml:18562(programlisting)
#, no-wrap
msgid "svn cleanup [PATH...]"
msgstr "svn cleanup [PATH...]"

#: build/en/book.xml:18567(para)
msgid "Recursively clean up the working copy, removing working copy locks and resuming unfinished operations. If you ever get a <quote>working copy locked</quote> error, run this command to remove stale locks and get your working copy into a usable state again."
msgstr "递归清理工作拷贝，删除未完成的工作拷贝锁定，并恢复未完成的操作。如果你得到一个<quote>工作拷贝已锁定</quote>的错误，运行这个命令可以删除无效的锁定，让你的工作拷贝再次回到可用的状态。"

#: build/en/book.xml:18573(para)
msgid "If, for some reason, an <command moreinfo=\"none\">svn update</command> fails due to a problem running an external diff program (e.g. user input or network failure), pass the <option>--diff3-cmd</option> to allow cleanup to complete any merging with your external diff program. You can also specify any configuration directory with the <option>--config-dir</option> switch, but you should need these switches extremely infrequently."
msgstr "如果，因为一些原因，运行外置的区别程序（例如，用户输入或是网络错误）有时候会导致一个<command moreinfo=\"none\">svn update</command>失败，使用<option>--diff3-cmd</option>选项可以完全清除你的外置区别程序所作的合并，你也可以使用<option>--config-dir</option>指定任何配置目录，但是你应该不会经常使用这些选项。"

#: build/en/book.xml:18591(para) build/en/book.xml:20247(para)
#: build/en/book.xml:21004(para) build/en/book.xml:21093(para)
#: build/en/book.xml:21604(para) build/en/book.xml:21903(para)
msgid "Working copy"
msgstr "工作拷贝2"

#: build/en/book.xml:18602(screen)
#, no-wrap
msgid ""
"\n"
"--diff3-cmd CMD\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--diff3-cmd CMD\n"
"--config-dir DIR\n"

#: build/en/book.xml:18612(para)
msgid "Well, there's not much to the examples here as <command moreinfo=\"none\">svn cleanup</command> generates no output. If you pass no <replaceable>PATH</replaceable>, <quote><filename moreinfo=\"none\">.</filename></quote> is used."
msgstr "<command moreinfo=\"none\">svn cleanup</command>没有输出，没有太多的例子，如果你没有传递<replaceable>PATH</replaceable>，会使用<quote><filename moreinfo=\"none\">.</filename></quote>。"

#: build/en/book.xml:18617(screen)
#, no-wrap
msgid ""
"\n"
"$ svn cleanup\n"
"\n"
"$ svn cleanup /path/to/working-copy\n"
msgstr ""
"\n"
"$ svn cleanup\n"
"\n"
"$ svn cleanup /path/to/working-copy\n"

#: build/en/book.xml:18631(tertiary)
msgid "commit"
msgstr "commit"

#: build/en/book.xml:18636(refpurpose)
msgid "Send changes from your working copy to the repository."
msgstr "将修改从工作拷贝发送到版本库。"

#: build/en/book.xml:18640(programlisting)
#, no-wrap
msgid "svn commit [PATH...]"
msgstr "svn commit [PATH...]"

#: build/en/book.xml:18645(para)
msgid "Send changes from your working copy to the repository. If you do not supply a log message with your commit by using either the <option>--file</option> or <option>--message</option> switch, <command moreinfo=\"none\">svn</command> will launch your editor for you to compose a commit message. See the <literal moreinfo=\"none\">editor-cmd</literal> section in <xref linkend=\"svn.advanced.confarea.opts.config\"/>."
msgstr "将修改从工作拷贝发送到版本库。如果你没有使用<option>--file</option>或<option>--message</option>提供一个提交日志信息，<command moreinfo=\"none\">svn</command>会启动你的编辑器来编写一个提交信息，见<xref linkend=\"svn.advanced.confarea.opts.config\"/>的<literal moreinfo=\"none\">editor-cmd</literal>小节。"

#: build/en/book.xml:18653(para)
msgid "<command moreinfo=\"none\">svn commit</command> will send found lock tokens and release locks on all <replaceable>PATHS</replaceable> committed (recursively) unless <option>--no-unlock</option> is passed."
msgstr "<command moreinfo=\"none\">svn commit</command> will send found lock tokens and release locks on all <replaceable>PATHS</replaceable> committed (recursively) unless <option>--no-unlock</option> is passed."

#: build/en/book.xml:18659(para)
msgid "If you begin a commit and Subversion launches your editor to compose the commit message, you can still abort without committing your changes. If you want to cancel your commit, just quit your editor without saving your commit message and Subversion will prompt you to either abort the commit, continue with no message, or edit the message again."
msgstr "如果你开始一个提交并且Subversion启动了你的编辑器来编辑提交信息，你仍可以退出而不会提交你的修改，如果你希望取消你的提交，只需要退出编辑器而不保存你的提交信息，Subversion会提示你是选择取消提交、空信息继续还是重新编辑信息。"

#: build/en/book.xml:18674(para)
msgid "ci (short for <quote>check in</quote>; not <quote>co</quote>, which is short for <quote>checkout</quote>)"
msgstr "ci（<quote>check in</quote>的缩写；不是<quote>checkout</quote>的缩写<quote>co</quote>。）"

#: build/en/book.xml:18681(para)
msgid "Working copy, repository"
msgstr "工作拷贝，版本库"

#: build/en/book.xml:18692(screen)
#, no-wrap
msgid ""
"\n"
"--message (-m) TEXT\n"
"--file (-F) FILE\n"
"--quiet (-q)\n"
"--no-unlock\n"
"--non-recursive (-N)\n"
"--targets FILENAME\n"
"--force-log\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--encoding ENC\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--message (-m) TEXT\n"
"--file (-F) FILE\n"
"--quiet (-q)\n"
"--no-unlock\n"
"--non-recursive (-N)\n"
"--targets FILENAME\n"
"--force-log\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--encoding ENC\n"
"--config-dir DIR\n"

#: build/en/book.xml:18712(para)
msgid "Commit a simple modification to a file with the commit message on the command line and an implicit target of your current directory (<quote><filename moreinfo=\"none\">.</filename></quote>):"
msgstr "使用命令行提交一个包含日志信息的文件修改，当前目录（<quote><filename moreinfo=\"none\">.</filename></quote>）是没有说明的目标路径："

#: build/en/book.xml:18717(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit -m \"added howto section.\"\n"
"Sending        a\n"
"Transmitting file data .\n"
"Committed revision 3.\n"
msgstr ""
"\n"
"$ svn commit -m \"added howto section.\"\n"
"Sending        a\n"
"Transmitting file data .\n"
"Committed revision 3.\n"

#: build/en/book.xml:18724(para)
msgid "Commit a modification to the file <filename moreinfo=\"none\">foo.c</filename> (explicitly specified on the command line) with the commit message in a file named <literal moreinfo=\"none\">msg</literal>:"
msgstr "提交一个修改到<filename moreinfo=\"none\">foo.c</filename>（在命令行明确指明），并且<literal moreinfo=\"none\">msg</literal>文件中保存了提交信息："

#: build/en/book.xml:18729(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit -F msg foo.c\n"
"Sending        foo.c\n"
"Transmitting file data .\n"
"Committed revision 5.\n"
msgstr ""
"\n"
"$ svn commit -F msg foo.c\n"
"Sending        foo.c\n"
"Transmitting file data .\n"
"Committed revision 5.\n"

#: build/en/book.xml:18736(para)
msgid "If you want to use a file that's under version control for your commit message with <option>--file</option>, you need to pass the <option>--force-log</option> switch:"
msgstr "如果你希望使用在<option>--file</option>选项中使用在版本控制之下的文件作为参数，你需要使用<option>--force-log</option>选项："

#: build/en/book.xml:18741(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit --file file_under_vc.txt foo.c\n"
"svn: The log message file is under version control\n"
"svn: Log message file is a versioned file; use '--force-log' to override\n"
"\n"
"$ svn commit --force-log --file file_under_vc.txt foo.c\n"
"Sending        foo.c\n"
"Transmitting file data .\n"
"Committed revision 6.\n"
msgstr ""
"\n"
"$ svn commit --file file_under_vc.txt foo.c\n"
"svn: The log message file is under version control\n"
"svn: Log message file is a versioned file; use '--force-log' to override\n"
"\n"
"$ svn commit --force-log --file file_under_vc.txt foo.c\n"
"Sending        foo.c\n"
"Transmitting file data .\n"
"Committed revision 6.\n"

#: build/en/book.xml:18752(para)
msgid "To commit a file scheduled for deletion:"
msgstr "提交一个已经预定要删除的文件："

#: build/en/book.xml:18754(screen)
#, no-wrap
msgid ""
"\n"
"$ svn commit -m \"removed file 'c'.\"\n"
"Deleting       c\n"
"\n"
"Committed revision 7.\n"
msgstr ""
"\n"
"$ svn commit -m \"removed file 'c'.\"\n"
"Deleting       c\n"
"\n"
"Committed revision 7.\n"

#: build/en/book.xml:18769(tertiary)
msgid "copy"
msgstr "copy"

#: build/en/book.xml:18774(refpurpose)
msgid "Copy a file or directory in a working copy or in the repository."
msgstr "拷贝工作拷贝的一个文件或目录到版本库。"

#: build/en/book.xml:18780(programlisting)
#, no-wrap
msgid "svn copy SRC DST"
msgstr "svn copy SRC DST"

#: build/en/book.xml:18786(para)
msgid "Copy a file in a working copy or in the repository. <replaceable>SRC</replaceable> and <replaceable>DST</replaceable> can each be either a working copy (WC) path or URL:"
msgstr "拷贝工作拷贝的一个文件或目录到版本库。<replaceable>SRC</replaceable>和<replaceable>DST</replaceable>既可以是工作拷贝（WC）路径也可以是URL："

#: build/en/book.xml:18794(term) build/en/book.xml:20434(term)
msgid "WC -&gt; WC"
msgstr "WC -&gt; WC"

#: build/en/book.xml:18796(para)
msgid "Copy and schedule an item for addition (with history)."
msgstr "拷贝并且预定一个添加的项目（包含历史）。"

#: build/en/book.xml:18802(term)
msgid "WC -&gt; URL"
msgstr "WC -&gt; URL"

#: build/en/book.xml:18804(para)
msgid "Immediately commit a copy of WC to URL."
msgstr "将WC或URL的拷贝立即提交。"

#: build/en/book.xml:18809(term)
msgid "URL -&gt; WC"
msgstr "URL -&gt; WC"

#: build/en/book.xml:18811(para)
msgid "Check out URL into WC, and schedule it for addition."
msgstr "检出URL到WC，并且加入到添加计划。"

#: build/en/book.xml:18817(term) build/en/book.xml:20442(term)
msgid "URL -&gt; URL"
msgstr "URL -&gt; URL"

#: build/en/book.xml:18819(para)
msgid "Complete server-side copy. This is usually used to branch and tag."
msgstr "完全的服务器端拷贝，通常用在分支和标签。"

#: build/en/book.xml:18827(para)
msgid "You can only copy files within a single repository. Subversion does not support cross-repository copying."
msgstr "你只可以在单个版本库中拷贝文件，Subversion还不支持跨版本库的拷贝。"

#: build/en/book.xml:18835(para)
msgid "cp"
msgstr "cp"

#: build/en/book.xml:18840(para)
msgid "Repository if destination is a URL."
msgstr "如果目标是URL则包括版本库。"

#: build/en/book.xml:18841(para)
msgid "Working copy if destination is a WC path."
msgstr "如果目标是WC路径，则是工作拷贝。"

#: build/en/book.xml:18846(para)
msgid "If source or destination is in the repository, or if needed to look up the source revision number."
msgstr "如果目标是版本库，或者需要查看修订版本号，则会访问版本库。"

#: build/en/book.xml:18853(screen)
#, no-wrap
msgid ""
"\n"
"--message (-m) TEXT\n"
"--file (-F) FILE\n"
"--revision (-r) REV\n"
"--quiet (-q)\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--force-log\n"
"--editor-cmd EDITOR\n"
"--encoding ENC\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--message (-m) TEXT\n"
"--file (-F) FILE\n"
"--revision (-r) REV\n"
"--quiet (-q)\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--force-log\n"
"--editor-cmd EDITOR\n"
"--encoding ENC\n"
"--config-dir DIR\n"

#: build/en/book.xml:18872(para)
msgid "Copy an item within your working copy (just schedules the copy—nothing goes into the repository until you commit):"
msgstr "拷贝工作拷贝的一个项目（只是预定要拷贝—在提交之前不会影响版本库）："

#: build/en/book.xml:18876(screen)
#, no-wrap
msgid ""
"\n"
"$ svn copy foo.txt bar.txt\n"
"A         bar.txt\n"
"$ svn status\n"
"A  +   bar.txt\n"
msgstr ""
"\n"
"$ svn copy foo.txt bar.txt\n"
"A         bar.txt\n"
"$ svn status\n"
"A  +   bar.txt\n"

#: build/en/book.xml:18883(para)
msgid "Copy an item in your working copy to a URL in the repository (an immediate commit, so you must supply a commit message):"
msgstr "拷贝你的工作拷贝的一个项目到版本库的URL（直接的提交，所以需要提供一个提交信息）："

#: build/en/book.xml:18887(screen)
#, no-wrap
msgid ""
"\n"
"$ svn copy near.txt file:///tmp/repos/test/far-away.txt -m \"Remote copy.\"\n"
"\n"
"Committed revision 8.\n"
msgstr ""
"\n"
"$ svn copy near.txt file:///tmp/repos/test/far-away.txt -m \"Remote copy.\"\n"
"\n"
"Committed revision 8.\n"

#: build/en/book.xml:18893(para)
msgid "Copy an item from the repository to your working copy (just schedules the copy—nothing goes into the repository until you commit):"
msgstr "拷贝版本库的一个项目到你的工作拷贝（只是预定要拷贝—在提交之前不会影响版本库）："

#: build/en/book.xml:18898(para)
msgid "This is the recommended way to resurrect a dead file in your repository!"
msgstr "这是恢复死掉文件的推荐方式！"

#: build/en/book.xml:18902(screen)
#, no-wrap
msgid ""
"\n"
"$ svn copy file:///tmp/repos/test/far-away near-here\n"
"A         near-here\n"
msgstr ""
"\n"
"$ svn copy file:///tmp/repos/test/far-away near-here\n"
"A         near-here\n"

#: build/en/book.xml:18907(para)
msgid "And finally, copying between two URLs:"
msgstr "最后，是在URL之间拷贝："

#: build/en/book.xml:18909(screen)
#, no-wrap
msgid ""
"\n"
"$ svn copy file:///tmp/repos/test/far-away file:///tmp/repos/test/over-there -m \"remote copy.\"\n"
"\n"
"Committed revision 9.\n"
msgstr ""
"\n"
"$ svn copy file:///tmp/repos/test/far-away file:///tmp/repos/test/over-there -m \"remote copy.\"\n"
"\n"
"Committed revision 9.\n"

#: build/en/book.xml:18916(para)
msgid "This is the easiest way to <quote>tag</quote> a revision in your repository—just <command moreinfo=\"none\">svn copy</command> that revision (usually <literal moreinfo=\"none\">HEAD</literal>) into your tags directory."
msgstr "这是在版本库里作<quote>标签</quote>最简单的方法—<command moreinfo=\"none\">svn copy</command>那个修订版本（通常是<literal moreinfo=\"none\">HEAD</literal>）到你的tags目录。"

#: build/en/book.xml:18922(screen)
#, no-wrap
msgid ""
"\n"
"$ svn copy file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0.6.32-prerelease -m \"tag tree\"\n"
"\n"
"Committed revision 12.\n"
msgstr ""
"\n"
"$ svn copy file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0.6.32-prerelease -m \"tag tree\"\n"
"\n"
"Committed revision 12.\n"

#: build/en/book.xml:18928(para)
msgid "And don't worry if you forgot to tag—you can always specify an older revision and tag anytime:"
msgstr "不要担心忘记作标签—你可以在以后任何时候给一个旧版本作标签："

#: build/en/book.xml:18931(screen)
#, no-wrap
msgid ""
"\n"
"$ svn copy -r 11 file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0.6.32-prerelease -m \"Forgot to tag at rev 11\"\n"
"\n"
"Committed revision 13.\n"
msgstr ""
"\n"
"$ svn copy -r 11 file:///tmp/repos/test/trunk file:///tmp/repos/test/tags/0.6.32-prerelease -m \"Forgot to tag at rev 11\"\n"
"\n"
"Committed revision 13.\n"

#: build/en/book.xml:18944(tertiary)
msgid "delete"
msgstr "delete"

#: build/en/book.xml:18949(refpurpose)
msgid "Delete an item from a working copy or the repository."
msgstr "从工作拷贝或版本库删除一个项目。"

#: build/en/book.xml:18954(programlisting)
#, no-wrap
msgid "svn delete PATH..."
msgstr "svn delete PATH..."

#: build/en/book.xml:18955(programlisting)
#, no-wrap
msgid "svn delete URL..."
msgstr "svn delete URL..."

#: build/en/book.xml:18960(para)
msgid "Items specified by <replaceable>PATH</replaceable> are scheduled for deletion upon the next commit. Files (and directories that have not been committed) are immediately removed from the working copy. The command will not remove any unversioned or modified items; use the <option>--force</option> switch to override this behavior."
msgstr "<replaceable>PATH</replaceable>指定的项目会在下次提交删除，文件（和没有提交的目录）会立即从版本库删除，这个命令不会删除任何未版本化或已经修改的项目；使用<option>--force</option>选项可以覆盖这种行为方式。"

#: build/en/book.xml:18968(para)
msgid "Items specified by URL are deleted from the repository via an immediate commit. Multiple URLs are committed atomically."
msgstr "URL指定的项目会在直接提交中从版本库删除，多个URL的提交是原子操作。"

#: build/en/book.xml:18975(para)
msgid "del, remove, rm"
msgstr "del, remove, rm"

#: build/en/book.xml:18980(para)
msgid "Working copy if operating on files, Repository if operating on URLs"
msgstr "如果操作对象是文件则是工作拷贝变化，对象是URL则会影响版本库。"

#: build/en/book.xml:18986(para) build/en/book.xml:19642(para)
msgid "Only if operating on URLs"
msgstr "对URL操作时访问"

#: build/en/book.xml:18992(screen)
#, no-wrap
msgid ""
"\n"
"--force\n"
"--force-log\n"
"--message (-m) TEXT\n"
"--file (-F) FILE\n"
"--quiet (-q)\n"
"--targets FILENAME\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--editor-cmd EDITOR\n"
"--encoding ENC\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--force\n"
"--force-log\n"
"--message (-m) TEXT\n"
"--file (-F) FILE\n"
"--quiet (-q)\n"
"--targets FILENAME\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--editor-cmd EDITOR\n"
"--encoding ENC\n"
"--config-dir DIR\n"

#: build/en/book.xml:19012(para)
msgid "Using <command moreinfo=\"none\">svn</command> to delete a file from your working copy merely schedules it to be deleted. When you commit, the file is deleted in the repository."
msgstr "使用<command moreinfo=\"none\">svn</command>从工作拷贝删除文件只是预定要删除，当你提交，文件才会从版本库删除。"

#: build/en/book.xml:19017(screen)
#, no-wrap
msgid ""
"\n"
"$ svn delete myfile\n"
"D         myfile\n"
"\n"
"$ svn commit -m \"Deleted file 'myfile'.\"\n"
"Deleting       myfile\n"
"Transmitting file data .\n"
"Committed revision 14.\n"
msgstr ""
"\n"
"$ svn delete myfile\n"
"D         myfile\n"
"\n"
"$ svn commit -m \"Deleted file 'myfile'.\"\n"
"Deleting       myfile\n"
"Transmitting file data .\n"
"Committed revision 14.\n"

#: build/en/book.xml:19027(para)
msgid "Deleting a URL, however, is immediate, so you have to supply a log message:"
msgstr "然而直接删除一个URL，你需要提供一个日志信息："

#: build/en/book.xml:19030(screen)
#, no-wrap
msgid ""
"\n"
"$ svn delete -m \"Deleting file 'yourfile'\" file:///tmp/repos/test/yourfile\n"
"\n"
"Committed revision 15.\n"
msgstr ""
"\n"
"$ svn delete -m \"Deleting file 'yourfile'\" file:///tmp/repos/test/yourfile\n"
"\n"
"Committed revision 15.\n"

#: build/en/book.xml:19036(para)
msgid "Here's an example of how to force deletion of a file that has local mods:"
msgstr "如下是强制删除本地已修改文件的例子："

#: build/en/book.xml:19039(screen)
#, no-wrap
msgid ""
"\n"
"$ svn delete over-there \n"
"svn: Attempting restricted operation for modified resource\n"
"svn: Use --force to override this restriction\n"
"svn: 'over-there' has local modifications\n"
"\n"
"$ svn delete --force over-there \n"
"D         over-there\n"
msgstr ""
"\n"
"$ svn delete over-there \n"
"svn: Attempting restricted operation for modified resource\n"
"svn: Use --force to override this restriction\n"
"svn: 'over-there' has local modifications\n"
"\n"
"$ svn delete --force over-there \n"
"D         over-there\n"

#: build/en/book.xml:19057(tertiary) build/en/book.xml:23255(tertiary)
msgid "diff"
msgstr "diff"

#: build/en/book.xml:19062(refpurpose)
msgid "Display the differences between two paths."
msgstr "比较两条路径的区别。"

#: build/en/book.xml:19066(programlisting)
#, no-wrap
msgid "diff [-r N[:M]] [TARGET[@REV]...]"
msgstr "diff [-r N[:M]] [TARGET[@REV]...]"

#: build/en/book.xml:19067(programlisting)
#, no-wrap
msgid "diff [-r N[:M]] --old OLD-TGT[@OLDREV] [--new NEW-TGT[@NEWREV]] [PATH...]"
msgstr "diff [-r N[:M]] --old OLD-TGT[@OLDREV] [--new NEW-TGT[@NEWREV]] [PATH...]"

#: build/en/book.xml:19068(programlisting)
#, no-wrap
msgid "diff OLD-URL[@OLDREV] NEW-URL[@NEWREV]"
msgstr "diff OLD-URL[@OLDREV] NEW-URL[@NEWREV]"

#: build/en/book.xml:19073(para)
msgid "Display the differences between two paths. The three different ways you can use <command moreinfo=\"none\">svn diff</command> are:"
msgstr "显示两条路径的区别，<command moreinfo=\"none\">svn diff</command>有三种使用方式："

#: build/en/book.xml:19077(para)
msgid "<command moreinfo=\"none\">svn diff [-r N[:M]] [--old OLD-TGT] [--new NEW-TGT] [PATH...]</command> displays the differences between <replaceable>OLD-TGT</replaceable> and <replaceable>NEW-TGT</replaceable>. If <replaceable>PATH</replaceable>s are given, they are treated as relative to <replaceable>OLD-TGT</replaceable> and <replaceable>NEW-TGT</replaceable> and the output is restricted to differences in only those paths. <replaceable>OLD-TGT</replaceable> and <replaceable>NEW-TGT</replaceable> may be working copy paths or <replaceable>URL</replaceable><literal moreinfo=\"none\">[@</literal><replaceable>REV</replaceable><literal moreinfo=\"none\">]</literal>. <replaceable>OLD-TGT</replaceable> defaults to the current working directory and <replaceable>NEW-TGT</replaceable> defaults to <replaceable>OLD-TGT</replaceable>. <replaceable>N</replaceable> defaults to <literal moreinfo=\"none\">BASE</literal> or, if <replaceable>OLD-TGT</replaceable> is a URL, to <literal moreinfo=\"none\">HEAD</literal>. <replaceable>M</replaceable> defaults to the current working version or, if <replaceable>NEW-TGT</replaceable> is a URL, to <literal moreinfo=\"none\">HEAD</literal>. <command moreinfo=\"none\">svn diff -r N</command> sets the revision of <replaceable>OLD-TGT</replaceable> to <replaceable>N</replaceable>, <command moreinfo=\"none\">svn diff -r N:M</command> also sets the revision of <replaceable>NEW-TGT</replaceable> to <replaceable>M</replaceable>."
msgstr "<command moreinfo=\"none\">svn diff [-r N[:M]] [--old OLD-TGT] [--new NEW-TGT] [PATH...]</command>会显示<replaceable>OLD-TGT</replaceable>和<replaceable>NEW-TGT</replaceable>的区别。如果给定路径<replaceable>PATH</replaceable>，它会被看作<replaceable>OLD-TGT</replaceable>和<replaceable>NEW-TGT</replaceable>的相对路径，输出也会限制在这些路径的区别上。<replaceable>OLD-TGT</replaceable>和<replaceable>NEW-TGT</replaceable>可以是工作拷贝路径或者是<replaceable>URL</replaceable><literal moreinfo=\"none\">[@</literal><replaceable>REV</replaceable><literal moreinfo=\"none\">]</literal>。<replaceable>OLD-TGT</replaceable>缺省是当前工作目录，而<replaceable>NEW-TGT</replaceable>缺省是<replaceable>OLD-TGT</replaceable>。<replaceable>N</replaceable>缺省是<literal moreinfo=\"none\">BASE</literal>，<replaceable>M</replaceable>缺省时当前目录的版本，但如果<replaceable>NEW-TGT</replaceable>是一个URL，则默认是<literal moreinfo=\"none\">HEAD</literal>。<command moreinfo=\"none\">svn diff -r N</command>设置<replaceable>OLD-TGT</replaceable>的修订版本为<replaceable>N</replaceable>，<command moreinfo=\"none\">svn diff -r N:M</command>设置<replaceable>NEW-TGT</replaceable>的修订版本是<replaceable>M</replaceable>。"

#: build/en/book.xml:19105(para)
msgid "<command moreinfo=\"none\">svn diff -r N:M URL</command> is shorthand for <command moreinfo=\"none\">svn diff -r N:M --old=URL --new=URL</command>."
msgstr "<command moreinfo=\"none\">svn diff -r N:M URL</command> is shorthand for <command moreinfo=\"none\">svn diff -r N:M --old=URL --new=URL</command>."

#: build/en/book.xml:19109(para)
msgid "<command moreinfo=\"none\">svn diff [-r N[:M]] URL1[@N] URL2[@M]</command> is shorthand for <command moreinfo=\"none\">svn diff [-r N[:M]] --old=URL1 --new=URL2</command>."
msgstr "<command moreinfo=\"none\">svn diff [-r N[:M]] URL1[@N] URL2[@M]</command>是<command moreinfo=\"none\">svn diff [-r N[:M]] --old=URL1 --new=URL2</command>的缩写。"

#: build/en/book.xml:19113(para)
msgid "If <replaceable>TARGET</replaceable> is a URL, then revs N and M can be given either via the <option>--revision</option> or by using <quote>@</quote> notation as described earlier."
msgstr "<replaceable>TARGET</replaceable>是一个URL，然后可以使用前面提到的<option>--revision</option>或<quote>@</quote>符号来指定N和M。"

#: build/en/book.xml:19118(para)
msgid "If <replaceable>TARGET</replaceable> is a working copy path, then the <option>--revision</option> switch means:"
msgstr "如果<replaceable>TARGET</replaceable>是工作拷贝路径，则<option>--revision</option>选项的含义是："

#: build/en/book.xml:19125(option)
msgid "--revision N:M"
msgstr "--revision N:M"

#: build/en/book.xml:19127(para)
msgid "The server compares <replaceable>TARGET</replaceable>@<replaceable>N</replaceable> and <replaceable>TARGET</replaceable>@<replaceable>M</replaceable>."
msgstr "服务器比较 <replaceable>TARGET</replaceable>@<replaceable>N</replaceable>和<replaceable>TARGET</replaceable>@<replaceable>M</replaceable>。"

#: build/en/book.xml:19135(option)
msgid "--revision N"
msgstr "--revision N"

#: build/en/book.xml:19137(para)
msgid "The client compares <replaceable>TARGET</replaceable>@<replaceable>N</replaceable> against working copy."
msgstr "客户端比较<replaceable>TARGET</replaceable>@<replaceable>N</replaceable>和工作拷贝。"

#: build/en/book.xml:19144(term)
msgid "(no <option>--revision</option>)"
msgstr "（无<option>--revision</option>）"

#: build/en/book.xml:19146(para)
msgid "The client compares base and working copies of <replaceable>TARGET</replaceable>."
msgstr "客户端比较base和 <replaceable>TARGET</replaceable>的<replaceable>TARGET</replaceable>。"

#: build/en/book.xml:19153(para)
msgid "If the alternate syntax is used, the server compares <replaceable>URL1</replaceable> and <replaceable>URL2</replaceable> at revisions <replaceable>N</replaceable> and <replaceable>M</replaceable> respectively. If either <replaceable>N</replaceable> or <replaceable>M</replaceable> are omitted, a value of <literal moreinfo=\"none\">HEAD</literal> is assumed."
msgstr "如果使用其他语法，服务器会比较<replaceable>URL1</replaceable>和<replaceable>URL2</replaceable>各自的<replaceable>N</replaceable>和<replaceable>M</replaceable>。如果省掉<replaceable>N</replaceable>或<replaceable>M</replaceable>，会假定为<literal moreinfo=\"none\">HEAD</literal>。"

#: build/en/book.xml:19162(para)
msgid "By default, <command moreinfo=\"none\">svn diff</command> ignores the ancestry of files and merely compares the contents of the two files being compared. If you use <option>--notice-ancestry</option>, the ancestry of the paths in question will be taken into consideration when comparing revisions (that is, if you run <command moreinfo=\"none\">svn diff</command> on two files with identical contents but different ancestry you will see the entire contents of the file as having been removed and added again)."
msgstr "缺省情况下，<command moreinfo=\"none\">svn diff</command>忽略文件的祖先，只会比较两个文件的内容。如果你使用<option>--notice-ancestry</option>，比较修订版本（也就是，当你运行<command moreinfo=\"none\">svn diff</command>比较两个内容相同，但祖先历史不同的对象会看到所有的内容被删除又再次添加）时就会考虑路径的祖先。"

#: build/en/book.xml:19175(para)
msgid "di"
msgstr "di"

#: build/en/book.xml:19185(para)
msgid "For obtaining differences against anything but <literal moreinfo=\"none\">BASE</literal> revision in your working copy"
msgstr "获得工作拷贝非<literal moreinfo=\"none\">BASE</literal>修订版本的区别时会"

#: build/en/book.xml:19192(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--old OLD-TARGET\n"
"--new NEW-TARGET\n"
"--extensions (-x) \"ARGS\"\n"
"--non-recursive (-N)\n"
"--diff-cmd CMD\n"
"--notice-ancestry\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--no-diff-deleted\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--old OLD-TARGET\n"
"--new NEW-TARGET\n"
"--extensions (-x) \"ARGS\"\n"
"--non-recursive (-N)\n"
"--diff-cmd CMD\n"
"--notice-ancestry\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--no-diff-deleted\n"
"--config-dir DIR\n"

#: build/en/book.xml:19212(para)
msgid "Compare <literal moreinfo=\"none\">BASE</literal> and your working copy (one of the most popular uses of <command moreinfo=\"none\">svn diff</command>):"
msgstr "比较<literal moreinfo=\"none\">BASE</literal>和你的工作拷贝（<command moreinfo=\"none\">svn diff</command>最经常的用法）："

#: build/en/book.xml:19216(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff COMMITTERS \n"
"Index: COMMITTERS\n"
"===================================================================\n"
"--- COMMITTERS\t(revision 4404)\n"
"+++ COMMITTERS\t(working copy)\n"
msgstr ""
"\n"
"$ svn diff COMMITTERS \n"
"Index: COMMITTERS\n"
"===================================================================\n"
"--- COMMITTERS\t(revision 4404)\n"
"+++ COMMITTERS\t(working copy)\n"

#: build/en/book.xml:19224(para)
msgid "See how your working copy's modifications compare against an older revision:"
msgstr "察看你的工作拷贝对旧的修订版本的修改："

#: build/en/book.xml:19227(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff -r 3900 COMMITTERS \n"
"Index: COMMITTERS\n"
"===================================================================\n"
"--- COMMITTERS\t(revision 3900)\n"
"+++ COMMITTERS\t(working copy)\n"
msgstr ""
"\n"
"$ svn diff -r 3900 COMMITTERS \n"
"Index: COMMITTERS\n"
"===================================================================\n"
"--- COMMITTERS\t(revision 3900)\n"
"+++ COMMITTERS\t(working copy)\n"

#: build/en/book.xml:19235(para)
msgid "Compare revision 3000 to revision 3500 using <quote>@</quote> syntax:"
msgstr "使用<quote>@</quote>语法与修订版本3000和35000比较："

#: build/en/book.xml:19238(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff http://svn.collab.net/repos/svn/trunk/COMMITTERS@3000 http://svn.collab.net/repos/svn/trunk/COMMITTERS@3500\n"
"Index: COMMITTERS\n"
"===================================================================\n"
"--- COMMITTERS\t(revision 3000)\n"
"+++ COMMITTERS\t(revision 3500)\n"
"…\n"
msgstr ""
"\n"
"$ svn diff http://svn.collab.net/repos/svn/trunk/COMMITTERS@3000 http://svn.collab.net/repos/svn/trunk/COMMITTERS@3500\n"
"Index: COMMITTERS\n"
"===================================================================\n"
"--- COMMITTERS\t(revision 3000)\n"
"+++ COMMITTERS\t(revision 3500)\n"
"…\n"

#: build/en/book.xml:19247(para)
msgid "Compare revision 3000 to revision 3500 using range notation (you only pass the one URL in this case):"
msgstr "使用范围符号来比较修订版本3000和3500（在这种情况下只能传递一个URL）："

#: build/en/book.xml:19251(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk/COMMITTERS\n"
"Index: COMMITTERS\n"
"===================================================================\n"
"--- COMMITTERS\t(revision 3000)\n"
"+++ COMMITTERS\t(revision 3500)\n"
msgstr ""
"\n"
"$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk/COMMITTERS\n"
"Index: COMMITTERS\n"
"===================================================================\n"
"--- COMMITTERS\t(revision 3000)\n"
"+++ COMMITTERS\t(revision 3500)\n"

#: build/en/book.xml:19260(para)
msgid "Compare revision 3000 to revision 3500 of all files in <filename moreinfo=\"none\">trunk</filename> using range notation:"
msgstr "使用范围符号比较修订版本3000和3500<filename moreinfo=\"none\">trunk</filename>中的所有文件："

#: build/en/book.xml:19263(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk\n"
"          "
msgstr ""
"\n"
"$ svn diff -r 3000:3500 http://svn.collab.net/repos/svn/trunk\n"
"          "

#: build/en/book.xml:19268(para)
msgid "Compare revision 3000 to revision 3500 of only three files in <filename moreinfo=\"none\">trunk</filename> using range notation:"
msgstr "使用范围符号比较修订版本3000和3500<filename moreinfo=\"none\">trunk</filename>中的三个文件："

#: build/en/book.xml:19272(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff -r 3000:3500 --old http://svn.collab.net/repos/svn/trunk COMMITTERS README HACKING\n"
"          "
msgstr ""
"\n"
"$ svn diff -r 3000:3500 --old http://svn.collab.net/repos/svn/trunk COMMITTERS README HACKING\n"
"          "

#: build/en/book.xml:19276(para)
msgid "If you have a working copy, you can obtain the differences without typing in the long URLs:"
msgstr "如果你有工作拷贝，你不必输入这么长的URL："

#: build/en/book.xml:19279(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff -r 3000:3500 COMMITTERS \n"
"Index: COMMITTERS\n"
"===================================================================\n"
"--- COMMITTERS\t(revision 3000)\n"
"+++ COMMITTERS\t(revision 3500)\n"
msgstr ""
"\n"
"$ svn diff -r 3000:3500 COMMITTERS \n"
"Index: COMMITTERS\n"
"===================================================================\n"
"--- COMMITTERS\t(revision 3000)\n"
"+++ COMMITTERS\t(revision 3500)\n"

#: build/en/book.xml:19287(para)
msgid "Use <option>--diff-cmd</option><replaceable>CMD</replaceable><option>-x</option> to pass arguments directly to the external diff program"
msgstr "使用<option>--diff-cmd</option><replaceable>CMD</replaceable><option>-x</option>来指定外部区别程序"

#: build/en/book.xml:19292(screen)
#, no-wrap
msgid ""
"\n"
"$ svn diff --diff-cmd /usr/bin/diff -x \"-i -b\" COMMITTERS \n"
"Index: COMMITTERS\n"
"===================================================================\n"
"0a1,2\n"
"&gt; This is a test\n"
"&gt; \n"
msgstr ""
"\n"
"$ svn diff --diff-cmd /usr/bin/diff -x \"-i -b\" COMMITTERS \n"
"Index: COMMITTERS\n"
"===================================================================\n"
"0a1,2\n"
"&gt; This is a test\n"
"&gt; \n"

#: build/en/book.xml:19309(tertiary)
msgid "export"
msgstr "export"

#: build/en/book.xml:19313(refname)
msgid "svn export"
msgstr "svn export"

#: build/en/book.xml:19314(refpurpose)
msgid "Export a clean directory tree."
msgstr "导出一个干净的目录树。"

#: build/en/book.xml:19318(programlisting)
#, no-wrap
msgid "svn export [-r REV] URL[@PEGREV] [PATH]"
msgstr "svn export [-r REV] URL[@PEGREV] [PATH]"

#: build/en/book.xml:19319(programlisting)
#, no-wrap
msgid "svn export [-r REV] PATH1[@PEGREV] [PATH2]"
msgstr "svn export [-r REV] PATH1[@PEGREV] [PATH2]"

#: build/en/book.xml:19324(para)
msgid "The first form exports a clean directory tree from the repository specified by URL, at revision <replaceable>REV</replaceable> if it is given, otherwise at <literal moreinfo=\"none\">HEAD</literal>, into <replaceable>PATH</replaceable>. If <replaceable>PATH</replaceable> is omitted, the last component of the <replaceable>URL</replaceable> is used for the local directory name."
msgstr "第一种从版本库导出干净工作目录树的形式是指定URL，如果指定了修订版本<replaceable>REV</replaceable>，会导出相应的版本，如果没有指定修订版本，则会导出<literal moreinfo=\"none\">HEAD</literal>，导出到<replaceable>PATH</replaceable>。如果省略<replaceable>PATH</replaceable>，<replaceable>URL</replaceable>的最后一部分会作为本地目录的名字。"

#: build/en/book.xml:19333(para)
msgid "The second form exports a clean directory tree from the working copy specified by <replaceable>PATH1</replaceable> into <replaceable>PATH2</replaceable>. All local changes will be preserved, but files not under version control will not be copied."
msgstr "从工作拷贝导出干净目录树的第二种形式是指定<replaceable>PATH1</replaceable>到<replaceable>PATH2</replaceable>，所有的本地修改将会保留，但是不再版本控制下的文件不会拷贝。"

#: build/en/book.xml:19348(para)
msgid "Local disk"
msgstr "本地磁盘"

#: build/en/book.xml:19353(para)
msgid "Only if exporting from a URL"
msgstr "只有当从URL导出时会访问"

#: build/en/book.xml:19359(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--quiet (-q)\n"
"--force\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--non-recursive (-N)\n"
"--config-dir DIR\n"
"--native-eol EOL\n"
"--ignore-externals\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--quiet (-q)\n"
"--force\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--non-recursive (-N)\n"
"--config-dir DIR\n"
"--native-eol EOL\n"
"--ignore-externals\n"

#: build/en/book.xml:19377(para)
msgid "Export from your working copy (doesn't print every file and directory):"
msgstr "从你的工作拷贝导出（不会打印每一个文件和目录）："

#: build/en/book.xml:19380(screen)
#, no-wrap
msgid ""
"\n"
"$ svn export a-wc my-export\n"
"Export complete.\n"
msgstr ""
"\n"
"$ svn export a-wc my-export\n"
"Export complete.\n"

#: build/en/book.xml:19385(para)
msgid "Export directly from the repository (prints every file and directory):"
msgstr "从版本库导出目录（打印所有的文件和目录）："

#: build/en/book.xml:19388(screen)
#, no-wrap
msgid ""
"\n"
"$ svn export file:///tmp/repos my-export\n"
"A  my-export/test\n"
"A  my-export/quiz\n"
"…\n"
"Exported revision 15.\n"
msgstr ""
"\n"
"$ svn export file:///tmp/repos my-export\n"
"A  my-export/test\n"
"A  my-export/quiz\n"
"…\n"
"Exported revision 15.\n"

#: build/en/book.xml:19396(para)
msgid "When rolling operating-system-specific release packages, it can be useful to export a tree which uses a specific EOL character for line endings. The <option>--native-eol</option> option will do this, but it only affects files that have <literal moreinfo=\"none\">svn:eol-style = native</literal> properties attached to them. For example, to export a tree with all CRLF line endings (possibly for a Windows .zip file distribution):"
msgstr "当使用操作系统特定的分发版本，使用特定的EOL字符作为行结束符号导出一棵树会非常有用。<option>--native-eol</option>选项会这样做，但是如果影响的文件拥有<literal moreinfo=\"none\">svn:eol-style = native</literal>属性，举个例子，导出一棵使用CRLF作为行结束的树（可能是为了做一个Windows的.zip文件分发版本）："

#: build/en/book.xml:19405(screen)
#, no-wrap
msgid ""
"\n"
"$ svn export file:///tmp/repos my-export --native-eol CRLF\n"
"A  my-export/test\n"
"A  my-export/quiz\n"
"…\n"
"Exported revision 15.\n"
msgstr ""
"\n"
"$ svn export file:///tmp/repos my-export --native-eol CRLF\n"
"A  my-export/test\n"
"A  my-export/quiz\n"
"…\n"
"Exported revision 15.\n"

#: build/en/book.xml:19423(tertiary) build/en/book.xml:22323(tertiary)
#: build/en/book.xml:23373(tertiary)
msgid "help"
msgstr "help"

#: build/en/book.xml:19427(refname)
msgid "svn help"
msgstr "svn help"

#: build/en/book.xml:19432(programlisting)
#, no-wrap
msgid "svn help [SUBCOMMAND...]"
msgstr "svn help [SUBCOMMAND...]"

#: build/en/book.xml:19437(para)
msgid "This is your best friend when you're using Subversion and this book isn't within reach!"
msgstr "当手边没有这本书时，这是你使用Subversion最好的朋友！"

#: build/en/book.xml:19443(para) build/en/book.xml:22345(para)
#: build/en/book.xml:23394(para)
msgid "?, h"
msgstr "?, h"

#: build/en/book.xml:19444(para)
msgid "The options <option>-?</option>, <option>-h</option> and <option>--help</option> have the same effect as using the <command moreinfo=\"none\">help</command> subcommand."
msgstr "不访问"

#: build/en/book.xml:19462(screen)
#, no-wrap
msgid ""
"\n"
"--version\n"
"--quiet (-q)\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--version\n"
"--quiet (-q)\n"

#: build/en/book.xml:19475(tertiary)
msgid "import"
msgstr "import"

#: build/en/book.xml:19480(refpurpose)
msgid "Commit an unversioned file or tree into the repository."
msgstr "递归提交一个路径的拷贝到版本库。"

#: build/en/book.xml:19485(programlisting)
#, no-wrap
msgid "svn import [PATH] URL"
msgstr "svn import [PATH] URL"

#: build/en/book.xml:19490(para)
msgid "Recursively commit a copy of <replaceable>PATH</replaceable> to <replaceable>URL</replaceable>. If <replaceable>PATH</replaceable> is omitted <quote><filename moreinfo=\"none\">.</filename></quote> is assumed. Parent directories are created in the repository as necessary."
msgstr "递归提交一个路径的拷贝到URL。如果省略<replaceable>PATH</replaceable>，默认是<quote><filename moreinfo=\"none\">.</filename></quote>。版本库中对应的父目录必须已经创建。"

#: build/en/book.xml:19506(para)
msgid "Repository"
msgstr "版本库"

#: build/en/book.xml:19517(screen)
#, no-wrap
msgid ""
"\n"
"--message (-m) TEXT\n"
"--file (-F) FILE\n"
"--quiet (-q)\n"
"--non-recursive (-N)\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--force-log\n"
"--editor-cmd EDITOR\n"
"--encoding ENC\n"
"--config-dir DIR\n"
"--auto-props\n"
"--no-auto-props\n"
"--ignore-externals\n"
msgstr ""
"\n"
"--message (-m) TEXT\n"
"--file (-F) FILE\n"
"--quiet (-q)\n"
"--non-recursive (-N)\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--force-log\n"
"--editor-cmd EDITOR\n"
"--encoding ENC\n"
"--config-dir DIR\n"
"--auto-props\n"
"--no-auto-props\n"
"--ignore-externals\n"

#: build/en/book.xml:19539(para)
msgid "This imports the local directory <filename moreinfo=\"none\">myproj</filename> into the root of your repository:"
msgstr "这会导入本地目录<filename moreinfo=\"none\">myproj</filename>到版本库的 根目录："

#: build/en/book.xml:19542(screen)
#, no-wrap
msgid ""
"\n"
"$ svn import -m \"New import\" myproj http://svn.red-bean.com/repos/test\n"
"Adding         myproj/sample.txt\n"
"…\n"
"Transmitting file data .........\n"
"Committed revision 16.\n"
msgstr ""
"\n"
"$ svn import -m \"New import\" myproj http://svn.red-bean.com/repos/test\n"
"Adding         myproj/sample.txt\n"
"…\n"
"Transmitting file data .........\n"
"Committed revision 16.\n"

#: build/en/book.xml:19550(para)
msgid "This imports the local directory <filename moreinfo=\"none\">myproj</filename> into <filename moreinfo=\"none\">trunk/misc</filename> in your repository. The directory <filename moreinfo=\"none\">trunk/misc</filename> need not exist before you import into it—<command moreinfo=\"none\">svn import</command> will recursively create directories for you:"
msgstr "这将本地目录<filename moreinfo=\"none\">myproj</filename>导入到版本库的<filename moreinfo=\"none\">trunk/misc</filename>，<filename moreinfo=\"none\">trunk/misc</filename>在导入之前不需要存在—<command moreinfo=\"none\">svn import</command>会递归的为你创建目录："

#: build/en/book.xml:19555(screen)
#, no-wrap
msgid ""
"\n"
"$ svn import -m \"New import\" myproj \\\n"
"    http://svn.red-bean.com/repos/test/trunk/misc/myproj\n"
"Adding         myproj/sample.txt\n"
"…\n"
"Transmitting file data .........\n"
"Committed revision 19.\n"
msgstr ""
"\n"
"$ svn import -m \"New import\" myproj \\\n"
"    http://svn.red-bean.com/repos/test/trunk/misc/myproj\n"
"Adding         myproj/sample.txt\n"
"…\n"
"Transmitting file data .........\n"
"Committed revision 19.\n"

#: build/en/book.xml:19564(para)
msgid "After importing data, note that the original tree is <emphasis>not</emphasis> under version control. To start working, you still need to <command moreinfo=\"none\">svn checkout</command> a fresh working copy of the tree."
msgstr "在导入数据之后，你会发现原先的目录树<emphasis>并没有</emphasis>纳入版本控制，为了开始工作，你还是要运行<command moreinfo=\"none\">svn checkout</command>得到一个干净的目录树工作拷贝。"

#: build/en/book.xml:19577(tertiary) build/en/book.xml:23469(tertiary)
msgid "info"
msgstr "info"

#: build/en/book.xml:19581(refname)
msgid "svn info"
msgstr "svn info"

#: build/en/book.xml:19582(refpurpose)
msgid "Display information about a local or remote item."
msgstr "显示本地或远程条目的信息。"

#: build/en/book.xml:19587(programlisting)
#, no-wrap
msgid "svn info [TARGET...]"
msgstr "svn info [TARGET...]"

#: build/en/book.xml:19592(para)
msgid "Print information about the working copy paths or URLs specified. The information shown for both may include:"
msgstr "打印你的工作拷贝路径和URL的信息，包括："

#: build/en/book.xml:19597(para)
msgid "Path"
msgstr "路经"

#: build/en/book.xml:19598(para)
msgid "Name"
msgstr "名称"

#: build/en/book.xml:19599(para)
msgid "URL"
msgstr "URL"

#: build/en/book.xml:19600(para)
msgid "Repository Root"
msgstr "版本库的根"

#: build/en/book.xml:19601(para)
msgid "Repository UUID"
msgstr "版本库的UUID"

#: build/en/book.xml:19603(para)
msgid "Node Kind"
msgstr "节点类型"

#: build/en/book.xml:19604(para)
msgid "Last Changed Author"
msgstr "最后修改的作者"

#: build/en/book.xml:19605(para)
msgid "Last Changed Revision"
msgstr "最后修改的修订版本"

#: build/en/book.xml:19606(para)
msgid "Last Changed Date"
msgstr "最后修改的日期"

#: build/en/book.xml:19607(para)
msgid "Lock Token"
msgstr "锁定令牌"

#: build/en/book.xml:19608(para)
msgid "Lock Owner"
msgstr "锁定拥有者"

#: build/en/book.xml:19609(para)
msgid "Lock Created (date)"
msgstr "锁定创建时间"

#: build/en/book.xml:19610(para)
msgid "Lock Expires (date)"
msgstr "Lock Expires (date)"

#: build/en/book.xml:19613(para)
msgid "Additional kinds of information available only for working copy paths are:"
msgstr "Additional kinds of information available only for working copy paths are:"

#: build/en/book.xml:19617(para)
msgid "Schedule"
msgstr "Schedule"

#: build/en/book.xml:19618(para)
msgid "Copied From URL"
msgstr "Copied From URL"

#: build/en/book.xml:19619(para)
msgid "Copied From Rev"
msgstr "Copied From Rev"

#: build/en/book.xml:19620(para)
msgid "Text Last Updated"
msgstr "Text Last Updated"

#: build/en/book.xml:19621(para)
msgid "Properties Last Updated"
msgstr "Properties Last Updated"

#: build/en/book.xml:19622(para)
msgid "Checksum"
msgstr "Checksum"

#: build/en/book.xml:19623(para)
msgid "Conflict Previous Base File"
msgstr "Conflict Previous Base File"

#: build/en/book.xml:19624(para)
msgid "Conflict Previous Working File"
msgstr "Conflict Previous Working File"

#: build/en/book.xml:19625(para)
msgid "Conflict Current Base File"
msgstr "Conflict Current Base File"

#: build/en/book.xml:19626(para)
msgid "Conflict Properties File"
msgstr "Conflict Properties File"

#: build/en/book.xml:19648(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--recursive (-R)\n"
"--targets FILENAME\n"
"--incremental\n"
"--xml\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--recursive (-R)\n"
"--targets FILENAME\n"
"--incremental\n"
"--xml\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"

#: build/en/book.xml:19665(para)
msgid "<command moreinfo=\"none\">svn info</command> will show you all the useful information that it has for items in your working copy. It will show information for files:"
msgstr "<command moreinfo=\"none\">svn info</command>会展示所有项目的所有有用信息，它会显示文件的信息："

#: build/en/book.xml:19669(screen)
#, no-wrap
msgid ""
"\n"
"$ svn info foo.c\n"
"Path: foo.c\n"
"Name: foo.c\n"
"URL: http://svn.red-bean.com/repos/test/foo.c\n"
"Repository Root: http://svn.red-bean.com/repos/test\n"
"Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25\n"
"Revision: 4417\n"
"Node Kind: file\n"
"Schedule: normal\n"
"Last Changed Author: sally\n"
"Last Changed Rev: 20\n"
"Last Changed Date: 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003)\n"
"Text Last Updated: 2003-01-16 21:18:16 -0600 (Thu, 16 Jan 2003)\n"
"Properties Last Updated: 2003-01-13 21:50:19 -0600 (Mon, 13 Jan 2003)\n"
"Checksum: d6aeb60b0662ccceb6bce4bac344cb66\n"
msgstr ""
"\n"
"$ svn info foo.c\n"
"Path: foo.c\n"
"Name: foo.c\n"
"URL: http://svn.red-bean.com/repos/test/foo.c\n"
"Repository Root: http://svn.red-bean.com/repos/test\n"
"Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25\n"
"Revision: 4417\n"
"Node Kind: file\n"
"Schedule: normal\n"
"Last Changed Author: sally\n"
"Last Changed Rev: 20\n"
"Last Changed Date: 2003-01-13 16:43:13 -0600 (Mon, 13 Jan 2003)\n"
"Text Last Updated: 2003-01-16 21:18:16 -0600 (Thu, 16 Jan 2003)\n"
"Properties Last Updated: 2003-01-13 21:50:19 -0600 (Mon, 13 Jan 2003)\n"
"Checksum: /3L38YwzhT93BWvgpdF6Zw==\n"

#: build/en/book.xml:19687(para)
msgid "It will also show information for directories:"
msgstr "它也会展示目录的信息："

#: build/en/book.xml:19689(screen)
#, no-wrap
msgid ""
"\n"
"$ svn info vendors\n"
"Path: vendors\n"
"URL: http://svn.red-bean.com/repos/test/vendors\n"
"Repository Root: http://svn.red-bean.com/repos/test\n"
"Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25\n"
"Revision: 19\n"
"Node Kind: directory\n"
"Schedule: normal\n"
"Last Changed Author: harry\n"
"Last Changed Rev: 19\n"
"Last Changed Date: 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003)\n"
"Properties Last Updated: 2003-01-16 23:39:02 -0600 (Thu, 16 Jan 2003)\n"
msgstr ""
"\n"
"$ svn info vendors\n"
"Path: vendors\n"
"URL: http://svn.red-bean.com/repos/test/vendors\n"
"Repository Root: http://svn.red-bean.com/repos/test\n"
"Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25\n"
"Revision: 19\n"
"Node Kind: directory\n"
"Schedule: normal\n"
"Last Changed Author: harry\n"
"Last Changed Rev: 19\n"
"Last Changed Date: 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003)\n"

#: build/en/book.xml:19704(para)
msgid "<command moreinfo=\"none\">svn info</command> also acts on URLs (also note that the file readme.doc in this example is locked, so lock information is also provided):"
msgstr "<command moreinfo=\"none\">svn info</command>也可以针对URL操作（另外，可以注意一下例子中的readme.doc文件已经被锁定，所以也会显示锁定信息）："

#: build/en/book.xml:19708(screen)
#, no-wrap
msgid ""
"\n"
"$ svn info http://svn.red-bean.com/repos/test/readme.doc\n"
"Path: readme.doc\n"
"Name: readme.doc\n"
"URL: http://svn.red-bean.com/repos/test/readme.doc\n"
"Repository Root: http://svn.red-bean.com/repos/test\n"
"Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25\n"
"Revision: 1\n"
"Node Kind: file\n"
"Schedule: normal\n"
"Last Changed Author: sally\n"
"Last Changed Rev: 42\n"
"Last Changed Date: 2003-01-14 23:21:19 -0600 (Tue, 14 Jan 2003)\n"
"Lock Token: opaquelocktoken:14011d4b-54fb-0310-8541-dbd16bd471b2\n"
"Lock Owner: harry\n"
"Lock Created: 2003-01-15 17:35:12 -0600 (Wed, 15 Jan 2003)\n"
"Lock Comment (1 line):\n"
"My test lock comment\n"
msgstr ""
"\n"
"$ svn info http://svn.red-bean.com/repos/test/readme.doc\n"
"Path: readme.doc\n"
"Name: readme.doc\n"
"URL: http://svn.red-bean.com/repos/test/readme.doc\n"
"Repository Root: http://svn.red-bean.com/repos/test\n"
"Repository UUID: 5e7d134a-54fb-0310-bd04-b611643e5c25\n"
"Revision: 1\n"
"Node Kind: file\n"
"Schedule: normal\n"
"Last Changed Author: sally\n"
"Last Changed Rev: 42\n"
"Last Changed Date: 2003-01-14 23:21:19 -0600 (Tue, 14 Jan 2003)\n"
"Text Last Updated: 2003-01-14 23:21:19 -0600 (Tue, 14 Jan 2003)\n"
"Checksum: d41d8cd98f00b204e9800998ecf8427e\n"
"Lock Token: opaquelocktoken:14011d4b-54fb-0310-8541-dbd16bd471b2\n"
"Lock Owner: harry\n"
"Lock Created: 2003-01-15 17:35:12 -0600 (Wed, 15 Jan 2003)\n"

#: build/en/book.xml:19738(tertiary)
msgid "list"
msgstr "list"

#: build/en/book.xml:19743(refpurpose)
msgid "List directory entries in the repository."
msgstr "列出版本库目录的条目。"

#: build/en/book.xml:19747(programlisting)
#, no-wrap
msgid "svn list [TARGET[@REV]...]"
msgstr "svn list [TARGET[@REV]...]"

#: build/en/book.xml:19752(para)
msgid "List each <replaceable>TARGET</replaceable> file and the contents of each <replaceable>TARGET</replaceable> directory as they exist in the repository. If <replaceable>TARGET</replaceable> is a working copy path, the corresponding repository URL will be used."
msgstr "列出每一个<replaceable>TARGET</replaceable>文件和<replaceable>TARGET</replaceable>目录的内容，如果<replaceable>TARGET</replaceable>是工作拷贝路径，会使用对应的版本库URL。"

#: build/en/book.xml:19758(para)
msgid "The default <replaceable>TARGET</replaceable> is <quote><filename moreinfo=\"none\">.</filename></quote>, meaning the repository URL of the current working copy directory."
msgstr "缺省的<replaceable>TARGET</replaceable>是<quote><filename moreinfo=\"none\">.</filename></quote>，意味着当前工作拷贝的版本库URL。"

#: build/en/book.xml:19763(para)
msgid "With <option>--verbose</option>, the following fields show the status of the item:"
msgstr "伴随<option>--verbose</option>，如下的字段展示了项目的状态："

#: build/en/book.xml:19767(para)
msgid "Revision number of the last commit"
msgstr "最后一次提交的修订版本号"

#: build/en/book.xml:19768(para)
msgid "Author of the last commit"
msgstr "最后一次提交的作者"

#: build/en/book.xml:19769(para)
msgid "Size (in bytes)"
msgstr "大小（单位字节）"

#: build/en/book.xml:19770(para)
msgid "Date and time of the last commit"
msgstr "最后提交的日期时间"

#: build/en/book.xml:19774(para)
msgid "With <option>--xml</option>, output is in XML format (with a header and an enclosing document element unless <option>--incremental</option> is also specified). All of the information is present; the <option>--verbose</option> option is not accepted."
msgstr "使用选项<option>--xml</option>，输出是XML格式（如果没有指定<option>--incremental</option>，会包括一个头和一个围绕的元素）。会展示所有的信息；不接受<option>--verbose</option>选项。"

#: build/en/book.xml:19783(para)
msgid "ls"
msgstr "ls"

#: build/en/book.xml:19799(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--verbose (-v)\n"
"--recursive (-R)\n"
"--incremental\n"
"--xml\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--verbose (-v)\n"
"--recursive (-R)\n"
"--incremental\n"
"--xml\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"

#: build/en/book.xml:19816(para)
msgid "<command moreinfo=\"none\">svn list</command> is most useful if you want to see what files a repository has without downloading a working copy:"
msgstr "如果你希望在没有下载工作拷贝时察看版本库有哪些文件，<command moreinfo=\"none\">svn list</command>会非常有用："

#: build/en/book.xml:19820(screen)
#, no-wrap
msgid ""
"\n"
"$ svn list http://svn.red-bean.com/repos/test/support\n"
"README.txt\n"
"INSTALL\n"
"examples/\n"
"…\n"
msgstr ""
"\n"
"$ svn list http://svn.red-bean.com/repos/test/support\n"
"README.txt\n"
"INSTALL\n"
"examples/\n"
"…\n"

#: build/en/book.xml:19828(para)
msgid "You can pass the <option>--verbose</option> switch for additional information, rather like the UNIX command <command moreinfo=\"none\">ls -l</command>:"
msgstr "你也可以传递<option>--verbose</option>选项来得到额外信息，非常类似UNIX的<command moreinfo=\"none\">ls -l</command>命令："

#: build/en/book.xml:19832(screen)
#, no-wrap
msgid ""
"\n"
"$ svn list --verbose file:///tmp/repos\n"
"     16 sally         28361 Jan 16 23:18 README.txt\n"
"     27 sally             0 Jan 18 15:27 INSTALL\n"
"     24 harry               Jan 18 11:27 examples/\n"
msgstr ""
"\n"
"$ svn list --verbose file:///tmp/repos\n"
"     16 sally         28361 Jan 16 23:18 README.txt\n"
"     27 sally             0 Jan 18 15:27 INSTALL\n"
"     24 harry               Jan 18 11:27 examples/\n"

#: build/en/book.xml:19839(para)
#, fuzzy
msgid "For further details, see <xref linkend=\"svn.tour.history.browsing.list\"/>."
msgstr "更多细节见<xref linkend=\"svn.tour.history.list\"/>。"

#: build/en/book.xml:19850(tertiary) build/en/book.xml:23520(tertiary)
msgid "lock"
msgstr "lock"

#: build/en/book.xml:19854(refname)
msgid "svn lock"
msgstr "svn lock"

#: build/en/book.xml:19855(refpurpose)
msgid "Lock working copy paths or URLs in the repository, so that no other user can commit changes to them."
msgstr "锁定版本库的工作拷贝路径或URL，所以没有其他用户可以提交这些文件的修改。"

#: build/en/book.xml:19861(programlisting)
#, no-wrap
msgid "svn lock TARGET..."
msgstr "Synopsis"

#: build/en/book.xml:19866(para)
msgid "Lock each <replaceable>TARGET</replaceable>. If any <replaceable>TARGET</replaceable> is already locked by another user, print a warning and continue locking the rest of the <replaceable>TARGET</replaceable>s. Use <option>--force</option> to steal a lock from another user or working copy."
msgstr "svn lock TARGET..."

#: build/en/book.xml:19882(para) build/en/book.xml:21762(para)
msgid "Working Copy, Repository"
msgstr "锁定每个<replaceable>TARGET</replaceable>。如果任何<replaceable>TARGET</replaceable>已经被另一个用户锁定，则会打印警告信息并且继续锁定剩下的<replaceable>TARGET</replaceable>。可以使用<option>--force</option>从其它用户来窃取锁定。"

#: build/en/book.xml:19893(screen)
#, no-wrap
msgid ""
"\n"
"--targets FILENAME\n"
"--message (-m) TEXT\n"
"--file (-F) FILE\n"
"--force-log\n"
"--encoding ENC\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
"--force\n"
msgstr ""
"\n"
"--targets FILENAME\n"
"--message (-m) TEXT\n"
"--file (-F) FILE\n"
"--force-log\n"
"--encoding ENC\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
"--force\n"

#: build/en/book.xml:19911(para)
msgid "Lock two files in your working copy:"
msgstr "在工作拷贝锁定两个文件："

#: build/en/book.xml:19913(screen)
#, no-wrap
msgid ""
"\n"
"\n"
"$ svn lock tree.jpg house.jpg\n"
"'tree.jpg' locked by user 'harry'.\n"
"'house.jpg' locked by user 'harry'.\n"
msgstr ""
"\n"
"\n"
"$ svn lock tree.jpg house.jpg\n"
"'tree.jpg' locked by user 'harry'.\n"
"'house.jpg' locked by user 'harry'.\n"

#: build/en/book.xml:19920(para)
msgid "Lock a file in your working copy that is currently locked by another user:"
msgstr "锁定工作拷贝的一个被其它用户锁定的文件："

#: build/en/book.xml:19923(screen)
#, no-wrap
msgid ""
"\n"
"$ svn lock tree.jpg\n"
"svn: warning: Path '/tree.jpg is already locked by user 'harry in \\\n"
"     filesystem '/svn/repos/db'\n"
"\n"
"$ svn lock --force foo\n"
"'tree.jpg' locked by user 'sally'.\n"
msgstr ""
"\n"
"$ svn lock tree.jpg\n"
"svn: warning: Path '/tree.jpg is already locked by user 'harry in \\\n"
"     filesystem '/svn/repos/db'\n"
"\n"
"$ svn lock --force foo\n"
"'tree.jpg' locked by user 'sally'.\n"

#: build/en/book.xml:19932(para)
msgid "Lock a file without a working copy:"
msgstr "没有工作拷贝的情况下锁定文件："

#: build/en/book.xml:19934(screen)
#, no-wrap
msgid ""
"\n"
"$ svn lock http://svn.red-bean.com/repos/test/tree.jpg\n"
"'tree.jpg' locked by user 'sally'.\n"
msgstr ""
"\n"
"$ svn lock http://svn.red-bean.com/repos/test/tree.jpg\n"
"'tree.jpg' locked by user 'sally'.\n"

#: build/en/book.xml:19939(para) build/en/book.xml:21813(para)
msgid "For further details, see <xref linkend=\"svn.advanced.locking\"/>."
msgstr "更多细节见<xref linkend=\"svn.advanced.locking\"/>。"

#: build/en/book.xml:19950(tertiary) build/en/book.xml:23572(tertiary)
msgid "log"
msgstr "log"

#: build/en/book.xml:19955(refpurpose)
msgid "Display commit log messages."
msgstr "显示提交日志信息。"

#: build/en/book.xml:19959(programlisting)
#, no-wrap
msgid "svn log [PATH]"
msgstr "svn log [PATH]"

#: build/en/book.xml:19960(programlisting)
#, no-wrap
msgid "svn log URL [PATH...]"
msgstr "svn log URL [PATH...]"

#: build/en/book.xml:19965(para)
msgid "The default target is the path of your current directory. If no arguments are supplied, <command moreinfo=\"none\">svn log</command> shows the log messages for all files and directories inside of (and including) the current working directory of your working copy. You can refine the results by specifying a path, one or more revisions, or any combination of the two. The default revision range for a local path is <literal moreinfo=\"none\">BASE:1</literal>."
msgstr "缺省目标是你的当前目录的路径，如果没有提供参数，<command moreinfo=\"none\">svn log</command>会显示当前目录下的所有文件和目录的日志信息，你可以通过指定路径来精炼结果，一个或多个修订版本，或者是任何两个的组合。对于本地路径的缺省修订版本范围<literal moreinfo=\"none\">BASE:1</literal>。"

#: build/en/book.xml:19974(para)
msgid "If you specify a URL alone, then it prints log messages for everything that the URL contains. If you add paths past the URL, only messages for those paths under that URL will be printed. The default revision range for a URL is <literal moreinfo=\"none\">HEAD:1</literal>."
msgstr "如果你只是指定一个URL，就会打印这个URL上所有的日志信息，如果添加部分路径，只有这条路径下的URL信息会被打印，URL缺省的修订版本范围是<literal moreinfo=\"none\">HEAD:1</literal>。"

#: build/en/book.xml:19980(para)
msgid "With <option>--verbose</option>, <command moreinfo=\"none\">svn log</command> will also print all affected paths with each log message. With <option>--quiet</option>, <command moreinfo=\"none\">svn log</command> will not print the log message body itself (this is compatible with <option>--verbose</option>)."
msgstr "<command moreinfo=\"none\">svn log</command>使用<option>--verbose</option>选项也会打印所有影响路径的日志信息，使用<option>--quiet</option>选项不会打印日志信息正文本身（这与<option>--verbose</option>协调一致）。"

#: build/en/book.xml:19986(para)
msgid "Each log message is printed just once, even if more than one of the affected paths for that revision were explicitly requested. Logs follow copy history by default. Use <option>--stop-on-copy</option> to disable this behavior, which can be useful for determining branch points."
msgstr "每个日志信息只会打印一次，即使是那些明确请求不止一次的路径，日志会跟随在拷贝过程中，使用<option>--stop-on-copy</option>可以关闭这个特性，可以用来监测分支点。"

#: build/en/book.xml:20012(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--quiet (-q)\n"
"--verbose (-v)\n"
"--targets FILENAME\n"
"--stop-on-copy\n"
"--incremental\n"
"--limit NUM\n"
"--xml\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--quiet (-q)\n"
"--verbose (-v)\n"
"--targets FILENAME\n"
"--stop-on-copy\n"
"--incremental\n"
"--limit NUM\n"
"--xml\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"

#: build/en/book.xml:20032(para)
msgid "You can see the log messages for all the paths that changed in your working copy by running <command moreinfo=\"none\">svn log</command> from the top:"
msgstr "你可以在顶级目录运行<command moreinfo=\"none\">svn log</command>看到工作拷贝中所有修改的路径的日志信息："

#: build/en/book.xml:20036(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log\n"
"------------------------------------------------------------------------\n"
"r20 | harry | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line\n"
"\n"
"Tweak.\n"
"------------------------------------------------------------------------\n"
"r17 | sally | 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003) | 2 lines\n"
"…\n"
msgstr ""
"\n"
"$ svn log\n"
"------------------------------------------------------------------------\n"
"r20 | harry | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line\n"
"\n"
"Tweak.\n"
"------------------------------------------------------------------------\n"
"r17 | sally | 2003-01-16 23:21:19 -0600 (Thu, 16 Jan 2003) | 2 lines\n"
"…\n"

#: build/en/book.xml:20047(para)
msgid "Examine all log messages for a particular file in your working copy:"
msgstr "检验一个特定文件所有的日志信息："

#: build/en/book.xml:20050(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log foo.c\n"
"------------------------------------------------------------------------\n"
"r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line\n"
"\n"
"Added defines.\n"
"------------------------------------------------------------------------\n"
"r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines\n"
"…\n"
msgstr ""
"\n"
"$ svn log foo.c\n"
"------------------------------------------------------------------------\n"
"r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line\n"
"\n"
"Added defines.\n"
"------------------------------------------------------------------------\n"
"r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines\n"
"…\n"

#: build/en/book.xml:20061(para)
msgid "If you don't have a working copy handy, you can log a URL:"
msgstr "如果你手边没有工作拷贝，你可以查看一个URL的日志："

#: build/en/book.xml:20064(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log http://svn.red-bean.com/repos/test/foo.c\n"
"------------------------------------------------------------------------\n"
"r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line\n"
"\n"
"Added defines.\n"
"------------------------------------------------------------------------\n"
"r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines\n"
"…\n"
msgstr ""
"\n"
"$ svn log http://svn.red-bean.com/repos/test/foo.c\n"
"------------------------------------------------------------------------\n"
"r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line\n"
"\n"
"Added defines.\n"
"------------------------------------------------------------------------\n"
"r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines\n"
"…\n"

#: build/en/book.xml:20075(para)
msgid "If you want several distinct paths underneath the same URL, you can use the <literal moreinfo=\"none\">URL [PATH...]</literal> syntax."
msgstr "如果你希望查看某个URL下面不同的多个路径，你可以使用<literal moreinfo=\"none\">URL [PATH...]</literal>语法。"

#: build/en/book.xml:20079(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log http://svn.red-bean.com/repos/test/ foo.c bar.c\n"
"------------------------------------------------------------------------\n"
"r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line\n"
"\n"
"Added defines.\n"
"------------------------------------------------------------------------\n"
"r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line\n"
"\n"
"Added new file bar.c\n"
"------------------------------------------------------------------------\n"
"r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines\n"
"…\n"
msgstr ""
"\n"
"$ svn log http://svn.red-bean.com/repos/test/ foo.c bar.c\n"
"------------------------------------------------------------------------\n"
"r32 | sally | 2003-01-13 00:43:13 -0600 (Mon, 13 Jan 2003) | 1 line\n"
"\n"
"Added defines.\n"
"------------------------------------------------------------------------\n"
"r31 | harry | 2003-01-10 12:25:08 -0600 (Fri, 10 Jan 2003) | 1 line\n"
"\n"
"Added new file bar.c\n"
"------------------------------------------------------------------------\n"
"r28 | sally | 2003-01-07 21:48:33 -0600 (Tue, 07 Jan 2003) | 3 lines\n"
"…\n"

#: build/en/book.xml:20094(para)
msgid "When you're concatenating the results of multiple calls to the log command, you may want to use the <option>--incremental</option> switch. <command moreinfo=\"none\">svn log</command> normally prints out a dashed line at the beginning of a log message, after each subsequent log message, and following the final log message. If you ran <command moreinfo=\"none\">svn log</command> on a range of two revisions, you would get this:"
msgstr "当你想¿接多个队日志命令的调用结果，你会希望使用<option>--incremental</option>选项。<command moreinfo=\"none\">svn log</command>通常会在日志信息的开头和每一小段间打印一行虚线，如果你对一段修订版本运行<command moreinfo=\"none\">svn log</command>，你会得到下面的结果："

#: build/en/book.xml:20102(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log -r 14:15\n"
"------------------------------------------------------------------------\n"
"r14 | …\n"
"\n"
"------------------------------------------------------------------------\n"
"r15 | …\n"
"\n"
"------------------------------------------------------------------------\n"
msgstr ""
"\n"
"$ svn log -r 14:15\n"
"------------------------------------------------------------------------\n"
"r14 | ...\n"
"\n"
"------------------------------------------------------------------------\n"
"r15 | ...\n"
"\n"
"------------------------------------------------------------------------\n"

#: build/en/book.xml:20113(para)
msgid "However, if you wanted to gather 2 non-sequential log messages into a file, you might do something like this:"
msgstr "然而，如果你希望收集两个不连续的日志信息到一个文件，你会这样做："

#: build/en/book.xml:20117(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log -r 14 &gt; mylog\n"
"$ svn log -r 19 &gt;&gt; mylog\n"
"$ svn log -r 27 &gt;&gt; mylog\n"
"$ cat mylog\n"
"------------------------------------------------------------------------\n"
"r14 | …\n"
"\n"
"------------------------------------------------------------------------\n"
"------------------------------------------------------------------------\n"
"r19 | …\n"
"\n"
"------------------------------------------------------------------------\n"
"------------------------------------------------------------------------\n"
"r27 | …\n"
"\n"
"------------------------------------------------------------------------\n"
msgstr ""
"\n"
"$ svn log -r 14 &gt; mylog\n"
"$ svn log -r 19 &gt;&gt; mylog\n"
"$ svn log -r 27 &gt;&gt; mylog\n"
"$ cat mylog\n"
"------------------------------------------------------------------------\n"
"r14 | ...\n"
"\n"
"------------------------------------------------------------------------\n"
"------------------------------------------------------------------------\n"
"r19 | ...\n"
"\n"
"------------------------------------------------------------------------\n"
"------------------------------------------------------------------------\n"
"r27 | ...\n"
"\n"
"------------------------------------------------------------------------\n"

#: build/en/book.xml:20136(para)
msgid "You can avoid the clutter of the double dashed lines in your output by using the incremental switch:"
msgstr "你可以使用incremental选项来避免两行虚线带来的混乱："

#: build/en/book.xml:20140(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log --incremental -r 14 &gt; mylog\n"
"$ svn log --incremental -r 19 &gt;&gt; mylog\n"
"$ svn log --incremental -r 27 &gt;&gt; mylog\n"
"$ cat mylog\n"
"------------------------------------------------------------------------\n"
"r14 | …\n"
"\n"
"------------------------------------------------------------------------\n"
"r19 | …\n"
"\n"
"------------------------------------------------------------------------\n"
"r27 | …\n"
msgstr ""
"\n"
"$ svn log --incremental -r 14 &gt; mylog\n"
"$ svn log --incremental -r 19 &gt;&gt; mylog\n"
"$ svn log --incremental -r 27 &gt;&gt; mylog\n"
"$ cat mylog\n"
"------------------------------------------------------------------------\n"
"r14 | ...\n"
"\n"
"------------------------------------------------------------------------\n"
"r19 | ...\n"
"\n"
"------------------------------------------------------------------------\n"
"r27 | ...\n"

#: build/en/book.xml:20155(para)
msgid "The <option>--incremental</option> switch provides similar output control when using the <option>--xml</option> switch."
msgstr "<option>--incremental</option>选项为<option>--xml</option>提供了一个相似的输出控制。"

#: build/en/book.xml:20162(para)
msgid "If you run <command moreinfo=\"none\">svn log</command> on a specific path and provide a specific revision and get no output at all"
msgstr "如果你在特定路径和修订版本运行<command moreinfo=\"none\">svn log</command>，输出结果为空"

#: build/en/book.xml:20166(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log -r 20 http://svn.red-bean.com/untouched.txt\n"
"------------------------------------------------------------------------\n"
msgstr ""
"\n"
"$ svn log -r 20 http://svn.red-bean.com/untouched.txt\n"
"------------------------------------------------------------------------\n"

#: build/en/book.xml:20171(para)
msgid "That just means that the path was not modified in that revision. If you log from the top of the repository, or know the file that changed in that revision, you can specify it explicitly:"
msgstr "这只意味着这条路径在那个修订版本没有修改，如果从版本库的顶级目录运行这个命令，或者是你知道那个修订版本修改了那个文件，你可以明确的指定它："

#: build/en/book.xml:20176(screen)
#, no-wrap
msgid ""
"\n"
"$ svn log -r 20 touched.txt \n"
"------------------------------------------------------------------------\n"
"r20 | sally | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line\n"
"\n"
"Made a change.\n"
"------------------------------------------------------------------------\n"
msgstr ""
"\n"
"$ svn log -r 20 touched.txt \n"
"------------------------------------------------------------------------\n"
"r20 | sally | 2003-01-17 22:56:19 -0600 (Fri, 17 Jan 2003) | 1 line\n"
"\n"
"Made a change.\n"
"------------------------------------------------------------------------\n"

#: build/en/book.xml:20194(tertiary)
msgid "merge"
msgstr "merge"

#: build/en/book.xml:20198(refname)
msgid "svn merge"
msgstr "svn merge"

#: build/en/book.xml:20199(refpurpose)
msgid "Apply the differences between two sources to a working copy path."
msgstr "应用两组源文件的差别到工作拷贝路径。"

#: build/en/book.xml:20204(programlisting)
#, no-wrap
msgid "svn merge sourceURL1[@N] sourceURL2[@M] [WCPATH]"
msgstr "svn merge sourceURL1[@N] sourceURL2[@M] [WCPATH]"

#: build/en/book.xml:20205(programlisting)
#, no-wrap
msgid "svn merge sourceWCPATH1@N sourceWCPATH2@M [WCPATH]"
msgstr "svn merge sourceWCPATH1@N sourceWCPATH2@M [WCPATH]"

#: build/en/book.xml:20206(programlisting)
#, no-wrap
msgid "svn merge -r N:M SOURCE[@REV] [WCPATH]"
msgstr "svn merge -r N:M SOURCE[@REV] [WCPATH]"

#: build/en/book.xml:20211(para)
msgid "In the first and second forms, the source paths (URLs in the first form, working copy paths in the second) are specified at revisions <replaceable>N</replaceable> and <replaceable>M</replaceable>. These are the two sources to be compared. The revisions default to <literal moreinfo=\"none\">HEAD</literal> if omitted."
msgstr "第一种和第二种形式里，源路径（第一种是URL，第二种是工作拷贝路径）用修订版本号<replaceable>N</replaceable>和<replaceable>M</replaceable>指定，这是要比较的两组源文件，如果省略修订版本号，缺省是<literal moreinfo=\"none\">HEAD</literal>。"

#: build/en/book.xml:20218(para)
msgid "In the third form, <replaceable>SOURCE</replaceable> can be a URL or working copy item, in which case the corresponding URL is used. This URL, at revisions <replaceable>N</replaceable> and <replaceable>M</replaceable>, defines the two sources to be compared."
msgstr "第三种形式，<replaceable>SOURCE</replaceable>可以是URL或者工作拷贝项目，与之对应的URL会被使用。在修订版本号<replaceable>N</replaceable>和<replaceable>M</replaceable>的URL定义了要比较的两组源。"

#: build/en/book.xml:20225(para)
msgid "<replaceable>WCPATH</replaceable> is the working copy path that will receive the changes. If <replaceable>WCPATH</replaceable> is omitted, a default value of <quote><filename moreinfo=\"none\">.</filename></quote> is assumed, unless the sources have identical basenames that match a file within <quote><filename moreinfo=\"none\">.</filename></quote>: in which case, the differences will be applied to that file."
msgstr "<replaceable>WCPATH</replaceable>是接收变化的工作拷贝路径，如果省略<replaceable>WCPATH</replaceable>，会假定缺省值<quote><filename moreinfo=\"none\">.</filename></quote>，除非源有相同基本名称与<quote><filename moreinfo=\"none\">.</filename></quote>中的某一文件名字匹配：在这种情况下，区别会应用到那个文件。"

#: build/en/book.xml:20233(para)
msgid "Unlike <command moreinfo=\"none\">svn diff</command>, the merge command takes the ancestry of a file into consideration when performing a merge operation. This is very important when you're merging changes from one branch into another and you've renamed a file on one branch but not the other."
msgstr "不像<command moreinfo=\"none\">svn diff</command>，合并操作在执行时会考虑文件的祖先，当你从一个分支合并到另一个分支，而这两个分支有各自重命名的文件时，这一点会非常重要。"

#: build/en/book.xml:20252(para)
msgid "Only if working with URLs"
msgstr "只有在对URL操作时会"

#: build/en/book.xml:20258(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--non-recursive (-N)\n"
"--quiet (-q)\n"
"--force\n"
"--dry-run\n"
"--diff3-cmd CMD\n"
"--ignore-ancestry\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--non-recursive (-N)\n"
"--quiet (-q)\n"
"--force\n"
"--dry-run\n"
"--diff3-cmd CMD\n"
"--ignore-ancestry\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"

#: build/en/book.xml:20277(para)
msgid "Merge a branch back into the trunk (assuming that you have a working copy of the trunk, and that the branch was created in revision 250):"
msgstr "将一个分支合并回主干（假定你有一份主干的工作拷贝，分支在修订版本250创建）："

#: build/en/book.xml:20281(screen)
#, no-wrap
msgid ""
"\n"
"$ svn merge -r 250:HEAD http://svn.red-bean.com/repos/branches/my-branch\n"
"U  myproj/tiny.txt\n"
"U  myproj/thhgttg.txt\n"
"U  myproj/win.txt\n"
"U  myproj/flo.txt\n"
msgstr ""
"\n"
"$ svn merge -r 250:HEAD http://svn.red-bean.com/repos/branches/my-branch\n"
"U  myproj/tiny.txt\n"
"U  myproj/thhgttg.txt\n"
"U  myproj/win.txt\n"
"U  myproj/flo.txt\n"

#: build/en/book.xml:20289(para)
msgid "If you branched at revision 23, and you want to merge changes on trunk into your branch, you could do this from inside the working copy of your branch:"
msgstr "如果你的分支在修订版本23，你希望将主干的修改合并到分支，你可以在你的工作拷贝的分支上这样做："

#: build/en/book.xml:20293(screen)
#, no-wrap
msgid ""
"\n"
"$ svn merge -r 23:30 file:///tmp/repos/trunk/vendors\n"
"U  myproj/thhgttg.txt\n"
"…\n"
msgstr ""
"\n"
"$ svn merge -r 23:30 file:///tmp/repos/trunk/vendors\n"
"U  myproj/thhgttg.txt\n"
"…\n"

#: build/en/book.xml:20299(para)
msgid "To merge changes to a single file:"
msgstr "合并一个单独文件的修改："

#: build/en/book.xml:20301(screen)
#, no-wrap
msgid ""
"\n"
"$ cd myproj\n"
"$ svn merge -r 30:31 thhgttg.txt \n"
"U  thhgttg.txt\n"
msgstr ""
"\n"
"$ cd myproj\n"
"$ svn merge -r 30:31 thhgttg.txt \n"
"U  thhgttg.txt\n"

#: build/en/book.xml:20315(tertiary)
msgid "mkdir"
msgstr "mkdir"

#: build/en/book.xml:20319(refname)
msgid "svn mkdir"
msgstr "svn mkdir"

#: build/en/book.xml:20320(refpurpose)
msgid "Create a new directory under version control."
msgstr "创建一个纳入版本控制的新目录。"

#: build/en/book.xml:20324(programlisting)
#, no-wrap
msgid "svn mkdir PATH..."
msgstr "svn mkdir PATH..."

#: build/en/book.xml:20325(programlisting)
#, no-wrap
msgid "svn mkdir URL..."
msgstr "svn mkdir URL..."

#: build/en/book.xml:20330(para)
msgid "Create a directory with a name given by the final component of the <replaceable>PATH</replaceable> or URL. A directory specified by a working copy <replaceable>PATH</replaceable> is scheduled for addition in the working copy. A directory specified by a URL is created in the repository via an immediate commit. Multiple directory URLs are committed atomically. In both cases all the intermediate directories must already exist."
msgstr "创建一个目录，名字是提供的<replaceable>PATH</replaceable>或者URL的最后一部分，工作拷贝<replaceable>PATH</replaceable>指定的目录会预定要添加，而通过URL指定的目录会作为一次立即提交在版本库建立。多个目录URL的提交是原子操作，在两种情况下，中介目录必须已经存在。"

#: build/en/book.xml:20348(para) build/en/book.xml:20458(para)
msgid "Working copy, repository if operating on a URL"
msgstr "如果是对URL操作则会影响版本库，否则是工作拷贝"

#: build/en/book.xml:20353(para) build/en/book.xml:20463(para)
#: build/en/book.xml:20548(para) build/en/book.xml:20627(para)
#: build/en/book.xml:20704(para) build/en/book.xml:20784(para)
#: build/en/book.xml:20880(para)
msgid "Only if operating on a URL"
msgstr "只有在对URl操作时会"

#: build/en/book.xml:20359(screen)
#, no-wrap
msgid ""
"\n"
"--message (-m) TEXT\n"
"--file (-F) FILE\n"
"--quiet (-q)\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--editor-cmd EDITOR\n"
"--encoding ENC\n"
"--force-log\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--message (-m) TEXT\n"
"--file (-F) FILE\n"
"--quiet (-q)\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--editor-cmd EDITOR\n"
"--encoding ENC\n"
"--force-log\n"
"--config-dir DIR\n"

#: build/en/book.xml:20377(para)
msgid "Create a directory in your working copy:"
msgstr "在工作拷贝创建一个目录："

#: build/en/book.xml:20379(screen)
#, no-wrap
msgid ""
"\n"
"$ svn mkdir newdir\n"
"A         newdir\n"
msgstr ""
"\n"
"$ svn mkdir newdir\n"
"A         newdir\n"

#: build/en/book.xml:20384(para)
msgid "Create one in the repository (instant commit, so a log message is required):"
msgstr "在版本库创建一个目录（立即提交，所以需要日志信息）："

#: build/en/book.xml:20387(screen)
#, no-wrap
msgid ""
"\n"
"$ svn mkdir -m \"Making a new dir.\" http://svn.red-bean.com/repos/newdir\n"
"\n"
"Committed revision 26.\n"
msgstr ""
"\n"
"$ svn mkdir -m \"Making a new dir.\" http://svn.red-bean.com/repos/newdir\n"
"\n"
"Committed revision 26.\n"

#: build/en/book.xml:20401(tertiary)
msgid "move"
msgstr "move"

#: build/en/book.xml:20406(refpurpose)
msgid "Move a file or directory."
msgstr "移动一个文件或目录。"

#: build/en/book.xml:20410(programlisting)
#, no-wrap
msgid "svn move SRC DST"
msgstr "svn move SRC DST"

#: build/en/book.xml:20415(para)
msgid "This command moves a file or directory in your working copy or in the repository."
msgstr "这个命令移动文件或目录到你的工作拷贝或者是版本库。"

#: build/en/book.xml:20419(para)
msgid "This command is equivalent to an <command moreinfo=\"none\">svn copy</command> followed by <command moreinfo=\"none\">svn delete</command>."
msgstr "这个命令同<command moreinfo=\"none\">svn copy</command>加一个<command moreinfo=\"none\">svn delete</command>等同。"

#: build/en/book.xml:20425(para)
msgid "Subversion does not support moving between working copies and URLs. In addition, you can only move files within a single repository—Subversion does not support cross-repository moving."
msgstr "Subversion不支持在工作拷贝和URL之间拷贝，此外，你只可以一个版本库内移动文件—Subversion不支持跨版本库的移动。"

#: build/en/book.xml:20436(para)
msgid "Move and schedule a file or directory for addition (with history)."
msgstr "移动和预订一个文件或目录将要添加（包含历史）。"

#: build/en/book.xml:20444(para)
msgid "Complete server-side rename."
msgstr "完全服务器端的重命名。"

#: build/en/book.xml:20453(para)
msgid "mv, rename, ren"
msgstr "mv, rename, ren"

#: build/en/book.xml:20469(screen)
#, no-wrap
msgid ""
"\n"
"--message (-m) TEXT\n"
"--file (-F) FILE\n"
"--revision (-r) REV\n"
"--quiet (-q)\n"
"--force\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--editor-cmd EDITOR\n"
"--encoding ENC\n"
"--force-log\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--message (-m) TEXT\n"
"--file (-F) FILE\n"
"--revision (-r) REV\n"
"--quiet (-q)\n"
"--force\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--editor-cmd EDITOR\n"
"--encoding ENC\n"
"--force-log\n"
"--config-dir DIR\n"

#: build/en/book.xml:20489(para)
msgid "Move a file in your working copy:"
msgstr "移动工作拷bede一个文件："

#: build/en/book.xml:20491(screen)
#, no-wrap
msgid ""
"\n"
"$ svn move foo.c bar.c\n"
"A         bar.c\n"
"D         foo.c\n"
msgstr ""
"\n"
"$ svn move foo.c bar.c\n"
"A         bar.c\n"
"D         foo.c\n"

#: build/en/book.xml:20497(para)
msgid "Move a file in the repository (an immediate commit, so it requires a commit message):"
msgstr "移动版本库中的一个文件（一个立即提交，所以需要提交信息）："

#: build/en/book.xml:20500(screen)
#, no-wrap
msgid ""
"\n"
"$ svn move -m \"Move a file\" http://svn.red-bean.com/repos/foo.c \\\n"
"                            http://svn.red-bean.com/repos/bar.c\n"
"\n"
"Committed revision 27.\n"
msgstr ""
"\n"
"$ svn move -m \"Move a file\" http://svn.red-bean.com/repos/foo.c \\\n"
"                            http://svn.red-bean.com/repos/bar.c\n"
"\n"
"Committed revision 27.\n"

#: build/en/book.xml:20515(tertiary)
msgid "propdel"
msgstr "propdel"

#: build/en/book.xml:20519(refname)
msgid "svn propdel"
msgstr "svn propdel"

#: build/en/book.xml:20520(refpurpose)
msgid "Remove a property from an item."
msgstr "删除一个项目的一个属性。"

#: build/en/book.xml:20524(programlisting)
#, no-wrap
msgid "svn propdel PROPNAME [PATH...]"
msgstr "svn propdel PROPNAME [PATH...]"

#: build/en/book.xml:20525(programlisting)
#, no-wrap
msgid "svn propdel PROPNAME --revprop -r REV [URL]"
msgstr "svn propdel PROPNAME --revprop -r REV [URL]"

#: build/en/book.xml:20530(para)
msgid "This removes properties from files, directories, or revisions. The first form removes versioned properties in your working copy, while the second removes unversioned remote properties on a repository revision."
msgstr "这会删除文件、目录或修订版本的属性。第一种形式是在工作拷贝删除版本化属性，第二种是在一个版本库修订版本中删除未版本化的属性。"

#: build/en/book.xml:20538(para)
msgid "pdel, pd"
msgstr "pdel, pd"

#: build/en/book.xml:20543(para) build/en/book.xml:20622(para)
#: build/en/book.xml:20699(para) build/en/book.xml:20779(para)
#: build/en/book.xml:20875(para)
msgid "Working copy, repository only if operating on a URL"
msgstr "只有在对URL操作时会 2"

#: build/en/book.xml:20554(screen)
#, no-wrap
msgid ""
"\n"
"--quiet (-q)\n"
"--recursive (-R)\n"
"--revision (-r) REV\n"
"--revprop\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--quiet (-q)\n"
"--recursive (-R)\n"
"--revision (-r) REV\n"
"--revprop\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"

#: build/en/book.xml:20570(para)
msgid "Delete a property from a file in your working copy"
msgstr "删除你的工作拷贝中一个文件的一个属性"

#: build/en/book.xml:20573(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propdel svn:mime-type  some-script\n"
"property 'svn:mime-type' deleted from 'some-script'.\n"
msgstr ""
"\n"
"$ svn propdel svn:mime-type  some-script\n"
"property 'svn:mime-type' deleted from 'some-script'.\n"

#: build/en/book.xml:20578(para)
msgid "Delete a revision property:"
msgstr "删除一个修订版本的属性："

#: build/en/book.xml:20580(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propdel --revprop -r 26 release-date \n"
"property 'release-date' deleted from repository revision '26'\n"
msgstr ""
"\n"
"$ svn propdel --revprop -r 26 release-date \n"
"property 'release-date' deleted from repository revision '26'\n"

#: build/en/book.xml:20593(tertiary)
msgid "propedit"
msgstr "propedit"

#: build/en/book.xml:20597(refname)
msgid "svn propedit"
msgstr "svn propedit"

#: build/en/book.xml:20598(refpurpose)
msgid "Edit the property of one or more items under version control."
msgstr "修改一个或多个版本控制之下文件的属性。"

#: build/en/book.xml:20603(programlisting)
#, no-wrap
msgid "svn propedit PROPNAME PATH..."
msgstr "svn propedit PROPNAME PATH..."

#: build/en/book.xml:20604(programlisting)
#, no-wrap
msgid "svn propedit PROPNAME --revprop -r REV [URL]"
msgstr "svn propedit PROPNAME --revprop -r REV [URL]"

#: build/en/book.xml:20609(para)
msgid "Edit one or more properties using your favorite editor. The first form edits versioned properties in your working copy, while the second edits unversioned remote properties on a repository revision."
msgstr "使用喜欢的编辑器编辑一个或多个属性，第一种形式是在工作拷贝编辑版本化的属性，第二种形式是远程编辑未版本化的版本库修订版本属性。"

#: build/en/book.xml:20617(para)
msgid "pedit, pe"
msgstr "pedit, pe"

#: build/en/book.xml:20633(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--revprop\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--encoding ENC\n"
"--editor-cmd EDITOR\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--revprop\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--encoding ENC\n"
"--editor-cmd EDITOR\n"
"--config-dir DIR\n"

#: build/en/book.xml:20649(para)
msgid "<command moreinfo=\"none\">svn propedit</command> makes it easy to modify properties that have multiple values:"
msgstr "<command moreinfo=\"none\">svn propedit</command>对修改多个值的属性非常简单："

#: build/en/book.xml:20652(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propedit svn:keywords  foo.c \n"
"    &lt;svn will launch your favorite editor here, with a buffer open\n"
"    containing the current contents of the svn:keywords property.  You\n"
"    can add multiple values to a property easily here by entering one\n"
"    value per line.&gt;\n"
"Set new value for property 'svn:keywords' on 'foo.c'\n"
msgstr ""
"\n"
"$ svn propedit svn:keywords  foo.c \n"
"    &lt;svn will launch your favorite editor here, with a buffer open\n"
"    containing the current contents of the svn:keywords property.  You\n"
"    can add multiple values to a property easily here by entering one\n"
"    value per line.&gt;\n"
"Set new value for property 'svn:keywords' on 'foo.c'\n"

#: build/en/book.xml:20669(tertiary) build/en/book.xml:23617(tertiary)
msgid "propget"
msgstr "propget"

#: build/en/book.xml:20673(refname)
msgid "svn propget"
msgstr "svn propget"

#: build/en/book.xml:20674(refpurpose)
msgid "Print the value of a property."
msgstr "打印一个属性的值。"

#: build/en/book.xml:20678(programlisting)
#, no-wrap
msgid "svn propget PROPNAME [TARGET[@REV]...]"
msgstr "svn propget PROPNAME [TARGET[@REV]...]"

#: build/en/book.xml:20679(programlisting)
#, no-wrap
msgid "svn propget PROPNAME --revprop -r REV [URL]"
msgstr "svn propget PROPNAME --revprop -r REV [URL]"

#: build/en/book.xml:20684(para)
msgid "Print the value of a property on files, directories, or revisions. The first form prints the versioned property of an item or items in your working copy, while the second prints unversioned remote property on a repository revision. See <xref linkend=\"svn.advanced.props\"/> for more information on properties."
msgstr "打印一个文件、目录或修订版本的一个属性的值，第一种形式是打印工作拷贝中一个或多个项目的版本化的属性，第二种形式是远程打印版本库修订版本的未版本化的属性。属性的详情见<xref linkend=\"svn.advanced.props\"/>。"

#: build/en/book.xml:20694(para)
msgid "pget, pg"
msgstr "pget, pg"

#: build/en/book.xml:20710(screen)
#, no-wrap
msgid ""
"\n"
"--recursive (-R)\n"
"--revision (-r) REV\n"
"--revprop\n"
"--strict\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--recursive (-R)\n"
"--revision (-r) REV\n"
"--revprop\n"
"--strict\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"

#: build/en/book.xml:20726(para)
msgid "Examine a property of a file in your working copy:"
msgstr "检查工作拷贝的一个文件的一个属性："

#: build/en/book.xml:20729(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propget svn:keywords foo.c\n"
"Author\n"
"Date\n"
"Rev\n"
msgstr ""
"\n"
"$ svn propget svn:keywords foo.c\n"
"Author\n"
"Date\n"
"Rev\n"

#: build/en/book.xml:20736(para)
msgid "The same goes for a revision property:"
msgstr "对于修订版本属性相同："

#: build/en/book.xml:20738(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propget svn:log --revprop -r 20 \n"
"Began journal.\n"
msgstr ""
"\n"
"$ svn propget svn:log --revprop -r 20 \n"
"Began journal.\n"

#: build/en/book.xml:20751(tertiary) build/en/book.xml:23672(tertiary)
msgid "proplist"
msgstr "proplist"

#: build/en/book.xml:20755(refname)
msgid "svn proplist"
msgstr "svn proplist"

#: build/en/book.xml:20756(refpurpose)
msgid "List all properties."
msgstr "列出所有的属性。"

#: build/en/book.xml:20760(programlisting)
#, no-wrap
msgid "svn proplist [TARGET[@REV]...]"
msgstr "svn proplist [TARGET[@REV]...]"

#: build/en/book.xml:20761(programlisting)
#, no-wrap
msgid "svn proplist --revprop -r REV [URL]"
msgstr "svn proplist --revprop -r REV [URL]"

#: build/en/book.xml:20766(para)
msgid "List all properties on files, directories, or revisions. The first form lists versioned properties in your working copy, while the second lists unversioned remote properties on a repository revision."
msgstr "列出文件、目录或修订版本的属性，第一种形式是列出工作拷贝的所有版本化的属性，第二种形式是列出版本库修订版本的未版本化的属性。"

#: build/en/book.xml:20774(para)
msgid "plist, pl"
msgstr "plist, pl"

#: build/en/book.xml:20790(screen)
#, no-wrap
msgid ""
"\n"
"--verbose (-v)\n"
"--recursive (-R)\n"
"--revision (-r) REV\n"
"--quiet (-q)\n"
"--revprop\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--verbose (-v)\n"
"--recursive (-R)\n"
"--revision (-r) REV\n"
"--quiet (-q)\n"
"--revprop\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"

#: build/en/book.xml:20807(para)
msgid "You can use proplist to see the properties on an item in your working copy:"
msgstr "你可以使用proplist察看你的工作拷贝的一个项目的属性："

#: build/en/book.xml:20810(screen)
#, no-wrap
msgid ""
"\n"
"$ svn proplist foo.c\n"
"Properties on 'foo.c':\n"
"  svn:mime-type\n"
"  svn:keywords\n"
"  owner\n"
msgstr ""
"\n"
"$ svn proplist foo.c\n"
"Properties on 'foo.c':\n"
"  svn:mime-type\n"
"  svn:keywords\n"
"  owner\n"

#: build/en/book.xml:20818(para)
msgid "But with the <option>--verbose</option> flag, svn proplist is extremely handy as it also shows you the values for the properties:"
msgstr "通过<option>--verbose</option>选项，svn proplist也可以非常便利的显示属性的值："

#: build/en/book.xml:20822(screen)
#, no-wrap
msgid ""
"\n"
"$ svn proplist --verbose foo.c\n"
"Properties on 'foo.c':\n"
"  svn:mime-type : text/plain\n"
"  svn:keywords : Author Date Rev\n"
"  owner : sally\n"
msgstr ""
"\n"
"$ svn proplist --verbose foo.c\n"
"Properties on 'foo.c':\n"
"  svn:mime-type : text/plain\n"
"  svn:keywords : Author Date Rev\n"
"  owner : sally\n"

#: build/en/book.xml:20838(tertiary)
msgid "propset"
msgstr "propset"

#: build/en/book.xml:20842(refname)
msgid "svn propset"
msgstr "svn propset"

#: build/en/book.xml:20843(refpurpose)
msgid "Set PROPNAME to PROPVAL on files, directories, or revisions."
msgstr "设置文件、目录或者修订版本的属性PROPNAME为PROPVAL。"

#: build/en/book.xml:20847(programlisting)
#, no-wrap
msgid "svn propset PROPNAME [PROPVAL | -F VALFILE] PATH..."
msgstr "svn propset PROPNAME [PROPVAL | -F VALFILE] PATH..."

#: build/en/book.xml:20848(programlisting)
#, no-wrap
msgid "svn propset PROPNAME --revprop -r REV [PROPVAL | -F VALFILE] [URL]"
msgstr "svn propset PROPNAME --revprop -r REV [PROPVAL | -F VALFILE] [URL]"

#: build/en/book.xml:20854(para)
msgid "Set <replaceable>PROPNAME</replaceable> to <replaceable>PROPVAL</replaceable> on files, directories, or revisions. The first example creates a versioned, local property change in the working copy, and the second creates an unversioned, remote property change on a repository revision."
msgstr "设置文件、目录或者修订版本的属性<replaceable>PROPNAME</replaceable>为<replaceable>PROPVAL</replaceable>。第一个例子在工作拷贝创建了一个版本化的本地属性修改，第二个例子创建了一个未版本化的远程的对版本库修订版本的属性修改。"

#: build/en/book.xml:20862(para)
#, fuzzy
msgid "Subversion has a number of <quote>special</quote> properties that affect its behavior. See <xref linkend=\"svn.ref.properties\"/> for more on these properties."
msgstr "Subversion有一系列<quote>特殊的</quote>影响行为方式的属性，关于这些属性的详情请见<xref linkend=\"svn.advanced.props.special\"/>。"

#: build/en/book.xml:20870(para)
msgid "pset, ps"
msgstr "pset, ps"

#: build/en/book.xml:20886(screen)
#, no-wrap
msgid ""
"\n"
"--file (-F) FILE\n"
"--quiet (-q)\n"
"--revision (-r) REV\n"
"--targets FILENAME\n"
"--recursive (-R)\n"
"--revprop\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--encoding ENC\n"
"--force\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--file (-F) FILE\n"
"--quiet (-q)\n"
"--revision (-r) REV\n"
"--targets FILENAME\n"
"--recursive (-R)\n"
"--revprop\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--encoding ENC\n"
"--force\n"
"--config-dir DIR\n"

#: build/en/book.xml:20906(para)
msgid "Set the mimetype on a file:"
msgstr "设置文件的mimetype："

#: build/en/book.xml:20908(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propset svn:mime-type image/jpeg foo.jpg \n"
"property 'svn:mime-type' set on 'foo.jpg'\n"
msgstr ""
"\n"
"$ svn propset svn:mime-type image/jpeg foo.jpg \n"
"property 'svn:mime-type' set on 'foo.jpg'\n"

#: build/en/book.xml:20913(para)
msgid "On a UNIX system, if you want a file to have the executable permission set:"
msgstr "在UNIX系统，如果你希望一个文件设置执行权限："

#: build/en/book.xml:20916(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propset svn:executable ON somescript\n"
"property 'svn:executable' set on 'somescript'\n"
msgstr ""
"\n"
"$ svn propset svn:executable ON somescript\n"
"property 'svn:executable' set on 'somescript'\n"

#: build/en/book.xml:20921(para)
msgid "Perhaps you have an internal policy to set certain properties for the benefit of your coworkers:"
msgstr "或许为了合作者的利益你有一个内部的属性设置："

#: build/en/book.xml:20924(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propset owner sally foo.c\n"
"property 'owner' set on 'foo.c'\n"
msgstr ""
"\n"
"$ svn propset owner sally foo.c\n"
"property 'owner' set on 'foo.c'\n"

#: build/en/book.xml:20929(para)
msgid "If you made a mistake in a log message for a particular revision and want to change it, use <option>--revprop</option> and set <literal moreinfo=\"none\">svn:log</literal> to the new log message:"
msgstr "如果你在特定修订版本的日志信息里有一些错误，并且希望修改，可以使用<option>--revprop</option>设置<literal moreinfo=\"none\">svn:log</literal>为新的日志信息："

#: build/en/book.xml:20934(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propset --revprop -r 25 svn:log \"Journaled about trip to New York.\"\n"
"property 'svn:log' set on repository revision '25'\n"
msgstr ""
"\n"
"$ svn propset --revprop -r 25 svn:log \"Journaled about trip to New York.\"\n"
"property 'svn:log' set on repository revision '25'\n"

#: build/en/book.xml:20939(para)
msgid "Or, if you don't have a working copy, you can provide a URL."
msgstr "或者，你没有工作拷贝，你可以提供一个URL。"

#: build/en/book.xml:20942(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propset --revprop -r 26 svn:log \"Document nap.\" http://svn.red-bean.com/repos\n"
"property 'svn:log' set on repository revision '25'\n"
msgstr ""
"\n"
"$ svn propset --revprop -r 26 svn:log \"Document nap.\" http://svn.red-bean.com/repos\n"
"property 'svn:log' set on repository revision '25'\n"

#: build/en/book.xml:20947(para)
msgid "Lastly, you can tell propset to take its input from a file. You could even use this to set the contents of a property to something binary:"
msgstr "最后，你可以告诉propset从一个文件得到输入，你甚至可以使用这个方式来设置一个属性为二进制内容："

#: build/en/book.xml:20951(screen)
#, no-wrap
msgid ""
"\n"
"$ svn propset owner-pic -F sally.jpg moo.c \n"
"property 'owner-pic' set on 'moo.c'\n"
msgstr ""
"\n"
"$ svn propset owner-pic -F sally.jpg moo.c \n"
"property 'owner-pic' set on 'moo.c'\n"

#: build/en/book.xml:20957(para)
msgid "By default, you cannot modify revision properties in a Subversion repository. Your repository administrator must explicitly enable revision property modifications by creating a hook named <literal moreinfo=\"none\">pre-revprop-change</literal>. See <xref linkend=\"svn.reposadmin.create.hooks\"/> for more information on hook scripts."
msgstr "缺省，你不可以在Subversion版本库修改修订版本属性，你的版本库管理员必须显示的通过创建一个名字为<literal moreinfo=\"none\">pre-revprop-change</literal>的钩子来允许修订版本属性修改，关于钩子脚本的详情请见<xref linkend=\"svn.reposadmin.create.hooks\"/>。"

#: build/en/book.xml:20973(tertiary)
msgid "resolved"
msgstr "resolved"

#: build/en/book.xml:20978(quote)
msgid "conflicted"
msgstr "冲突"

#: build/en/book.xml:20978(refpurpose)
msgid "Remove <placeholder-1/> state on working copy files or directories."
msgstr "删除工作拷贝文件或目录的<placeholder-1/>状态。"

#: build/en/book.xml:20983(programlisting)
#, no-wrap
msgid "svn resolved PATH..."
msgstr "svn resolved PATH..."

#: build/en/book.xml:20988(para)
msgid "Remove <quote>conflicted</quote> state on working copy files or directories. This routine does not semantically resolve conflict markers; it merely removes conflict-related artifact files and allows <replaceable>PATH</replaceable> to be committed again; that is, it tells Subversion that the conflicts have been <quote>resolved</quote>. See <xref linkend=\"svn.tour.cycle.resolve\"/> for an in-depth look at resolving conflicts."
msgstr "删除工作拷贝文件或目录的<quote>conflicted</quote>状态。这个程序不是语义上的改变冲突标志，它只是删除冲突相关的人造文件，从而重新允许<replaceable>PATH</replaceable>提交；也就是说，它告诉Subversion冲突已经<quote>解决了</quote>。关于解决冲突更深入的考虑可以查看<xref linkend=\"svn.tour.cycle.resolve\"/>。"

#: build/en/book.xml:21015(screen) build/en/book.xml:21104(screen)
#, no-wrap
msgid ""
"\n"
"--targets FILENAME\n"
"--recursive (-R)\n"
"--quiet (-q)\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--targets FILENAME\n"
"--recursive (-R)\n"
"--quiet (-q)\n"
"--config-dir DIR\n"

#: build/en/book.xml:21026(para)
msgid "If you get a conflict on an update, your working copy will sprout three new files:"
msgstr "如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件："

#: build/en/book.xml:21029(screen)
#, no-wrap
msgid ""
"\n"
"$ svn update\n"
"C  foo.c\n"
"Updated to revision 31.\n"
"$ ls\n"
"foo.c\n"
"foo.c.mine\n"
"foo.c.r30\n"
"foo.c.r31\n"
msgstr ""
"\n"
"$ svn update\n"
"C  foo.c\n"
"Updated to revision 31.\n"
"$ ls\n"
"foo.c\n"
"foo.c.mine\n"
"foo.c.r30\n"
"foo.c.r31\n"

#: build/en/book.xml:21040(para)
msgid "Once you've resolved the conflict and <filename moreinfo=\"none\">foo.c</filename> is ready to be committed, run <command moreinfo=\"none\">svn resolved</command> to let your working copy know you've taken care of everything."
msgstr "当你解决了<filename moreinfo=\"none\">foo.c</filename>的冲突，并且准备提交，运行<command moreinfo=\"none\">svn resolved</command>让你的工作拷贝知道你已经完成了所有事情。"

#: build/en/book.xml:21046(para)
msgid "You <emphasis>can</emphasis> just remove the conflict files and commit, but <command moreinfo=\"none\">svn resolved</command> fixes up some bookkeeping data in the working copy administrative area in addition to removing the conflict files, so we recommend that you use this command."
msgstr "你<emphasis>可以</emphasis>仅仅删除冲突的文件并且提交，但是<command moreinfo=\"none\">svn resolved</command>除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，所以我们推荐你使用这个命令。"

#: build/en/book.xml:21062(tertiary)
msgid "revert"
msgstr "revert"

#: build/en/book.xml:21067(refpurpose)
msgid "Undo all local edits."
msgstr "取消所有的本地编辑。"

#: build/en/book.xml:21071(programlisting)
#, no-wrap
msgid "svn revert PATH..."
msgstr "svn revert PATH..."

#: build/en/book.xml:21076(para)
msgid "Reverts any local changes to a file or directory and resolves any conflicted states. <command moreinfo=\"none\">svn revert</command> will not only revert the contents of an item in your working copy, but also any property changes. Finally, you can use it to undo any scheduling operations that you may have done (e.g. files scheduled for addition or deletion can be <quote>unscheduled</quote>)."
msgstr "恢复所有对文件和目录的修改，并且解决所有的冲突状态。<command moreinfo=\"none\">svn revert</command>不会只是恢复工作拷贝中一个项目的内容，也包括了对属性修改的恢复。最终，你可以使用它来取消所有已经做过的预定操作（例如，文件预定要添加或删除可以<quote>恢复</quote>）。"

#: build/en/book.xml:21115(para)
msgid "Discard changes to a file:"
msgstr "丢弃对一个文件的修改："

#: build/en/book.xml:21117(screen)
#, no-wrap
msgid ""
"\n"
"$ svn revert foo.c\n"
"Reverted foo.c\n"
msgstr ""
"\n"
"$ svn revert foo.c\n"
"Reverted foo.c\n"

#: build/en/book.xml:21122(para)
msgid "If you want to revert a whole directory of files, use the <option>--recursive</option> flag:"
msgstr "如果你希望恢复一整个目录的文件，可以使用<option>--recursive</option>选项："

#: build/en/book.xml:21125(screen)
#, no-wrap
msgid ""
"\n"
"$ svn revert --recursive .\n"
"Reverted newdir/afile\n"
"Reverted foo.c\n"
"Reverted bar.txt\n"
msgstr ""
"\n"
"$ svn revert --recursive .\n"
"Reverted newdir/afile\n"
"Reverted foo.c\n"
"Reverted bar.txt\n"

#: build/en/book.xml:21132(para)
msgid "Lastly, you can undo any scheduling operations:"
msgstr "最后，你可以取消预定的操作："

#: build/en/book.xml:21135(screen)
#, no-wrap
msgid ""
"\n"
"$ svn add mistake.txt whoops\n"
"A         mistake.txt\n"
"A         whoops\n"
"A         whoops/oopsie.c\n"
"\n"
"$ svn revert mistake.txt whoops\n"
"Reverted mistake.txt\n"
"Reverted whoops\n"
"\n"
"$ svn status\n"
"?      mistake.txt\n"
"?      whoops\n"
msgstr ""
"\n"
"$ svn add mistake.txt whoops\n"
"A         mistake.txt\n"
"A         whoops\n"
"A         whoops/oopsie.c\n"
"\n"
"$ svn revert mistake.txt whoops\n"
"Reverted mistake.txt\n"
"Reverted whoops\n"
"\n"
"$ svn status\n"
"?      mistake.txt\n"
"?      whoops\n"

#: build/en/book.xml:21151(para)
msgid "If you provide no targets to <command moreinfo=\"none\">svn revert</command>, it will do nothing—to protect you from accidentally losing changes in your working copy, <command moreinfo=\"none\">svn revert</command> requires you to provide at least one target."
msgstr "如果你没有给<command moreinfo=\"none\">svn revert</command>提供了目标，它不会做任何事情—为了保护你不小心失去对工作拷贝的修改，<command moreinfo=\"none\">svn revert</command>需要你提供至少一个目标。"

#: build/en/book.xml:21166(tertiary)
msgid "status"
msgstr "status"

#: build/en/book.xml:21171(refpurpose)
msgid "Print the status of working copy files and directories."
msgstr "打印工作拷贝文件和目录的状态。"

#: build/en/book.xml:21175(programlisting)
#, no-wrap
msgid "svn status [PATH...]"
msgstr "svn status [PATH...]"

#: build/en/book.xml:21180(para)
msgid "Print the status of working copy files and directories. With no arguments, it prints only locally modified items (no repository access). With <option>--show-updates</option>, add working revision and server out-of-date information. With <option>--verbose</option>, print full revision information on every item."
msgstr "打印工作拷贝文件和目录的状态。如果没有参数，只会打印本地修改的项目（不会访问版本库），使用<option>--show-updates</option>选项，会添加工作修订版本和服务器过期信息。使用<option>--verbose</option>会打印每个项目的完全修订版本信息。"

#: build/en/book.xml:21188(para)
msgid "The first six columns in the output are each one character wide, and each column gives you information about different aspects of each working copy item."
msgstr "输出的前六列都是一个字符宽，每一列给出了工作拷贝项目的每一方面的信息。"

#: build/en/book.xml:21192(para)
msgid "The first column indicates that an item was added, deleted, or otherwise changed."
msgstr "第一列指出一个项目的是添加、删除还是其它的修改。"

#: build/en/book.xml:21198(term) build/en/book.xml:21293(term)
#: build/en/book.xml:21325(term) build/en/book.xml:21346(term)
#: build/en/book.xml:21367(term) build/en/book.xml:21387(term)
#: build/en/book.xml:21446(term)
msgid "' '"
msgstr "' '"

#: build/en/book.xml:21200(para) build/en/book.xml:21295(para)
msgid "No modifications."
msgstr "没有修改。"

#: build/en/book.xml:21205(term)
msgid "'A'"
msgstr "'A'"

#: build/en/book.xml:21207(para)
msgid "Item is scheduled for Addition."
msgstr "预定要添加的项目。"

#: build/en/book.xml:21212(term)
msgid "'D'"
msgstr "'D'"

#: build/en/book.xml:21214(para)
msgid "Item is scheduled for Deletion."
msgstr "预定要删除的项目。"

#: build/en/book.xml:21219(term) build/en/book.xml:21300(term)
msgid "'M'"
msgstr "'M'"

#: build/en/book.xml:21221(para)
msgid "Item has been modified."
msgstr "项目已经修改了。"

#: build/en/book.xml:21226(term)
msgid "'R'"
msgstr "'R'"

#: build/en/book.xml:21228(para)
msgid "Item has been replaced in your working copy. This means the file was scheduled for deletion, and then a new file with the same name was scheduled for addition in its place."
msgstr "项目在工作拷贝中已经被替换了。这意味着文件预定要删除，然后有一个同样名称的文件要在同一个位置替换它。"

#: build/en/book.xml:21236(term) build/en/book.xml:21308(term)
msgid "'C'"
msgstr "'C'"

#: build/en/book.xml:21238(para)
msgid "The contents (as opposed to the properties) of the item conflict with updates received from the repository."
msgstr "项目的内容（相对于属性）与更新得到的数据冲突了。"

#: build/en/book.xml:21245(term)
msgid "'X'"
msgstr "'X'"

#: build/en/book.xml:21247(para)
msgid "Item is related to an externals definition."
msgstr "项目与外部定义相关。"

#: build/en/book.xml:21252(term)
msgid "'I'"
msgstr "'I'"

#: build/en/book.xml:21254(para)
msgid "Item is being ignored (e.g. with the <literal moreinfo=\"none\">svn:ignore</literal> property)."
msgstr "项目被忽略（例如使用<literal moreinfo=\"none\">svn:ignore</literal>属性）。"

#: build/en/book.xml:21260(term)
msgid "'?'"
msgstr "'?'"

#: build/en/book.xml:21262(para)
msgid "Item is not under version control."
msgstr "项目不在版本控制之下。"

#: build/en/book.xml:21267(term)
msgid "'!'"
msgstr "'!'"

#: build/en/book.xml:21269(para)
msgid "Item is missing (e.g. you moved or deleted it without using <command moreinfo=\"none\">svn</command>). This also indicates that a directory is incomplete (a checkout or update was interrupted)."
msgstr "项目已经丢失（例如，你使用<command moreinfo=\"none\">svn</command>移动或者删除了它）。这也说明了一个目录不是完整的（一个检出或更新中断）。"

#: build/en/book.xml:21277(term)
msgid "'~'"
msgstr "'~'"

#: build/en/book.xml:21279(para)
msgid "Item is versioned as one kind of object (file, directory, link), but has been replaced by different kind of object."
msgstr "项目作为一种对象（文件、目录或链接）纳入版本控制，但是已经被另一种对象替代。"

#: build/en/book.xml:21287(para)
msgid "The second column tells the status of a file's or directory's properties."
msgstr "第二列告诉一个文件或目录的属性的状态。"

#: build/en/book.xml:21302(para)
msgid "Properties for this item have been modified."
msgstr "这个项目的属性已经修改。"

#: build/en/book.xml:21310(para)
msgid "Properties for this item are in conflict with property updates received from the repository."
msgstr "这个项目的属性与从版本库得到的更新有冲突。"

#: build/en/book.xml:21318(para)
#, fuzzy
msgid "The third column is populated only if the working copy directory is locked. (See <xref linkend=\"svn.tour.cleanup\"/>.)"
msgstr "第三列只在工作拷贝锁定时才会出现。（见<xref linkend=\"svn.tour.other.cleanup\"/>。）"

#: build/en/book.xml:21327(para)
msgid "Item is not locked."
msgstr "项目没有锁定。"

#: build/en/book.xml:21332(term)
msgid "'L'"
msgstr "'L'"

#: build/en/book.xml:21334(para)
msgid "Item is locked."
msgstr "项目已经锁定。"

#: build/en/book.xml:21340(para)
msgid "The fourth column is populated only if the item is scheduled for addition-with-history."
msgstr "第四列只在预定包含历史添加的项目出现。"

#: build/en/book.xml:21348(para)
msgid "No history scheduled with commit."
msgstr "没有历史预定要提交。"

#: build/en/book.xml:21353(term)
msgid "'+'"
msgstr "'+'"

#: build/en/book.xml:21355(para)
msgid "History scheduled with commit."
msgstr "历史预定要伴随提交。"

#: build/en/book.xml:21361(para)
msgid "The fifth column is populated only if the item is switched relative to its parent (see <xref linkend=\"svn.branchmerge.switchwc\"/>)."
msgstr "第五列只在项目跳转到相对于它的父目录时出现（见<xref linkend=\"svn.branchmerge.switchwc\"/>）。"

#: build/en/book.xml:21369(para)
msgid "Item is a child of its parent directory."
msgstr "项目是它的父目录的孩子。"

#: build/en/book.xml:21374(term)
msgid "'S'"
msgstr "'S'"

#: build/en/book.xml:21376(para)
msgid "Item is switched."
msgstr "项目已经转换。"

#: build/en/book.xml:21382(para)
msgid "The sixth column is populated with lock information."
msgstr "第六列显示锁定信息。"

#: build/en/book.xml:21389(para)
msgid "When <option>--show-updates</option> is used, the file is not locked. If <option>--show-updates</option> is <emphasis>not</emphasis> used, this merely means that the file is not locked in this working copy."
msgstr "当使用<option>--show-updates</option>，文件没有锁定。如果<emphasis>不</emphasis>使用<option>--show-updates</option>，这意味着文件在工作拷贝被锁定。"

#: build/en/book.xml:21398(term)
msgid "K"
msgstr "K"

#: build/en/book.xml:21400(para)
msgid "File is locked in this working copy."
msgstr "文件锁定在工作拷贝。"

#: build/en/book.xml:21405(term)
msgid "O"
msgstr "O"

#: build/en/book.xml:21407(para)
msgid "File is locked either by another user or in another working copy. This only appears when <option>--show-updates</option> is used."
msgstr "文件被另一个工作拷贝的另一个用户锁定，只有在使用<option>--show-updates</option>时显示。"

#: build/en/book.xml:21414(term)
msgid "T"
msgstr "T"

#: build/en/book.xml:21416(para)
msgid "File was locked in this working copy, but the lock has been <quote>stolen</quote>and is invalid. The file is currently locked in the repository. This only appears when <option>--show-updates</option> is used."
msgstr "文件锁定在工作拷贝，但是锁定被<quote>窃取</quote>而不可用。文件当前锁定在版本库，只有在使用<option>--show-updates</option>时显示。"

#: build/en/book.xml:21425(term)
msgid "B"
msgstr "B"

#: build/en/book.xml:21427(para)
msgid "File was locked in this working copy, but the lock has been <quote>broken</quote>and is invalid. The file is no longer locked This only appears when <option>--show-updates</option> is used."
msgstr "文件锁定在工作拷贝，但是锁定被<quote>破坏</quote>而不可用。文件当前锁定在版本库，只有在使用<option>--show-updates</option>时显示。"

#: build/en/book.xml:21439(para)
msgid "The out-of-date information appears in the seventh column (only if you pass the <option>--show-updates</option> switch)."
msgstr "过期信息出现在第七列（只在使用<option>--show-updates</option>选项时出现）。"

#: build/en/book.xml:21448(para)
msgid "The item in your working copy is up-to-date."
msgstr "这个项目在工作拷贝是最新的。"

#: build/en/book.xml:21453(term)
msgid "'*'"
msgstr "'*'"

#: build/en/book.xml:21455(para)
msgid "A newer revision of the item exists on the server."
msgstr "在服务器这个项目有了新的修订版本。"

#: build/en/book.xml:21462(para)
msgid "The remaining fields are variable width and delimited by spaces. The working revision is the next field if the <option>--show-updates</option> or <option>--verbose</option> switches are passed."
msgstr "余下的字段是可变得宽度且使用空格分隔，如果使用<option>--show-updates</option>或<option>--verbose</option>选项，工作修订版本是下一个字段。"

#: build/en/book.xml:21467(para)
msgid "If the <option>--verbose</option> switch is passed, the last committed revision and last committed author are displayed next."
msgstr "如果传递<option>--verbose</option>选项，最后提交的修订版本和最后的提交作者会在后面显示。"

#: build/en/book.xml:21471(para)
msgid "The working copy path is always the final field, so it can include spaces."
msgstr "工作拷贝路径永远是最后一个字段，所以它可以包括空格。"

#: build/en/book.xml:21478(para)
msgid "stat, st"
msgstr "stat, st"

#: build/en/book.xml:21488(para)
msgid "Only if using <option>--show-updates</option>"
msgstr "只有使用<option>--show-updates</option>时会访问"

#: build/en/book.xml:21494(screen)
#, no-wrap
msgid ""
"\n"
"--show-updates (-u)\n"
"--verbose (-v)\n"
"--non-recursive (-N)\n"
"--quiet (-q)\n"
"--no-ignore\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
"--ignore-externals\n"
msgstr ""
"\n"
"--show-updates (-u)\n"
"--verbose (-v)\n"
"--non-recursive (-N)\n"
"--quiet (-q)\n"
"--no-ignore\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
"--ignore-externals\n"

#: build/en/book.xml:21512(para)
msgid "This is the easiest way to find out what changes you have made to your working copy:"
msgstr "这是查看你在工作拷贝所做的修改的最简单的方法。"

#: build/en/book.xml:21515(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status wc\n"
" M     wc/bar.c\n"
"A  +   wc/qax.c\n"
msgstr ""
"\n"
"$ svn status wc\n"
" M     wc/bar.c\n"
"A  +   wc/qax.c\n"

#: build/en/book.xml:21521(para)
msgid "If you want to find out what files in your working copy are out-of-date, pass the <option>--show-updates</option> switch (this will <emphasis>not</emphasis> make any changes to your working copy). Here you can see that <filename moreinfo=\"none\">wc/foo.c</filename> has changed in the repository since we last updated our working copy:"
msgstr "如果你希望找出工作拷贝哪些文件是最新的，使用<option>--show-updates</option>选项（这不会对工作拷贝有任何修改）。这里你会看到<filename moreinfo=\"none\">wc/foo.c</filename>在上次更新后有了修改："

#: build/en/book.xml:21530(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status --show-updates wc\n"
" M           965    wc/bar.c\n"
"       *     965    wc/foo.c\n"
"A  +         965    wc/qax.c\n"
"Status against revision:    981\n"
msgstr ""
"\n"
"$ svn status --show-updates wc\n"
" M           965    wc/bar.c\n"
"       *     965    wc/foo.c\n"
"A  +         965    wc/qax.c\n"
"Status against revision:    981\n"

#: build/en/book.xml:21539(para)
msgid "<option>--show-updates</option><emphasis>only</emphasis> places an asterisk next to items that are out of date (that is, items that will be updated from the repository if you run <command moreinfo=\"none\">svn update</command>). <option>--show-updates</option> does <emphasis>not</emphasis> cause the status listing to reflect the repository's version of the item."
msgstr "<option>--show-updates</option><emphasis>只会</emphasis>在过期的项目（如果你运行<command moreinfo=\"none\">svn update</command>，就会更新的项目）旁边安置一个星号。<option>--show-updates</option>不会导致状态列表反映项目的版本库版本。"

#: build/en/book.xml:21548(para)
msgid "And finally, the most information you can get out of the status subcommand:"
msgstr "最后，是你能从status子命令得到的所有信息："

#: build/en/book.xml:21551(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status --show-updates --verbose wc\n"
" M           965       938 sally        wc/bar.c\n"
"       *     965       922 harry        wc/foo.c\n"
"A  +         965       687 harry        wc/qax.c\n"
"             965       687 harry        wc/zig.c\n"
"Head revision:   981\n"
msgstr ""
"\n"
"$ svn status --show-updates --verbose wc\n"
" M           965       938 sally        wc/bar.c\n"
"       *     965       922 harry        wc/foo.c\n"
"A  +         965       687 harry        wc/qax.c\n"
"             965       687 harry        wc/zig.c\n"
"Head revision:   981\n"

#: build/en/book.xml:21560(para)
msgid "For many more examples of <command moreinfo=\"none\">svn status</command>, see <xref linkend=\"svn.tour.cycle.examine.status\"/>."
msgstr "关于<command moreinfo=\"none\">svn status</command>的更多例子可以见<xref linkend=\"svn.tour.cycle.examine.status\"/>。"

#: build/en/book.xml:21571(tertiary)
msgid "switch"
msgstr "switch"

#: build/en/book.xml:21575(refname)
msgid "svn switch"
msgstr "svn switch"

#: build/en/book.xml:21576(refpurpose)
msgid "Update working copy to a different URL."
msgstr "把工作拷贝更新到别的URL。"

#: build/en/book.xml:21580(programlisting)
#, no-wrap
msgid "svn switch URL [PATH]"
msgstr "svn switch URL [PATH]"

#: build/en/book.xml:21582(programlisting)
#, no-wrap
msgid "switch --relocate FROM TO [PATH...]"
msgstr "switch --relocate FROM TO [PATH...]"

#: build/en/book.xml:21589(para)
msgid "This subcommand updates your working copy to mirror a new URL—usually a URL which shares a common ancestor with your working copy, although not necessarily. This is the Subversion way to move a working copy to a new branch. See <xref linkend=\"svn.branchmerge.switchwc\"/> for an in-depth look at switching."
msgstr "这个子命令更新你的工作拷贝来反映新的URL—通常是一个与你的工作拷贝分享共同祖先的URL，尽管这不是必需的。这是Subversion移动工作拷贝到分支的方式。更深入的了解请见<xref linkend=\"svn.branchmerge.switchwc\"/>。"

#: build/en/book.xml:21599(para)
msgid "sw"
msgstr "sw"

#: build/en/book.xml:21615(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--non-recursive (-N)\n"
"--quiet (-q)\n"
"--diff3-cmd CMD\n"
"--relocate FROM TO\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--non-recursive (-N)\n"
"--quiet (-q)\n"
"--diff3-cmd CMD\n"
"--relocate FROM TO\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"

#: build/en/book.xml:21632(para)
msgid "If you're currently inside the directory <filename moreinfo=\"none\">vendors</filename> which was branched to <filename moreinfo=\"none\">vendors-with-fix</filename> and you'd like to switch your working copy to that branch:"
msgstr "如果你目前所在目录<filename moreinfo=\"none\">vendors</filename>分支到<filename moreinfo=\"none\">vendors-with-fix</filename>，你希望转移到那个分支："

#: build/en/book.xml:21637(screen)
#, no-wrap
msgid ""
"\n"
"$ svn switch http://svn.red-bean.com/repos/branches/vendors-with-fix .\n"
"U  myproj/foo.txt\n"
"U  myproj/bar.txt\n"
"U  myproj/baz.c\n"
"U  myproj/qux.c\n"
"Updated to revision 31.\n"
msgstr ""
"\n"
"$ svn switch http://svn.red-bean.com/repos/branches/vendors-with-fix .\n"
"U  myproj/foo.txt\n"
"U  myproj/bar.txt\n"
"U  myproj/baz.c\n"
"U  myproj/qux.c\n"
"Updated to revision 31.\n"

#: build/en/book.xml:21646(para)
msgid "And to switch back, just provide the URL to the location in the repository from which you originally checked out your working copy:"
msgstr "为了跳转回来，只需要提供最初取出工作拷贝的版本库URL："

#: build/en/book.xml:21650(screen)
#, no-wrap
msgid ""
"\n"
"$ svn switch http://svn.red-bean.com/repos/trunk/vendors .\n"
"U  myproj/foo.txt\n"
"U  myproj/bar.txt\n"
"U  myproj/baz.c\n"
"U  myproj/qux.c\n"
"Updated to revision 31.\n"
msgstr ""
"\n"
"$ svn switch http://svn.red-bean.com/repos/trunk/vendors .\n"
"U  myproj/foo.txt\n"
"U  myproj/bar.txt\n"
"U  myproj/baz.c\n"
"U  myproj/qux.c\n"
"Updated to revision 31.\n"

#: build/en/book.xml:21660(para)
msgid "You can just switch part of your working copy to a branch if you don't want to switch your entire working copy."
msgstr "如果你不希望跳转所有的工作拷贝，你可以只跳转一部分。"

#: build/en/book.xml:21665(para)
msgid "Sometimes an administrator might change the <quote>base location</quote> of your repository—in other words, the contents of the repository doesn't change, but the main URL used to reach the root of the repository does. For example, the hostname may change, the URL scheme, or any part of the URL which leads to the repository itself. Rather than checkout a new working copy, you can have the <command moreinfo=\"none\">svn switch</command> command <quote>rewrite</quote> the beginnings of all the URLs in your working copy. Use the <option>--relocate</option> option to do the substitution. No file contents are changed, nor is the repository contacted. It's similar to running a Perl script over your working copy <filename moreinfo=\"none\">.svn/</filename> directories which runs <command moreinfo=\"none\">s/OldRoot/NewRoot/</command>."
msgstr "有时候管理员会修改版本库的<quote>基本位置</quote>—换句话说，版本库的内容并不改变，但是访问根的主URL变了。举个例子，主机名变了、URL模式变了或者是URL中的任何一部分改变了。我们不选择重新检出一个工作拷贝，你可以使用<command moreinfo=\"none\">svn switch</command>来重写版本库所有URL的开头。使用<option>--relocate</option>来做这种替换，没有文件内容会改变，访问的版本库也不会改变。只是像在工作拷贝<filename moreinfo=\"none\">.svn/</filename>运行了一段Perl脚本<command moreinfo=\"none\">s/OldRoot/NewRoot/</command>。"

#: build/en/book.xml:21681(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout file:///tmp/repos test\n"
"A  test/a\n"
"A  test/b\n"
"…\n"
"\n"
"$ mv repos newlocation\n"
"$ cd test/\n"
"\n"
"$ svn update\n"
"svn: Unable to open an ra_local session to URL\n"
"svn: Unable to open repository 'file:///tmp/repos'\n"
"\n"
"$ svn switch --relocate file:///tmp/repos file:///tmp/newlocation .\n"
"$ svn update\n"
"At revision 3.\n"
msgstr ""
"\n"
"$ svn checkout file:///tmp/repos test\n"
"A  test/a\n"
"A  test/b\n"
"…\n"
"\n"
"$ mv repos newlocation\n"
"$ cd test/\n"
"\n"
"$ svn update\n"
"svn: Unable to open an ra_local session to URL\n"
"svn: Unable to open repository 'file:///tmp/repos'\n"
"\n"
"$ svn switch --relocate file:///tmp/repos file:///tmp/newlocation .\n"
"$ svn update\n"
"At revision 3.\n"

#: build/en/book.xml:21700(para)
msgid "Be careful when using the <option>--relocate</option> option. If you mistype the argument, you might end up creating nonsensical URLs within your working copy that render the whole workspace unusable and tricky to fix. It's also important to understand exactly when one should or shouldn't use <option>--relocate</option>. Here's the rule of thumb:"
msgstr "小心使用<option>--relocate</option>选项，如果你输入了错误的选项，你会在工作拷贝创建无意义的URL，会导致整个工作区不可用并且难于修复。理解何时应该使用<option>--relocate</option>也是非常重要的，下面是一些规则："

#: build/en/book.xml:21710(para)
msgid "If the working copy needs to reflect a new directory <emphasis>within</emphasis> the repository, then use just <command moreinfo=\"none\">svn switch</command>."
msgstr "如果工作拷贝需要反映一个版本库的新目录，只需要使用<command moreinfo=\"none\">svn switch</command>。"

#: build/en/book.xml:21715(para)
msgid "If the working copy still reflects the same repository directory, but the location of the repository itself has changed, then use <command moreinfo=\"none\">svn switch --relocate</command>."
msgstr "如果你的工作拷贝还是反映相同的版本库目录，但是版本库本身的位置改变了，使用<command moreinfo=\"none\">svn switch --relocate</command>。"

#: build/en/book.xml:21731(tertiary)
msgid "unlock"
msgstr "unlock"

#: build/en/book.xml:21735(refname)
msgid "svn unlock"
msgstr "svn unlock"

#: build/en/book.xml:21736(refpurpose)
msgid "Unlock working copy paths or URLs."
msgstr "解锁工作拷贝路径或URL。"

#: build/en/book.xml:21740(programlisting)
#, no-wrap
msgid "svn unlock TARGET..."
msgstr "svn unlock TARGET..."

#: build/en/book.xml:21745(para)
msgid "Unlock each <replaceable>TARGET</replaceable>. If any <replaceable>TARGET</replaceable> is either locked by another user or no valid lock token exists in the working copy, print a warning and continue unlocking the rest of the <replaceable>TARGET</replaceable>s. Use <option>--force</option> to break a lock belonging to another user or working copy."
msgstr "解锁每个<replaceable>TARGET</replaceable>。如果任何另一个用户锁定了<replaceable>TARGET</replaceable>，或者没有正确工作拷贝的锁定令牌，打印警告并继续解锁余下的<replaceable>TARGET</replaceable>。使用<option>--force</option>可以打破其它用户或工作拷贝的锁定。"

#: build/en/book.xml:21773(screen)
#, no-wrap
msgid ""
"\n"
"--targets FILENAME\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
"--force\n"
msgstr ""
"\n"
"--targets FILENAME\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
"--force\n"

#: build/en/book.xml:21787(para)
msgid "Unlock two files in your working copy:"
msgstr "解锁工作拷贝中的两个文件："

#: build/en/book.xml:21789(screen)
#, no-wrap
msgid ""
"\n"
"\n"
"$ svn unlock tree.jpg house.jpg\n"
"'tree.jpg' unlocked.\n"
"'house.jpg' unlocked.\n"
msgstr ""
"\n"
"\n"
"$ svn unlock tree.jpg house.jpg\n"
"'tree.jpg' unlocked.\n"
"'house.jpg' unlocked.\n"

#: build/en/book.xml:21796(para)
msgid "Unlock a file in your working copy that is currently locked by another user:"
msgstr "解锁工作拷贝的一个被其他用户锁定的文件："

#: build/en/book.xml:21799(screen)
#, no-wrap
msgid ""
"\n"
"$ svn unlock tree.jpg\n"
"svn: 'tree.jpg' is not locked in this working copy\n"
"$ svn unlock --force tree.jpg\n"
"'tree.jpg' unlocked.\n"
msgstr ""
"\n"
"$ svn unlock tree.jpg\n"
"svn: 'tree.jpg' is not locked in this working copy\n"
"$ svn unlock --force tree.jpg\n"
"'tree.jpg' unlocked.\n"

#: build/en/book.xml:21806(para)
msgid "Unlock a file without a working copy:"
msgstr "没有工作拷贝时解锁一个文件："

#: build/en/book.xml:21808(screen)
#, no-wrap
msgid ""
"\n"
"$ svn unlock http://svn.red-bean.com/repos/test/tree.jpg\n"
"'tree.jpg unlocked.\n"
msgstr ""
"\n"
"$ svn unlock http://svn.red-bean.com/repos/test/tree.jpg\n"
"'tree.jpg unlocked.\n"

#: build/en/book.xml:21824(tertiary)
msgid "update"
msgstr "update"

#: build/en/book.xml:21829(refpurpose)
msgid "Update your working copy."
msgstr "更新你的工作拷贝。"

#: build/en/book.xml:21833(programlisting)
#, no-wrap
msgid "svn update [PATH...]"
msgstr "svn update [PATH...]"

#: build/en/book.xml:21838(para)
#, fuzzy
msgid "<command moreinfo=\"none\">svn update</command> brings changes from the repository into your working copy. If no revision given, it brings your working copy up-to-date with the <literal moreinfo=\"none\">HEAD</literal> revision. Otherwise, it synchronizes the working copy to the revision given by the <option>--revision</option> switch. As part of the synchronization, <command moreinfo=\"none\">svn update</command> also removes any stale locks (see <xref linkend=\"svn.tour.cleanup\"/>) found in the working copy."
msgstr "<command moreinfo=\"none\">svn update</command>会把版本库的修改带到工作拷贝，如果没有给定修订版本，它会把你的工作拷贝更新到<literal moreinfo=\"none\">HEAD</literal>修订版本，否则，它会把工作拷贝更新到你用<option>--revision</option>指定的修订版本。为了保持同步，也会删除所有在工作拷贝发现的无效锁定（见<xref linkend=\"svn.tour.other.cleanup\"/>）。"

#: build/en/book.xml:21848(para)
msgid "For each updated item a line will start with a character reporting the action taken. These characters have the following meaning:"
msgstr "对于每一个更新的项目开头都有一个表示所做动作的字符，这些字符有下面的意思："

#: build/en/book.xml:21855(term)
msgid "A"
msgstr "A"

#: build/en/book.xml:21857(para)
msgid "Added"
msgstr "添加"

#: build/en/book.xml:21862(term)
msgid "D"
msgstr "D"

#: build/en/book.xml:21864(para)
msgid "Deleted"
msgstr "删除"

#: build/en/book.xml:21869(term)
msgid "U"
msgstr "U"

#: build/en/book.xml:21871(para)
msgid "Updated"
msgstr "更新"

#: build/en/book.xml:21876(term)
msgid "C"
msgstr "C"

#: build/en/book.xml:21878(para)
msgid "Conflict"
msgstr "冲突 x"

#: build/en/book.xml:21883(term)
msgid "G"
msgstr "G"

#: build/en/book.xml:21885(para)
msgid "Merged"
msgstr "合并"

#: build/en/book.xml:21891(para)
msgid "A character in the first column signifies an update to the actual file, while updates to the file's properties are shown in the second column."
msgstr "第一列的字符反映文件本身的更新，而第二列会反映文件属性的更新。"

#: build/en/book.xml:21898(para)
msgid "up"
msgstr "up"

#: build/en/book.xml:21914(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--non-recursive (-N)\n"
"--quiet (-q)\n"
"--diff3-cmd CMD\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
"--ignore-externals\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--non-recursive (-N)\n"
"--quiet (-q)\n"
"--diff3-cmd CMD\n"
"--username USER\n"
"--password PASS\n"
"--no-auth-cache\n"
"--non-interactive\n"
"--config-dir DIR\n"
"--ignore-externals\n"

#: build/en/book.xml:21931(para)
msgid "Pick up repository changes that have happened since your last update:"
msgstr "获取你上次更新之后版本库的修改："

#: build/en/book.xml:21934(screen)
#, no-wrap
msgid ""
"\n"
"$ svn update\n"
"A  newdir/toggle.c\n"
"A  newdir/disclose.c\n"
"A  newdir/launch.c\n"
"D  newdir/README\n"
"Updated to revision 32.\n"
msgstr ""
"\n"
"$ svn update\n"
"A  newdir/toggle.c\n"
"A  newdir/disclose.c\n"
"A  newdir/launch.c\n"
"D  newdir/README\n"
"Updated to revision 32.\n"

#: build/en/book.xml:21943(para)
msgid "You can also update your working copy to an older revision (Subversion doesn't have the concept of <quote>sticky</quote> files like CVS does; see <xref linkend=\"svn.forcvs\"/>):"
msgstr "你也可以将工作拷贝更新到旧的修订版本（Subversion没有CVS的<quote>sticky</quote>文件的概念；见<xref linkend=\"svn.forcvs\"/>）："

#: build/en/book.xml:21947(screen)
#, no-wrap
msgid ""
"\n"
"$ svn update -r30\n"
"A  newdir/README\n"
"D  newdir/toggle.c\n"
"D  newdir/disclose.c\n"
"D  newdir/launch.c\n"
"U  foo.c\n"
"Updated to revision 30.\n"
msgstr ""
"\n"
"$ svn update -r30\n"
"A  newdir/README\n"
"D  newdir/toggle.c\n"
"D  newdir/disclose.c\n"
"D  newdir/launch.c\n"
"U  foo.c\n"
"Updated to revision 30.\n"

#: build/en/book.xml:21958(para)
msgid "If you want to examine an older revision of a single file, you may want to use <command moreinfo=\"none\">svn cat</command>."
msgstr "如果你希望检查单个文件的旧的修订版本，你会希望使用<command moreinfo=\"none\">svn cat</command>。"

#: build/en/book.xml:21975(para)
msgid "<command moreinfo=\"none\">svnadmin</command> is the administrative tool for monitoring and repairing your Subversion repository. For detailed information, see <xref linkend=\"svn.reposadmin.maint.tk.svnadmin\"/>."
msgstr "<command moreinfo=\"none\">svnadmin</command>是一个用来监控和修改Subversion版本库的管理工具，详情请见<xref linkend=\"svn.reposadmin.maint.tk.svnadmin\"/>。"

#: build/en/book.xml:21979(para)
msgid "Since <command moreinfo=\"none\">svnadmin</command> works via direct repository access (and thus can only be used on the machine that holds the repository), it refers to the repository with a path, not a URL."
msgstr "因为<command moreinfo=\"none\">svnadmin</command>直接访问版本库（因此只可以在存放版本库的机器上使用），它通过路径访问版本库，而不是URL。"

#: build/en/book.xml:21985(title)
msgid "<command moreinfo=\"none\">svnadmin</command> Switches"
msgstr "<command moreinfo=\"none\">svnadmin</command> 选项"

#: build/en/book.xml:21990(option)
msgid "--bdb-log-keep"
msgstr "--bdb-log-keep"

#: build/en/book.xml:21992(para)
msgid "(Berkeley DB specific) Disable automatic log removal of database log files."
msgstr "（Berkeley DB 特定）禁用数据库日志自动日志删除功能。"

#: build/en/book.xml:21998(option)
msgid "--bdb-txn-nosync"
msgstr "--bdb-txn-nosync"

#: build/en/book.xml:22000(para)
msgid "(Berkeley DB specific) Disables fsync when committing database transactions."
msgstr "（Berkeley DB特定）当提交数据库事务时关闭fsync。"

#: build/en/book.xml:22006(option)
msgid "--bypass-hooks"
msgstr "--bypass-hooks"

#: build/en/book.xml:22008(para)
msgid "Bypass the repository hook system."
msgstr "绕过版本库钩子系统。"

#: build/en/book.xml:22013(option)
msgid "--clean-logs"
msgstr "--clean-logs"

#: build/en/book.xml:22015(para)
msgid "Removes unused Berkeley DB logs."
msgstr "删除不使用的Berkeley DB日志。"

#: build/en/book.xml:22022(option)
msgid "--force-uuid"
msgstr "--force-uuid"

#: build/en/book.xml:22024(para)
msgid "By default, when loading data into repository that already contains revisions, <command moreinfo=\"none\">svnadmin</command> will ignore the <literal moreinfo=\"none\">UUID</literal> from the dump stream. This switch will cause the repository's <literal moreinfo=\"none\">UUID</literal> to be set to the <literal moreinfo=\"none\">UUID</literal> from the stream."
msgstr "缺省情况下，当版本库加载已经包含修订版本的数据时<command moreinfo=\"none\">svnadmin</command>会忽略流中的<literal moreinfo=\"none\">UUID</literal>，这个选项会导致版本库的<literal moreinfo=\"none\">UUID</literal>设置为流的<literal moreinfo=\"none\">UUID</literal>。"

#: build/en/book.xml:22034(option)
msgid "--ignore-uuid"
msgstr "--ignore-uuid"

#: build/en/book.xml:22036(para)
msgid "By default, when loading an empty repository, <command moreinfo=\"none\">svnadmin</command> will use the <literal moreinfo=\"none\">UUID</literal> from the dump stream. This switch will cause that UUID to be ignored."
msgstr "缺省情况下，当加载空版本库时，<command moreinfo=\"none\">svnadmin</command>会使用来自流中的<literal moreinfo=\"none\">UUID</literal>，这个选项会导致忽略UUID。"

#: build/en/book.xml:22046(para)
msgid "Dump a revision only as a diff against the previous revision, instead of the usual fulltext."
msgstr "导出一个修订版本针对前一个修订版本的区别，而不是通常的完全结果。"

#: build/en/book.xml:22053(option)
msgid "--parent-dir <placeholder-1/>"
msgstr "--parent-dir <placeholder-1/>"

#: build/en/book.xml:22056(para)
msgid "When loading a dump file, root paths at <replaceable>DIR</replaceable> instead of <filename moreinfo=\"none\">/</filename>."
msgstr "当加载一个转储文件时，根路径为<replaceable>DIR</replaceable>而不是<filename moreinfo=\"none\">/</filename>。"

#: build/en/book.xml:22063(term)
msgid "<option>--revision</option> (<option>-r</option>) <replaceable>ARG</replaceable>"
msgstr "<option>--revision</option> (<option>-r</option>) <replaceable>ARG</replaceable>"

#: build/en/book.xml:22066(para)
msgid "Specify a particular revision to operate on."
msgstr "指定一个操作的修订版本。"

#: build/en/book.xml:22072(option)
msgid "--quiet"
msgstr "--quiet"

#: build/en/book.xml:22074(para)
msgid "Do not show normal progress—show only errors."
msgstr "不显示通常的过程—只显示错误。"

#: build/en/book.xml:22080(option)
msgid "--use-post-commit-hook"
msgstr "--use-post-commit-hook"

#: build/en/book.xml:22082(para)
msgid "When loading a dump file, run the repository's post-commit hook after finalizing each newly loaded revision."
msgstr "当导入使用一个转储文件时，在每次新的修订版本产生时运行版本库post-commit钩子。"

#: build/en/book.xml:22089(option)
msgid "--use-pre-commit-hook"
msgstr "--use-pre-commit-hook"

#: build/en/book.xml:22091(para)
msgid "When loading a dump file, run the repository's pre-commit hook before finalizing each newly loaded revision. If the hook fails, abort the commit and terminate the load process."
msgstr "当加载一个转储文件时，每次新加修订版本之前运行版本库的pre-commit钩子。如果钩子失败，终止提交并中断加载进程。"

#: build/en/book.xml:22103(title)
msgid "<command moreinfo=\"none\">svnadmin</command> Subcommands"
msgstr "<command moreinfo=\"none\">svnadmin</command> 子命令"

#: build/en/book.xml:22110(tertiary)
msgid "create"
msgstr "create"

#: build/en/book.xml:22114(refname)
msgid "svnadmin create"
msgstr "svnadmin create"

#: build/en/book.xml:22115(refpurpose)
msgid "Create a new, empty repository."
msgstr "创建一个新的空的版本库。"

#: build/en/book.xml:22119(programlisting)
#, no-wrap
msgid "svnadmin create REPOS_PATH"
msgstr "svnadmin create REPOS_PATH"

#: build/en/book.xml:22126(para)
msgid "Remember, <command moreinfo=\"none\">svnadmin</command> works only with local <emphasis>paths</emphasis>, not <emphasis>URLs</emphasis>."
msgstr "记住<command moreinfo=\"none\">svnadmin</command>只工作在本地<emphasis>路径</emphasis>，而不是<emphasis>URL</emphasis>。"

#: build/en/book.xml:22124(para)
msgid "Create a new, empty repository at the path provided. If the provided directory does not exist, it will be created for you.<placeholder-1/> As of Subversion 1.2, <command moreinfo=\"none\">svnadmin</command> creates new repositories with the <literal moreinfo=\"none\">fsfs</literal> filesystem backend by default."
msgstr "在提供的路径上创建一个新的空的版本库，如果提供的目录不存在，它会为你创建。<placeholder-1/>对于Subversion 1.2，<command moreinfo=\"none\">svnadmin</command>缺省使用<literal moreinfo=\"none\">fsfs</literal>文件系统后端创建版本库。"

#: build/en/book.xml:22138(screen)
#, no-wrap
msgid ""
"\n"
"--bdb-txn-nosync\n"
"--bdb-log-keep\n"
"--config-dir DIR\n"
"--fs-type TYPE\n"
msgstr ""
"\n"
"--bdb-txn-nosync\n"
"--bdb-log-keep\n"
"--config-dir DIR\n"
"--fs-type TYPE\n"

#: build/en/book.xml:22149(para)
msgid "Creating a new repository is just this easy:"
msgstr "创建一个版本库就是这样简单："

#: build/en/book.xml:22151(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create /usr/local/svn/repos\n"
msgstr ""
"\n"
"$ svnadmin create /usr/local/svn/repos\n"

#: build/en/book.xml:22155(para)
msgid "In Subversion 1.0, a Berkeley DB repository is always created. In Subversion 1.1, a Berkeley DB repository is the default repository type, but an FSFS repository can be created using the <option>--fs-type</option> option:"
msgstr "在Subversion 1.0，一定会创建一个Berkeley DB版本库，在Subversion 1.1，Berkeley DB版本库是缺省类型，但是一个FSFS版本库也是可以创建，使用<option>--fs-type</option>选项："

#: build/en/book.xml:22161(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create /usr/local/svn/repos --fs-type fsfs\n"
msgstr ""
"\n"
"$ svnadmin create /usr/local/svn/repos --fs-type fsfs\n"

#: build/en/book.xml:22173(tertiary)
msgid "deltify"
msgstr "deltify"

#: build/en/book.xml:22177(refname)
msgid "svnadmin deltify"
msgstr "svnadmin deltify"

#: build/en/book.xml:22178(refpurpose)
msgid "Deltify changed paths in a revision range."
msgstr "修订版本范围的路径的增量变化。"

#: build/en/book.xml:22182(programlisting)
#, no-wrap
msgid "svnadmin deltify [-r LOWER[:UPPER]] REPOS_PATH"
msgstr "svnadmin deltify [-r LOWER[:UPPER]] REPOS_PATH"

#: build/en/book.xml:22187(para)
#, fuzzy
msgid "<command moreinfo=\"none\">svnadmin deltify</command> only exists in current versions of Subversion due to historical reasons. This command is deprecated and no longer needed."
msgstr "<command moreinfo=\"none\">svnadmin deltify</command>因为历史原因之存在于1.0.x，这个命令已经废弃，不再需要。"

#: build/en/book.xml:22191(para)
msgid "It dates from a time when Subversion offered administrators greater control over compression strategies in the repository. This turned out to be a lot of complexity for <emphasis>very</emphasis> little gain, and this <quote>feature</quote> was deprecated."
msgstr "它开始于当Subversion提供了管理员控制版本库压缩策略的能力，结果是复杂工作得到了<emphasis>非常</emphasis>小的收益，所以这个<quote>特性</quote>被废弃了。"

#: build/en/book.xml:22201(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--quiet (-q)\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--quiet (-q)\n"

#: build/en/book.xml:22213(tertiary)
msgid "dump"
msgstr "dump"

#: build/en/book.xml:22217(refname)
msgid "svnadmin dump"
msgstr "svnadmin dump"

#: build/en/book.xml:22218(refpurpose)
msgid "Dump the contents of filesystem to stdout."
msgstr "将文件系统的内容转储到标准输出。"

#: build/en/book.xml:22222(programlisting)
#, no-wrap
msgid "svnadmin dump REPOS_PATH [-r LOWER[:UPPER]] [--incremental]"
msgstr "svnadmin dump REPOS_PATH [-r LOWER[:UPPER]] [--incremental]"

#: build/en/book.xml:22227(para)
msgid "Dump the contents of filesystem to stdout in a <quote>dumpfile</quote> portable format, sending feedback to stderr. Dump revisions <replaceable>LOWER</replaceable> rev through <replaceable>UPPER</replaceable> rev. If no revisions are given, dump all revision trees. If only <replaceable>LOWER</replaceable> is given, dump that one revision tree. See <xref linkend=\"svn.reposadmin.maint.migrate\"/> for a practical use."
msgstr "使用<quote>dumpfile</quote>可移植格式将文件系统的内容转储到标准输出，将反馈发送到标准错误，导出的修订版本从<replaceable>LOWER</replaceable>到<replaceable>UPPER</replaceable>。如果没有提供修订版本，会导出所有的修订版本树，如果只提供<replaceable>LOWER</replaceable>，导出一个修订版本树，通常的用法见<xref linkend=\"svn.reposadmin.maint.migrate\"/>。"

#: build/en/book.xml:22237(para)
msgid "By default, the Subversion dumpfile stream contains a single revision (the first revision in the requested revision range) in which every file and directory in the repository in that revision is presented as if that whole tree was added at once, followed by other revisions (the remainder of the revisions in the requested range) which contain only the files and directories which were modified in those revisions. For a modified file, the complete fulltext representation of its contents, as well as all of its properties, are presented in the dumpfile; for a directory, all of its properties are presented."
msgstr "缺省情况下，Subversion的转储流包含了一个包括所有文件和目录的单独修订版本（请求的修订版本范围的第一个），后面是其它的只包含本修订所修改的文件和目录的修订版本（请求范围的其它版本）。对于修改的文件，转储文件包括所有的内容和属性，对于目录，包括所有的属性。"

#: build/en/book.xml:22249(para)
msgid "There are a pair of useful options which modify the dumpfile generator's behavior. The first is the <option>--incremental</option> option, which simply causes that first revision in the dumpfile stream to contain only the files and directories modified in that revision, instead of being presented as the addition of a new tree, and in exactly the same way that every other revision in the dumpfile is presented. This is useful for generating a dumpfile that is to be loaded into another repository which already has the files and directories that exist in the original repository."
msgstr "有一对有用的选项可以改变转储文件产生的方式，第一个是<option>--incremental</option>，使得第一个修订版本只显示其修改的文件和目录，而不是整个目录树，就像转储文件中其它的修订版本。这对产生一个准备导入到已经有数据的版本库时非常有用。"

#: build/en/book.xml:22261(para)
msgid "The second useful option is <option>--deltas</option>. This switch causes <command moreinfo=\"none\">svnadmin dump</command> to, instead of emitting fulltext representations of file contents and property lists, emit only deltas of those items against their previous versions. This reduces (in some cases, drastically) the size of the dumpfile that <command moreinfo=\"none\">svnadmin dump</command> creates. There are, however, disadvantages to using this option—deltified dumpfiles are more CPU intensive to create, cannot be operated on by <command moreinfo=\"none\">svndumpfilter</command>, and tend not to compress as well as their non-deltified counterparts when using third-party tools like <command moreinfo=\"none\">gzip</command> and <command moreinfo=\"none\">bzip2</command>."
msgstr "第二个有用的选项是<option>--deltas</option>，这个选项导致<command moreinfo=\"none\">svnadmin dump</command>不会保留修改文件的所有内容，而只是记录修改的部分。这样减少（有些情况下是非常大的）了<command moreinfo=\"none\">svnadmin dump</command>产生的转储文件的大小。然而，也有缺点—增量转储文件需要更多的CPU来创建，也不可以用<command moreinfo=\"none\">svndumpfilter</command>操作，也不如非增量文件容易被如<command moreinfo=\"none\">gzip</command>和<command moreinfo=\"none\">bzip2</command>等第三方工具压缩。"

#: build/en/book.xml:22279(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--incremental\n"
"--quiet (-q)\n"
"--deltas\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--incremental\n"
"--quiet (-q)\n"
"--deltas\n"

#: build/en/book.xml:22290(para)
msgid "Dump your whole repository:"
msgstr "转储整个版本库："

#: build/en/book.xml:22292(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin dump /usr/local/svn/repos\n"
"SVN-fs-dump-format-version: 1\n"
"Revision-number: 0\n"
"* Dumped revision 0.\n"
"Prop-content-length: 56\n"
"Content-length: 56\n"
"…\n"
msgstr ""
"\n"
"$ svnadmin dump /usr/local/svn/repos\n"
"SVN-fs-dump-format-version: 1\n"
"Revision-number: 0\n"
"* Dumped revision 0.\n"
"Prop-content-length: 56\n"
"Content-length: 56\n"
"…\n"

#: build/en/book.xml:22302(para)
msgid "Incrementally dump a single transaction from your repository:"
msgstr "从版本库增量转储一个单独的事务："

#: build/en/book.xml:22305(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin dump /usr/local/svn/repos -r 21 --incremental \n"
"* Dumped revision 21.\n"
"SVN-fs-dump-format-version: 1\n"
"Revision-number: 21\n"
"Prop-content-length: 101\n"
"Content-length: 101\n"
"…\n"
msgstr ""
"\n"
"$ svnadmin dump /usr/local/svn/repos -r 21 --incremental \n"
"* Dumped revision 21.\n"
"SVN-fs-dump-format-version: 1\n"
"Revision-number: 21\n"
"Prop-content-length: 101\n"
"Content-length: 101\n"
"…\n"

#: build/en/book.xml:22327(refname)
msgid "svnadmin help"
msgstr "svnadmin help"

#: build/en/book.xml:22331(programlisting)
#, no-wrap
msgid "svnadmin help [SUBCOMMAND...]"
msgstr "svnadmin help [SUBCOMMAND...]"

#: build/en/book.xml:22337(para)
msgid "This subcommand is useful when you're trapped on a desert island with neither a net connection nor a copy of this book."
msgstr "当你困于一个没有网络连接和本书的沙漠岛屿时，这个子命令非常有用。"

#: build/en/book.xml:22355(tertiary)
msgid "hotcopy"
msgstr "hotcopy"

#: build/en/book.xml:22359(refname)
msgid "svnadmin hotcopy"
msgstr "svnadmin hotcopy"

#: build/en/book.xml:22360(refpurpose)
msgid "Make a hot copy of a repository."
msgstr "制作一个版本库的热备份。"

#: build/en/book.xml:22364(programlisting)
#, no-wrap
msgid "svnadmin hotcopy REPOS_PATH NEW_REPOS_PATH"
msgstr "svnadmin hotcopy REPOS_PATH NEW_REPOS_PATH"

#: build/en/book.xml:22370(para)
msgid "This subcommand makes a full <quote>hot</quote> backup of your repository, including all hooks, configuration files, and, of course, database files. If you pass the <option>--clean-logs</option> switch, <command moreinfo=\"none\">svnadmin</command> will perform a hotcopy of your repository, and then remove unused Berkeley DB logs from the original repository. You can run this command at any time and make a safe copy of the repository, regardless of whether other processes are using the repository."
msgstr "这个子命令会制作一个版本库的完全<quote>热</quote>拷贝，包括所有的钩子，配置文件，当然还有数据库文件。如果你传递<option>--clean-logs</option>选项，<command moreinfo=\"none\">svnadmin</command>会执行热拷贝操作，然后删除不用的Berkeley DB日志文件。你可以在任何时候运行这个命令得到一个版本库的安全拷贝，不管其它进程是否使用这个版本库。"

#: build/en/book.xml:22385(screen)
#, no-wrap
msgid ""
"\n"
"--clean-logs\n"
msgstr ""
"\n"
"--clean-logs\n"

#: build/en/book.xml:22397(tertiary)
msgid "list-dblogs"
msgstr "list-dblogs"

#: build/en/book.xml:22401(refname)
msgid "svnadmin list-dblogs"
msgstr "svnadmin list-dblogs"

#: build/en/book.xml:22404(literal) build/en/book.xml:22436(literal)
#: build/en/book.xml:22639(literal)
msgid "bdb"
msgstr "bdb"

#: build/en/book.xml:22401(refpurpose)
msgid "Ask Berkeley DB which log files exist for a given Subversion repository (applies only to repositories using the <placeholder-1/> backend)."
msgstr "询问Berkeley DB在给定的Subversion版本库有哪些日志文件存在（只有在版本库使用<placeholder-1/>作为后端时使用）。"

#: build/en/book.xml:22408(programlisting)
#, no-wrap
msgid "svnadmin list-dblogs REPOS_PATH"
msgstr "svnadmin list-dblogs REPOS_PATH"

#: build/en/book.xml:22413(para) build/en/book.xml:22445(para)
msgid "Berkeley DB creates logs of all changes to the repository, which allow it to recover in the face of catastrophe. Unless you enable <literal moreinfo=\"none\">DB_LOG_AUTOREMOVE</literal>, the log files accumulate, although most are no longer used and can be deleted to reclaim disk space. See <xref linkend=\"svn.reposadmin.maint.diskspace\"/> for more information."
msgstr "Berkeley DB创建了记录所有版本库修改的日志，允许我们在面对大灾难时恢复。除非你开启了<literal moreinfo=\"none\">DB_LOG_AUTOREMOVE</literal>，否则日志文件会累积，尽管大多数是不再使用可以从磁盘删除得到空间。详情见<xref linkend=\"svn.reposadmin.maint.diskspace\"/>。"

#: build/en/book.xml:22429(tertiary)
msgid "list-unused-dblogs"
msgstr "list-unused-dblogs"

#: build/en/book.xml:22433(refname)
msgid "svnadmin list-unused-dblogs"
msgstr "svnadmin list-unused-dblogs"

#: build/en/book.xml:22434(refpurpose)
msgid "Ask Berkeley DB which log files can be safely deleted (applies only to repositories using the <placeholder-1/> backend)."
msgstr "询问Berkeley DB哪些日志文件可以安全的删除（只有在版本库使用<placeholder-1/>作为后端时使用）。"

#: build/en/book.xml:22440(programlisting)
#, no-wrap
msgid "svnadmin list-unused-dblogs REPOS_PATH"
msgstr "svnadmin list-unused-dblogs REPOS_PATH"

#: build/en/book.xml:22457(para)
msgid "Remove all unused log files from a repository:"
msgstr "Berkeley DB创建了记录所有版本库修改的日志，允许我们在面对大灾难时恢复。除非你开启了<literal moreinfo=\"none\">DB_LOG_AUTOREMOVE</literal>，否则日志文件会累积，尽管大多数是不再使用，可以从磁盘删除得到空间。详情见<xref linkend=\"svn.reposadmin.maint.diskspace\"/>。"

#: build/en/book.xml:22477(tertiary)
msgid "load"
msgstr "load"

#: build/en/book.xml:22481(refname)
msgid "svnadmin load"
msgstr "svnadmin load"

#: build/en/book.xml:22482(quote)
msgid "dumpfile"
msgstr "svnadmin load"

#: build/en/book.xml:22481(refpurpose)
msgid "Read a <placeholder-1/>-formatted stream from stdin."
msgstr ""

#: build/en/book.xml:22487(programlisting)
#, no-wrap
msgid "svnadmin load REPOS_PATH"
msgstr "svnadmin load REPOS_PATH"

#: build/en/book.xml:22492(para)
msgid "Read a <quote>dumpfile</quote>-formatted stream from stdin, committing new revisions into the repository's filesystem. Send progress feedback to stdout."
msgstr ""

#: build/en/book.xml:22500(screen)
#, no-wrap
msgid ""
"\n"
"--quiet (-q)\n"
"--ignore-uuid\n"
"--force-uuid\n"
"--use-pre-commit-hook\n"
"--use-post-commit-hook\n"
"--parent-dir\n"
msgstr ""
"\n"
"--quiet (-q)\n"
"--ignore-uuid\n"
"--force-uuid\n"
"--use-pre-commit-hook\n"
"--use-post-commit-hook\n"
"--parent-dir\n"

#: build/en/book.xml:22511(title) build/en/book.xml:22567(title)
#: build/en/book.xml:22738(title)
msgid "Example"
msgstr "例子"

#: build/en/book.xml:22513(para)
msgid "This shows the beginning of loading a repository from a backup file (made, of course, with <command moreinfo=\"none\">svnadmin dump</command>):"
msgstr "这里显示了加载一个备份文件到版本库（当然，使用<command moreinfo=\"none\">svnadmin dump</command>）："

#: build/en/book.xml:22517(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin load /usr/local/svn/restored &lt; repos-backup\n"
"&lt;&lt;&lt; Started new txn, based on original revision 1\n"
"     * adding path : test ... done.\n"
"     * adding path : test/a ... done.\n"
"…\n"
msgstr ""
"\n"
"$ svnadmin load /usr/local/svn/restored &lt; repos-backup\n"
"&lt;&lt;&lt; Started new txn, based on original revision 1\n"
"     * adding path : test ... done.\n"
"     * adding path : test/a ... done.\n"
"…\n"

#: build/en/book.xml:22525(para)
msgid "Or if you want to load into a subdirectory:"
msgstr "或者你希望加载到一个子目录："

#: build/en/book.xml:22527(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin load --parent-dir new/subdir/for/project /usr/local/svn/restored &lt; repos-backup\n"
"&lt;&lt;&lt; Started new txn, based on original revision 1\n"
"     * adding path : test ... done.\n"
"     * adding path : test/a ... done.\n"
"…\n"
msgstr ""
"\n"
"$ svnadmin load --parent-dir new/subdir/for/project /usr/local/svn/restored &lt; repos-backup\n"
"&lt;&lt;&lt; Started new txn, based on original revision 1\n"
"     * adding path : test ... done.\n"
"     * adding path : test/a ... done.\n"
"…\n"

#: build/en/book.xml:22543(tertiary)
msgid "lslocks"
msgstr "lslocks"

#: build/en/book.xml:22547(refname)
msgid "svnadmin lslocks"
msgstr "svnadmin lslocks"

#: build/en/book.xml:22548(refpurpose)
msgid "Print descriptions of all locks."
msgstr "打印所有锁定的描述。"

#: build/en/book.xml:22552(programlisting)
#, no-wrap
msgid "svnadmin lslocks REPOS_PATH"
msgstr "svnadmin lslocks REPOS_PATH"

#: build/en/book.xml:22557(para)
msgid "Print descriptions of all locks in a repository."
msgstr "打印版本库所有锁定的描述。"

#: build/en/book.xml:22570(para)
msgid "This lists the one locked file in the repository at <filename moreinfo=\"none\">/svn/repos</filename>"
msgstr "显示了版本库<filename moreinfo=\"none\">/svn/repos</filename>中一个锁定的文件："

#: build/en/book.xml:22573(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin lslocks /svn/repos\n"
"Path: /tree.jpg\n"
"UUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753\n"
"Owner: harry\n"
"Created: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)\n"
"Expires: \n"
"Comment (1 line):\n"
"Rework the uppermost branches on the bald cypress in the foreground.\n"
msgstr ""
"\n"
"$ svnadmin lslocks /svn/repos\n"
"Path: /tree.jpg\n"
"UUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753\n"
"Owner: harry\n"
"Created: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)\n"
"Expires: \n"
"Comment (1 line):\n"
"Rework the uppermost branches on the bald cypress in the foreground.\n"

#: build/en/book.xml:22591(tertiary)
msgid "lstxns"
msgstr "lstxns"

#: build/en/book.xml:22595(refname)
msgid "svnadmin lstxns"
msgstr "svnadmin lstxns"

#: build/en/book.xml:22596(refpurpose)
msgid "Print the names of all uncommitted transactions."
msgstr "打印所有未提交的事物名称。"

#: build/en/book.xml:22600(programlisting)
#, no-wrap
msgid "svnadmin lstxns REPOS_PATH"
msgstr "svnadmin lstxns REPOS_PATH"

#: build/en/book.xml:22605(para)
#, fuzzy
msgid "Print the names of all uncommitted transactions. See <xref linkend=\"svn.reposadmin.maint.diskspace.deadtxns\"/> for information on how uncommitted transactions are created and what you should do with them."
msgstr "打印所有未提交的事物名称。关于未提交事物是怎样创建和如何使用的信息见<xref linkend=\"svn.reposadmin.maint.cleanup\"/>。"

#: build/en/book.xml:22614(para)
msgid "List all outstanding transactions in a repository."
msgstr "列出版本库所有突出的事物。"

#: build/en/book.xml:22617(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin lstxns /usr/local/svn/repos/ \n"
"1w\n"
"1x\n"
msgstr ""
"\n"
"$ svnadmin lstxns /usr/local/svn/repos/ \n"
"1w\n"
"1x\n"

#: build/en/book.xml:22631(tertiary)
msgid "recover"
msgstr "recover"

#: build/en/book.xml:22635(refname)
msgid "svnadmin recover"
msgstr "svnadmin recover"

#: build/en/book.xml:22640(filename)
msgid "repos/conf/passwd"
msgstr "repos/conf/passwd"

#: build/en/book.xml:22637(refpurpose)
msgid "Bring a repository database back into a consistent state (applies only to repositories using the <placeholder-1/> backend). In addition, if <placeholder-2/> does not exist, it will create a default password file ."
msgstr "将版本库数据库恢复到稳定状态（只有在版本库使用<placeholder-1/>作为后端时使用），此外，如果<placeholder-2/>不存在，它会创建一个默认的密码文件。"

#: build/en/book.xml:22646(programlisting)
#, no-wrap
msgid "svnadmin recover REPOS_PATH"
msgstr "svnadmin recover REPOS_PATH"

#: build/en/book.xml:22651(para)
msgid "Run this command if you get an error indicating that your repository needs to be recovered."
msgstr "在你得到的错误说明你需要恢复版本库时运行这个命令。"

#: build/en/book.xml:22656(screen)
#, no-wrap
msgid ""
"\n"
"--wait\n"
msgstr ""
"\n"
"--wait\n"

#: build/en/book.xml:22663(para)
msgid "Recover a hung repository:"
msgstr "恢复挂起的版本库："

#: build/en/book.xml:22665(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin recover /usr/local/svn/repos/ \n"
"Repository lock acquired.\n"
"Please wait; recovering the repository may take some time...\n"
"\n"
"Recovery completed.\n"
"The latest repos revision is 34.\n"
msgstr ""
"\n"
"$ svnadmin recover /usr/local/svn/repos/ \n"
"Repository lock acquired.\n"
"Please wait; recovering the repository may take some time...\n"
"\n"
"Recovery completed.\n"
"The latest repos revision is 34.\n"

#: build/en/book.xml:22674(para)
msgid "Recovering the database requires an exclusive lock on the repository. (This is a <quote>database lock</quote>; see <xref linkend=\"svn.advanced.locking.meanings\"/>.) If another process is accessing the repository, then <command moreinfo=\"none\">svnadmin recover</command> will error:"
msgstr "恢复数据库需要一个版本库的独占锁（这是一个<quote>数据库锁</quote>；见<xref linkend=\"svn.advanced.locking.meanings\"/>），如果另一个进程访问版本库，<command moreinfo=\"none\">svnadmin recover</command>会出错："

#: build/en/book.xml:22679(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin recover /usr/local/svn/repos\n"
"svn: Failed to get exclusive repository access; perhaps another process\n"
"such as httpd, svnserve or svn has it open?\n"
"\n"
"$\n"
msgstr ""
"\n"
"$ svnadmin recover /usr/local/svn/repos\n"
"svn: Failed to get exclusive repository access; perhaps another process\n"
"such as httpd, svnserve or svn has it open?\n"
"\n"
"$\n"

#: build/en/book.xml:22687(para)
msgid "The <option>--wait</option> option, however, will cause <command moreinfo=\"none\">svnadmin recover</command> to wait indefinitely for other processes to disconnect:"
msgstr "<option>--wait</option>选项可以导致<command moreinfo=\"none\">svnadmin recover</command>一直等待其它进程断开连接："

#: build/en/book.xml:22691(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin recover /usr/local/svn/repos --wait\n"
"Waiting on repository lock; perhaps another process has it open?\n"
"\n"
"### time goes by…\n"
"\n"
"Repository lock acquired.\n"
"Please wait; recovering the repository may take some time...\n"
"\n"
"Recovery completed.\n"
"The latest repos revision is 34.\n"
msgstr ""
"\n"
"$ svnadmin recover /usr/local/svn/repos --wait\n"
"Waiting on repository lock; perhaps another process has it open?\n"
"\n"
"### time goes by...\n"
"\n"
"Repository lock acquired.\n"
"Please wait; recovering the repository may take some time...\n"
"\n"
"Recovery completed.\n"
"The latest repos revision is 34.\n"

#: build/en/book.xml:22713(tertiary)
msgid "rmlocks"
msgstr "rmlocks"

#: build/en/book.xml:22717(refname)
msgid "svnadmin rmlocks"
msgstr "svnadmin rmlocks"

#: build/en/book.xml:22718(refpurpose)
msgid "Unconditionally remove one or more locks from a repository."
msgstr "无条件的删除版本库的一个或多个锁定。"

#: build/en/book.xml:22723(programlisting)
#, no-wrap
msgid "svnadmin rmlocks REPOS_PATH LOCKED_PATH..."
msgstr "svnadmin rmlocks REPOS_PATH LOCKED_PATH..."

#: build/en/book.xml:22728(para)
msgid "Remove lock from each <replaceable>LOCKED_PATH</replaceable>."
msgstr "从<replaceable>LOCKED_PATH</replaceable>删除没个锁定。"

#: build/en/book.xml:22740(para)
msgid "This deletes the locks on <filename moreinfo=\"none\">tree.jpg</filename> and <filename moreinfo=\"none\">house.jpg</filename> in the repository at <filename moreinfo=\"none\">/svn/repos</filename>"
msgstr "这删除了版本库<filename moreinfo=\"none\">/svn/repos</filename>里<filename moreinfo=\"none\">tree.jpg</filename>和<filename moreinfo=\"none\">house.jpg</filename>文件上的锁定："

#: build/en/book.xml:22745(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin rmlocks /svn/repos tree.jpg house.jpg\n"
"Removed lock on '/tree.jpg.\n"
"Removed lock on '/house.jpg.\n"
msgstr ""
"\n"
"$ svnadmin rmlocks /svn/repos tree.jpg house.jpg\n"
"Removed lock on '/tree.jpg.\n"
"Removed lock on '/house.jpg.\n"

#: build/en/book.xml:22759(tertiary)
msgid "rmtxns"
msgstr "rmtxns"

#: build/en/book.xml:22763(refname)
msgid "svnadmin rmtxns"
msgstr "svnadmin rmtxns"

#: build/en/book.xml:22764(refpurpose)
msgid "Delete transactions from a repository."
msgstr "从版本库删除事物。"

#: build/en/book.xml:22768(programlisting)
#, no-wrap
msgid "svnadmin rmtxns REPOS_PATH TXN_NAME..."
msgstr "svnadmin rmtxns REPOS_PATH TXN_NAME..."

#: build/en/book.xml:22773(para)
#, fuzzy
msgid "Delete outstanding transactions from a repository. This is covered in detail in <xref linkend=\"svn.reposadmin.maint.diskspace.deadtxns\"/>."
msgstr "删除版本库突出的事物，更多细节在<xref linkend=\"svn.reposadmin.maint.cleanup\"/>。"

#: build/en/book.xml:22780(screen)
#, no-wrap
msgid ""
"\n"
"--quiet (-q)\n"
msgstr ""
"\n"
"--quiet (-q)\n"

#: build/en/book.xml:22788(para)
msgid "Remove named transactions:"
msgstr "删除命名的事物："

#: build/en/book.xml:22790(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin rmtxns /usr/local/svn/repos/ 1w 1x\n"
msgstr ""
"\n"
"$ svnadmin rmtxns /usr/local/svn/repos/ 1w 1x\n"

#: build/en/book.xml:22794(para)
msgid "Fortunately, the output of <command moreinfo=\"none\">lstxns</command> works great as the input for <command moreinfo=\"none\">rmtxns</command>:"
msgstr "很幸运，<command moreinfo=\"none\">lstxns</command>的输出作为<command moreinfo=\"none\">rmtxns</command>输入工作良好："

#: build/en/book.xml:22797(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin rmtxns /usr/local/svn/repos/  `svnadmin lstxns /usr/local/svn/repos/`\n"
msgstr ""
"\n"
"$ svnadmin rmtxns /usr/local/svn/repos/  `svnadmin lstxns /usr/local/svn/repos/`\n"

#: build/en/book.xml:22801(para)
msgid "Which will remove all uncommitted transactions from your repository."
msgstr "从版本库删除所有未提交的事务。"

#: build/en/book.xml:22813(tertiary)
msgid "setlog"
msgstr "setlog"

#: build/en/book.xml:22817(refname)
msgid "svnadmin setlog"
msgstr "svnadmin setlog"

#: build/en/book.xml:22818(refpurpose)
msgid "Set the log-message on a revision."
msgstr "设置某个修订版本的日志信息。"

#: build/en/book.xml:22822(programlisting)
#, no-wrap
msgid "svnadmin setlog REPOS_PATH -r REVISION FILE"
msgstr "svnadmin setlog REPOS_PATH -r REVISION FILE"

#: build/en/book.xml:22827(para)
msgid "Set the log-message on revision REVISION to the contents of FILE."
msgstr "设置修订版本REVISION的日志信息为FILE的内容。"

#: build/en/book.xml:22830(para)
msgid "This is similar to using <command moreinfo=\"none\">svn propset --revprop</command> to set the <literal moreinfo=\"none\">svn:log</literal> property on a revision, except that you can also use the option <option>--bypass-hooks</option> to avoid running any pre- or post-commit hooks, which is useful if the modification of revision properties has not been enabled in the pre-revprop-change hook."
msgstr "这与使用<command moreinfo=\"none\">svn propset --revprop</command>设置某一修订版本的<literal moreinfo=\"none\">svn:log</literal>属性效果一样，除了你也可以使用<option>--bypass-hooks</option>选项绕过的所有pre-或post-commit的钩子脚本，这在pre-revprop-change钩子脚本中禁止修改修订版本属性时非常有用。"

#: build/en/book.xml:22839(para)
msgid "Revision properties are not under version control, so this command will permanently overwrite the previous log message."
msgstr "修订版本属性不在版本控制之下的，所以这个命令会永久覆盖前一个日志信息。"

#: build/en/book.xml:22849(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--bypass-hooks\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--bypass-hooks\n"

#: build/en/book.xml:22858(para)
msgid "Set the log message for revision 19 to the contents of the file <filename moreinfo=\"none\">msg</filename>:"
msgstr "设置修订版本19的日志信息为文件<filename moreinfo=\"none\">msg</filename>的内容："

#: build/en/book.xml:22861(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin setlog /usr/local/svn/repos/ -r 19 msg\n"
msgstr ""
"\n"
"$ svnadmin setlog /usr/local/svn/repos/ -r 19 msg\n"

#: build/en/book.xml:22873(tertiary)
msgid "verify"
msgstr "verify"

#: build/en/book.xml:22877(refname)
msgid "svnadmin verify"
msgstr "svnadmin verify"

#: build/en/book.xml:22878(refpurpose)
msgid "Verify the data stored in the repository."
msgstr "验证版本库保存的数据。"

#: build/en/book.xml:22882(programlisting)
#, no-wrap
msgid "svnadmin verify REPOS_PATH"
msgstr "svnadmin verify REPOS_PATH"

#: build/en/book.xml:22887(para)
msgid "Run this command if you wish to verify the integrity of your repository. This basically iterates through all revisions in the repository by internally dumping all revisions and discarding the output."
msgstr "如果希望验证版本库的完整性可以运行这个命令，原理是通过在内部转储遍历所有的修订版本并且丢掉输出。"

#: build/en/book.xml:22896(para)
msgid "Verify a hung repository:"
msgstr "检验挂起的版本库："

#: build/en/book.xml:22898(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin verify /usr/local/svn/repos/ \n"
"* Verified revision 1729.\n"
msgstr ""
"\n"
"$ svnadmin verify /usr/local/svn/repos/ \n"
"* Verified revision 1729.\n"

#: build/en/book.xml:22916(para)
msgid "<command moreinfo=\"none\">svnlook</command> is a command-line utility for examining different aspects of a Subversion repository. It does not make any changes to the repository—it's just used for <quote>peeking</quote>. <command moreinfo=\"none\">svnlook</command> is typically used by the repository hooks, but a repository administrator might find it useful for diagnostic purposes."
msgstr "<command moreinfo=\"none\">svnlook</command>是检验Subversion版本库不同方面的命令行工具，它不会对版本库有任何修改—它只是用来<quote>看</quote>。<command moreinfo=\"none\">svnlook</command>通常被版本库钩子使用，但是版本库管理也会发现它在诊断目的上也非常有用。"

#: build/en/book.xml:22924(para)
msgid "Since <command moreinfo=\"none\">svnlook</command> works via direct repository access (and thus can only be used on the machine that holds the repository), it refers to the repository with a path, not a URL."
msgstr "因为<command moreinfo=\"none\">svnlook</command>通过直接版本库访问（因此只可以在保存版本库的机器上工作）工作，所以他通过版本库的路径访问，而不是URL。"

#: build/en/book.xml:22928(para)
msgid "If no revision or transaction is specified, <command moreinfo=\"none\">svnlook</command> defaults to the youngest (most recent) revision of the repository."
msgstr "如果没有指定修订版本或事物，<command moreinfo=\"none\">svnlook</command>缺省的是版本库最年轻的（最新的）修订版本。"

#: build/en/book.xml:22934(title)
msgid "<command moreinfo=\"none\">svnlook</command> Switches"
msgstr "<command moreinfo=\"none\">svnlook</command> 选项"

#: build/en/book.xml:22936(para)
msgid "Switches in <command moreinfo=\"none\">svnlook</command> are global, just like in <command moreinfo=\"none\">svn</command> and <command moreinfo=\"none\">svnadmin</command>; however, most switches only apply to one subcommand since the functionality of <command moreinfo=\"none\">svnlook</command> is (intentionally) limited in scope."
msgstr "<command moreinfo=\"none\">svnlook</command>的选项是全局的，就像<command moreinfo=\"none\">svn</command>和<command moreinfo=\"none\">svnadmin</command>；然而，大多数选项只会应用到一个子命令，因为<command moreinfo=\"none\">svnlook</command>的功能是（有意的）限制在一定范围的。"

#: build/en/book.xml:22948(para)
msgid "Prevents <command moreinfo=\"none\">svnlook</command> from printing differences for deleted files. The default behavior when a file is deleted in a transaction/revision is to print the same differences that you would see if you had left the file but removed all the content."
msgstr "防止<command moreinfo=\"none\">svnlook</command>打印删除文件的区别，缺省的行为方式是当一个文件在一次事物/修订版本中删除后，得到的结果与保留这个文件的内容变成空相同。"

#: build/en/book.xml:22957(term)
msgid "<option>--revision</option> (<option>-r</option>)"
msgstr "<option>--revision</option> (<option>-r</option>)"

#: build/en/book.xml:22960(para)
msgid "Specify a particular revision number that you wish to examine."
msgstr "指定要进行检查的特定修订版本。"

#: build/en/book.xml:22977(term)
msgid "<option>--transaction</option> (<option>-t</option>)"
msgstr "<option>--transaction</option> (<option>-t</option>)"

#: build/en/book.xml:22980(para)
msgid "Specify a particular transaction ID that you wish to examine."
msgstr "指定一个希望检查的特定事物ID。"

#: build/en/book.xml:22986(option)
msgid "--show-ids"
msgstr "--show-ids"

#: build/en/book.xml:22988(para)
msgid "Show the filesystem node revision IDs for each path in the filesystem tree."
msgstr "显示文件系统树中每条路径的文件系统节点修订版本ID。"

#: build/en/book.xml:22999(title)
msgid "<command moreinfo=\"none\">svnlook</command> Subcommands"
msgstr "<command moreinfo=\"none\">svnlook</command> 子命令"

#: build/en/book.xml:23006(tertiary)
msgid "author"
msgstr "author"

#: build/en/book.xml:23010(refname)
msgid "svnlook author"
msgstr "svnlook author"

#: build/en/book.xml:23011(refpurpose)
msgid "Print the author."
msgstr "打印作者。"

#: build/en/book.xml:23015(programlisting)
#, no-wrap
msgid "svnlook author REPOS_PATH"
msgstr "svnlook author REPOS_PATH"

#: build/en/book.xml:23020(para)
msgid "Print the author of a revision or transaction in the repository."
msgstr "打印版本库一个修订版本或者事物的作者。"

#: build/en/book.xml:23027(screen) build/en/book.xml:23073(screen)
#: build/en/book.xml:23177(screen) build/en/book.xml:23230(screen)
#: build/en/book.xml:23348(screen) build/en/book.xml:23491(screen)
#: build/en/book.xml:23592(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--transaction (-t)\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--transaction (-t)\n"

#: build/en/book.xml:23036(para)
msgid "<command moreinfo=\"none\">svnlook author</command> is handy, but not very exciting:"
msgstr "<command moreinfo=\"none\">svnlook author</command>垂手可得，但是并不令人激动："

#: build/en/book.xml:23039(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook author -r 40 /usr/local/svn/repos \n"
"sally\n"
msgstr ""
"\n"
"$ svnlook author -r 40 /usr/local/svn/repos \n"
"sally\n"

#: build/en/book.xml:23056(refname)
msgid "svnlook cat"
msgstr "svnlook cat"

#: build/en/book.xml:23057(refpurpose) build/en/book.xml:23066(para)
msgid "Print the contents of a file."
msgstr "打印一个文件的内容。"

#: build/en/book.xml:23061(programlisting)
#, no-wrap
msgid "svnlook cat REPOS_PATH PATH_IN_REPOS"
msgstr "svnlook cat REPOS_PATH PATH_IN_REPOS"

#: build/en/book.xml:23082(para)
msgid "This shows the contents of a file in transaction <literal moreinfo=\"none\">ax8</literal>, located at <filename moreinfo=\"none\">/trunk/README</filename>:"
msgstr "这会显示事物<literal moreinfo=\"none\">ax8</literal>中一个文件的内容，位于<filename moreinfo=\"none\">/trunk/README</filename>："

#: build/en/book.xml:23086(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook cat -t ax8 /usr/local/svn/repos /trunk/README\n"
"\n"
"               Subversion, a version control system.\n"
"               =====================================\n"
"\n"
"$LastChangedDate: 2003-07-17 10:45:25 -0500 (Thu, 17 Jul 2003) $\n"
"\n"
"Contents:\n"
"\n"
"     I. A FEW POINTERS\n"
"    II. DOCUMENTATION\n"
"   III. PARTICIPATING IN THE SUBVERSION COMMUNITY\n"
"…\n"
msgstr ""
"\n"
"$ svnlook cat -t ax8 /usr/local/svn/repos /trunk/README\n"
"\n"
"               Subversion, a version control system.\n"
"               =====================================\n"
"\n"
"$LastChangedDate: 2003-07-17 10:45:25 -0500 (Thu, 17 Jul 2003) $\n"
"\n"
"Contents:\n"
"\n"
"     I. A FEW POINTERS\n"
"    II. DOCUMENTATION\n"
"   III. PARTICIPATING IN THE SUBVERSION COMMUNITY\n"
"…\n"

#: build/en/book.xml:23110(tertiary)
msgid "changed"
msgstr "changed"

#: build/en/book.xml:23114(refname)
msgid "svnlook changed"
msgstr "svnlook changed"

#: build/en/book.xml:23115(refpurpose)
msgid "Print the paths that were changed."
msgstr "打印修改的路径。"

#: build/en/book.xml:23119(programlisting)
#, no-wrap
msgid "svnlook changed REPOS_PATH"
msgstr "svnlook changed REPOS_PATH"

#: build/en/book.xml:23124(para)
msgid "Print the paths that were changed in a particular revision or transaction, as well as <quote>svn update-style</quote> status letters in the first two columns:"
msgstr "打印在特定修订版本或事物修改的路径，也是在前两列使用<quote>svn update样式的</quote>状态字符："

#: build/en/book.xml:23132(term)
msgid "'<literal moreinfo=\"none\">A </literal>'"
msgstr "'<literal moreinfo=\"none\">A </literal>'"

#: build/en/book.xml:23134(para)
msgid "Item added to repository."
msgstr "条目添加到版本库。"

#: build/en/book.xml:23139(term)
msgid "'<literal moreinfo=\"none\">D </literal>'"
msgstr "'<literal moreinfo=\"none\">D </literal>'"

#: build/en/book.xml:23141(para)
msgid "Item deleted from repository."
msgstr "条目从版本库删除。"

#: build/en/book.xml:23146(term)
msgid "'<literal moreinfo=\"none\">U </literal>'"
msgstr "'<literal moreinfo=\"none\">U </literal>'"

#: build/en/book.xml:23148(para)
msgid "File contents changed."
msgstr "文件内容改变了。"

#: build/en/book.xml:23153(term)
msgid "'<literal moreinfo=\"none\">_U</literal>'"
msgstr "'<literal moreinfo=\"none\">_U</literal>'"

#: build/en/book.xml:23155(para)
msgid "Properties of item changed."
msgstr "条目属性改变了。"

#: build/en/book.xml:23160(term)
msgid "'<literal moreinfo=\"none\">UU</literal>'"
msgstr "'<literal moreinfo=\"none\">UU</literal>'"

#: build/en/book.xml:23162(para)
msgid "File contents and properties changed."
msgstr "文件内容和属性修改了。"

#: build/en/book.xml:23168(para)
msgid "Files and directories can be distinguished, as directory paths are displayed with a trailing '<literal moreinfo=\"none\">/</literal>' character."
msgstr "文件和目录可以区分，目录路径后面会显示字符'<literal moreinfo=\"none\">/</literal>'。"

#: build/en/book.xml:23186(para)
msgid "This shows a list of all the changed files in revision 39 of a test repository:"
msgstr "显示在测试版本库修订版本39修改的文件列表："

#: build/en/book.xml:23189(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook changed -r 39 /usr/local/svn/repos\n"
"A   trunk/vendors/deli/\n"
"A   trunk/vendors/deli/chips.txt\n"
"A   trunk/vendors/deli/sandwich.txt\n"
"A   trunk/vendors/deli/pickle.txt\n"
"U   trunk/vendors/baker/bagel.txt\n"
"_U  trunk/vendors/baker/croissant.txt\n"
"UU  trunk/vendors/baker/pretzel.txt\n"
"D   trunk/vendors/baker/baguette.txt\n"
msgstr ""
"\n"
"$ svnlook changed -r 39 /usr/local/svn/repos\n"
"A   trunk/vendors/deli/\n"
"A   trunk/vendors/deli/chips.txt\n"
"A   trunk/vendors/deli/sandwich.txt\n"
"A   trunk/vendors/deli/pickle.txt\n"
"U   trunk/vendors/baker/bagel.txt\n"
"_U  trunk/vendors/baker/croissant.txt\n"
"UU  trunk/vendors/baker/pretzel.txt\n"
"D   trunk/vendors/baker/baguette.txt\n"

#: build/en/book.xml:23209(tertiary)
msgid "date"
msgstr "date"

#: build/en/book.xml:23213(refname)
msgid "svnlook date"
msgstr "svnlook date"

#: build/en/book.xml:23214(refpurpose)
msgid "Print the datestamp."
msgstr "打印时间戳。"

#: build/en/book.xml:23218(programlisting)
#, no-wrap
msgid "svnlook date REPOS_PATH"
msgstr "svnlook date REPOS_PATH"

#: build/en/book.xml:23223(para)
msgid "Print the datestamp of a revision or transaction in a repository."
msgstr "打印版本库一个修订版本或事物的时间戳。"

#: build/en/book.xml:23239(para)
msgid "This shows the date of revision 40 of a test repository:"
msgstr "显示测试版本库修订版本40的日期："

#: build/en/book.xml:23242(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook date -r 40 /tmp/repos/\n"
"2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)\n"
msgstr ""
"\n"
"$ svnlook date -r 40 /tmp/repos/\n"
"2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)\n"

#: build/en/book.xml:23259(refname)
msgid "svnlook diff"
msgstr "svnlook diff"

#: build/en/book.xml:23260(refpurpose)
msgid "Print differences of changed files and properties."
msgstr "打印修改的文件和属性的区别。"

#: build/en/book.xml:23264(programlisting)
#, no-wrap
msgid "svnlook diff REPOS_PATH"
msgstr "svnlook diff REPOS_PATH"

#: build/en/book.xml:23269(para)
msgid "Print GNU-style differences of changed files and properties in a repository."
msgstr "打印版本库中GNU样式的文件和属性修改区别。"

#: build/en/book.xml:23276(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--transaction (-t)\n"
"--no-diff-added\n"
"--no-diff-deleted\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--transaction (-t)\n"
"--no-diff-added\n"
"--no-diff-deleted\n"

#: build/en/book.xml:23287(para)
msgid "This shows a newly added (empty) file, a deleted file, and a copied file:"
msgstr "这显示了一个新添加的（空的）文件，一个删除的文件和一个拷贝的文件："

#: build/en/book.xml:23290(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook diff -r 40 /usr/local/svn/repos/\n"
"Copied: egg.txt (from rev 39, trunk/vendors/deli/pickle.txt)\n"
"\n"
"Added: trunk/vendors/deli/soda.txt\n"
"==============================================================================\n"
"\n"
"Modified: trunk/vendors/deli/sandwich.txt\n"
"==============================================================================\n"
"--- trunk/vendors/deli/sandwich.txt\t(original)\n"
"+++ trunk/vendors/deli/sandwich.txt\t2003-02-22 17:45:04.000000000 -0600\n"
"@@ -0,0 +1 @@\n"
"+Don't forget the mayo!\n"
"\n"
"Modified: trunk/vendors/deli/logo.jpg\n"
"==============================================================================\n"
"(Binary files differ)\n"
"\n"
"Deleted: trunk/vendors/deli/chips.txt\n"
"==============================================================================\n"
"\n"
"Deleted: trunk/vendors/deli/pickle.txt\n"
"==============================================================================\n"
msgstr ""
"\n"
"$ svnlook diff -r 40 /usr/local/svn/repos/\n"
"Copied: egg.txt (from rev 39, trunk/vendors/deli/pickle.txt)\n"
"\n"
"Added: trunk/vendors/deli/soda.txt\n"
"==============================================================================\n"
"\n"
"Modified: trunk/vendors/deli/sandwich.txt\n"
"==============================================================================\n"
"--- trunk/vendors/deli/sandwich.txt\t(original)\n"
"+++ trunk/vendors/deli/sandwich.txt\t2003-02-22 17:45:04.000000000 -0600\n"
"@@ -0,0 +1 @@\n"
"+Don't forget the mayo!\n"
"\n"
"Modified: trunk/vendors/deli/logo.jpg\n"
"==============================================================================\n"
"(Binary files differ)\n"
"\n"
"Deleted: trunk/vendors/deli/chips.txt\n"
"==============================================================================\n"
"\n"
"Deleted: trunk/vendors/deli/pickle.txt\n"
"==============================================================================\n"

#: build/en/book.xml:23315(para)
msgid "If a file has a non-textual <literal moreinfo=\"none\">svn:mime-type</literal> property, then the differences are not explicitly shown."
msgstr "如果一个文件有非文本的<literal moreinfo=\"none\">svn:mime-type</literal>属性，区别不会明确显示。"

#: build/en/book.xml:23326(tertiary)
msgid "dirs-changed"
msgstr "dirs-changed"

#: build/en/book.xml:23330(refname)
msgid "svnlook dirs-changed"
msgstr "svnlook dirs-changed"

#: build/en/book.xml:23331(refpurpose)
msgid "Print the directories that were themselves changed."
msgstr "打印本身修改的目录。"

#: build/en/book.xml:23335(programlisting)
#, no-wrap
msgid "svnlook dirs-changed REPOS_PATH"
msgstr "svnlook dirs-changed REPOS_PATH"

#: build/en/book.xml:23340(para)
msgid "Print the directories that were themselves changed (property edits) or whose file children were changed."
msgstr "打印本身修改（属性编辑）或子文件修改的目录。"

#: build/en/book.xml:23357(para)
msgid "This shows the directories that changed in revision 40 in our sample repository:"
msgstr "这显示了在我们的实例版本库中在修订版本40修改的目录："

#: build/en/book.xml:23360(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook dirs-changed -r 40 /usr/local/svn/repos\n"
"trunk/vendors/deli/\n"
msgstr ""
"\n"
"$ svnlook dirs-changed -r 40 /usr/local/svn/repos\n"
"trunk/vendors/deli/\n"

#: build/en/book.xml:23377(refname)
msgid "svnlook help"
msgstr "svnlook help"

#: build/en/book.xml:23381(programlisting)
#, no-wrap
msgid "Also svnlook -h and svnlook -?."
msgstr "Also svnlook -h and svnlook -?."

#: build/en/book.xml:23386(para)
msgid "Displays the help message for svnlook. This command, like its brother <command moreinfo=\"none\">svn help</command>, is also your friend, even though you never call it anymore and forgot to invite it to your last party."
msgstr "显示svnlook的帮助信息，这个命令如同<command moreinfo=\"none\">svn help</command>的兄弟，也是你的朋友，即使你从不调用它，并且忘掉了邀请它加入你的上一次聚会。"

#: build/en/book.xml:23404(tertiary)
msgid "history"
msgstr "history"

#: build/en/book.xml:23408(refname)
msgid "svnlook history"
msgstr "svnlook history"

#: build/en/book.xml:23409(refpurpose) build/en/book.xml:23420(para)
msgid "Print information about the history of a path in the repository (or the root directory if no path is supplied)."
msgstr "打印版本库（如果没有路径，则是根目录）某一个路径的历史。"

#: build/en/book.xml:23415(programlisting)
#, no-wrap
msgid "svnlook history REPOS_PATH [PATH_IN_REPOS]"
msgstr ""
"svnlook history REPOS_PATH\n"
"            [PATH_IN_REPOS]"

#: build/en/book.xml:23428(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--show-ids\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--show-ids\n"

#: build/en/book.xml:23437(para)
msgid "This shows the history output for the path <filename moreinfo=\"none\">/tags/1.0</filename> as of revision 20 in our sample repository."
msgstr "这显示了实例版本库中作为修订版本20的路径<filename moreinfo=\"none\">/tags/1.0</filename>的历史输出。"

#: build/en/book.xml:23441(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook history -r 20 /usr/local/svn/repos /tags/1.0 --show-ids\n"
"REVISION   PATH &lt;ID&gt;\n"
"--------   ---------\n"
"      19   /tags/1.0 &lt;1.2.12&gt;\n"
"      17   /branches/1.0-rc2 &lt;1.1.10&gt;\n"
"      16   /branches/1.0-rc2 &lt;1.1.x&gt;\n"
"      14   /trunk &lt;1.0.q&gt;\n"
"      13   /trunk &lt;1.0.o&gt;\n"
"      11   /trunk &lt;1.0.k&gt;\n"
"       9   /trunk &lt;1.0.g&gt;\n"
"       8   /trunk &lt;1.0.e&gt;\n"
"       7   /trunk &lt;1.0.b&gt;\n"
"       6   /trunk &lt;1.0.9&gt;\n"
"       5   /trunk &lt;1.0.7&gt;\n"
"       4   /trunk &lt;1.0.6&gt;\n"
"       2   /trunk &lt;1.0.3&gt;\n"
"       1   /trunk &lt;1.0.2&gt;\n"
msgstr ""
"\n"
"$ svnlook history -r 20 /usr/local/svn/repos /tags/1.0 --show-ids\n"
"REVISION   PATH &lt;ID&gt;\n"
"--------   ---------\n"
"      19   /tags/1.0 &lt;1.2.12&gt;\n"
"      17   /branches/1.0-rc2 &lt;1.1.10&gt;\n"
"      16   /branches/1.0-rc2 &lt;1.1.x&gt;\n"
"      14   /trunk &lt;1.0.q&gt;\n"
"      13   /trunk &lt;1.0.o&gt;\n"
"      11   /trunk &lt;1.0.k&gt;\n"
"       9   /trunk &lt;1.0.g&gt;\n"
"       8   /trunk &lt;1.0.e&gt;\n"
"       7   /trunk &lt;1.0.b&gt;\n"
"       6   /trunk &lt;1.0.9&gt;\n"
"       5   /trunk &lt;1.0.7&gt;\n"
"       4   /trunk &lt;1.0.6&gt;\n"
"       2   /trunk &lt;1.0.3&gt;\n"
"       1   /trunk &lt;1.0.2&gt;\n"

#: build/en/book.xml:23473(refname)
msgid "svnlook info"
msgstr "svnlook info"

#: build/en/book.xml:23474(refpurpose) build/en/book.xml:23484(para)
msgid "Print the author, datestamp, log message size, and log message."
msgstr "打印作者、时间戳、日志信息大小和日志信息。"

#: build/en/book.xml:23479(programlisting)
#, no-wrap
msgid "svnlook info REPOS_PATH"
msgstr "svnlook info REPOS_PATH"

#: build/en/book.xml:23500(para)
msgid "This shows the info output for revision 40 in our sample repository."
msgstr "显示了你的实例版本库在修订版本40的信息输出。"

#: build/en/book.xml:23503(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook info -r 40 /usr/local/svn/repos\n"
"sally\n"
"2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)\n"
"15\n"
"Rearrange lunch.\n"
msgstr ""
"\n"
"$ svnlook info -r 40 /usr/local/svn/repos\n"
"sally\n"
"2003-02-22 17:44:49 -0600 (Sat, 22 Feb 2003)\n"
"15\n"
"Rearrange lunch.\n"

#: build/en/book.xml:23524(refname)
msgid "svnlook lock"
msgstr "svnlook lock"

#: build/en/book.xml:23525(refpurpose)
msgid "If a lock exists on a path in the repository, describe it."
msgstr "如果版本库路径已经被锁定，描述它。"

#: build/en/book.xml:23530(programlisting)
#, no-wrap
msgid "svnlook lock REPOS_PATH PATH_IN_REPOS"
msgstr "svnlook lock REPOS_PATH PATH_IN_REPOS"

#: build/en/book.xml:23535(para)
msgid "Print all information available for the lock at <replaceable>PATH_IN_REPOS</replaceable>. If <replaceable>PATH_IN_REPOS</replaceable> is not locked, print nothing."
msgstr "打印<replaceable>PATH_IN_REPOS</replaceable>锁定的所有信息，如果<replaceable>PATH_IN_REPOS</replaceable>没有锁定，则不打印任何内容。"

#: build/en/book.xml:23550(para)
msgid "This describes the lock on the file <filename moreinfo=\"none\">tree.jpg</filename>."
msgstr "这描述了文件<filename moreinfo=\"none\">tree.jpg</filename>的锁定。"

#: build/en/book.xml:23553(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook lock /svn/repos tree.jpg\n"
"UUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753\n"
"Owner: harry\n"
"Created: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)\n"
"Expires: \n"
"Comment (1 line):\n"
"Rework the uppermost branches on the bald cypress in the foreground.\n"
msgstr ""
"\n"
"$ svnlook lock /svn/repos tree.jpg\n"
"UUID Token: opaquelocktoken:ab00ddf0-6afb-0310-9cd0-dda813329753\n"
"Owner: harry\n"
"Created: 2005-07-08 17:27:36 -0500 (Fri, 08 Jul 2005)\n"
"Expires: \n"
"Comment (1 line):\n"
"Rework the uppermost branches on the bald cypress in the foreground.\n"

#: build/en/book.xml:23576(refname)
msgid "svnlook log"
msgstr "svnlook log"

#: build/en/book.xml:23577(refpurpose) build/en/book.xml:23586(para)
msgid "Print the log message."
msgstr "打印日志信息。"

#: build/en/book.xml:23581(programlisting)
#, no-wrap
msgid "svnlook log REPOS_PATH"
msgstr "svnlook log REPOS_PATH"

#: build/en/book.xml:23601(para)
msgid "This shows the log output for revision 40 in our sample repository:"
msgstr "这显示了实例版本库在修订版本40的日志输出："

#: build/en/book.xml:23604(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook log /tmp/repos/\n"
"Rearrange lunch.\n"
msgstr ""
"\n"
"$ svnlook log /tmp/repos/\n"
"Rearrange lunch.\n"

#: build/en/book.xml:23621(refname)
msgid "svnlook propget"
msgstr "svnlook propget"

#: build/en/book.xml:23622(refpurpose)
msgid "Print the raw value of a property on a path in the repository."
msgstr "打印版本库中一个路径一个属性的原始值。"

#: build/en/book.xml:23627(programlisting)
#, no-wrap
msgid "svnlook propget REPOS_PATH PROPNAME [PATH_IN_REPOS]"
msgstr "svnlook propget REPOS_PATH PROPNAME [PATH_IN_REPOS]"

#: build/en/book.xml:23632(para)
msgid "List the value of a property on a path in the repository."
msgstr "列出版本库中一个路径一个属性的值。"

#: build/en/book.xml:23639(para)
msgid "pg, pget"
msgstr "pg, pget"

#: build/en/book.xml:23645(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--transaction (-t)\n"
"--revprop\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--transaction (-t)\n"
"--revprop\n"

#: build/en/book.xml:23655(para)
msgid "This shows the value of the <quote>seasonings</quote> property on the file <filename moreinfo=\"none\">/trunk/sandwich</filename> in the <literal moreinfo=\"none\">HEAD</literal> revision:"
msgstr "这显示了<literal moreinfo=\"none\">HEAD</literal>修订版本中文件<filename moreinfo=\"none\">/trunk/sandwich</filename>的<quote>seasonings</quote>属性的值："

#: build/en/book.xml:23659(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook pg /usr/local/svn/repos seasonings /trunk/sandwich\n"
"mustard\n"
msgstr ""
"\n"
"$ svnlook pg /usr/local/svn/repos seasonings /trunk/sandwich\n"
"mustard\n"

#: build/en/book.xml:23676(refname)
msgid "svnlook proplist"
msgstr "svnlook proplist"

#: build/en/book.xml:23677(refpurpose)
msgid "Print the names and values of versioned file and directory properties."
msgstr "打印版本化的文件和目录的属性名称和值。"

#: build/en/book.xml:23682(programlisting)
#, no-wrap
msgid "svnlook proplist REPOS_PATH [PATH_IN_REPOS]"
msgstr "svnlook proplist REPOS_PATH [PATH_IN_REPOS]"

#: build/en/book.xml:23687(para)
msgid "List the properties of a path in the repository. With <option>--verbose</option>, show the property values too."
msgstr "列出版本库中一个路径的属性，使用<option>--verbose</option>选项也会显示所有的属性值。"

#: build/en/book.xml:23694(para)
msgid "pl, plist"
msgstr "pl, plist"

#: build/en/book.xml:23700(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--transaction (-t)\n"
"--verbose (-v)\n"
"--revprop\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--transaction (-t)\n"
"--verbose (-v)\n"
"--revprop\n"

#: build/en/book.xml:23711(para)
msgid "This shows the names of properties set on the file <filename moreinfo=\"none\">/trunk/README</filename> in the <literal moreinfo=\"none\">HEAD</literal> revision:"
msgstr "这显示了<literal moreinfo=\"none\">HEAD</literal>修订版本中<filename moreinfo=\"none\">/trunk/README</filename>的属性名称："

#: build/en/book.xml:23715(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook proplist /usr/local/svn/repos /trunk/README\n"
"  original-author\n"
"  svn:mime-type\n"
msgstr ""
"\n"
"$ svnlook proplist /usr/local/svn/repos /trunk/README\n"
"  original-author\n"
"  svn:mime-type\n"

#: build/en/book.xml:23721(para)
msgid "This is the same command as in the previous example, but this time showing the property values as well:"
msgstr "这与前一个例子是同一个命令，但是同时显示了属性值："

#: build/en/book.xml:23724(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook --verbose proplist /usr/local/svn/repos /trunk/README\n"
"  original-author : fitz\n"
"  svn:mime-type : text/plain\n"
msgstr ""
"\n"
"$ svnlook --verbose proplist /usr/local/svn/repos /trunk/README\n"
"  original-author : fitz\n"
"  svn:mime-type : text/plain\n"

#: build/en/book.xml:23738(tertiary)
msgid "tree"
msgstr "tree"

#: build/en/book.xml:23742(refname)
msgid "svnlook tree"
msgstr "svnlook tree"

#: build/en/book.xml:23743(refpurpose)
msgid "Print the tree."
msgstr "打印树。"

#: build/en/book.xml:23747(programlisting)
#, no-wrap
msgid "svnlook tree REPOS_PATH [PATH_IN_REPOS]"
msgstr "svnlook tree REPOS_PATH [PATH_IN_REPOS]"

#: build/en/book.xml:23751(para)
msgid "Print the tree, starting at <replaceable>PATH_IN_REPOS</replaceable> (if supplied, at the root of the tree otherwise), optionally showing node revision IDs."
msgstr "打印树，从<replaceable>PATH_IN_REPOS</replaceable>（如果提供，会作为树的根）开始，可以选择显示节点修订版本ID。"

#: build/en/book.xml:23760(screen)
#, no-wrap
msgid ""
"\n"
"--revision (-r) REV\n"
"--transaction (-t)\n"
"--show-ids\n"
msgstr ""
"\n"
"--revision (-r) REV\n"
"--transaction (-t)\n"
"--show-ids\n"

#: build/en/book.xml:23770(para)
msgid "This shows the tree output (with node-IDs) for revision 40 in our sample repository:"
msgstr "这会显示实例版本库中修订版本40的树输出（包括节点ID）："

#: build/en/book.xml:23773(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook tree -r 40 /usr/local/svn/repos --show-ids\n"
"/ &lt;0.0.2j&gt;\n"
" trunk/ &lt;p.0.2j&gt;\n"
"  vendors/ &lt;q.0.2j&gt;\n"
"   deli/ &lt;1g.0.2j&gt;\n"
"    egg.txt &lt;1i.e.2j&gt;\n"
"    soda.txt &lt;1k.0.2j&gt;\n"
"    sandwich.txt &lt;1j.0.2j&gt;\n"
msgstr ""
"\n"
"$ svnlook tree -r 40 /usr/local/svn/repos --show-ids\n"
"/ &lt;0.0.2j&gt;\n"
" trunk/ &lt;p.0.2j&gt;\n"
"  vendors/ &lt;q.0.2j&gt;\n"
"   deli/ &lt;1g.0.2j&gt;\n"
"    egg.txt &lt;1i.e.2j&gt;\n"
"    soda.txt &lt;1k.0.2j&gt;\n"
"    sandwich.txt &lt;1j.0.2j&gt;\n"

#: build/en/book.xml:23792(tertiary)
msgid "uuid"
msgstr "uuid"

#: build/en/book.xml:23796(refname)
msgid "svnlook uuid"
msgstr "svnlook uuid"

#: build/en/book.xml:23798(literal)
msgid "UUID"
msgstr "UUID"

#: build/en/book.xml:23797(refpurpose)
msgid "Print the repository's <placeholder-1/>."
msgstr "打印版本库的<placeholder-1/>。"

#: build/en/book.xml:23802(programlisting)
#, no-wrap
msgid "svnlook uuid REPOS_PATH"
msgstr "svnlook uuid REPOS_PATH"

#: build/en/book.xml:23807(para)
msgid "Print the <literal moreinfo=\"none\">UUID</literal> for the repository. the UUID is the repository's <emphasis>u</emphasis>niversal <emphasis>u</emphasis>nique <emphasis>id</emphasis>entifier. The Subversion client uses this identifier to differentiate between one repository and another."
msgstr "打印版本库的<literal moreinfo=\"none\">UUID</literal>，UUID是版本库的<emphasis>u</emphasis>niversal <emphasis>u</emphasis>nique <emphasis>ID</emphasis>entifier（全局唯一标示），Subversion客户端可以使用这个标示区分不同的版本库。"

#: build/en/book.xml:23818(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook uuid /usr/local/svn/repos\n"
"e7fe1b91-8cd5-0310-98dd-2f12e793c5e8\n"
msgstr ""
"\n"
"$ svnlook uuid /usr/local/svn/repos\n"
"e7fe1b91-8cd5-0310-98dd-2f12e793c5e8\n"

#: build/en/book.xml:23831(tertiary)
msgid "youngest"
msgstr "youngest"

#: build/en/book.xml:23835(refname)
msgid "svnlook youngest"
msgstr "svnlook youngest"

#: build/en/book.xml:23836(refpurpose)
msgid "Print the youngest revision number."
msgstr "显示最年轻的修订版本号。"

#: build/en/book.xml:23840(programlisting)
#, no-wrap
msgid "svnlook youngest REPOS_PATH"
msgstr "svnlook youngest REPOS_PATH"

#: build/en/book.xml:23845(para)
msgid "Print the youngest revision number of a repository."
msgstr "打印一个版本库最年轻的修订版本号。"

#: build/en/book.xml:23851(para)
msgid "This shows the youngest revision of our sample repository:"
msgstr "这显示了在实例版本库显示最年轻的修订版本："

#: build/en/book.xml:23854(screen)
#, no-wrap
msgid ""
"\n"
"$ svnlook youngest /tmp/repos/ \n"
"42\n"
msgstr ""
"\n"
"$ svnlook youngest /tmp/repos/ \n"
"42\n"

#: build/en/book.xml:23872(para)
msgid "<command moreinfo=\"none\">svnserve</command> allows access to Subversion repositories using the <literal moreinfo=\"none\">svn</literal> network protocol. You can run svnserve either as a standalone server process, or you can have another process, such as <command moreinfo=\"none\">inetd</command>, <command moreinfo=\"none\">xinetd</command> or <command moreinfo=\"none\">sshd</command>, launch it for you."
msgstr "<command moreinfo=\"none\">svnserve</command>允许Subversion版本库使用<literal moreinfo=\"none\">svn</literal>网络协议，你可以作为独立服务器进程运行svnserve，或者是使用其它进程，如<command moreinfo=\"none\">inetd</command>、<command moreinfo=\"none\">xinetd</command>或<command moreinfo=\"none\">sshd</command>为你启动进程。"

#: build/en/book.xml:23879(para)
msgid "Once the client has selected a repository by transmitting its URL, <command moreinfo=\"none\">svnserve</command> reads a file named <filename moreinfo=\"none\">conf/svnserve.conf</filename> in the repository directory to determine repository-specific settings such as what authentication database to use and what authorization policies to apply. See <xref linkend=\"svn.serverconfig.svnserve\"/> for details of the <filename moreinfo=\"none\">svnserve.conf</filename> file."
msgstr "一旦客户端已经选择了一个版本库来传递它的URL，<command moreinfo=\"none\">svnserve</command>会读取版本库目录的<filename moreinfo=\"none\">conf/svnserve.conf</filename>文件，来检测版本库特定的设置，如使用哪个认证数据库和应用怎样的授权策略。关于<filename moreinfo=\"none\">svnserve.conf</filename>文件的详情见<xref linkend=\"svn.serverconfig.svnserve\"/>。"

#: build/en/book.xml:23889(title)
msgid "<command moreinfo=\"none\">svnserve</command> Switches"
msgstr "<command moreinfo=\"none\">svnserve</command> 选项"

#: build/en/book.xml:23891(para)
msgid "Unlike the previous commands we've described. <command moreinfo=\"none\">svnserve</command> has no subcommands—<command moreinfo=\"none\">svnserve</command> is controlled exclusively by switches."
msgstr "不象前面描述的例子，<command moreinfo=\"none\">svnserve</command>没有子命令—<command moreinfo=\"none\">svnserve</command>完全通过选项控制。"

#: build/en/book.xml:23899(term)
msgid "<option>--daemon</option> (<option>-d</option>)"
msgstr "<option>--daemon</option> (<option>-d</option>)"

#: build/en/book.xml:23901(para)
msgid "Causes <command moreinfo=\"none\">svnserve</command> to run in daemon mode. <command moreinfo=\"none\">svnserve</command> backgrounds itself and accepts and serves TCP/IP connections on the svn port (3690, by default)."
msgstr "导致<command moreinfo=\"none\">svnserve</command>以守护进程方式运行，<command moreinfo=\"none\">svnserve</command>维护本身并且接受和服务svn端口（缺省3690）的TCP/IP连接。"

#: build/en/book.xml:23909(term)
msgid "<option>--listen-port</option>=<replaceable>PORT</replaceable>"
msgstr "<option>--listen-port</option>=<replaceable>PORT</replaceable>"

#: build/en/book.xml:23911(para)
msgid "Causes svnserve to listen on <replaceable>PORT</replaceable> when run in daemon mode."
msgstr "在守护进程模式时导致svnserve监听<replaceable>PORT</replaceable>端口。"

#: build/en/book.xml:23918(term)
msgid "<option>--listen-host</option>=<replaceable>HOST</replaceable>"
msgstr "<option>--listen-host</option>=<replaceable>HOST</replaceable>"

#: build/en/book.xml:23920(para)
msgid "Causes <command moreinfo=\"none\">svnserve</command> to listen on the interface specified by <replaceable>HOST</replaceable>, which may be either a hostname or an IP address."
msgstr "<command moreinfo=\"none\">svnserve</command>监听的<replaceable>HOST</replaceable>，可能是一个主机名或是一个IP地址。"

#: build/en/book.xml:23927(option)
msgid "--foreground"
msgstr "--foreground"

#: build/en/book.xml:23929(para)
msgid "When used together with <option>-d</option>, this switch causes <command moreinfo=\"none\">svnserve</command> to stay in the foreground. This switch is mainly useful for debugging."
msgstr "当与<option>-d</option>一起使用，会导致<command moreinfo=\"none\">svnserve</command>停留在前台，主要用来调试。"

#: build/en/book.xml:23937(term)
msgid "<option>--inetd</option> (<option>-i</option>)"
msgstr "<option>--inetd</option> (<option>-i</option>)"

#: build/en/book.xml:23939(para)
msgid "Causes <command moreinfo=\"none\">svnserve</command> to use the stdin/stdout file descriptors, as is appropriate for a daemon running out of <command moreinfo=\"none\">inetd</command>."
msgstr "导致<command moreinfo=\"none\">svnserve</command>使用标准输出/标准输入文件描述符，更准确的是使用<command moreinfo=\"none\">inetd</command>作为守护进程。"

#: build/en/book.xml:23946(term) build/en/book.xml:24095(term)
msgid "<option>--help</option> (<option>-h</option>)"
msgstr "<option>--help</option> (<option>-h</option>)"

#: build/en/book.xml:23948(para)
msgid "Displays a usage summary and exits."
msgstr "显示有用的摘要和选项。"

#: build/en/book.xml:23955(para)
msgid "Displays version information, a list of repository back-end modules available, and exits."
msgstr "显示版本信息，版本库后端存在和可用的模块列表。"

#: build/en/book.xml:23961(term)
msgid "<option>--root</option>=<replaceable>ROOT</replaceable> (<option>-r</option>=<replaceable>ROOT</replaceable>)"
msgstr "<option>--root</option>=<replaceable>ROOT</replaceable> (<option>-r</option>=<replaceable>ROOT</replaceable>)"

#: build/en/book.xml:23964(para)
msgid "Sets the virtual root for repositories served by <command moreinfo=\"none\">svnserve</command>. The pathname in URLs provided by the client will be interpreted relative to this root, and will not be allowed to escape this root."
msgstr "设置<command moreinfo=\"none\">svnserve</command>服务的版本库的虚拟根，客户端提供的URL中显示的路径会解释为这个根的相对路径，不会允许离开这个根。"

#: build/en/book.xml:23973(term)
msgid "<option>--tunnel</option> (<option>-t</option>)"
msgstr "<option>--tunnel</option> (<option>-t</option>)"

#: build/en/book.xml:23975(para)
msgid "Causes <command moreinfo=\"none\">svnserve</command> to run in tunnel mode, which is just like the <command moreinfo=\"none\">inetd</command> mode of operation (serve one connection over stdin/stdout) except that the connection is considered to be pre-authenticated with the username of the current uid. This flag is selected by the client when running over a tunnel agent such as <command moreinfo=\"none\">ssh</command>."
msgstr "导致<command moreinfo=\"none\">svnserve</command>以管道模式运行，很像<command moreinfo=\"none\">inetd</command>操作的模式（服务于一个标准输入/标准输出的连接），除了连接是用当前uid的用户名预先认证过的这一点。这个选项在客户端使用如<command moreinfo=\"none\">ssh</command>之类的管道时使用。"

#: build/en/book.xml:23987(option)
msgid "--tunnel-user NAME"
msgstr "--tunnel-user NAME"

#: build/en/book.xml:23989(para)
msgid "Used in conjunction with <option>--tunnel</option> switch; tells svnserve to assume that <replaceable>NAME</replaceable> is the authenticated user, rather than the UID of the svnserve process. Useful for users wishing to share a single system account over SSH, but maintaining separate commit identities."
msgstr "与<option>--tunnel</option>选项结合使用；告诉svnserve假定<replaceable>NAME</replaceable>就是认证用户，而不是svnserve进程的UID用户，当希望多个用户通过SSH共享同一个系统帐户，但是维护各自的提交标示符时非常有用。"

#: build/en/book.xml:24000(term)
msgid "<option>--threads</option> (<option>-T</option>)"
msgstr "<option>--threads</option> (<option>-T</option>)"

#: build/en/book.xml:24002(para)
msgid "When running in daemon mode, causes <command moreinfo=\"none\">svnserve</command> to spawn a thread instead of a process for each connection. The <command moreinfo=\"none\">svnserve</command> process still backgrounds itself at startup time."
msgstr "当以守护进程模式运行，导致<command moreinfo=\"none\">svnserve</command>为每个连接产生一个线程而不是一个进程，<command moreinfo=\"none\">svnserve</command>进程本身在启动后会一直在后台。"

#: build/en/book.xml:24011(term)
msgid "<option>--listen-once</option> (<option>-X</option>)"
msgstr "<option>--listen-once</option> (<option>-X</option>)"

#: build/en/book.xml:24013(para)
msgid "Causes <command moreinfo=\"none\">svnserve</command> to accept one connection on the svn port, serve it, and exit. This option is mainly useful for debugging."
msgstr "导致<command moreinfo=\"none\">svnserve</command>在svn端口接受一个连接，维护完成它退出。这个选项主要用来调试。"

#: build/en/book.xml:24040(refpurpose)
msgid "Summarize the local revision(s) of a working copy."
msgstr "总结工作拷贝的本地修订版本。"

#: build/en/book.xml:24046(programlisting)
#, no-wrap
msgid "svnversion [OPTIONS] [WC_PATH [TRAIL_URL]]"
msgstr "svnversion [OPTIONS] [WC_PATH [TRAIL_URL]]"

#: build/en/book.xml:24052(para)
msgid "<command moreinfo=\"none\">svnversion</command> is a program for summarizing the revision mixture of a working copy. The resultant revision number, or revision range, is written to standard output."
msgstr "<command moreinfo=\"none\">svnversion</command>是用来总结工作拷贝修订版本混合的程序，结果修订版本号或范围会写到标准输出。"

#: build/en/book.xml:24057(para)
msgid "<replaceable>TRAIL_URL</replaceable>, if present, is the trailing portion of the URL used to determine if <replaceable>WC_PATH</replaceable> itself is switched (detection of switches within <replaceable>WC_PATH</replaceable> does not rely on <replaceable>TRAIL_URL</replaceable>)."
msgstr "如果提供<replaceable>TRAIL_URL</replaceable>，URL的尾端部分用来监测是否<replaceable>WC_PATH</replaceable>本身已经跳转（监测<replaceable>WC_PATH</replaceable>的跳转不需要依赖<replaceable>TRAIL_URL</replaceable>）。"

#: build/en/book.xml:24064(para)
msgid "When WC_PATH is not defined the current directory will be used as the working copy path. TRAIL_URL cannot be defined if WC_PATH is not explicitly given."
msgstr ""

#: build/en/book.xml:24073(para)
msgid "Like <command moreinfo=\"none\">svnserve</command>, <command moreinfo=\"none\">svnversion</command> has no subcommands, it only has switches."
msgstr "像<command moreinfo=\"none\">svnserve</command>，<command moreinfo=\"none\">svnversion</command>没有子命令，只有选项。"

#: build/en/book.xml:24080(term)
msgid "<option>--no-newline</option> (<option>-n</option>)"
msgstr "<option>--no-newline</option> (<option>-n</option>)"

#: build/en/book.xml:24082(para)
msgid "Omit the usual trailing newline from the output."
msgstr "忽略输出的尾端新行。."

#: build/en/book.xml:24087(term)
msgid "<option>--committed</option> (<option>-c</option>)"
msgstr "<option>--committed</option> (<option>-c</option>)"

#: build/en/book.xml:24089(para)
msgid "Use the last-changed revisions rather than the current (i.e., highest locally available) revisions."
msgstr "使用最后修改修订版本而不是当前的（例如，本地存在的最高修订版本）修订版本。"

#: build/en/book.xml:24097(para)
msgid "Print a help summary."
msgstr "打印帮助摘要。"

#: build/en/book.xml:24104(para)
msgid "Print the version of <command moreinfo=\"none\">svnversion</command> and exit with no error."
msgstr "打印<command moreinfo=\"none\">svnversion</command>，如果没有错误退出。"

#: build/en/book.xml:24115(para)
msgid "If the working copy is all at the same revision (for example, immediately after an update), then that revision is printed out:"
msgstr "如果工作拷贝都是一样的修订版本（例如，在更新后那一刻），会打印修订版本："

#: build/en/book.xml:24119(screen)
#, no-wrap
msgid ""
"\n"
"$ svnversion\n"
"4168\n"
msgstr ""
"\n"
"$ svnversion\n"
"4168\n"

#: build/en/book.xml:24124(para)
#, fuzzy
msgid "You can add TRAIL_URL to show that the working copy is not switched from what you expect. Note that the WC_PATH was required in this command:"
msgstr "添加TRAIL_URL来展示工作拷贝不是从你希望的地方跳转过来的："

#: build/en/book.xml:24128(screen)
#, no-wrap
msgid ""
"\n"
"$ svnversion . /repos/svn/trunk\n"
"4168\n"
msgstr ""
"\n"
"$ svnversion . /repos/svn/trunk\n"
"4168\n"

#: build/en/book.xml:24133(para)
msgid "For a mixed-revision working copy, the range of revisions present is printed:"
msgstr "对于混合修订版本的工作拷贝，修订版本的范围会被打印："

#: build/en/book.xml:24136(screen)
#, no-wrap
msgid ""
"\n"
"$ svnversion\n"
"4123:4168\n"
msgstr ""
"\n"
"$ svnversion\n"
"4123:4168\n"

#: build/en/book.xml:24141(para)
msgid "If the working copy contains modifications, a trailing \"M\" is added:"
msgstr "如果工作拷贝包含修改，后面会紧跟一个\"M\"："

#: build/en/book.xml:24144(screen)
#, no-wrap
msgid ""
"\n"
"$ svnversion\n"
"4168M\n"
msgstr ""
"\n"
"$ svnversion\n"
"4168M\n"

#: build/en/book.xml:24149(para)
msgid "If the working copy is switched, a trailing \"S\" is added:"
msgstr "如果工作拷贝已经跳转，后面会有一个\"S\"："

#: build/en/book.xml:24152(screen)
#, no-wrap
msgid ""
"\n"
"$ svnversion\n"
"4168S\n"
msgstr ""
"\n"
"$ svnversion\n"
"4168S\n"

#: build/en/book.xml:24157(para)
msgid "Thus, here is a mixed-revision, switched working copy containing some local modifications:"
msgstr "因此，这里是一个混合修订版本，跳转的工作拷贝包含了一些本地修改："

#: build/en/book.xml:24160(screen)
#, no-wrap
msgid ""
"\n"
"$ svnversion\n"
"4212:4168MS\n"
msgstr ""
"\n"
"$ svnversion\n"
"4212:4168MS\n"

#: build/en/book.xml:24165(para)
msgid "If invoked on a directory that is not a working copy, <command moreinfo=\"none\">svnversion</command> assumes it is an exported working copy and prints \"exported\":"
msgstr "如果从一个目录而不是工作拷贝调用，<command moreinfo=\"none\">svnversion</command>假定它是一个导出的工作拷贝并且打印\"exported\"："

#: build/en/book.xml:24169(screen)
#, no-wrap
msgid ""
"\n"
"$ svnversion\n"
"exported\n"
msgstr ""
"\n"
"$ svnversion\n"
"exported\n"

#: build/en/book.xml:24189(refname)
msgid "<placeholder-1/> Configuration Directives"
msgstr "<placeholder-1/> Configuration Directives"

#: build/en/book.xml:24190(refpurpose)
msgid "Apache configuration directives for serving Subversion repositories through Apache HTTP Server."
msgstr "Apache通过Apache HTTP服务器用来维护Subversion版本库配置指示。"

#: build/en/book.xml:24199(para)
msgid "This section briefly describes each of the Subversion Apache configuration directives. For an in-depth description of configuring Apache with Subversion, see <xref linkend=\"svn.serverconfig.httpd\"/>.)"
msgstr "这个小节主要描述了Subversion Apache配置的每个指示，关于Apache配置Subversion的更多信息见<xref linkend=\"svn.serverconfig.httpd\"/>。"

#: build/en/book.xml:24206(title)
msgid "Directives"
msgstr "指示"

#: build/en/book.xml:24211(literal)
msgid "DAV svn"
msgstr "DAV svn"

#: build/en/book.xml:24214(para)
msgid "This directive must be included in any <literal moreinfo=\"none\">Directory</literal> or <literal moreinfo=\"none\">Location</literal> block for a Subversion repository. It tells httpd to use the Subversion backend for mod_dav to handle all requests."
msgstr "这个指示必须包含在所有Subversion版本库的<literal moreinfo=\"none\">Directory</literal>或<literal moreinfo=\"none\">Location</literal>块中，它告诉httpd使用Subversion的后端，用mod_dav来处理所有的请求。"

#: build/en/book.xml:24224(literal)
msgid "SVNAutoversioning On"
msgstr "SVNAutoversioning On"

#: build/en/book.xml:24227(para)
msgid "This directive allows write requests from WebDAV clients to result in automatic commits. A generic log message is auto-generated and attached to each revision. If you enable Autoversioning, you'll likely want to set <literal moreinfo=\"none\">ModMimeUsePathInfo On</literal> so that <literal moreinfo=\"none\">mod_mime</literal> can set <literal moreinfo=\"none\">svn:mime-type</literal> to the correct mime-type automatically (as best as <literal moreinfo=\"none\">mod_mime</literal> is able to, of course). For more information, see <xref linkend=\"svn.webdav\"/>"
msgstr "这个指示允许WebDAV客户端的请求导致自动提交，每个修订版本会产生一个普通的日志信息。如果你开启了自动版本化，你很可能需要设置<literal moreinfo=\"none\">ModMimeUsePathInfo On</literal>，这样<literal moreinfo=\"none\">mod_mime</literal>可以自动的（像<literal moreinfo=\"none\">mod_mime</literal>一样好，当然）将<literal moreinfo=\"none\">svn:mime-type</literal>设置为正确的mime-type值。更多信息见<xref linkend=\"svn.webdav\"/>。"

#: build/en/book.xml:24242(literal)
msgid "SVNPath"
msgstr "SVNPath"

#: build/en/book.xml:24245(para)
msgid "This directive specifies the location in the filesystem for a Subversion repository's files. In a configuration block for a Subversion repository, either this directive or <literal moreinfo=\"none\">SVNParentPath</literal> must be present, but not both."
msgstr "这个指示指定Subversion版本库文件文件系统的位置，在一个Subversion版本库的配置块里，必须提供这个指示或<literal moreinfo=\"none\">SVNParentPath</literal>，但不能同时存在。"

#: build/en/book.xml:24256(literal)
msgid "SVNSpecialURI"
msgstr "SVNSpecialURI"

#: build/en/book.xml:24259(para)
msgid "Specifies the URI component (namespace) for special Subversion resources. The default is <quote><literal moreinfo=\"none\">!svn</literal></quote>, and most administrators will never use this directive. Only set this if there is a pressing need to have a file named <filename moreinfo=\"none\">!svn</filename> in your repository. If you change this on a server already in use, it will break all of the outstanding working copies and your users will hunt you down with pitchforks and flaming torches."
msgstr "指定特定Subversion资源的URI部分（命名空间），缺省是<quote><literal moreinfo=\"none\">!svn</literal></quote>，大多数管理员不会用到这个指示。只有那些必须要在版本库中放一个名字为<filename moreinfo=\"none\">!svn</filename>的文件时需要设置。如果你在一个已经使用中的服务器上这样修改，它会破坏所有的工作拷贝，你的用户会拿着叉子和火把追杀你。"

#: build/en/book.xml:24274(literal)
msgid "SVNReposName"
msgstr "SVNReposName"

#: build/en/book.xml:24277(para)
msgid "Specifies the name of a Subversion repository for use in <literal moreinfo=\"none\">HTTP GET</literal> requests. This value will be prepended to the title of all directory listings (which are served when you navigate to a Subversion repository with a web browser). This directive is optional."
msgstr "指定Subversion版本库在<literal moreinfo=\"none\">HTTP GET</literal>请求中使用的名字，这个值会作为所有目录列表（当你用web浏览器察看Subversion版本库时会看到）的标题，这个指示是可选的。"

#: build/en/book.xml:24288(literal)
msgid "SVNIndexXSLT"
msgstr "SVNIndexXSLT"

#: build/en/book.xml:24291(para)
msgid "Specifies the URI of an XSL transformation for directory indexes. This directive is optional."
msgstr "目录列表所使用的XSL转化的URI，这个指示可选。"

#: build/en/book.xml:24298(literal)
msgid "SVNParentPath"
msgstr "SVNParentPath"

#: build/en/book.xml:24301(para)
msgid "Specifies the location in the filesystem of a parent directory whose child directories are Subversion repositories. In a configuration block for a Subversion repository, either this directive or <literal moreinfo=\"none\">SVNPath</literal> must be present, but not both."
msgstr "指定子目录会是版本库的父目录在文件系统的位置，在一个Subversion版本库的配置块里，必须提供这个指示或<literal moreinfo=\"none\">SVNPath</literal>，但不能同时存在。"

#: build/en/book.xml:24312(literal)
msgid "SVNPathAuthz"
msgstr "SVNPathAuthz"

#: build/en/book.xml:24315(para)
msgid "Control path-based authorization by enabling or disabling subrequests. See <xref linkend=\"svn.serverconfig.httpd.authz.pathauthzoff\"/> for details."
msgstr "控制开启和关闭路径为基础的授权，更多细节见<xref linkend=\"svn.serverconfig.httpd.authz.pathauthzoff\"/>。"

#: build/en/book.xml:24331(title)
msgid "Subversion properties"
msgstr "Subversion 属性"

#: build/en/book.xml:24333(para)
msgid "Subversion allows users to invent arbitrarily-named versioned properties on files and directories, as well as unversioned properties on revisions. The only restriction is on properties prefixed with <quote>svn:</quote>. Properties in that namespace are reserved for Subversion's own use. While these properties may be set by users to control Subversion's behavior, users may not invent new <quote>svn:</quote> properties."
msgstr "Subversion允许用户在文件或目录上发明任意名称的版本化属性和非版本化属性，唯一的限制就是<quote>svn:</quote>是Subversion本身的保留前缀，用户可以设置这些属性来改变Subversion的行为方式，用户不能发明新的<quote>svn:</quote>属性。"

#: build/en/book.xml:24343(title)
msgid "Versioned Properties"
msgstr "版本控制的属性"

#: build/en/book.xml:24348(literal)
msgid "svn:executable"
msgstr "svn:executable"

#: build/en/book.xml:24351(para)
msgid "If present on a file, the client will make the file executable in Unix-hosted working copies. See <xref linkend=\"svn.advanced.props.special.executable\"/>."
msgstr "如果出现在一个文件上，客户端会将此文件在Unix工作拷贝中设置为可执行，见<xref linkend=\"svn.advanced.props.special.executable\"/>。"

#: build/en/book.xml:24359(literal)
msgid "svn:mime-type"
msgstr "svn:mime-type"

#: build/en/book.xml:24362(para)
msgid "If present on a file, the value indicates the file's mime-type. This allows the client to decide whether line-based contextual merging is safe to perform during updates, and can also affect how the file behaves when fetched via web browser. See <xref linkend=\"svn.advanced.props.special.mime-type\"/>."
msgstr "如果出现在一个文件，这个值表示了文件的mime-type，这允许客户端在执行更新时决定以行为依据的合并是否安全，同时也会影响使用浏览器浏览文件时的行为方式。见<xref linkend=\"svn.advanced.props.special.mime-type\"/>。"

#: build/en/book.xml:24373(literal)
msgid "svn:ignore"
msgstr "svn:ignore"

#: build/en/book.xml:24376(para)
msgid "If present on a directory, the value is a list of unversioned file patterns to be ignored by <command moreinfo=\"none\">svn status</command> and other subcommands. See <xref linkend=\"svn.advanced.props.special.ignore\"/>"
msgstr "如果出现在目录上，这是一组<command moreinfo=\"none\">svn status</command>可以忽略的未版本化文件的名称模式，见<xref linkend=\"svn.advanced.props.special.ignore\"/>。"

#: build/en/book.xml:24386(literal)
msgid "svn:keywords"
msgstr "svn:keywords"

#: build/en/book.xml:24389(para)
msgid "If present on a file, the value tells the client how to expand particular keywords within the file. See <xref linkend=\"svn.advanced.props.special.keywords\"/>."
msgstr "如果出现在一个文件上，这个值告诉客户端如何扩展文件的特定关键字，见<xref linkend=\"svn.advanced.props.special.keywords\"/>。"

#: build/en/book.xml:24398(literal)
msgid "svn:eol-style"
msgstr "svn:eol-style"

#: build/en/book.xml:24401(para)
msgid "If present on a file, the value tells the client how to manipulate the file's line-endings in the working copy. See <xref linkend=\"svn.advanced.props.special.eol-style\"/>."
msgstr "如果出现在一个文件上，这个值告诉客户端如何处理工作拷贝中的文件的行结束符，见<xref linkend=\"svn.advanced.props.special.eol-style\"/>。"

#: build/en/book.xml:24410(literal)
msgid "svn:externals"
msgstr "svn:externals"

#: build/en/book.xml:24413(para)
#, fuzzy
msgid "If present on a directory, the value is a multi-line list of other paths and URLs the client should check out. See <xref linkend=\"svn.advanced.externals\"/>."
msgstr "如果出现在一个目录上，则这个值就是客户端必须要检出的路径和URL列表。见<xref linkend=\"svn.advanced.props.special.externals\"/>。"

#: build/en/book.xml:24422(literal)
msgid "svn:special"
msgstr "svn:special"

#: build/en/book.xml:24425(para)
#, fuzzy
msgid "If present on a file, indicates that the file is not an ordinary file, but a symbolic link or other special object."
msgstr "如果出现在一个文件上，表示了那个文件不是一个普通的文件，而是一个符号链或者是其他特殊的对象，见<xref linkend=\"svn.advanced.props.special.special\"/>。"

#: build/en/book.xml:24433(literal)
msgid "svn:needs-lock"
msgstr "svn:needs-lock"

#: build/en/book.xml:24436(para)
msgid "If present on a file, tells the client to make the file read-only in the working copy, as a reminder that the file should be locked before editing begins. See <xref linkend=\"svn.advanced.locking.lock-communication\"/>."
msgstr "如果出现在一个文件上，告诉客户端在工作拷贝将文件置为只读，可以提醒我们在修改以前必须解锁。见<xref linkend=\"svn.advanced.locking.lock-communication\"/>。"

#: build/en/book.xml:24448(title)
msgid "Unversioned Properties"
msgstr "未版本控制的属性"

#: build/en/book.xml:24453(literal)
msgid "svn:author"
msgstr "svn:author"

#: build/en/book.xml:24456(para)
msgid "If present, contains the authenticated username of the person who created the revision. (If not present, then the revision was committed anonymously.)"
msgstr "如果出现，则保存了创建这个修订版本的认证用户名。（如果没有出现，则修订版本是匿名提交的。）"

#: build/en/book.xml:24464(literal)
msgid "svn:date"
msgstr "svn:date"

#: build/en/book.xml:24467(para)
msgid "Contains the UTC time the revision was created, in ISO format. The value comes from the server machine's clock."
msgstr "保存了修订版本创建的UTC时间，这个值来自服务器主机时钟。"

#: build/en/book.xml:24475(literal)
msgid "svn:log"
msgstr "svn:log"

#: build/en/book.xml:24478(para)
msgid "Contains the log message describing the revision."
msgstr "保存了描述修订版本的日志信息。"

#: build/en/book.xml:24485(literal)
msgid "svn:autoversioned"
msgstr "svn:autoversioned"

#: build/en/book.xml:24488(para)
msgid "If present, the revision was created via the autoversioning feature. See <xref linkend=\"svn.webdav.autoversioning\"/>."
msgstr "如果出现，则修订版本是通过自动版本化特性创建，见<xref linkend=\"svn.webdav.autoversioning\"/>。"

#: build/en/book.xml:24505(title)
msgid "Repository Hooks"
msgstr "版本库钩子"

#: build/en/book.xml:24511(primary) build/en/book.xml:24563(primary)
#: build/en/book.xml:24618(primary) build/en/book.xml:24670(primary)
#: build/en/book.xml:24741(primary) build/en/book.xml:24811(primary)
#: build/en/book.xml:24868(primary) build/en/book.xml:24922(primary)
#: build/en/book.xml:24981(primary)
msgid "repository"
msgstr "版本库"

#: build/en/book.xml:24513(tertiary) build/en/book.xml:24517(refname)
msgid "start-commit"
msgstr "start-commit"

#: build/en/book.xml:24518(refpurpose)
msgid "Notification of the beginning of a commit."
msgstr "开始提交的通知"

#: build/en/book.xml:24524(para)
msgid "The start-commit hook is run before the commit transaction is even created. It is typically used to decide if the user has commit privileges at all."
msgstr ""

#: build/en/book.xml:24528(para)
msgid "If the start-commit hook program returns a non-zero exit value, the commit is stopped before the commit transaction is even created, and anything printed to stderr is marshalled back to the client."
msgstr ""

#: build/en/book.xml:24536(title) build/en/book.xml:24592(title)
#: build/en/book.xml:24644(title) build/en/book.xml:24700(title)
#: build/en/book.xml:24770(title) build/en/book.xml:24838(title)
#: build/en/book.xml:24891(title) build/en/book.xml:24951(title)
#: build/en/book.xml:25004(title)
msgid "Input Parameter(s)"
msgstr "输入参数"

#: build/en/book.xml:24538(para) build/en/book.xml:24594(para)
#: build/en/book.xml:24646(para) build/en/book.xml:24702(para)
#: build/en/book.xml:24772(para) build/en/book.xml:24840(para)
#: build/en/book.xml:24893(para) build/en/book.xml:24953(para)
#: build/en/book.xml:25006(para)
msgid "The command-line arguments passed to the hook program, in order, are:"
msgstr ""

#: build/en/book.xml:24543(para) build/en/book.xml:24599(para)
#: build/en/book.xml:24651(para) build/en/book.xml:24707(para)
#: build/en/book.xml:24777(para) build/en/book.xml:24845(para)
#: build/en/book.xml:24898(para) build/en/book.xml:24958(para)
#: build/en/book.xml:25011(para)
msgid "repository path"
msgstr "版本库路径"

#: build/en/book.xml:24546(para)
msgid "authenticated username attempting the commit"
msgstr ""

#: build/en/book.xml:24552(title) build/en/book.xml:24608(title)
#: build/en/book.xml:24660(title) build/en/book.xml:24731(title)
#: build/en/book.xml:24801(title) build/en/book.xml:24858(title)
#: build/en/book.xml:24912(title) build/en/book.xml:24971(title)
#: build/en/book.xml:25025(title)
msgid "Common Uses"
msgstr "普通用户"

#: build/en/book.xml:24554(para) build/en/book.xml:24859(para)
#: build/en/book.xml:24972(para)
msgid "access control"
msgstr "访问控制"

#: build/en/book.xml:24565(tertiary) build/en/book.xml:24569(refname)
msgid "pre-commit"
msgstr "pre-commit"

#: build/en/book.xml:24570(refpurpose)
msgid "Notification just prior to commit completion."
msgstr ""

#: build/en/book.xml:24576(para)
#, fuzzy
msgid "The pre-commit hook is run just before a commit transaction is promoted to a new revision. Typically, this hook is used to protect against commits that are disallowed due to content or location (for example, your site might require that all commits to a certain branch include a ticket number from the bug tracker, or that the incoming log message is non-empty)."
msgstr "在事务完成提交之前运行，通常这个钩子是用来保护因为内容或位置（例如，你要求所有到一个特定分支的提交必须包括一个bug追踪的ticket号，或者是要求日志信息不为空）而不允许的提交。版本库传递两个参数到程序：版本库的路径和正在提交的事务名称，如果程序返回非零值，提交会失败，事务也会删除。如果钩子程序在stderr中写入了数据，也会传递到客户端。"

#: build/en/book.xml:24584(para)
msgid "If the pre-commit hook program returns a non-zero exit value, the commit is aborted, the commit transaction is removed, and anything printed to stderr is marshalled back to the client."
msgstr ""

#: build/en/book.xml:24602(para)
msgid "commit transaction name"
msgstr "提交事务的名称"

#: build/en/book.xml:24609(para)
msgid "change validation and control"
msgstr ""

#: build/en/book.xml:24620(tertiary) build/en/book.xml:24624(refname)
msgid "post-commit"
msgstr "post-commit"

#: build/en/book.xml:24625(refpurpose)
msgid "Notification of a successful commit."
msgstr ""

#: build/en/book.xml:24631(para)
#, fuzzy
msgid "The post-commit hook is run after the transaction is committed, and a new revision created. Most people use this hook to send out descriptive emails about the commit or to notify some other tool (such as an issue tracker) that a commit has happened. Some configurations also use this hook to trigger backup processes."
msgstr "它在事务完成后运行，创建一个新的修订版本。大多数人用这个钩子来发送关于提交的描述性电子邮件，或者作为版本库的备份。版本库传给程序两个参数：到版本库的路径和被创建的新的修订版本号。退出程序会被忽略。"

#: build/en/book.xml:24638(para)
msgid "The output from and exit value returned by the post-commit hook program are ignored."
msgstr ""

#: build/en/book.xml:24654(para)
msgid "revision number created by the commit"
msgstr "提交创建的版本号"

#: build/en/book.xml:24661(para)
msgid "commit notification, tool integration"
msgstr ""

#: build/en/book.xml:24672(tertiary) build/en/book.xml:24676(refname)
msgid "pre-revprop-change"
msgstr "pre-revprop-change"

#: build/en/book.xml:24677(refpurpose)
msgid "Notification of a revision property change attempt."
msgstr ""

#: build/en/book.xml:24684(para)
msgid "The pre-revprop-change hook is run immediately prior to the modification of a revision property when performed outside the scope of a normal commit. Unlike the other hooks, the default state of this one is to deny the proposed action. The hook must actually exist and return a zero exit value before a revision property modification can happen."
msgstr ""

#: build/en/book.xml:24692(para)
msgid "If the pre-revprop-change hook is not implemented or the hook program returns a non-zero exit value, no change to the property will be made, and anything printed to stderr is marshalled back to the client."
msgstr ""

#: build/en/book.xml:24710(para)
msgid "revision whose property is about to be modified"
msgstr ""

#: build/en/book.xml:24713(para)
msgid "authenticated username attempting the propchange"
msgstr ""

#: build/en/book.xml:24716(para) build/en/book.xml:24786(para)
msgid "name of the property changed"
msgstr "属性名称已修改"

#: build/en/book.xml:24719(para) build/en/book.xml:24789(para)
#, fuzzy
msgid "change description: <literal moreinfo=\"none\">A</literal> (added), <literal moreinfo=\"none\">D</literal> (deleted), or <literal moreinfo=\"none\">M</literal> (modified)"
msgstr "Windows文件系统使用文件扩展名（如<literal moreinfo=\"none\">.EXE</literal>、<literal moreinfo=\"none\">.BAT</literal>和<literal moreinfo=\"none\">.COM</literal>）来标示可执行文件。"

#: build/en/book.xml:24725(para)
msgid "Additionally, Subversion passes to the hook program via standard input the proposed value of the property."
msgstr ""

#: build/en/book.xml:24732(para)
msgid "access control, change validation and control"
msgstr ""

#: build/en/book.xml:24743(tertiary) build/en/book.xml:24747(refname)
msgid "post-revprop-change"
msgstr "post-revprop-change"

#: build/en/book.xml:24748(refpurpose)
msgid "Notification of a successful revision property change."
msgstr ""

#: build/en/book.xml:24755(para)
msgid "The post-revprop-change hook is run immediately after to the modification of a revision property when performed outside the scope of a normal commit. As can be derived from the description of its counterpart, the pre-revprop-change hook, this hook will not run at all unless the pre-revprop-change hook is implemented. It is typically used to send email notification of the property change."
msgstr ""

#: build/en/book.xml:24764(para)
msgid "The output from and exit value returned by the post-revprop-change hook program are ignored."
msgstr ""

#: build/en/book.xml:24780(para)
msgid "revision whose property was modified"
msgstr ""

#: build/en/book.xml:24783(para)
msgid "authenticated username of the person making the change"
msgstr ""

#: build/en/book.xml:24795(para)
msgid "Additionally, Subversion passes to the hook program via standard input the previous value of the property."
msgstr ""

#: build/en/book.xml:24802(para)
msgid "propchange notification"
msgstr "属性修改通知"

#: build/en/book.xml:24813(tertiary) build/en/book.xml:24817(refname)
msgid "pre-lock"
msgstr "pre-lock"

#: build/en/book.xml:24818(refpurpose)
msgid "Notification of a path lock attempt."
msgstr ""

#: build/en/book.xml:24824(para)
#, fuzzy
msgid "The pre-lock hook runs whenever someone attempts to lock a path. It can be used to prevent locks altogether, or to create a more complex policy specifying exactly which users are allowed to lock particular paths. If the hook notices a pre-existing lock, then it can also decide whether a user is allowed to <quote>steal</quote> the existing lock."
msgstr "这个钩子会在每次有人尝试锁定文件时执行，可以防止完全的锁定，或者用来制定控制哪些用户可以锁定特定路径的复杂策略，如果钩子发现已存在的钩子，也可以决定是否<quote>窃取</quote>这个钩子。版本库传递三个参数到钩子：到版本库的路径、锁定的路径和企图执行锁定的用户。如果程序返回非零值，锁定动作会退出，并且所有的标准输出返回到客户端。"

#: build/en/book.xml:24831(para)
msgid "If the pre-lock hook program returns a non-zero exit value, the lock action is aborted and anything printed to stderr is marshalled back to the client."
msgstr ""

#: build/en/book.xml:24848(para) build/en/book.xml:24961(para)
msgid "versioned path which is to be locked"
msgstr ""

#: build/en/book.xml:24851(para) build/en/book.xml:24964(para)
msgid "authenticated username of the person attempting the lock"
msgstr ""

#: build/en/book.xml:24870(tertiary) build/en/book.xml:24874(refname)
msgid "post-lock"
msgstr "post-lock"

#: build/en/book.xml:24875(refpurpose)
msgid "Notification of a successful path lock."
msgstr ""

#: build/en/book.xml:24881(para)
msgid "The post-lock hook runs after one or more paths has been locked. It is typically used to send email notification of the lock event."
msgstr ""

#: build/en/book.xml:24885(para)
msgid "The output from and exit value returned by the post-look hook program are ignored."
msgstr ""

#: build/en/book.xml:24901(para)
msgid "authenticated username of the person who locked the paths"
msgstr ""

#: build/en/book.xml:24906(para)
msgid "Additionally, the list of paths locked is passed to the hook program via standard input, one path per line."
msgstr ""

#: build/en/book.xml:24913(para)
msgid "lock notification"
msgstr "加锁通知"

#: build/en/book.xml:24924(tertiary) build/en/book.xml:24928(refname)
msgid "pre-unlock"
msgstr "pre-unlock"

#: build/en/book.xml:24929(refpurpose)
msgid "Notification of a path unlock attempt."
msgstr ""

#: build/en/book.xml:24935(para)
#, fuzzy
msgid "The pre-unlock hook runs whenever someone attempts to remove a lock on a file. It can be used to create policies that specify which users are allowed to unlock particular paths. It's particularly important for determining policies about lock breakage. If user A locks a file, is user B allowed to break the lock? What if the lock is more than a week old? These sorts of things can be decided and enforced by the hook."
msgstr "这个钩子在某人企图删除一个文件上的钩子时发生，可以用来制定哪些用户可以解除文件锁定的策略。制定破坏锁定的策略非常重要，如果一个用户A锁定了一个文件，允许用户B打开这个锁？如果这个锁已经一周了呢？这种事情可以通过钩子决定并执行。版本库传递三个参数到钩子：到版本库的路径、将要解锁的路径和企图解锁的用户。如果程序返回非零值，解锁操作退出并会将标准错误传输到客户端。"

#: build/en/book.xml:24944(para)
msgid "If the pre-unlock hook program returns a non-zero exit value, the unlock action is aborted and anything printed to stderr is marshalled back to the client."
msgstr ""

#: build/en/book.xml:24983(tertiary) build/en/book.xml:24987(refname)
msgid "post-unlock"
msgstr "post-unlock"

#: build/en/book.xml:24988(refpurpose)
msgid "Notification of a successful path unlock."
msgstr ""

#: build/en/book.xml:24994(para)
msgid "The post-unlock hook runs after one or more paths has been unlocked. It is typically used to send email notification of the unlock event."
msgstr ""

#: build/en/book.xml:24998(para)
msgid "The output from and exit value returned by the post-unlock hook program are ignored."
msgstr ""

#: build/en/book.xml:25014(para)
msgid "authenticated username of the person who unlocked the paths"
msgstr ""

#: build/en/book.xml:25019(para)
msgid "Additionally, the list of paths unlocked is passed to the hook program via standard input, one path per line."
msgstr ""

#: build/en/book.xml:25026(para)
msgid "unlock notification"
msgstr "解锁通知"

#: build/en/book.xml:25042(title)
msgid "Subversion Quick-Start Guide"
msgstr "Subversion 快速入门指南"

#: build/en/book.xml:25045(para)
#, fuzzy
msgid "Some people have trouble absorbing a new technology by reading the sort of <quote>top down</quote> approach provided by this book. This appendix contains a very short introduction to Subversion, and is designed to give <quote>bottom up</quote> learners a fighting chance. If you prefer to learn by experimentation, the following demonstration will get you up and running. Along the way, we give links to the relevant chapters of this book."
msgstr "本书所采用的<quote>由上至下</quote>的方式讲述Subversion，某些读者可能不习惯以这样的方式学习一种新的技术。为此，本节对Subversion进行了一个简短的介绍，并为那些喜欢<quote>自下而上</quote>学习的读者提供一个实战的机会。下面的示例可以引导那些喜欢<quote>自下而上</quote>学习方式的读者走入Subversion的大门。同时，我们也会在相应的位置给出书中详细叙述部分的链接。"

#: build/en/book.xml:25054(para)
msgid "If you're new to the entire concept of version control or to the <quote>copy-modify-merge</quote> model used by both CVS and Subversion, then you should read <xref linkend=\"svn.basic\"/> before going any further."
msgstr "如果读者还不熟悉版本控制，以及在Subversion和CVS中使用的<quote>拷贝-修改-合并</quote>模型这些基础的概念，那么建议在进一步学习之前，首先阅读<xref linkend=\"svn.basic\"/>。"

#: build/en/book.xml:25065(title)
msgid "Installing Subversion"
msgstr "安装 Subversion"

#: build/en/book.xml:25067(para)
msgid "Subversion is built on a portability layer called APR—the Apache Portable Runtime library. The APR library provides all the interfaces that Subversion needs to function on different operating systems: disk access, network access, memory management, and so on. While Subversion is able to use Apache as one of its network server programs, its dependence on APR <emphasis>does not</emphasis> mean that Apache is a required component. APR is a standalone library useable by any application. It does mean, however, that like Apache, Subversion clients and servers run on any operating system that the Apache httpd server runs on: Windows, Linux, all flavors of BSD, Mac OS X, Netware, and others."
msgstr "Subversion是基于APR构建的。APR全称为Apache Portable Runtime library，是一个移植性很好的程序库。APR库提供了全部与操作系统相关的操作接口，如磁盘访问、内存管理等等，这使得Subversion自身能够在不加修改的情况下运行于不同的操作系统之上。Subversion对APR的依赖并不意味着必须使用Apache作为它的网络服务器程序，相反，Apache只是Subversion支持的网络服务器程序之一。APR是一个独立的程序库，任何应用程序都可以使用它（Apache也是基于它开发的）。这就是说，Subversion能够在所有可运行Apache服务器的操作系统上运转，如Windows、Linux、各种BSD、Mac OS X、Netware等等。"

#: build/en/book.xml:25080(para)
msgid "The easiest way to get Subversion is to download a binary package built for your operating system. Subversion's website (<ulink url=\"http://subversion.tigris.org\"/>) often has these packages available for download, posted by volunteers. The site usually contains graphical installer packages for users of Microsoft operating systems. If you run a Unix-like operating system, you can use your system's native package distribution system (RPMs, DEBs, the ports tree, etc.) to get Subversion."
msgstr "最简单的安装Subversion的方法就是下载与你的操作系统对应的二进制程序包。在Subversion的网站（<ulink url=\"http://subversion.tigris.org\"/>）上通常可以找到由志愿者提供下载的程序包。在这个网站上，会提供微软操作系统上的图形化应用程序安装包。而对于类Unix系统，则可以使用其自身的程序包系统（PRMs、DEBs、ports tree等等）来获取Subversion。"

#: build/en/book.xml:25090(para)
#, fuzzy
msgid "Alternately, you can build Subversion directly from source code. From the Subversion website, download the latest source-code release. After unpacking it, follow the instructions in the <filename moreinfo=\"none\">INSTALL</filename> file to build it. Note that a released source package contains everything you need to build a command-line client capable of talking to a remote repository (in particular, the apr, apr-util, and neon libraries). But optional portions of Subversion have many other dependencies, such as Berkeley DB and possibly Apache httpd. If you want to do a complete build, make sure you have all of the packages documented in the <filename moreinfo=\"none\">INSTALL</filename> file."
msgstr "此外，还可以通过编译源代码包直接生成Subversion程序。首先，从Subversion网站下载最新的源代码包，然后解压缩。最后，根据<filename moreinfo=\"none\">INSTALL</filename>文件的指示进行编译。需要注意的是，正式发布的源代码包中包含了构建命令行客户端工具所需的全部内容（如apr，apr-util和neno库），可以直接进行编译。但是一些可选的组件则依赖于其它一些程序库，如Berkeley DB和Apache httpd。因此，如果想要进行完整的编译，请根据<filename moreinfo=\"none\">INSTALL</filename>文件中的内容确认这些程序库是否可用。如果想为Subversion做一些工作，可以使用客户端程序取得最新的源代码，这部分内容参见<xref linkend=\"svn.developer.contrib.get-code\"/>。"

#: build/en/book.xml:25110(para)
msgid "Note that the URL checked out in the example above ends not with <literal moreinfo=\"none\">svn</literal>, but with a subdirectory thereof called <literal moreinfo=\"none\">trunk</literal>. See our discussion of Subversion's branching and tagging model for the reasoning behind this."
msgstr "注意上面例子中检出的URL并不是以<literal moreinfo=\"none\">svn</literal>结尾，而是它的一个叫做<literal moreinfo=\"none\">trunk</literal>的子目录，可以看我们对Subversion的分支和标签模型的讨论来理解背后的原因。"

#: build/en/book.xml:25103(para)
#, fuzzy
msgid "If you're one of those folks that likes to use bleeding-edge software, you can also get the Subversion source code from the Subversion repository in which it lives. Obviously, you'll need to already have a Subversion client on hand to do this. But once you do, you can checkout a working copy of the Subversion source repository from <ulink url=\"http://svn.collab.net/repos/svn/trunk/\"/>: <placeholder-1/>"
msgstr "在你有了工作的Subversion客户端后，你可以泰然自若的从Subversion源代码版本库<ulink url=\"http://svn.collab.net/repos/svn/trunk/\"/>检出一个工作拷贝： <footnote><placeholder-1/></footnote>"

#: build/en/book.xml:25117(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout http://svn.collab.net/repos/svn/trunk subversion\n"
"A    subversion/HACKING\n"
"A    subversion/INSTALL\n"
"A    subversion/README\n"
"A    subversion/autogen.sh\n"
"A    subversion/build.conf\n"
"…\n"
msgstr ""
"\n"
"$ svn checkout http://svn.collab.net/repos/svn/trunk subversion\n"
"A    subversion/HACKING\n"
"A    subversion/INSTALL\n"
"A    subversion/README\n"
"A    subversion/autogen.sh\n"
"A    subversion/build.conf\n"
"…\n"

#: build/en/book.xml:25127(para)
msgid "The above command will checkout the bleeding-edge, latest version of the Subversion source code into a subdirectory named <filename moreinfo=\"none\">subversion</filename> in your current working directory. Obviously, you can adjust that last argument as you see fit. Regardless of what you call the new working copy directory, though, after this operation completes, you will now have the Subversion source code. Of course, you will still need to fetch a few helper libraries (apr, apr-util, etc.)—see the <filename moreinfo=\"none\">INSTALL</filename> file in the top level of the working copy for details."
msgstr "上面的命令会检出一个流血的，最新的Subversion源代码版本到你的叫做<filename moreinfo=\"none\">subversion</filename>的当前工作目录。很明显，你可以调整最后的参数改为你需要的。不管你怎么称呼你的新的工作拷贝目录，在操作之后，你现在已经有了Subversion的源代码。当然，你还是需要得到一些帮助库（apr，apr-util等等）—见工作拷贝根目录的<filename moreinfo=\"none\">INSTALL</filename>来得到更多细节。"

#: build/en/book.xml:25145(title)
msgid "High-speed Tutorial"
msgstr "快速指南"

#: build/en/book.xml:25148(quote)
msgid "Please make sure your seat backs are in their full, upright position, and that your tray tables are stored. Flight attendants, prepare for take-off…."
msgstr ""

#: build/en/book.xml:25153(para)
msgid "The following is a very high-level tutorial which will walk you through some basic Subversion configuration and operation. By the time you complete the tutorial, you should have a basic understanding of Subversion's typical usage."
msgstr ""

#: build/en/book.xml:25159(para)
#, fuzzy
msgid "The examples used in this appendix assume that you have <command moreinfo=\"none\">svn</command>, the Subversion command-line client, and <command moreinfo=\"none\">svnadmin</command>, the administrative tool, ready to go. It also assumes you are using Subversion 1.2 or later (run <command moreinfo=\"none\">svn --version</command> to check.)"
msgstr "运行下面的例子需要首先正确安装Subversion客户端程序<command moreinfo=\"none\">svn</command>以及管理工具<command moreinfo=\"none\">svnadmin</command>，并且必须为1.2或更新版本的Subversion程序（可以运行<command moreinfo=\"none\">svn --version</command>来检查Subversion的版本）。"

#: build/en/book.xml:25166(para)
msgid "Subversion stores all versioned data in a central repository. To begin, create a new repository:"
msgstr "Subversion的所有版本化数据都储存在中心版本库中。因此首先，我们需要创建一个版本库："

#: build/en/book.xml:25169(screen)
#, no-wrap
msgid ""
"\n"
"$ svnadmin create /path/to/repos\n"
"$ ls /path/to/repos\n"
"conf/  dav/  db/  format  hooks/  locks/  README.txt\n"
msgstr ""
"\n"
"$ svnadmin create /path/to/repos\n"
"$ ls /path/to/repos\n"
"conf/  dav/  db/  format  hooks/  locks/  README.txt\n"

#: build/en/book.xml:25175(para)
msgid "This command creates a new directory <filename moreinfo=\"none\">/path/to/repos</filename> which contains a Subversion repository. This new directory contains (among other things) a collection of database files. You won't see your versioned files if you peek inside. For more information about repository creation and maintenance, see <xref linkend=\"svn.reposadmin\"/>."
msgstr "这个命令创建了一个新目录<filename moreinfo=\"none\">/path/to/repos</filename>，并在其中创建了一个Subversion版本库。这个目录里主要保存了一些数据库文件（还有其它一些文件），而不像CVS那样保存着版本化的文件。需要更多版本库创建和维护方面的内容，参见<xref linkend=\"svn.reposadmin\"/>。"

#: build/en/book.xml:25183(para)
msgid "Subversion has no concept of a <quote>project</quote>. The repository is just a virtual versioned filesystem, a large tree that can hold anything you wish. Some administrators prefer to store only one project in a repository, and others prefer to store multiple projects in a repository by placing them into separate directories. The merits of each approach are discussed in <xref linkend=\"svn.reposadmin.projects.chooselayout\"/>. Either way, the repository only manages files and directories, so it's up to humans to interpret particular directories as <quote>projects</quote>. So while you might see references to projects throughout this book, keep in mind that we're only ever talking about some directory (or collection of directories) in the repository."
msgstr "在Subversion没有<quote>项目</quote>的概念。Subversion的版本库只是一个虚拟的版本化文件系统，可以存放你想要存放的任何文件。有些管理员喜欢为每个项目建立一个独立的版本库，而另外一些管理员则喜欢将多个项目存放到同一个版本库的不同目录里。这两种方式各有各的优点，关于这方面内容的叙述，参见<xref linkend=\"svn.reposadmin.projects.chooselayout\"/>。不论是哪一种方式，版本库都只是负责管理文件和目录，而<quote>项目</quote>则是人为指定的概念。因此，尽管本书中遍布着项目这个词，但是请记住我们只不过是在谈论版本库中的某些特定目录（或者是一组目录）。"

#: build/en/book.xml:25197(para)
msgid "In this example, we assume that you already have some sort of project (a collection of files and directories) that you wish to import into your newly created Subversion repository. Begin by organizing them into a single directory called <filename moreinfo=\"none\">myproject</filename> (or whatever you wish). For reasons that will be clear later (see <xref linkend=\"svn.branchmerge\"/>), your project's tree structure should contain three top-level directories named <filename moreinfo=\"none\">branches</filename>, <filename moreinfo=\"none\">tags</filename>, and <filename moreinfo=\"none\">trunk</filename>. The <filename moreinfo=\"none\">trunk</filename> directory should contain all of your data, while <filename moreinfo=\"none\">branches</filename> and <filename moreinfo=\"none\">tags</filename> directories are empty:"
msgstr "在这个例子中，我们假定已经有一些需要导入到Subversion版本库的条目（一组文件和目录）。接下来，我们需要把这些条目整理到一个名为<filename moreinfo=\"none\">myproject</filename>的目录（或者其它任意目录）里。在这个目录下，创建三个顶级子目录：<filename moreinfo=\"none\">branches</filename>、<filename moreinfo=\"none\">tags</filename>和<filename moreinfo=\"none\">trunk</filename>，这样做的原因将在后文中阐述。之后，将所有需版本化的数据保存到<filename moreinfo=\"none\">trunk</filename>目录下，同时保持<filename moreinfo=\"none\">branches</filename>和<filename moreinfo=\"none\">tags</filename>目录为空："

#: build/en/book.xml:25212(screen)
#, no-wrap
msgid ""
"\n"
"/tmp/myproject/branches/\n"
"/tmp/myproject/tags/\n"
"/tmp/myproject/trunk/\n"
"                     foo.c\n"
"                     bar.c\n"
"                     Makefile\n"
"                     …\n"
msgstr ""
"\n"
"/tmp/myproject/branches/\n"
"/tmp/myproject/tags/\n"
"/tmp/myproject/trunk/\n"
"                     foo.c\n"
"                     bar.c\n"
"                     Makefile\n"
"                     …\n"

#: build/en/book.xml:25222(para)
msgid "The <filename moreinfo=\"none\">branches</filename>, <filename moreinfo=\"none\">tags</filename>, and <filename moreinfo=\"none\">trunk</filename> subdirectories aren't actually required by Subversion. They're merely a popular convention that you'll most likely want to use later on."
msgstr "<filename moreinfo=\"none\">branches</filename>、<filename moreinfo=\"none\">tags</filename>和<filename moreinfo=\"none\">trunk</filename>这三个子目录不是Subversion必须的。但这样做是Subversion的习惯用法，我们还是遵守这个约定吧。"

#: build/en/book.xml:25227(para)
#, fuzzy
msgid "Once you have your tree of data ready to go, import it into the repository with the <command moreinfo=\"none\">svn import</command> command (see <xref linkend=\"svn.tour.importing\"/>):"
msgstr "准备好了数据之后，就可以使用<command moreinfo=\"none\">svn import</command>命令（参见<xref linkend=\"svn.tour.other.import\"/>）将其导入到版本库中："

#: build/en/book.xml:25231(screen)
#, no-wrap
msgid ""
"\n"
"$ svn import /tmp/myproject file:///path/to/repos/myproject -m \"initial import\"\n"
"Adding         /tmp/myproject/branches\n"
"Adding         /tmp/myproject/tags\n"
"Adding         /tmp/myproject/trunk\n"
"Adding         /tmp/myproject/trunk/foo.c\n"
"Adding         /tmp/myproject/trunk/bar.c\n"
"Adding         /tmp/myproject/trunk/Makefile\n"
"…\n"
"Committed revision 1.\n"
"$ \n"
msgstr ""
"\n"
"$ svn import /tmp/myproject file:///path/to/repos/myproject -m \"initial import\"\n"
"Adding         /tmp/myproject/branches\n"
"Adding         /tmp/myproject/tags\n"
"Adding         /tmp/myproject/trunk\n"
"Adding         /tmp/myproject/trunk/foo.c\n"
"Adding         /tmp/myproject/trunk/bar.c\n"
"Adding         /tmp/myproject/trunk/Makefile\n"
"…\n"
"Committed revision 1.\n"
"$ \n"

#: build/en/book.xml:25244(para)
msgid "Now the repository contains this tree of data. As mentioned earlier, you won't see your files by directly peeking into the repository; they're all stored within a database. But the repository's imaginary filesystem now contains a top-level directory named <filename moreinfo=\"none\">myproject</filename>, which in turn contains your data."
msgstr "现在版本库中已经保存了目录中的数据。如前所述，直接查看版本库是看不到文件和目录的；它们存放在数据库之中。但是版本库的虚拟文件系统中则包含了一个名为<filename moreinfo=\"none\">myproject</filename>的顶级目录，其中依此保存了所有的数据。"

#: build/en/book.xml:25251(para)
msgid "Note that the original <filename moreinfo=\"none\">/tmp/myproject</filename> directory is unchanged; Subversion is unaware of it. (In fact, you can even delete that directory if you wish.) In order to start manipulating repository data, you need to create a new <quote>working copy</quote> of the data, a sort of private workspace. Ask Subversion to <quote>check out</quote> a working copy of the <filename moreinfo=\"none\">myproject/trunk</filename> directory in the repository:"
msgstr "注意我们在一开始创建的那个<filename moreinfo=\"none\">/tmp/myproject</filename>目录并没有改变，Subversion并不在意它（事实上，完全可以删除这个目录）。要开始使用版本库数据，我们还要创建一个新的用于存储数据的<quote>工作拷贝</quote>，这是一个私有工作区。从Subversion版本库里<quote>检出</quote>一个<filename moreinfo=\"none\">myproject/trunk</filename>目录工作拷贝的操作如下："

#: build/en/book.xml:25260(screen)
#, no-wrap
msgid ""
"\n"
"$ svn checkout file:///path/to/repos/myproject/trunk myproject\n"
"A  myproject/foo.c\n"
"A  myproject/bar.c\n"
"A  myproject/Makefile\n"
"…\n"
"Checked out revision 1.\n"
msgstr ""
"\n"
"$ svn checkout file:///path/to/repos/myproject/trunk myproject\n"
"A  myproject/foo.c\n"
"A  myproject/bar.c\n"
"A  myproject/Makefile\n"
"…\n"
"Checked out revision 1.\n"

#: build/en/book.xml:25269(para)
msgid "Now you have a personal copy of part of the repository in a new directory named <filename moreinfo=\"none\">myproject</filename>. You can edit the files in your working copy and then commit those changes back into the repository."
msgstr "现在，在<filename moreinfo=\"none\">myproject</filename>目录下生成了一个版本库数据的独立拷贝。我们可以在这个工作拷贝中编辑文件，并将修改提交到版本库中。"

#: build/en/book.xml:25276(para)
msgid "Enter your working copy and edit a file's contents."
msgstr "进入工作拷贝目录，编辑某个文件的内容。"

#: build/en/book.xml:25280(para)
msgid "Run <command moreinfo=\"none\">svn diff</command> to see unified diff output of your changes."
msgstr "运行<command moreinfo=\"none\">svn diff</command>以标准差别格式查看修改的内容。"

#: build/en/book.xml:25284(para)
msgid "Run <command moreinfo=\"none\">svn commit</command> to commit the new version of your file to the repository."
msgstr "运行<command moreinfo=\"none\">svn commit</command>将更改提交到版本库中。"

#: build/en/book.xml:25288(para)
msgid "Run <command moreinfo=\"none\">svn update</command> to bring your working copy <quote>up-to-date</quote> with the repository."
msgstr "运行<command moreinfo=\"none\">svn update</command><quote>更新</quote>工作拷贝。"

#: build/en/book.xml:25293(para)
msgid "For a full tour of all the things you can do with your working copy, read <xref linkend=\"svn.tour\"/>."
msgstr "完整的工作拷贝操作指南，请参见<xref linkend=\"svn.tour\"/>。"

#: build/en/book.xml:25296(para)
msgid "At this point, you have the option of making your repository available to others over a network. See <xref linkend=\"svn.serverconfig\"/> to learn about the different sorts of server processes available and how to configure them."
msgstr "现在，Subversion版本库可以通过网络方式访问。参考<xref linkend=\"svn.serverconfig\"/>，了解不同服务器软件的使用以及配置方法。"

#: build/en/book.xml:25300(para)
msgid "### TODO: Let's make this into a full tutorial, rather than simply referring off to other sections. ###"
msgstr ""

#: build/en/book.xml:25315(title)
msgid "Subversion for CVS Users"
msgstr "CVS 用户的 Subversion 指南"

#: build/en/book.xml:25317(para)
#, fuzzy
msgid "This appendix is a guide for CVS users new to Subversion. It's essentially a list of differences between the two systems as <quote>viewed from 10,000 feet</quote>. For each section, we provide backreferences to relevant chapters when possible."
msgstr "这个附录可以作为CVS用户开始使用Subversion的指南，实质上就是鸟瞰这两个系统之间的区别列表，在每一小节，我们会尽可能提供相关章节的引用。"

#: build/en/book.xml:25323(para)
msgid "Although the goal of Subversion is to take over the current and future CVS user base, some new features and design changes were required to fix certain <quote>broken</quote> behaviors that CVS had. This means that, as a CVS user, you may need to break habits—ones that you forgot were odd to begin with."
msgstr "尽管Subversion的目标是接管当前和未来的CVS用户基础，需要一些新的特性设计来修正一些CVS<quote>不好的</quote>行为习惯，这意味着，作为一个CVS用户，你或许需要打破习惯—忘记一些奇怪的习惯来作为开始。"

#: build/en/book.xml:25335(title)
msgid "Revision Numbers Are Different Now"
msgstr "版本号现在不同了"

#: build/en/book.xml:25337(para)
msgid "In CVS, revision numbers are per-file. This is because CVS stores its data in RCS files; each file has a corresponding RCS file in the repository, and the repository is roughly laid out according to the structure of your project tree."
msgstr "在CVS中，修订版本号是每文件的，这是因为CVS使用RCS文件保存数据，每个文件都在版本库有一个对应的RCS文件，版本库几乎就是根据项目树的结构创建。"

#: build/en/book.xml:25342(para)
msgid "In Subversion, the repository looks like a single filesystem. Each commit results in an entirely new filesystem tree; in essence, the repository is an array of trees. Each of these trees is labeled with a single revision number. When someone talks about <quote>revision 54</quote>, they're talking about a particular tree (and indirectly, the way the filesystem looked after the 54th commit)."
msgstr "在Subversion，版本库看起来像是一个单独的文件系统，每次提交导致一个新的文件系统；本质上，版本库是一堆树，每棵树都有一个单独的修订版本号。当有人谈论<quote>修订版本54</quote>时，他们是在讨论一个特定的树（并且间接来说，文件系统在提交54次之后的样子）。"

#: build/en/book.xml:25350(para)
msgid "Technically, it's not valid to talk about <quote>revision 5 of <filename moreinfo=\"none\">foo.c</filename></quote>. Instead, one would say <quote><filename moreinfo=\"none\">foo.c</filename> as it appears in revision 5</quote>. Also, be careful when making assumptions about the evolution of a file. In CVS, revisions 5 and 6 of <filename moreinfo=\"none\">foo.c</filename> are always different. In Subversion, it's most likely that <filename moreinfo=\"none\">foo.c</filename> did <emphasis>not</emphasis> change between revisions 5 and 6."
msgstr "技术上讲，谈论<quote>文件<filename moreinfo=\"none\">foo.c</filename>的修订版本5</quote>是不正确的，相反，一个人会说<quote><filename moreinfo=\"none\">foo.c</filename>在修订版本5出现</quote>。同样，我们在假定文件的进展时也要小心，在CVS，文件<filename moreinfo=\"none\">foo.c</filename>的修订版本5和6一定是不同的，在Subversion，<filename moreinfo=\"none\">foo.c</filename>可能在修订版本5和6之间<emphasis>没有</emphasis>改变。"

#: build/en/book.xml:25360(para)
msgid "For more details on this topic, see <xref linkend=\"svn.basic.in-action.revs\"/>."
msgstr "更多细节见<xref linkend=\"svn.basic.in-action.revs\"/>."

#: build/en/book.xml:25368(title)
msgid "Directory Versions"
msgstr "目录的版本"

#: build/en/book.xml:25370(para)
msgid "Subversion tracks tree structures, not just file contents. It's one of the biggest reasons Subversion was written to replace CVS."
msgstr "Subversion会记录目录树的结构，不仅仅是文件的内容。这是编写Subversion替代CVS最重要的一个原因。"

#: build/en/book.xml:25374(para)
msgid "Here's what this means to you, as a former CVS user:"
msgstr "以下是对你这意味着什么的说明，作为一个前CVS用户："

#: build/en/book.xml:25378(para)
msgid "The <command moreinfo=\"none\">svn add</command> and <command moreinfo=\"none\">svn delete</command> commands work on directories now, just as they work on files. So do <command moreinfo=\"none\">svn copy</command> and <command moreinfo=\"none\">svn move</command>. However, these commands do <emphasis>not</emphasis> cause any kind of immediate change in the repository. Instead, the working items are simply <quote>scheduled</quote> for addition or deletion. No repository changes happen until you run <command moreinfo=\"none\">svn commit</command>."
msgstr "<command moreinfo=\"none\">svn add</command>和<command moreinfo=\"none\">svn delete</command>现在也工作在目录上了，就像在文件上一样，还有<command moreinfo=\"none\">svn copy</command>和<command moreinfo=\"none\">svn move</command>也一样。然而，这些命令<emphasis>不</emphasis>会导致版本库即时的变化，相反，工作的项目只是<quote>预定要</quote>添加和删除，在运行<command moreinfo=\"none\">svn commit</command>之前没有版本库的修改。"

#: build/en/book.xml:25389(para)
msgid "Directories aren't dumb containers anymore; they have revision numbers like files. (Or more properly, it's correct to talk about <quote>directory <filename moreinfo=\"none\">foo/</filename> in revision 5</quote>.)"
msgstr "目录不再是哑容器了；它们也有文件一样的修订版本号。（更准确一点，谈论<quote>修订版本5的目录 <filename moreinfo=\"none\">foo/</filename></quote>是正确的。）"

#: build/en/book.xml:25396(para)
msgid "Let's talk more about that last point. Directory versioning is a hard problem; because we want to allow mixed-revision working copies, there are some limitations on how far we can abuse this model."
msgstr "让我们再讨论一下最后一点，目录版本化是一个困难的问题；因为我们希望允许混合修订版本的工作拷贝，有一些防止我们滥用这个模型的限制。"

#: build/en/book.xml:25401(para)
msgid "From a theoretical point of view, we define <quote>revision 5 of directory <filename moreinfo=\"none\">foo</filename></quote> to mean a specific collection of directory-entries and properties. Now suppose we start adding and removing files from <filename moreinfo=\"none\">foo</filename>, and then commit. It would be a lie to say that we still have revision 5 of <filename moreinfo=\"none\">foo</filename>. However, if we bumped <filename moreinfo=\"none\">foo</filename>'s revision number after the commit, that would be a lie too; there may be other changes to <filename moreinfo=\"none\">foo</filename> we haven't yet received, because we haven't updated yet."
msgstr "从理论观点，我们定义<quote>目录<filename moreinfo=\"none\">foo</filename>的修订版本5</quote>意味着一组目录条目和属性。现在假定我们从<filename moreinfo=\"none\">foo</filename>开始添加和删除文件，然后提交。如果说我们还有<filename moreinfo=\"none\">foo</filename>的修订版本5就是一个谎言。然而，如果说我们在提交之后增加了一位<filename moreinfo=\"none\">foo</filename>的修订版本号码，这也是一个谎言；<filename moreinfo=\"none\">foo</filename>还有一些修改我们没有得到，因为我们还没有更新。"

#: build/en/book.xml:25413(para)
msgid "Subversion deals with this problem by quietly tracking committed adds and deletes in the <filename moreinfo=\"none\">.svn</filename> area. When you eventually run <command moreinfo=\"none\">svn update</command>, all accounts are settled with the repository, and the directory's new revision number is set correctly. <emphasis>Therefore, only after an update is it truly safe to say that you have a <quote>perfect</quote> revision of a directory.</emphasis> Most of the time, your working copy will contain <quote>imperfect</quote> directory revisions."
msgstr "Subversion通过在<filename moreinfo=\"none\">.svn</filename>区域偷偷的纪录添加和删除来处理这些问题，当你最后运行<command moreinfo=\"none\">svn update</command>，所有的账目会到版本库结算，并且目录的新修订版本号会正确设置。<emphasis>因此，只有在更新之后才可以真正安全地说我们有了一个<quote>完美的</quote>修订版本目录。</emphasis>在大多数时候，你的工作拷贝会保存<quote>不完美的</quote>目录修订版本。"

#: build/en/book.xml:25423(para)
msgid "Similarly, a problem arises if you attempt to commit property changes on a directory. Normally, the commit would bump the working directory's local revision number. But again, that would be a lie, because there may be adds or deletes that the directory doesn't yet have, because no update has happened. <emphasis>Therefore, you are not allowed to commit property-changes on a directory unless the directory is up-to-date.</emphasis>"
msgstr "同样的，如果你尝试提交目录的属性修改会有一个问题，通常情况下，提交应该会提高工作目录的本地修订版本号，但是再一次，这还是一个谎言，因为这个目录还没有添加和删除发生，因为还没有更新发生。<emphasis>因此，在你的目录不是最新的时候不允许你提交属性修改。</emphasis>"

#: build/en/book.xml:25432(para)
msgid "For more discussion about the limitations of directory versioning, see <xref linkend=\"svn.basic.in-action.mixedrevs\"/>."
msgstr "关于目录版本的更多讨论见<xref linkend=\"svn.basic.in-action.mixedrevs\"/>。"

#: build/en/book.xml:25442(title)
msgid "More Disconnected Operations"
msgstr "更多离线操作"

#: build/en/book.xml:25444(para)
msgid "In recent years, disk space has become outrageously cheap and abundant, but network bandwidth has not. Therefore, the Subversion working copy has been optimized around the scarcer resource."
msgstr "近些年来，磁盘空间变得异常便宜和丰富，但是网络带宽还没有，因此Subversion工作拷贝为紧缺资源进行了优化。"

#: build/en/book.xml:25449(para)
msgid "The <filename moreinfo=\"none\">.svn</filename> administrative directory serves the same purpose as the <filename moreinfo=\"none\">CVS</filename> directory, except that it also stores read-only, <quote>pristine</quote> copies of your files. This allows you to do many things off-line:"
msgstr "<filename moreinfo=\"none\">.svn</filename>管理目录维护者与<filename moreinfo=\"none\">CVS</filename>同样的功能，除了它还保存了只读的文件<quote>原始</quote>拷贝，这允许你做许多离线操作："

#: build/en/book.xml:25460(para)
msgid "Shows you any local changes you've made (see <xref linkend=\"svn.tour.cycle.examine.status\"/>)"
msgstr "显示你所做的本地修改（见<xref linkend=\"svn.tour.cycle.examine.status\"/>）"

#: build/en/book.xml:25467(para)
msgid "Shows you the details of your changes (see <xref linkend=\"svn.tour.cycle.examine.diff\"/>)"
msgstr "显示修改的详细信息（见see <xref linkend=\"svn.tour.cycle.examine.diff\"/>）"

#: build/en/book.xml:25474(para)
#, fuzzy
msgid "Removes your local changes (see <xref linkend=\"svn.tour.cycle.revert\"/>)"
msgstr "删除你的本地修改（见<xref linkend=\"svn.tour.cycle.examine.revert\"/>）"

#: build/en/book.xml:25480(para)
msgid "Also, the cached pristine files allow the Subversion client to send differences when committing, which CVS cannot do."
msgstr "另外，原始文件的缓存允许Subversion客户端在提交时只提交区别，这是CVS做不到的。"

#: build/en/book.xml:25483(para)
msgid "The last subcommand in the list is new; it will not only remove local changes, but it will un-schedule operations such as adds and deletes. It's the preferred way to revert a file; running <command moreinfo=\"none\">rm file; svn update</command> will still work, but it blurs the purpose of updating. And, while we're on this subject…"
msgstr "列表中最后一个子命令是新的；它不仅仅删除本地修改，也会取消如增加和删除的预定操作，这是恢复文件推荐的方式；运行<command moreinfo=\"none\">rm file; svn update</command>还可以工作，但是这样侮辱了更新操作的作用，而且，我们在这个主题…"

#: build/en/book.xml:25498(title)
msgid "Distinction Between Status and Update"
msgstr "区分状态和更新"

#: build/en/book.xml:25500(para)
msgid "In Subversion, we've tried to erase a lot of the confusion between the <command moreinfo=\"none\">cvs status</command> and <command moreinfo=\"none\">cvs update</command> commands."
msgstr "在Subversion，我们已经设法抹去<command moreinfo=\"none\">cvs status</command>和<command moreinfo=\"none\">cvs update</command>之间的混乱。"

#: build/en/book.xml:25504(para)
msgid "The <command moreinfo=\"none\">cvs status</command> command has two purposes: first, to show the user any local modifications in the working copy, and second, to show the user which files are out-of-date. Unfortunately, because of CVS's hard-to-read status output, many CVS users don't take advantage of this command at all. Instead, they've developed a habit of running <command moreinfo=\"none\">cvs update</command> or <command moreinfo=\"none\">cvs -n update</command> to quickly see their changes. If users forget to use the <option>-n</option> option, this has the side effect of merging repository changes they may not be ready to deal with."
msgstr "<command moreinfo=\"none\">cvs status</command>命令有两个目的：第一，显示用户在工作拷贝的所有本地修改，第二，显示给用户哪些文件是最新的。很不幸，因为CVS难以阅读的状态输出，许多CVS用户并没有充分利用这个命令的好处。相反，他们慢慢习惯运行<command moreinfo=\"none\">cvs update</command>或<command moreinfo=\"none\">cvs -n update</command>来快速查看区别，如果用户忘记使用<option>-n</option>选项，副作用就是将还没有准备好处理的版本库修改合并到工作拷贝。"

#: build/en/book.xml:25516(para)
msgid "With Subversion, we've tried to remove this muddle by making the output of <command moreinfo=\"none\">svn status</command> easy to read for both humans and parsers. Also, <command moreinfo=\"none\">svn update</command> only prints information about files that are updated, <emphasis>not</emphasis> local modifications."
msgstr "对于Subversion，我们通过修改<command moreinfo=\"none\">svn status</command>的输出使之同时满足阅读和解析的需要来努力消除这种混乱，同样，<command moreinfo=\"none\">svn update</command>只会打印将要更新的文件信息，而<emphasis>不是</emphasis>本地修改。"

#: build/en/book.xml:25523(title)
msgid "Status"
msgstr "状态"

#: build/en/book.xml:25525(para)
msgid "<command moreinfo=\"none\">svn status</command> prints all files that have local modifications. By default, the repository is not contacted. While this subcommand accepts a fair number of options, the following are the most commonly used ones:"
msgstr "<command moreinfo=\"none\">svn status</command>打印所有本地修改的文件，缺省情况下，不会联系版本库，然而这个命令接受一些选项，如下是一些最常用的："

#: build/en/book.xml:25532(option)
msgid "-u"
msgstr "-u"

#: build/en/book.xml:25534(para)
msgid "Contact the repository to determine, and then display, out-of-dateness information."
msgstr "访问版本库检测并显示过期的信息。"

#: build/en/book.xml:25540(option)
msgid "-v"
msgstr "-v"

#: build/en/book.xml:25542(para)
msgid "Show <emphasis>all</emphasis> entries under version control."
msgstr "显示<emphasis>所有</emphasis>版本控制下的文件。"

#: build/en/book.xml:25548(option)
msgid "-N"
msgstr "-N"

#: build/en/book.xml:25550(para)
msgid "Run non-recursively (do not descend into subdirectories)."
msgstr "非递归方式运行（不会访问子目录）。"

#: build/en/book.xml:25556(para)
msgid "The <command moreinfo=\"none\">status</command> command has two output formats. In the default <quote>short</quote> format, local modifications look like this:"
msgstr "<command moreinfo=\"none\">status</command>命令有两种输出格式，缺省是<quote>短</quote>格式，本地修改像这样："

#: build/en/book.xml:25560(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status\n"
"M      foo.c\n"
"M      bar/baz.c\n"
msgstr ""
"\n"
"$ svn status\n"
"M      foo.c\n"
"M      bar/baz.c\n"

#: build/en/book.xml:25566(para)
msgid "If you specify the <option>--show-updates</option> (<option>-u</option>) switch, a longer output format is used:"
msgstr "如果你指定<option>--show-updates</option>（<option>-u</option>）选项，就会使用较长的格式输出："

#: build/en/book.xml:25570(screen)
#, no-wrap
msgid ""
"\n"
"$ svn status -u\n"
"M            1047   foo.c\n"
"       *     1045   faces.html\n"
"       *            bloo.png\n"
"M            1050   bar/baz.c\n"
"Status against revision:   1066\n"
msgstr ""
"\n"
"$ svn status -u\n"
"M            1047   foo.c\n"
"       *     1045   faces.html\n"
"       *            bloo.png\n"
"M            1050   bar/baz.c\n"
"Status against revision:   1066\n"

#: build/en/book.xml:25579(para)
msgid "In this case, two new columns appear. The second column contains an asterisk if the file or directory is out-of-date. The third column shows the working-copy's revision number of the item. In the example above, the asterisk indicates that <filename moreinfo=\"none\">faces.html</filename> would be patched if we updated, and that <filename moreinfo=\"none\">bloo.png</filename> is a newly added file in the repository. (The absence of any revision number next to <filename moreinfo=\"none\">bloo.png</filename> means that it doesn't yet exist in the working copy.)"
msgstr "在这个例子里，出现了两列，第二列的星号表示了文件或目录是否过期，第三列显示了工作拷贝修订版本号，在上面的例子里，星号表示如果进行更新，<filename moreinfo=\"none\">faces.html</filename>会被合并，而<filename moreinfo=\"none\">bloo.png</filename>则是版本库新加的文件。（<filename moreinfo=\"none\">bloo.png</filename>前面的修订版本号为空表示了这个文件在工作拷贝已经不存在了。）"

#. ###TODO describe -v here as well as -uv. -u and -v use
#.            different <quote>long</quote> formats and need to be
#.            documented separately.  Moreover, as you can combine -u and
#.            -v, it needs to be explained what each of them does.  As -u is
#.            much more important than -v, and the example following that
#.            paragraph *is* about -u, not -v, my patch concentrated on
#.            that.
#: build/en/book.xml:25597(para)
msgid "Lastly, here's a quick summary of the most common status codes that you may see:"
msgstr "最后，下面是大多数你可能看到的最普通状态码的总结："

#: build/en/book.xml:25600(screen)
#, no-wrap
msgid ""
"\n"
"A    Resource is scheduled for Addition\n"
"D    Resource is scheduled for Deletion\n"
"M    Resource has local Modifications\n"
"C    Resource has Conflicts (changes have not been completely merged\n"
"       between the repository and working copy version)\n"
"X    Resource is eXternal to this working copy (may come from another\n"
"       repository).  See <xref linkend=\"svn.advanced.externals\"></xref>\n"
"?    Resource is not under version control\n"
"!    Resource is missing or incomplete (removed by another tool than\n"
"       Subversion)\n"
msgstr ""
"\n"
"A    Resource is scheduled for Addition\n"
"D    Resource is scheduled for Deletion\n"
"M    Resource has local Modifications\n"
"C    Resource has Conflicts (changes have not been completely merged\n"
"       between the repository and working copy version)\n"
"X    Resource is eXternal to this working copy (may come from another\n"
"       repository).  See <xref linkend=\"svn.advanced.externals\"></xref>\n"
"?    Resource is not under version control\n"
"!    Resource is missing or incomplete (removed by another tool than\n"
"       Subversion)\n"

#: build/en/book.xml:25613(para)
msgid "For a more detailed discussion of <command moreinfo=\"none\">svn status</command>, see <xref linkend=\"svn.tour.cycle.examine.status\"/>."
msgstr "关于<command moreinfo=\"none\">svn status</command>的详细讨论，见<xref linkend=\"svn.tour.cycle.examine.status\"/>。"

#: build/en/book.xml:25619(title)
msgid "Update"
msgstr "更新"

#: build/en/book.xml:25621(para)
msgid "<command moreinfo=\"none\">svn update</command> updates your working copy, and only prints information about files that it updates."
msgstr "<command moreinfo=\"none\">svn update</command>会更新你的工作拷贝，只打印这次更新的文件。"

#: build/en/book.xml:25624(para)
msgid "Subversion has combined the CVS <literal moreinfo=\"none\">P</literal> and <literal moreinfo=\"none\">U</literal> codes into just <literal moreinfo=\"none\">U</literal>. When a merge or conflict occurs, Subversion simply prints <literal moreinfo=\"none\">G</literal> or <literal moreinfo=\"none\">C</literal>, rather than a whole sentence about it."
msgstr "Subversion将CVS的<literal moreinfo=\"none\">P</literal>和<literal moreinfo=\"none\">U</literal>合并为<literal moreinfo=\"none\">U</literal>，当合并或冲突发生时，Subversion会简单的打印<literal moreinfo=\"none\">G</literal>或<literal moreinfo=\"none\">C</literal>，而不是大段相关内容。"

#: build/en/book.xml:25630(para)
msgid "For a more detailed discussion of <command moreinfo=\"none\">svn update</command>, see <xref linkend=\"svn.tour.cycle.update\"/>."
msgstr "关于<command moreinfo=\"none\">svn update</command>的详细讨论，见<xref linkend=\"svn.tour.cycle.update\"/>。"

#: build/en/book.xml:25641(title)
msgid "Branches and Tags"
msgstr "分支和标签"

#: build/en/book.xml:25643(para)
msgid "Subversion doesn't distinguish between filesystem space and <quote>branch</quote> space; branches and tags are ordinary directories within the filesystem. This is probably the single biggest mental hurdle a CVS user will need to climb. Read all about it in <xref linkend=\"svn.branchmerge\"/>."
msgstr "Subversion不区分文件系统空间和<quote>分支</quote>空间；分支和标签都是普通的文件系统目录，这恐怕是CVS用户需要逾越的最大心理障碍，所有信息在<xref linkend=\"svn.branchmerge\"/>。"

#: build/en/book.xml:25660(para)
msgid "That is, providing you don't run out of disk space before your checkout finishes."
msgstr "如果在检出完成之前没有消耗完磁盘空间的话。"

#: build/en/book.xml:25651(para)
msgid "Since Subversion treats branches and tags as ordinary directories, always remember to check out the <literal moreinfo=\"none\">trunk</literal> (<literal moreinfo=\"none\">http://svn.example.com/repos/calc/trunk/</literal>) of your project, and not the project itself (<literal moreinfo=\"none\">http://svn.example.com/repos/calc/</literal>). If you make the mistake of checking out the project itself, you'll wind up with a working copy that contains a copy of your project for every branch and tag you have.<placeholder-1/>"
msgstr "因为Subversion把分支和标签看作普通目录看待，一直要记住检出项目的<literal moreinfo=\"none\">trunk</literal>（<literal moreinfo=\"none\">http://svn.example.com/repos/calc/trunk/</literal>），而不是项目本身的（<literal moreinfo=\"none\">http://svn.example.com/repos/calc/</literal>）。如果你错误的检出了项目本身，你会紧张的发现你的项目拷贝包含了所有的分支和标签。<placeholder-1/>"

#: build/en/book.xml:25672(title)
msgid "Metadata Properties"
msgstr "元数据属性"

#: build/en/book.xml:25674(para)
msgid "A new feature of Subversion is that you can attach arbitrary metadata (or <quote>properties</quote>) to files and directories. Properties are arbitrary name/value pairs associated with files and directories in your working copy."
msgstr "Subversion的一个新特性就是你可以对文件和目录任意附加元数据（或者是<quote>属性</quote>），属性是关联在工作拷贝文件或目录的任意名称/值对。"

#: build/en/book.xml:25680(para)
msgid "To set or get a property name, use the <command moreinfo=\"none\">svn propset</command> and <command moreinfo=\"none\">svn propget</command> subcommands. To list all properties on an object, use <command moreinfo=\"none\">svn proplist</command>."
msgstr "为了设置或得到一个属性名称，使用<command moreinfo=\"none\">svn propset</command>和<command moreinfo=\"none\">svn propget</command>子命令，列出对象所有的属性，使用<command moreinfo=\"none\">svn proplist</command>。"

#: build/en/book.xml:25685(para)
msgid "For more information, see <xref linkend=\"svn.advanced.props\"/>."
msgstr "更多信息见<xref linkend=\"svn.advanced.props\"/>。"

#: build/en/book.xml:25693(title)
msgid "Conflict Resolution"
msgstr "解决冲突"

#: build/en/book.xml:25695(para)
msgid "CVS marks conflicts with in-line <quote>conflict markers</quote>, and prints a <literal moreinfo=\"none\">C</literal> during an update. Historically, this has caused problems, because CVS isn't doing enough. Many users forget about (or don't see) the <literal moreinfo=\"none\">C</literal> after it whizzes by on their terminal. They often forget that the conflict-markers are even present, and then accidentally commit files containing conflict-markers."
msgstr "CVS使用内联<quote>冲突标志</quote>来标记冲突，并且在更新时打印<literal moreinfo=\"none\">C</literal>。历史上讲，这导致了许多问题，因为CVS做得还不够。许多用户在它们快速闪过终端时忘记（或没有看到）<literal moreinfo=\"none\">C</literal>，即使出现了冲突标记，他们也经常忘记，然后提交了带有冲突标记的文件。"

#: build/en/book.xml:25704(para)
msgid "Subversion solves this problem by making conflicts more tangible. It remembers that a file is in a state of conflict, and won't allow you to commit your changes until you run <command moreinfo=\"none\">svn resolved</command>. See <xref linkend=\"svn.tour.cycle.resolve\"/> for more details."
msgstr "Subversion通过让冲突更明显来解决这个问题，它记住一个文件是处于冲突状态，在你运行<command moreinfo=\"none\">svn resolved</command>之前不会允许你提交修改，详情见<xref linkend=\"svn.tour.cycle.resolve\"/>。"

#: build/en/book.xml:25714(title)
msgid "Binary Files and Translation"
msgstr "二进制文件和行结束标记转换"

#: build/en/book.xml:25716(para)
msgid "In the most general sense, Subversion handles binary files more gracefully than CVS does. Because CVS uses RCS, it can only store successive full copies of a changing binary file. Subversion, however, expresses differences between files using a binary-differencing algorithm, regardless of whether they contain textual or binary data. That means that all files are stored differentially (compressed) in the repository."
msgstr "在大多数情况下，Subversion比CVS更好的处理二进制文件，因为CVS使用RCS，它只可以存储二进制文件的完整拷贝，但是，Subversion使用二进制区别算法来表示文件的区别，而不管文件是文本文件还是二进制文件。这意味着所有的文件是以微分的（压缩的）形式存放在版本库。"

#: build/en/book.xml:25724(para)
msgid "CVS users have to mark binary files with <option>-kb</option> flags, to prevent data from being garbled (due to keyword expansion and line-ending translations). They sometimes forget to do this."
msgstr "CVS用户需要使用<option>-kb</option>选项来标记二进制文件，防止数据的混淆（因为关键字解释和行结束转化），他们有时候会忘记这样做。"

#: build/en/book.xml:25729(para)
msgid "Subversion takes the more paranoid route—first, it never performs any kind of keyword or line-ending translation unless you explicitly ask it do so (see <xref linkend=\"svn.advanced.props.special.keywords\"/> and <xref linkend=\"svn.advanced.props.special.eol-style\"/> for more details). By default, Subversion treats all file data as literal byte strings, and files are always stored in the repository in an untranslated state."
msgstr "Subversion使用更加异想天开的方法—第一，如果你不明确的告诉它（详情见<xref linkend=\"svn.advanced.props.special.keywords\"/>和<xref linkend=\"svn.advanced.props.special.eol-style\"/>）这样做，它不会做任何关键字或行结束转化的操作，缺省情况下Subversion会把所有的数据看作字节串，所有的储存在版本库的文件都处于未转化的状态。"

#: build/en/book.xml:25736(para)
msgid "Second, Subversion maintains an internal notion of whether a file is <quote>text</quote> or <quote>binary</quote> data, but this notion is <emphasis>only</emphasis> extant in the working copy. During an <command moreinfo=\"none\">svn update</command>, Subversion will perform contextual merges on locally modified text files, but will not attempt to do so for binary files."
msgstr "第二，Subversion维护了一个内部的概念来区别一个文件是<quote>文本</quote>还是<quote>二进制</quote>文件，但这个概念<emphasis>只</emphasis>在工作拷贝非常重要，在<command moreinfo=\"none\">svn update</command>，Subversion会对本地修改的文本文件执行上下文的合并，但是对二进制文件不会。"

#: build/en/book.xml:25743(para)
msgid "To determine whether a contextual merge is possible, Subversion examines the <literal moreinfo=\"none\">svn:mime-type</literal> property. If the file has no <literal moreinfo=\"none\">svn:mime-type</literal> property, or has a mime-type that is textual (e.g. <literal moreinfo=\"none\">text/*</literal>), Subversion assumes it is text. Otherwise, Subversion assumes the file is binary. Subversion also helps users by running a binary-detection algorithm in the <command moreinfo=\"none\">svn import</command> and <command moreinfo=\"none\">svn add</command> commands. These commands will make a good guess and then (possibly) set a binary <literal moreinfo=\"none\">svn:mime-type</literal> property on the file being added. (If Subversion guesses wrong, the user can always remove or hand-edit the property.)"
msgstr "为了检测一个上下文的合并是可能的，Subversion检测<literal moreinfo=\"none\">svn:mime-type</literal>属性，如果没有<literal moreinfo=\"none\">svn:mime-type</literal>属性，或者这个属性是文本的（例如<literal moreinfo=\"none\">text/*</literal>），Subversion会假定它是文本的，否则Subversion认为它是二进制文件。Subversion也会在<command moreinfo=\"none\">svn import</command>和<command moreinfo=\"none\">svn add</command>命令时通过运行一个二进制检测算法来帮助用户。这些命令会做出很好的猜测，然后（如果可能）设置添加文件的<literal moreinfo=\"none\">svn:mime-type</literal>属性。（如果Subversion猜测错误，用户可以删除或手工编辑这个属性。）"

#: build/en/book.xml:25764(title)
msgid "Versioned Modules"
msgstr "版本化的模块"

#: build/en/book.xml:25766(para)
msgid "Unlike CVS, a Subversion working copy is aware that it has checked out a module. That means that if somebody changes the definition of a module (e.g. adds or removes components), then a call to <command moreinfo=\"none\">svn update</command> will update the working copy appropriately, adding and removing components."
msgstr "不像CVS，Subversion工作拷贝会意识到它检出了一个模块，这意味着如果有人修改了模块的定义（例如添加和删除组件），然后一个对<command moreinfo=\"none\">svn update</command>的调用会适当的更新工作拷贝，添加或删除组件。"

#: build/en/book.xml:25772(para)
msgid "Subversion defines modules as a list of directories within a directory property: see <xref linkend=\"svn.advanced.externals\"/>."
msgstr "Subversion定义了模块作为一个目录属性的目录列表：见<xref linkend=\"svn.advanced.externals\"/>。"

#: build/en/book.xml:25782(title)
msgid "Authentication"
msgstr "认证"

#: build/en/book.xml:25784(para)
msgid "With CVS's pserver, you are required to <quote>login</quote> to the server before any read or write operation—you even have to login for anonymous operations. With a Subversion repository using Apache <command moreinfo=\"none\">httpd</command> or <command moreinfo=\"none\">svnserve</command> as the server, you don't provide any authentication credentials at the outset—if an operation that you perform requires authentication, the server will challenge you for your credentials (whether those credentials are username and password, a client certificate, or even both). So if your repository is world-readable, you will not be required to authenticate at all for read operations."
msgstr "通过CVS的pserver，你需要在读写操作之前<quote>登陆</quote>到服务器—即使是匿名操作。Subversion版本库使用Apache的<command moreinfo=\"none\">httpd</command>或<command moreinfo=\"none\">svnserve</command>作为服务器，你不需要开始时提供认证凭证—如果一个操作需要认证，服务器会要求你的凭证（不管这凭证是用户名与密码，客户证书还是两个都有）。所以如果你的工作拷贝是全局可读的，在所有的读操作中不需要任何认证。"

#: build/en/book.xml:25797(para)
msgid "As with CVS, Subversion still caches your credentials on disk (in your <filename moreinfo=\"none\">~/.subversion/auth/</filename> directory) unless you tell it not to by using the <option>--no-auth-cache</option> switch."
msgstr "相对于CVS，Subversion会一直在磁盘（在你的<filename moreinfo=\"none\">~/.subversion/auth/</filename>目录）缓存凭证，除非你通过<option>--no-auth-cache</option>选项告诉它不这样做。"

#: build/en/book.xml:25802(para)
msgid "The exception to this behavior, however, is in the case of accessing an <command moreinfo=\"none\">svnserve</command> server over an SSH tunnel, using the <literal moreinfo=\"none\">svn+ssh://</literal> URL schema. In that case, the <command moreinfo=\"none\">ssh</command> program unconditionally demands authentication just to start the tunnel."
msgstr "这个行为也有例外，当使用SSH管道的<command moreinfo=\"none\">svnserve</command>服务器时，使用<literal moreinfo=\"none\">svn+ssh://</literal>的URL模式这种情况下，<command moreinfo=\"none\">ssh</command>会在通道刚开始时无条件的要求认证。"

#: build/en/book.xml:25815(title)
msgid "Converting a Repository from CVS to Subversion"
msgstr "迁移 CVS 版本库到 Subversion"

#: build/en/book.xml:25817(para)
msgid "Perhaps the most important way to familiarize CVS users with Subversion is to let them continue to work on their projects using the new system. And while that can be somewhat accomplished using a flat import into a Subversion repository of an exported CVS repository, the more thorough solution involves transferring not just the latest snapshot of their data, but all the history behind it as well, from one system to another. This is an extremely difficult problem to solve that involves deducing changesets in the absence of atomicity, and translating between the systems' completely orthogonal branching policies, among other complications. Still, there are a handful of tools claiming to at least partially support the ability to convert existing CVS repositories into Subversion ones."
msgstr "或许让CVS用户熟悉Subversion最好的办法就是让他们的项目继续在新系统下工作，这可以简单得通过平淡的把CVS版本库的导出数据导入到Subversion完成，或者是更加完全的方案，不仅仅包括最新数据快照，还包括所有的历史，从一个系统到另一个系统。这是一个非常困难的问题，包括推导保持原子性的修改集，转化两个系统完全不同的分支政策。但是我们还是有许多工具声称至少部分具备了的转化已存在的CVS版本库为Subversion版本库的能力。"

#: build/en/book.xml:25831(para)
msgid "One such tool is cvs2svn (<ulink url=\"http://cvs2svn.tigris.org/\"/>), a Python script originally created by members of Subversion's own development community. Others include Lev Serebryakov's RefineCVS (<ulink url=\"http://lev.serebryakov.spb.ru/refinecvs/\"/>). These tools have various levels of completeness, and may make entirely different decisions about how to handle your CVS repository history. Whichever tool you decide to use, be sure to perform as much verification as you can stand on the conversion results—after all, you've worked hard to build that history!"
msgstr "其中一个工具是cvs2svn（<ulink url=\"http://cvs2svn.tigris.org/\"/>），是一个Python脚本，最初是Subversion自己的开发社区的成员编写的。其他的如Lev Serebryakov的RefineCVS（<ulink url=\"http://lev.serebryakov.spb.ru/refinecvs/\"/>）。这些工具具备不同程度的完成性，也许会具备完全不同的处理CVS历史的方法。无论你决定使用哪个工具，确定要执行尽可能多的验证来确定你可以接受转化结果—毕竟，你曾经努力创建这些历史！"

#: build/en/book.xml:25843(para)
msgid "For an updated collection of links to known converter tools, visit the Links page of the Subversion website (<ulink url=\"http://subversion.tigris.org/project_links.html\"/>)."
msgstr "关于最新的转化工具链接列表，可以访问Subversion的网站（<ulink url=\"http://subversion.tigris.org/project_links.html\"/>）。"

#: build/en/book.xml:25858(title)
msgid "WebDAV and Autoversioning"
msgstr "WebDAV 和自动版本"

#: build/en/book.xml:25860(para)
msgid "WebDAV is an extension to HTTP, and is growing more and more popular as a standard for file-sharing. Today's operating systems are becoming extremely Web-aware, and many now have built-in support for mounting <quote>shares</quote> exported by WebDAV servers."
msgstr "WebDAV是HTTP的一个扩展，作为一个文件共享的标准不断发展。当今的操作系统变得极端的web化，许多内置了对装配WebDAV服务器导出的<quote>共享</quote>的支持。"

#: build/en/book.xml:25866(para)
#, fuzzy
msgid "If you use Apache as your Subversion network server, then to some extent you are also running a WebDAV server. This appendix gives some background on the nature of this protocol, how Subversion uses it, and how well Subversion interoperates with other software that is WebDAV-aware."
msgstr "如果你使用Apache/mod_dav_svn作为你的Subversion网络服务器，某种程度上，你也是在运行一个WebDAV服务器。这个附录提供了这种协议一些背景知识，Subversion如何使用它，Subversion如何和认识WebDAV的软件交互工作。"

#: build/en/book.xml:25877(title)
msgid "What is WebDAV?"
msgstr "什么是 WebDAV ？"

#: build/en/book.xml:25879(para)
#, fuzzy
msgid "<firstterm>DAV</firstterm> stands for <quote>Distributed Authoring and Versioning</quote>. RFC 2518 defines a set of concepts and accompanying extension methods to HTTP 1.1 that make the web into a more universal read/write medium. The basic idea is that a WebDAV-compliant web server can act like a generic file server; clients can <quote>mount</quote> shared folders over HTTP that behave much like other network filesystems (such as NFS or SMB.)"
msgstr "RFC 2518为HTTP 1.1定义了一组概念和附加扩展方法来把web变成一个更加普遍的读/写媒体，基本思想是一个WebDAV兼容的web服务器可以像普通的文件服务器一样工作；客户端可以装配类似于NFS或SMB的WebDAV共享文件夹。"

#: build/en/book.xml:25888(para)
#, fuzzy
msgid "The tragedy, though, is that despite the acronym, the RFC specification doesn't actually describe any sort of version control. Basic WebDAV clients and servers assume only one version of each file or directory exists, and can be repeatedly overwritten."
msgstr "悲惨的是，WebDAV规范RFC 2518并没有提供任何版本控制模型，尽管DAV中有<quote>V</quote>。基本的DAV客户端和服务器只是假定每个文件或目录只有一个版本存在，可以重复的覆盖。"

#: build/en/book.xml:25894(para)
#, fuzzy
msgid "Because RFC 2518 left out versioning concepts, another committee was left with the responsibility of writing RFC 3253 a few years later. The new RFC adds versioning concepts to WebDAV, placing the <quote>V</quote> back in <quote>DAV</quote> — hence the term <quote>DeltaV</quote>. WebDAV/DeltaV clients and servers are often called just <quote>DeltaV</quote> programs, since DeltaV implies the existence of basic WebDAV."
msgstr "因为RFC 2518漏下了版本概念，另一个委员会留下来负责撰写RFC 3253来添加WebDAV的版本化，也就是<quote>DeltaV</quote>。WebDAV/DeltaV客户端和服务器经常叫做<quote>DeltaV</quote>客户端和服务器，因为DeltaV暗含了基本的WebDAV。"

#: build/en/book.xml:25903(para)
msgid "The original WebDAV standard has been widely successful. Every modern computer operating system has a general WebDAV client built-in (details to follow), and a number of popular standalone applications are also able to speak WebDAV — Microsoft Office, Dreamweaver, and Photoshop to name a few. On the server end, the Apache webserver has been able to provide WebDAV services since 1998 and is considered the de-facto open-source standard. There are several other commercial WebDAV servers available, including Microsoft's own IIS."
msgstr "最初的WebDAV标准得到了广泛的成功，所有的现代操作系统拥有内置的（后面有详细资料）对普通WebDAV的支持，许多流行的应用程序也可以使用WebDAV—Microsoft Office，Dreamweaver和Photoshop。在服务器方面，Apache从1998年就开始支持WebDAV，并被认为是一个事实上的开源标准，也有许多商业的WebDAV服务器，例如Microsoft的IIS。"

#: build/en/book.xml:25913(para)
msgid "DeltaV, unfortunately, has not been so successful. It's very difficult to find any DeltaV clients or servers. The few that do exist are relatively unknown commercial products, and thus it's very difficult to test interoperability. It's not entirely clear as to why DeltaV has remained stagnant. Some argue that the specification is just too complex, others argue that while WebDAV's features have mass appeal (even the least technical users appreciate network file-sharing), version control features aren't interesting or necessary for most users. Finally, some have argued that DeltaV remains unpopular because there's still no open-source server product which implements it."
msgstr "不幸的是，DeltaV没有这样的成功，很难寻找到任何DeltaV客户端和服务器。只有一些不太出名的商业产品，因此很难测试交互性，不清楚为什么DeltaV还这样停滞，一些人说规范太复杂了，还有些人认为尽管DeltaV的特性有很大的吸引力（即使最新的技术用户也喜欢使用网络文件共享），版本控制特性对大多数用户还不是这样有趣和必须。最后，有些人认为DeltaV还这样不流行主要是因为一直没有开源的服务器产品实现它。"

#: build/en/book.xml:25926(para)
#, fuzzy
msgid "When Subversion was still in its design phase, it seemed like a great idea to use Apache as a network server. It already had a module to provide WebDAV services. DeltaV was a relatively new specification. The hope was that the Subversion server module (<command moreinfo=\"none\">mod_dav_svn</command>) would eventually evolve into an open-source DeltaV reference implementation. Unfortunately, DeltaV has a very specific versioning model that doesn't quite line up with Subversion's model. Some concepts were mappable, others were not."
msgstr "当Subversion还在设计阶段时，使用Apache的httpd作为主要网络服务器就是一个很好的想法，已经有了支持WebDAV服务的模块。DeltaV有一个很新的规范，希望就是Subversion服务器模块最终能够成为一个开源的DeltaV参考实现，但非常不幸，DeltaV得版本模型过于详细，与Subversion的模型并不匹配，虽然有些概念可以对应起来，但有些则不能。"

#: build/en/book.xml:25936(para)
msgid "What does this mean, then?"
msgstr ""

#: build/en/book.xml:25938(para)
#, fuzzy
msgid "First, the Subversion client is not a fully-implemented DeltaV client. It needs certain types of things from the server that DeltaV itself cannot provide, and thus is largely dependent on a number of Subversion-specific HTTP <literal moreinfo=\"none\">REPORT</literal> requests that only <command moreinfo=\"none\">mod_dav_svn</command> understands."
msgstr "客户端需要从服务器得到DeltaV不能提供的东西，因此非常依赖于只有mod_dav_svn理解的Subversion特定的<literal moreinfo=\"none\">REPORT</literal>请求。"

#: build/en/book.xml:25945(para)
#, fuzzy
msgid "Second, <command moreinfo=\"none\">mod_dav_svn</command> is not a fully-realized DeltaV server. Many portions of the DeltaV specification were irrelevant to Subversion, and thus left unimplemented."
msgstr "许多与Subversion不相关的DeltaV规范还没有实现。"

#: build/en/book.xml:25950(para)
#, fuzzy
msgid "There is still some debate in the developer community as to whether or not it's worthwhile to remedy either of these situations. It's fairly unrealistic to change Subversion's design to match DeltaV, so there's probably no way the client can ever learn to get everything it needs from a general DeltaV server. On the other hand, <command moreinfo=\"none\">mod_dav_svn</command><emphasis>could</emphasis> be further developed to implement all of DeltaV, but it's hard to find motivation to do so—there are almost no DeltaV clients to interoperate with."
msgstr "在开发者社区一直有这样的讨论，是否值得弥补这种形势。改变Subversion的设计来匹配DeltaV看起来并不值得，所以可能没有办法让客户端从普通的DeltaV服务器上得到所有的东西。另一方面，mod_dav_svn<emphasis>可以</emphasis>继续开发来实现所有的DeltaV，但缺乏这样做的动力—几乎没有能与之交户的DeltaV客户端。"

#: build/en/book.xml:25967(title)
msgid "Autoversioning"
msgstr "自动版本"

#: build/en/book.xml:25969(para)
msgid "While the Subversion client is not a full DeltaV client, nor the Subversion server a full DeltaV server, there's still a glimmer of WebDAV interoperability to be happy about: it's called autoversioning."
msgstr "因为Subversion客户端不是完整的DeltaV客户端，Subversion服务器也不是完整的DeltaV服务器，但仍有值得高兴的交互特性：叫做自动版本化。"

#: build/en/book.xml:25974(para)
#, fuzzy
msgid "Autoversioning is an optional feature defined in the DeltaV standard. A typical DeltaV server will reject an ignorant WebDAV client attempting to do a <literal moreinfo=\"none\">PUT</literal> to a file that's under version control. To change a version-controlled file, the server expects a series proper versioning requests: something like <literal moreinfo=\"none\">MKACTIVITY</literal>, <literal moreinfo=\"none\">CHECKOUT</literal>, <literal moreinfo=\"none\">PUT</literal>, <literal moreinfo=\"none\">CHECKIN</literal>. But if the DeltaV server supports autoversioning, then write-requests from basic WebDAV clients are accepted. The server behaves as if the client <emphasis>had</emphasis> issued the proper series of versioning requests, performing a commit under the hood. In other words, it allows a DeltaV server to interoperate with ordinary WebDAV clients that don't understand versioning."
msgstr "自动版本化是DeltaV标准中的可选特性，一个典型的DeltaV服务器会拒绝一个对版本控制之下文件的<literal moreinfo=\"none\">PUT</literal>操作，为了修改一个版本控制下的文件，服务器只会接受一系列正确的版本请求：例如<literal moreinfo=\"none\">MKACTIVITY</literal>、<literal moreinfo=\"none\">CHECKOUT</literal>、<literal moreinfo=\"none\">PUT</literal>和<literal moreinfo=\"none\">CHECKIN</literal>。但是如果DeltaV服务器支持自动版本化，服务器可以在后台假装客户端执行了一些列正确的版本请求，也就是说，DeltaV服务器可以与一个对版本化一无所知的普通WebDAV客户端交互。"

#: build/en/book.xml:25989(para)
msgid "Because so many operating systems already have integrated WebDAV clients, the use case for this feature borders on fantastical: imagine an office of ordinary users running Microsoft Windows or Mac OS. Each user <quote>mounts</quote> the Subversion repository, which appears to be an ordinary network folder. They use the shared folder as they always do: open files, edit them, save them. Meanwhile, the server is automatically versioning everything. Any administrator (or knowledgeable user) can still use a Subversion client to search history and retrieve older versions of data."
msgstr "因为有许多操作系统已经集成了WebDAV客户端，这个特性的用例可能是这样的：假设一个办公室有许多使用Microsoft Windows或Mac OS的普通用户，每个用户<quote>装载</quote>了一个Subversion版本库，看起来就是普通的网络共享文件夹。他们像普通目录一样的操作这个目录：打开文件、编辑它们，保存它们。同时，服务器自动的版本化所有的东西，任何管理员（或有知识的用户）可以一直使用Subversion客户端来查询历史来检索旧版本的数据。"

#: build/en/book.xml:26000(para)
#, fuzzy
msgid "This scenario isn't fiction: it's real and it works, as of Subversion 1.2 and later. To activate autoversioning in <command moreinfo=\"none\">mod_dav_svn</command>, use the <literal moreinfo=\"none\">SVNAutoversioning</literal> directive within the <filename moreinfo=\"none\">httpd.conf</filename> Location block, like so:"
msgstr "这个场景不是小说：对于Subversion 1.2来说，是真实的和有效的。为了激活mod_dav_svn的自动版本化，需要使用<filename moreinfo=\"none\">httpd.conf</filename>中Location区块的<literal moreinfo=\"none\">SVNAutoversioning</literal>指示，例如："

#: build/en/book.xml:26007(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNPath /path/to/repository\n"
"  SVNAutoversioning on\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNPath /path/to/repository\n"
"  SVNAutoversioning on\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:26015(para)
msgid "When SVNAutoversioning is active, write requests from WebDAV clients result in automatic commits. A generic log message is auto-generated and attached to each revision."
msgstr "当激活了SVNAutoversioning，来自WebDAV的客户端请求会导致自动提交，每个修订版本会自动附加一个原始的日志信息。"

#: build/en/book.xml:26019(para)
#, fuzzy
msgid "Before activating this feature, however, understand what you're getting into. WebDAV clients tend to do <emphasis>many</emphasis> write requests, resulting in a huge number of automatically committed revisions. For example, when saving data, many clients will do a <literal moreinfo=\"none\">PUT</literal> of a 0-byte file (as a way of reserving a name) followed by another <literal moreinfo=\"none\">PUT</literal> with the real file data. The single file-write results in two separate commits. Also consider that many applications auto-save every few minutes, resulting in even more commits."
msgstr "然而，在激活这个特性之前，需要理解你做的事情。WebDAV会做许多写请求，导致了产生数量绝大的自动提交修订版本。例如，当保存数据，许多客户端会使用一个<literal moreinfo=\"none\">PUT</literal>一个0字节的文件，然后紧跟一个<literal moreinfo=\"none\">PUT</literal>真实的文件数据。一个单独的文件写操作产生了两个不同的提交。考虑到许多应用程序隔几分钟的自动保存，会产生更多的提交。"

#: build/en/book.xml:26030(para)
msgid "If you have a post-commit hook program that sends email, you may want to disable email generation either altogether, or on certain sections of the repository; it depends on whether you think the influx of emails will still prove to be valuable notifications or not. Also, a smart post-commit hook program can distinguish between a transaction created via autoversioning and one created through a normal <command moreinfo=\"none\">svn commit</command>. The trick is to look for a revision property named <literal moreinfo=\"none\">svn:autoversioned</literal>. If present, the commit was made by a generic WebDAV client."
msgstr "如果你有发送邮件的post-commit钩子程序，例如，你会根据是否有价值来开启和关闭邮件通知，另外，一个聪明的post-commit钩子也应该能够区分自动版本化和<command moreinfo=\"none\">svn commit</command>产生的事务。技巧就是检查修订版本的<literal moreinfo=\"none\">svn:autoversioned</literal>属性，如果有，则提交来自一个原始的WebDAV客户端。"

#: build/en/book.xml:26041(para)
#, fuzzy
msgid "Another feature that may be a useful complement for <literal moreinfo=\"none\">SVNAutoversioning</literal> comes from Apache's <literal moreinfo=\"none\">mod_mime</literal> module. If a WebDAV client adds a new file to the repository, there's no opportunity for the user to set the the <literal moreinfo=\"none\">svn:mime-type</literal> property. This might cause the file to appear as generic icon when viewed within a WebDAV shared folder, not having an association with any application. One remedy is to have a sysadmin (or other Subversion-knowledgeable person) check out a working copy and manually set the <literal moreinfo=\"none\">svn:mime-type</literal> property on necessary files. But there's potentially no end to such cleanup tasks. Instead, you can use the <literal moreinfo=\"none\">ModMimeUsePathInfo</literal> directive in your Subversion <literal moreinfo=\"none\">&lt;Location&gt;</literal> block:"
msgstr "另一个作为<literal moreinfo=\"none\">SVNAutoversioning</literal>特性补充的特性来自Apache的<literal moreinfo=\"none\">mod_mime</literal>模块，如果一个原始的WebDAV客户端在版本库添加了一个新文件，用户就没有机会设置<literal moreinfo=\"none\">svn:mime-type</literal>属性，这会导致使用WebDAV共享目录查看时会看到原始的图标，而没有关联到任何应用。一个补救办法就是让系统管理员（或其他理解Subversion）的人检出一份工作拷贝，然后为需要的文件手动设置<literal moreinfo=\"none\">svn:mime-type</literal>属性，但是这个整理工作永远不会结束，作为替代，你可以在你的Subversion<literal moreinfo=\"none\">&lt;Location&gt;</literal>区使用<literal moreinfo=\"none\">ModMimeUsePathInfo</literal>指示："

#: build/en/book.xml:26057(screen)
#, no-wrap
msgid ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNPath /path/to/repository\n"
"  SVNAutoversioning on\n"
"\n"
"  ModMimeUsePathInfo on\n"
"\n"
"&lt;/Location&gt;\n"
msgstr ""
"\n"
"&lt;Location /repos&gt;\n"
"  DAV svn\n"
"  SVNPath /path/to/repository\n"
"  SVNAutoversioning on\n"
"\n"
"  ModMimeUsePathInfo on\n"
"\n"
"&lt;/Location&gt;\n"

#: build/en/book.xml:26068(para)
#, fuzzy
msgid "This directive allows <literal moreinfo=\"none\">mod_mime</literal> to attempt automatic deduction of the mime-type on new files that enter the repository via autoversioning. The module looks at the file's named extension and possibly the contents as well; if the file matches some common patterns, then the the file's <literal moreinfo=\"none\">svn:mime-type</literal> property will be set automatically."
msgstr "这个指示允许<literal moreinfo=\"none\">mod_mime</literal>在使用自动版本化添加新文件时尝试自动检测新文件的mime-type，这个模块查看文件的扩展名，有可能的话还包括检查内容；如果文件符合某个常用模式，就会自动设置文件的<literal moreinfo=\"none\">svn;mime-type</literal>。"

#: build/en/book.xml:26082(title)
msgid "Client Interoperability"
msgstr "客户端交互性"

#: build/en/book.xml:26084(para)
msgid "All WebDAV clients fall into one of three categories—standalone applications, file-explorer extensions, or filesystem implementations. These categories broadly define the types of WebDAV functionality available to users. <xref linkend=\"svn.webdav.clients.tbl-1\"/> gives our categorization and a quick description of some common pieces of WebDAV-enabled software. More details about these software offerings, as well as their general category, can be found in the sections that follow."
msgstr "所有的WebDAV客户端分为三类—独立应用程序，文件浏览器扩展或文件系统实现，这些分类定义了WebDAV用户可用的功能性。<xref linkend=\"svn.webdav.clients.tbl-1\"/>给WebDAV常见软件进行了分类，并提供了的简短描述。"

#: build/en/book.xml:26095(title)
msgid "Common WebDAV Clients"
msgstr "常用 WebDAV 客户端"

#: build/en/book.xml:26099(entry)
msgid "Software"
msgstr "软件"

#: build/en/book.xml:26100(entry)
msgid "Type"
msgstr "类型"

#: build/en/book.xml:26101(entry)
msgid "Windows"
msgstr "Windows"

#: build/en/book.xml:26102(entry)
msgid "Mac"
msgstr "Mac"

#: build/en/book.xml:26103(entry)
msgid "Linux"
msgstr "Linux"

#: build/en/book.xml:26109(entry)
msgid "Adobe Photoshop"
msgstr "Adobe Photoshop"

#: build/en/book.xml:26110(entry) build/en/book.xml:26119(entry)
#: build/en/book.xml:26128(entry) build/en/book.xml:26172(entry)
#: build/en/book.xml:26181(entry) build/en/book.xml:26224(title)
msgid "Standalone WebDAV applications"
msgstr "独立的 WebDAV 应用程序"

#: build/en/book.xml:26111(entry) build/en/book.xml:26121(entry)
#: build/en/book.xml:26122(entry) build/en/book.xml:26129(entry)
#: build/en/book.xml:26130(entry) build/en/book.xml:26131(entry)
#: build/en/book.xml:26139(entry) build/en/book.xml:26148(entry)
#: build/en/book.xml:26157(entry) build/en/book.xml:26165(entry)
#: build/en/book.xml:26173(entry) build/en/book.xml:26182(entry)
#: build/en/book.xml:26192(entry) build/en/book.xml:26201(entry)
#: build/en/book.xml:26210(entry)
msgid "X"
msgstr "X"

#: build/en/book.xml:26114(entry)
msgid "Image editing software, allowing direct opening from, and writing to, WebDAV URLs"
msgstr "图像编辑软件，允许直接从WebDAV的URL打开文件和修改。"

#: build/en/book.xml:26118(entry)
msgid "Cadaver"
msgstr "Cadaver"

#: build/en/book.xml:26123(entry)
msgid "Command-line WebDAV client supporting file transfer, tree, and locking operations"
msgstr "命令行的WebDAV客户端，支持文件传输，目录树显示和锁定操作"

#: build/en/book.xml:26127(entry)
msgid "DAV Explorer"
msgstr "DAV Explorer"

#: build/en/book.xml:26132(entry)
msgid "Java GUI tool for exploring WebDAV shares"
msgstr "浏览 WebDAV 共享的 Java GUI 工具"

#: build/en/book.xml:26135(entry)
msgid "davfs2"
msgstr "davfs2"

#: build/en/book.xml:26136(entry) build/en/book.xml:26163(entry)
#: build/en/book.xml:26200(entry) build/en/book.xml:26209(entry)
#: build/en/book.xml:26443(title)
msgid "WebDAV filesystem implementation"
msgstr "WebDAV 文件系统实现"

#: build/en/book.xml:26140(entry)
msgid "Linux file system driver that allows you to mount a WebDAV share"
msgstr "Linux 文件系统驱动允许加载 WebDAV 共享"

#: build/en/book.xml:26144(entry)
msgid "GNOME Nautilus"
msgstr "GNOME Nautilus"

#: build/en/book.xml:26145(entry) build/en/book.xml:26154(entry)
#: build/en/book.xml:26191(entry) build/en/book.xml:26314(title)
msgid "File-explorer WebDAV extensions"
msgstr "文件浏览器 WebDAV 扩展"

#: build/en/book.xml:26149(entry) build/en/book.xml:26158(entry)
msgid "GUI file explorer able to perform tree operations on a WebDAV share"
msgstr "GUI文件浏览器，可以对WebDAV共享执行目录树操作"

#: build/en/book.xml:26153(entry)
msgid "KDE Konqueror"
msgstr "KDE Konqueror"

#: build/en/book.xml:26162(entry) build/en/book.xml:26475(title)
msgid "Mac OS X"
msgstr "Mac OS X"

#: build/en/book.xml:26167(entry)
#, fuzzy
msgid "Operating system has built-in support for mounting WebDAV shares."
msgstr "内置可以加载WebDAV到本地功能的操作系统"

#: build/en/book.xml:26171(entry)
msgid "Macromedia Dreamweaver"
msgstr "Macromedia Dreamweaver"

#: build/en/book.xml:26176(entry)
msgid "Web production software able to directly read from and write to WebDAV URLs"
msgstr "Web制作软件，可以直接读写WebDAV的URL"

#: build/en/book.xml:26180(entry)
msgid "Microsoft Office"
msgstr "Microsoft Office"

#: build/en/book.xml:26185(entry)
msgid "Office productivity suite with several components able to directly read from and write to WebDAV URLs"
msgstr "Office上产套件，可以直接读写WebDAV的URL"

#: build/en/book.xml:26190(entry) build/en/book.xml:26330(title)
msgid "Microsoft Web Folders"
msgstr "Microsoft Web 文件夹"

#: build/en/book.xml:26195(entry)
msgid "GUI file explorer program able to perform tree operations on a WebDAV share"
msgstr "Novell NetDrive"

#: build/en/book.xml:26199(entry)
msgid "Novell NetDrive"
msgstr "驱动器映射程序，可以将Windows驱动器加载为远程的WebDAV共享"

#: build/en/book.xml:26204(entry)
msgid "Drive-mapping program for assigning Windows drive letters to a mounted remote WebDAV share"
msgstr "SRT WebDrive"

#: build/en/book.xml:26208(entry)
msgid "SRT WebDrive"
msgstr "文件传输软件，可以将Windows驱动器加载为远程的WebDAV共享"

#: build/en/book.xml:26213(entry)
msgid "File transfer software which, among other things, allows the assignment of Windows drive letters to a mounted remote WebDAV share"
msgstr "一个WebDAV应用就是一个内置WebDAV协议的程序，我们会覆盖大多数支持WebDAV的流行程序。"

#: build/en/book.xml:26226(para)
msgid "A WebDAV application is a program which contains built-in functionality for speaking WebDAV protocols with a WebDAV server. We'll cover some of the most popular programs with this kind of WebDAV support."
msgstr "Microsoft Office，Dreamweaver，Photoshop"

#: build/en/book.xml:26233(title)
msgid "Microsoft Office, Dreamweaver, Photoshop"
msgstr "Microsoft Office，Dreamweaver，Photoshop"

#: build/en/book.xml:26239(para)
msgid "WebDAV support was removed from Microsoft Access for some reason, but exists in the rest of the Office suite."
msgstr "在Windows下，有一些有名的集成WebDAV客户端功能的软件，例如Microsoft's Office、Adobe的Photoshop和Macromedia的Dreamweaver。它们都可以直接打开和保存URL，也可以在编辑时大量的使用WebDAV的锁定。"

#: build/en/book.xml:26235(para)
#, fuzzy
msgid "On Windows, there are several well-known applications that contain integrated WebDAV client functionality, such as Microsoft's Office, <placeholder-1/> Adobe's Photoshop, and Macromedia's Dreamweaver programs. They're able to directly open and save to URLs, and tend to make heavy use of WebDAV locks when editing a file."
msgstr "请注意，尽管这些程序都有Mac OS X版本，但在这个平台并不直接支持。事实上，在Mac OS X上，不允许<guimenu moreinfo=\"none\">File-&gt;Open</guimenu>对话框中出现URL路径。也有可能WebDAV特性是被故意漏掉，因为OS X已经提供了完美的WebDAV文件系统支持。"

#: build/en/book.xml:26247(para)
msgid "Note that while many of these programs also exist for the Mac OS X, they do not appear to support WebDAV directly on that platform. In fact, on Mac OS X, the <guimenu moreinfo=\"none\">File-&gt;Open</guimenu> dialog box doesn't allow one to type a path or URL at all. It's likely that the WebDAV features were deliberately left out of Macintosh versions of these programs, since OS X already provides such excellent low-level filesystem support for WebDAV."
msgstr ""

#: build/en/book.xml:26260(title)
msgid "Cadaver, DAV Explorer"
msgstr "Cadaver，DAV 浏览器"

#: build/en/book.xml:26262(para)
msgid "Cadaver is a bare-bones Unix commandline program for browsing and changing WebDAV shares. Like the Subversion client, it uses the neon HTTP library—not surprisingly, both neon and cadaver are written by the same author. Cadaver is free software (GPL license) and is available at <ulink url=\"http://www.webdav.org/cadaver/\"/>."
msgstr "使用cadaver就像使用命令行的FTP程序，因此它很适合基本的WebDAV调试。它可以以压缩方式上传和下载文件，也会检验属性、拷贝、移动、锁定和解锁文件："

#: build/en/book.xml:26268(para)
msgid "Using cadaver is similar to using a commandline FTP program, and thus it's extremely useful for basic WebDAV debugging. It can be used to upload or download files in a pinch, and also to examine properties, copy, move, lock or unlock files:"
msgstr ""

#: build/en/book.xml:26274(screen)
#, no-wrap
msgid ""
"\n"
"$ cadaver http://host/repos\n"
"dav:/repos/&gt; ls\n"
"Listing collection `/repos/': succeeded.\n"
"Coll: &gt; foobar                                 0  May 10 16:19\n"
"      &gt; playwright.el                       2864  May  4 16:18\n"
"      &gt; proofbypoem.txt                     1461  May  5 15:09\n"
"      &gt; westcoast.jpg                      66737  May  5 15:09\n"
"\n"
"dav:/repos/&gt; put README\n"
"Uploading README to `/repos/README':\n"
"Progress: [=============================&gt;] 100.0% of 357 bytes succeeded.\n"
"\n"
"dav:/repos/&gt; get proofbypoem.txt\n"
"Downloading `/repos/proofbypoem.txt' to proofbypoem.txt:\n"
"Progress: [=============================&gt;] 100.0% of 1461 bytes succeeded.\n"
msgstr ""
"\n"
"$ cadaver http://host/repos\n"
"dav:/repos/&gt; ls\n"
"Listing collection `/repos/': succeeded.\n"
"Coll: &gt; foobar                                 0  May 10 16:19\n"
"      &gt; playwright.el                       2864  May  4 16:18\n"
"      &gt; proofbypoem.txt                     1461  May  5 15:09\n"
"      &gt; westcoast.jpg                      66737  May  5 15:09\n"
"\n"
"dav:/repos/&gt; put README\n"
"Uploading README to `/repos/README':\n"
"Progress: [=============================&gt;] 100.0% of 357 bytes succeeded.\n"
"\n"
"dav:/repos/&gt; get proofbypoem.txt\n"
"Downloading `/repos/proofbypoem.txt' to proofbypoem.txt:\n"
"Progress: [=============================&gt;] 100.0% of 1461 bytes succeeded.\n"

#: build/en/book.xml:26292(para)
#, fuzzy
msgid "DAV Explorer is another standalone WebDAV client, written in Java. It's under a free Apache-like license and is available at <ulink url=\"http://www.ics.uci.edu/~webdav/\"/>. DAV Explorer does everything cadaver does, but has the advantages of being portable and being a more user-friendly GUI application. It's also one of the first clients to support the new WebDAV Access Control Protocol (RFC 3744)."
msgstr "DAV Explorer是另一个独立运行的WebDAV客户端，使用Java编写，有一个类Apache的许可证，网站是<ulink url=\"http://www.ics.uci.edu/~webdav/\"/>。DAV Explorer与cadaver功能差不多，优点可移植，并有一个用户友好的GUI程序。它也是最早的支持WebDAV访问控制协议（RFC 3744）的客户端。"

#: build/en/book.xml:26300(para)
#, fuzzy
msgid "Of course, DAV Explorer's ACL support is useless in this case, since <command moreinfo=\"none\">mod_dav_svn</command> doesn't support it. The fact that both Cadaver and DAV Explorer support some limited DeltaV commands isn't particularly useful either, since they don't allow <literal moreinfo=\"none\">MKACTIVITY</literal> requests. But it's not relevant anyway; we're assuming all of these clients are operating against an autoversioning repository."
msgstr "一些流行的文件浏览器程序支持WebDAV扩展，允许用户浏览DAV共享如同访问本机，并允许基本的目录树操作。例如，Windows的资源管理器可以把WebDAV服务器看作一个<quote>网络位置</quote>，用户可以从桌面托拽文件到这个目录，或者是重命名、拷贝或者删除文件。但是这只是文件浏览器的特性，DAV共享对于普通的应用不可见，所有的DAV操作需要通过浏览器界面完成。"

#: build/en/book.xml:26316(para)
msgid "Some popular file explorer GUI programs support WebDAV extensions which allow a user to browse a DAV share as if it was just another directory on the local computer, and allowing basic tree editing operations on the items in that share. For example, Windows Explorer is able to browse a WebDAV server as a <quote>network place</quote>. Users can drag files to and from the desktop, or can rename, copy, or delete files in the usual way. But because it's only a feature of the file-explorer, the DAV share isn't visible to ordinary applications. All DAV interaction must happen through the explorer interface."
msgstr ""

#: build/en/book.xml:26332(para)
msgid "Microsoft was one of the original backers of the WebDAV specification, and first started shipping a client in Windows 98, known as <quote>Web Folders</quote>. This client was also shipped in Windows NT4 and 2000."
msgstr "Microsoft是WebDAV规范最早的支持者，最早在Windows 98配置客户端，被称作<quote>网络文件夹</quote>，这个客户端在Windows NT4和2000上也存在。"

#: build/en/book.xml:26337(para)
msgid "The original Web Folders client was an extension to Explorer, the main GUI program used to browse filesystems. It works well enough. In Windows 98, the feature might need to be explicitly installed if Web Folders aren't already visible inside <quote>My Computer</quote>. In Windows 2000, simply add a new <quote>network place</quote>, enter the URL, and the WebDAV share will pop up for browsing."
msgstr "最早的Webfolders客户端是浏览器的扩展，主要的浏览文件系统的GUI程序，工作良好。在Windows 98，如果<quote>我的电脑</quote>里没有网络文件夹，这个特性需要明确安装。在Windows 2000，只需要添加一个新的<quote>网络位置</quote>，输入URL，WebDAV共享就会弹出让你浏览。"

#: build/en/book.xml:26345(para)
msgid "With the release of Windows XP, Microsoft started shipping a new implementation of Web Folders, known as the <quote>WebDAV mini-redirector</quote>. The new implementation is a filesystem-level client, allowing WebDAV shares to be mounted as drive letters. Unfortunately, this implementation is incredibly buggy. The client usually tries to convert http URLs (<literal moreinfo=\"none\">http://host/repos</literal>) into UNC share notation (<literal moreinfo=\"none\">\\\\host\\repos</literal>); it also often tries to use Windows Domain authentication to respond to basic-auth HTTP challenges, sending usernames as <literal moreinfo=\"none\">HOST\\username</literal>. These interoperability problems are severe and documented in numerous places around the web, to the frustration of many users. Even Greg Stein, the original author of Apache's WebDAV module, recommends against trying to use XP Web Folders against an Apache server."
msgstr "伴随着Windows XP，Microsoft开始了另一种网络文件夹的实现，叫做<quote>WebDAV mini-redirector</quote>，这个新的实现是文件系统级的客户端，允许WebDAV转载到驱动器盘符上。不幸的是，这个实现充满难以相信的bug。客户端经常会尝试把http的URL（<literal moreinfo=\"none\">http://host/repos</literal>）转化为UNC共享符号（<literal moreinfo=\"none\">\\\\host\\repos</literal>），它也经常使用Windows域认证来回应基本的HTTP认证，按照<literal moreinfo=\"none\">HOST\\username</literal>发送用户名。这类互动性问题在网络上大量传播，使大量用户受挫。即使是ApacheWebDAV的作者Greg Stein也建议不要对Apaache服务器使用XP的网络文件夹。"

#: build/en/book.xml:26362(para)
msgid "It turns out that the original <quote>Explorer-only</quote> Web Folders implementation isn't dead in XP, it's just buried. It's still possible to find it by using this technique:"
msgstr "结果是原始的网络文件夹并没有在XP中死掉，只是要被埋葬了。还是有办法适用这个技术："

#: build/en/book.xml:26370(para)
msgid "Go to 'Network Places'."
msgstr "到网络位置。"

#: build/en/book.xml:26374(para)
msgid "Add a new network place."
msgstr "添加一个新的网络位置。"

#: build/en/book.xml:26378(para)
msgid "When prompted, enter the URL of the repository, but <emphasis>include a port number</emphasis> in the URL. For example, <literal moreinfo=\"none\">http://host/repos</literal> would be entered as <literal moreinfo=\"none\">http://host:80/repos</literal> instead."
msgstr "当要求输入，输入版本库的URL，但URL中<emphasis>要包含端口号</emphasis>。例如<literal moreinfo=\"none\">http://host/repos</literal>的输入是<literal moreinfo=\"none\">http://host:80/repos</literal>。"

#: build/en/book.xml:26386(para)
msgid "Respond to any authentication prompts."
msgstr "回应所有的认证请求。"

#: build/en/book.xml:26391(para)
#, fuzzy
msgid "There are a number of other rumored workarounds to the problems, but none of them seem to work on all versions and patchlevels of Windows XP. In our tests, only the previous algorithm seems to work consistently on every system. The general consensus of the WebDAV community is that you should avoid the new Web Folders implementation and use the old one instead, and that if you need a real filesystem-level client for Windows XP, then use a third-party program like WebDrive or NetDrive."
msgstr "有各种解决问题的方法，但好像没有一种能够在各版本和各级别的Windows XP中有效。在我们的测试里，只有上面这种策略在各种系统中有效。WebDAV社区一致认为避免使用新的网络文件夹实现，而使用旧的，如果你希望在Windows XP使用真实的文件系统级的客户端，请使用第三方的程序，例如WebDrive或NetDrive。"

#: build/en/book.xml:26401(para)
msgid "A final tip: if you're attempting to use XP Web Folders, make sure you have the absolute latest version from Microsoft. For example, Microsoft released a bug-fixed version in January 2005, available at <ulink url=\"http://support.microsoft.com/?kbid=892211\"/>. In particular, this release is known to fix a bug whereby browsing a DAV share shows an unexpected infinite recursion."
msgstr "最后一个提示：如果你尝试使用XP的网络文件夹，确定你有Microsoft最新的版本，Microsoft在2005年1月发布了一个问题修正，在<ulink url=\"http://support.microsoft.com/?kbid=892211\"/>，特别的，这个发布是用来修正在访问DAV时发生无限递归的问题。"

#: build/en/book.xml:26414(title)
msgid "Nautilus, Konqueror"
msgstr "Nautilus，Konqueror"

#: build/en/book.xml:26416(para)
#, fuzzy
msgid "Nautilus is the official file manager/browser for the GNOME desktop (<ulink url=\"http://www.gnome.org\"/>), and Konqueror is the manager/browser for the KDE desktop (<ulink url=\"http://www.kde.org\"/>). Both of these applications have an explorer-level WebDAV client built-in, and operate just fine against an autoversioning repository."
msgstr "Nautilus是GNOME桌面（<ulink url=\"http://www.gnome.org\"/>）官方的文件管理/浏览器，KDE桌面（<ulink url=\"http://www.kde.org\"/>）的则是Konqueror。两个应用程序都是浏览器级别的WebDAV客户端，对自动版本化的版本库工作良好。"

#: build/en/book.xml:26422(para)
msgid "In GNOME's Nautilus, from the <guimenu moreinfo=\"none\">File menu</guimenu>, select <guimenuitem moreinfo=\"none\">Open location</guimenuitem> and enter the URL. The repository should then be displayed like any other filesystem."
msgstr "GNOME的Nautilus里，从<guimenu moreinfo=\"none\">File menu</guimenu>选择<guimenuitem moreinfo=\"none\">Open location</guimenuitem>，并且输入URL。版本库就会显示出来，就像其他文件系统。"

#: build/en/book.xml:26427(para)
#, fuzzy
msgid "In KDE's Konqueror, you need to use the <literal moreinfo=\"none\">webdav://</literal> scheme when entering the URL in the location bar. If you enter an <literal moreinfo=\"none\">http://</literal> URL, Konqueror will behave like an ordinary web browser. You'll likely see the generic HTML directory listing produced by <command moreinfo=\"none\">mod_dav_svn</command>. By entering <literal moreinfo=\"none\">webdav://host/repos</literal> instead of <literal moreinfo=\"none\">http://host/repos</literal>, Konqueror becomes a WebDAV client and displays the repository as a filesystem."
msgstr "KDE的Konqueror里你需要在地址栏使用<literal moreinfo=\"none\">webdav://</literal>模式来输入URL，如果你输入<literal moreinfo=\"none\">http://</literal>的URL，Konqueror会像普通的web浏览器。你会看到mod_dav_svn输出的普通HTML目录列表。通过输入<literal moreinfo=\"none\">webdav://host/repos</literal>代替<literal moreinfo=\"none\">http://host/repos</literal>，Konqueror就成为了一个WebDAV客户端，并且按照文件系统的方式显示版本库。"

#: build/en/book.xml:26445(para)
msgid "The WebDAV filesystem implementation is arguably the best sort of WebDAV client. It's implemented as a low-level filesystem module, typically within the operating system's kernel. This means that the DAV share is mounted like any other network filesystem, similar to mounting an NFS share on Unix, or attaching an SMB share as drive-letter in Windows. As a result, this sort of client provides completely transparent read/write WebDAV access to all programs. Applications aren't even aware that WebDAV requests are happening."
msgstr "WebDAV文件系统实现被认为是最佳的WebDAV客户端，它通过低级的文件系统模块实现，通常在操作系统的核心。这意味着DAV共享像网络的其他文件系统一样装载，就像在Unix下面装载NFS，或者是在Windows下装载一个SMB共享。结果就是这种客户端为所有程序提供了对WebDAV得透明访问。"

#: build/en/book.xml:26458(title)
msgid "WebDrive, NetDrive"
msgstr "WebDrive，NetDrive"

#: build/en/book.xml:26460(para)
#, fuzzy
msgid "Both WebDrive and NetDrive are excellent commercial products which allow a WebDAV share to be attached as drive letters in Windows. We've had nothing but success with these products. At the time of writing, WebDrive can be purchased from South River Technologies (<ulink url=\"http://www.southrivertech.com\"/>). NetDrive ships with Netware, is free of charge, and can be found by searching the web for <quote>netdrive.exe</quote>. Though it is freely available online, users are required to have a Netware license. (If any of that sounds odd to you, you're not alone. See this page on Novell's website: <ulink url=\"http://www.novell.com/coolsolutions/qna/999.html\"/>)"
msgstr "WebDrive和NetDrive都是完美的商业产品，允许将WebDAV绑定到Windows的盘符，当我们写作的时候，WebDrive可以从South River Technologies（<ulink url=\"http://www.southrivertech.com\"/>）购买。NetDrive由Netware装运，通过查找<quote>netdrive.exe</quote>就会找到。尽管它可以自由得到，用户还是需要一个Netware许可证。（如果着听起来有点奇怪，你并不孤单，看Novell网站的这个页面：<ulink url=\"http://www.novell.com/coolsolutions/qna/999.html\"/>）"

#: build/en/book.xml:26477(para)
#, fuzzy
msgid "Apple's OS X operating system has an integrated filesystem-level WebDAV client. From the Finder, select the <guimenuitem moreinfo=\"none\">Connect to Server</guimenuitem> item from the <guimenu moreinfo=\"none\">Go menu</guimenu>. Enter a WebDAV URL, and it appears as a disk on the desktop, just like any other mounted volume. You can also mount a WebDAV share from the Darwin terminal by using the <literal moreinfo=\"none\">webdav</literal> filesystem type with the <command moreinfo=\"none\">mount</command> command:"
msgstr "Apple的OS X操作系统是集成的文件系统级的客户端，通过Finder，选择<guimenu moreinfo=\"none\">Go menu</guimenu>的<guimenuitem moreinfo=\"none\">Connect to Server</guimenuitem>条目，输入WebDAV的URL，会在桌面显示一个磁盘，就像其他装载的卷。<placeholder-1/>。"

#: build/en/book.xml:26486(screen)
#, no-wrap
msgid ""
"\n"
"$ mount -t webdav http://svn.example.com/repos/project /some/mountpoint\n"
"$\n"
msgstr ""
"\n"
"$ mount -t webdav http://svn.example.com/repos/project /some/mountpoint\n"
"$\n"

#: build/en/book.xml:26491(para)
#, fuzzy
msgid "Note that if your <command moreinfo=\"none\">mod_dav_svn</command> is older than version 1.2, OS X will refuse to mount the share as read-write; it will appear as read-only. This is because OS X insists on locking support for read-write shares, and the ability to lock files first appeared in Subversion 1.2."
msgstr "注意如果mod_dav_svn是1.2之前的版本，OS X不能按照可读写装载，而是会成为只读。这是因为，OS X坚持要读些共享支持锁定，而锁定文件出现在Subversion 1.2。"

#: build/en/book.xml:26498(para)
msgid "One more word of warning: OS X's WebDAV client can sometimes be overly sensitive to HTTP redirects. If OS X is unable to mount the repository at all, you may need to enable the BrowserMatch directive in the Apache server's <filename moreinfo=\"none\">httpd.conf</filename>:"
msgstr "警告一句话：OS X的WebDAV客户端有时候对HTTP重定向很敏感，如果OS X不能装载版本库，你或许需要开启Apache服务器<filename moreinfo=\"none\">httpd.conf</filename>的BrowserMatch指示："

#: build/en/book.xml:26504(screen)
#, no-wrap
msgid ""
"\n"
"BrowserMatch \"^WebDAVFS/1.[012]\" redirect-carefully\n"
msgstr ""
"\n"
"BrowserMatch \"^WebDAVFS/1.[012]\" redirect-carefully\n"

#: build/en/book.xml:26512(title)
msgid "Linux davfs2"
msgstr "Linux davfs2"

#: build/en/book.xml:26514(para)
msgid "Linux davfs2 is a filesystem module for the Linux kernel, whose development is located at <ulink url=\"http://dav.sourceforge.net/\"/>. Once installed, a WebDAV network share can be mounted with the usual Linux mount command:"
msgstr "Linux davfs2是一个Linux核心的文件系统模块，开发坐落在<ulink url=\"http://dav.sourceforge.net/\"/>。一旦安装，一个WebDAV网络共享可以使用mount命令装载："

#: build/en/book.xml:26519(screen)
#, no-wrap
msgid ""
"\n"
"$ mount.davfs http://host/repos /mnt/dav\n"
msgstr ""
"\n"
"$ mount.davfs http://host/repos /mnt/dav\n"

#: build/en/book.xml:26536(title)
msgid "Third Party Tools"
msgstr "第三方工具"

#: build/en/book.xml:26538(para)
msgid "Subversion's modular design (covered in <xref linkend=\"svn.developer.layerlib\"/>) and the availability of language bindings (as described in <xref linkend=\"svn.developer.usingapi.otherlangs\"/>) make it a likely candidate for use as an extension or backend to other pieces of software. For a listing of many third-party tools that are using Subversion functionality under-the-hood, check out the Links page on the Subversion website (<ulink url=\"http://subversion.tigris.org/project_links.html\"/>)."
msgstr "Subversion的模块设计（在<xref linkend=\"svn.developer.layerlib\"/>讨论过）和语言绑定的能力（在<xref linkend=\"svn.developer.usingapi.otherlangs\"/>描述过）使的我们可以作为扩展和后端支持来替代软件的某些部分，在这个附录里，我们会简略介绍一些使用Subversion功能的第三方的工具。关于更新的信息，可以在Subversion的网站（<ulink url=\"http://subversion.tigris.org/project_links.html\"/>）查看。"

#: build/en/book.xml:26554(title)
msgid "Copyright"
msgstr ""

#: build/en/book.xml:26556(programlisting)
#, no-wrap
msgid ""
"\n"
"\n"
"Copyright (c) 2002-2006\n"
"Ben Collins-Sussman, Brian W. Fitzpatrick, C. Michael Pilato.  \n"
"\n"
"This work is licensed under the Creative Commons Attribution License.\n"
"To view a copy of this license, visit\n"
"http://creativecommons.org/licenses/by/2.0/ or send a letter to\n"
"Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305,\n"
"USA.\n"
"\n"
"A summary of the license is given below, followed by the full legal\n"
"text.\n"
"\n"
"--------------------------------------------------------------------\n"
"\n"
"You are free:\n"
"\n"
"    * to copy, distribute, display, and perform the work\n"
"    * to make derivative works\n"
"    * to make commercial use of the work\n"
"\n"
"Under the following conditions:\n"
"\t\n"
"Attribution. You must give the original author credit.\n"
"\n"
"    * For any reuse or distribution, you must make clear to others the\n"
"      license terms of this work.\n"
"\n"
"    * Any of these conditions can be waived if you get permission from\n"
"      the author.\n"
"\n"
"Your fair use and other rights are in no way affected by the above.\n"
"\n"
"The above is a summary of the full license below.\n"
"\n"
"====================================================================\n"
"\n"
"Creative Commons Legal Code\n"
"Attribution 2.0\n"
"\n"
"CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE\n"
"LEGAL SERVICES. DISTRIBUTION OF THIS LICENSE DOES NOT CREATE AN\n"
"ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS\n"
"INFORMATION ON AN \"AS-IS\" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES\n"
"REGARDING THE INFORMATION PROVIDED, AND DISCLAIMS LIABILITY FOR\n"
"DAMAGES RESULTING FROM ITS USE.\n"
"\n"
"License\n"
"\n"
"THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS\n"
"CREATIVE COMMONS PUBLIC LICENSE (\"CCPL\" OR \"LICENSE\"). THE WORK IS\n"
"PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE\n"
"WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS\n"
"PROHIBITED.\n"
"\n"
"BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND\n"
"AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. THE LICENSOR GRANTS\n"
"YOU THE RIGHTS CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF\n"
"SUCH TERMS AND CONDITIONS.\n"
"\n"
"1. Definitions\n"
"\n"
"   a. \"Collective Work\" means a work, such as a periodical issue,\n"
"      anthology or encyclopedia, in which the Work in its entirety in\n"
"      unmodified form, along with a number of other contributions,\n"
"      constituting separate and independent works in themselves, are\n"
"      assembled into a collective whole. A work that constitutes a\n"
"      Collective Work will not be considered a Derivative Work (as\n"
"      defined below) for the purposes of this License.\n"
"\n"
"   b. \"Derivative Work\" means a work based upon the Work or upon the\n"
"      Work and other pre-existing works, such as a translation,\n"
"      musical arrangement, dramatization, fictionalization, motion\n"
"      picture version, sound recording, art reproduction, abridgment,\n"
"      condensation, or any other form in which the Work may be recast,\n"
"      transformed, or adapted, except that a work that constitutes a\n"
"      Collective Work will not be considered a Derivative Work for the\n"
"      purpose of this License. For the avoidance of doubt, where the\n"
"      Work is a musical composition or sound recording, the\n"
"      synchronization of the Work in timed-relation with a moving\n"
"      image (\"synching\") will be considered a Derivative Work for the\n"
"      purpose of this License.\n"
"\n"
"   c. \"Licensor\" means the individual or entity that offers the Work\n"
"      under the terms of this License.\n"
"\n"
"   d. \"Original Author\" means the individual or entity who created the Work.\n"
"\n"
"   e. \"Work\" means the copyrightable work of authorship offered under\n"
"      the terms of this License.\n"
"\n"
"   f. \"You\" means an individual or entity exercising rights under this\n"
"      License who has not previously violated the terms of this\n"
"      License with respect to the Work, or who has received express\n"
"      permission from the Licensor to exercise rights under this\n"
"      License despite a previous violation.\n"
"\n"
"2. Fair Use Rights. Nothing in this license is intended to reduce,\n"
"   limit, or restrict any rights arising from fair use, first sale or\n"
"   other limitations on the exclusive rights of the copyright owner\n"
"   under copyright law or other applicable laws.\n"
"\n"
"3. License Grant. Subject to the terms and conditions of this License,\n"
"   Licensor hereby grants You a worldwide, royalty-free,\n"
"   non-exclusive, perpetual (for the duration of the applicable\n"
"   copyright) license to exercise the rights in the Work as stated\n"
"   below:\n"
"\n"
"   a. to reproduce the Work, to incorporate the Work into one or more\n"
"      Collective Works, and to reproduce the Work as incorporated in\n"
"      the Collective Works;\n"
"\n"
"   b. to create and reproduce Derivative Works;\n"
"\n"
"   c. to distribute copies or phonorecords of, display publicly,\n"
"      perform publicly, and perform publicly by means of a digital\n"
"      audio transmission the Work including as incorporated in\n"
"      Collective Works;\n"
"\n"
"   d. to distribute copies or phonorecords of, display publicly,\n"
"      perform publicly, and perform publicly by means of a digital\n"
"      audio transmission Derivative Works.\n"
"\n"
"   e.\n"
"\n"
"      For the avoidance of doubt, where the work is a musical composition:\n"
"\n"
"         i. Performance Royalties Under Blanket Licenses. Licensor\n"
"            waives the exclusive right to collect, whether\n"
"            individually or via a performance rights society\n"
"            (e.g. ASCAP, BMI, SESAC), royalties for the public\n"
"            performance or public digital performance (e.g. webcast)\n"
"            of the Work.\n"
"\n"
"        ii. Mechanical Rights and Statutory Royalties. Licensor waives\n"
"            the exclusive right to collect, whether individually or\n"
"            via a music rights agency or designated agent (e.g. Harry\n"
"            Fox Agency), royalties for any phonorecord You create from\n"
"            the Work (\"cover version\") and distribute, subject to the\n"
"            compulsory license created by 17 USC Section 115 of the US\n"
"            Copyright Act (or the equivalent in other jurisdictions).\n"
"\n"
"   f. Webcasting Rights and Statutory Royalties. For the avoidance of\n"
"      doubt, where the Work is a sound recording, Licensor waives the\n"
"      exclusive right to collect, whether individually or via a\n"
"      performance-rights society (e.g. SoundExchange), royalties for\n"
"      the public digital performance (e.g. webcast) of the Work,\n"
"      subject to the compulsory license created by 17 USC Section 114\n"
"      of the US Copyright Act (or the equivalent in other\n"
"      jurisdictions).\n"
"\n"
"The above rights may be exercised in all media and formats whether now\n"
"known or hereafter devised. The above rights include the right to make\n"
"such modifications as are technically necessary to exercise the rights\n"
"in other media and formats. All rights not expressly granted by\n"
"Licensor are hereby reserved.\n"
"\n"
"4. Restrictions.The license granted in Section 3 above is expressly\n"
"   made subject to and limited by the following restrictions:\n"
"\n"
"   a. You may distribute, publicly display, publicly perform, or\n"
"      publicly digitally perform the Work only under the terms of this\n"
"      License, and You must include a copy of, or the Uniform Resource\n"
"      Identifier for, this License with every copy or phonorecord of\n"
"      the Work You distribute, publicly display, publicly perform, or\n"
"      publicly digitally perform. You may not offer or impose any\n"
"      terms on the Work that alter or restrict the terms of this\n"
"      License or the recipients' exercise of the rights granted\n"
"      hereunder. You may not sublicense the Work. You must keep intact\n"
"      all notices that refer to this License and to the disclaimer of\n"
"      warranties. You may not distribute, publicly display, publicly\n"
"      perform, or publicly digitally perform the Work with any\n"
"      technological measures that control access or use of the Work in\n"
"      a manner inconsistent with the terms of this License\n"
"      Agreement. The above applies to the Work as incorporated in a\n"
"      Collective Work, but this does not require the Collective Work\n"
"      apart from the Work itself to be made subject to the terms of\n"
"      this License. If You create a Collective Work, upon notice from\n"
"      any Licensor You must, to the extent practicable, remove from\n"
"      the Collective Work any reference to such Licensor or the\n"
"      Original Author, as requested. If You create a Derivative Work,\n"
"      upon notice from any Licensor You must, to the extent\n"
"      practicable, remove from the Derivative Work any reference to\n"
"      such Licensor or the Original Author, as requested.\n"
"\n"
"   b. If you distribute, publicly display, publicly perform, or\n"
"      publicly digitally perform the Work or any Derivative Works or\n"
"      Collective Works, You must keep intact all copyright notices for\n"
"      the Work and give the Original Author credit reasonable to the\n"
"      medium or means You are utilizing by conveying the name (or\n"
"      pseudonym if applicable) of the Original Author if supplied; the\n"
"      title of the Work if supplied; to the extent reasonably\n"
"      practicable, the Uniform Resource Identifier, if any, that\n"
"      Licensor specifies to be associated with the Work, unless such\n"
"      URI does not refer to the copyright notice or licensing\n"
"      information for the Work; and in the case of a Derivative Work,\n"
"      a credit identifying the use of the Work in the Derivative Work\n"
"      (e.g., \"French translation of the Work by Original Author,\" or\n"
"      \"Screenplay based on original Work by Original Author\"). Such\n"
"      credit may be implemented in any reasonable manner; provided,\n"
"      however, that in the case of a Derivative Work or Collective\n"
"      Work, at a minimum such credit will appear where any other\n"
"      comparable authorship credit appears and in a manner at least as\n"
"      prominent as such other comparable authorship credit.\n"
"\n"
"5. Representations, Warranties and Disclaimer\n"
"\n"
"UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING,\n"
"LICENSOR OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR\n"
"WARRANTIES OF ANY KIND CONCERNING THE WORK, EXPRESS, IMPLIED,\n"
"STATUTORY OR OTHERWISE, INCLUDING, WITHOUT LIMITATION, WARRANTIES OF\n"
"TITLE, MERCHANTIBILITY, FITNESS FOR A PARTICULAR PURPOSE,\n"
"NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY,\n"
"OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT\n"
"DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED\n"
"WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.\n"
"\n"
"6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY\n"
"   APPLICABLE LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY\n"
"   LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE\n"
"   OR EXEMPLARY DAMAGES ARISING OUT OF THIS LICENSE OR THE USE OF THE\n"
"   WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n"
"   DAMAGES.\n"
"\n"
"7. Termination\n"
"\n"
"   a. This License and the rights granted hereunder will terminate\n"
"      automatically upon any breach by You of the terms of this\n"
"      License. Individuals or entities who have received Derivative\n"
"      Works or Collective Works from You under this License, however,\n"
"      will not have their licenses terminated provided such\n"
"      individuals or entities remain in full compliance with those\n"
"      licenses. Sections 1, 2, 5, 6, 7, and 8 will survive any\n"
"      termination of this License.\n"
"\n"
"   b. Subject to the above terms and conditions, the license granted\n"
"      here is perpetual (for the duration of the applicable copyright\n"
"      in the Work). Notwithstanding the above, Licensor reserves the\n"
"      right to release the Work under different license terms or to\n"
"      stop distributing the Work at any time; provided, however that\n"
"      any such election will not serve to withdraw this License (or\n"
"      any other license that has been, or is required to be, granted\n"
"      under the terms of this License), and this License will continue\n"
"      in full force and effect unless terminated as stated above.\n"
"\n"
"8. Miscellaneous\n"
"\n"
"   a. Each time You distribute or publicly digitally perform the Work\n"
"      or a Collective Work, the Licensor offers to the recipient a\n"
"      license to the Work on the same terms and conditions as the\n"
"      license granted to You under this License.\n"
"\n"
"   b. Each time You distribute or publicly digitally perform a\n"
"      Derivative Work, Licensor offers to the recipient a license to\n"
"      the original Work on the same terms and conditions as the\n"
"      license granted to You under this License.\n"
"\n"
"   c. If any provision of this License is invalid or unenforceable\n"
"      under applicable law, it shall not affect the validity or\n"
"      enforceability of the remainder of the terms of this License,\n"
"      and without further action by the parties to this agreement,\n"
"      such provision shall be reformed to the minimum extent necessary\n"
"      to make such provision valid and enforceable.\n"
"\n"
"   d. No term or provision of this License shall be deemed waived and\n"
"      no breach consented to unless such waiver or consent shall be in\n"
"      writing and signed by the party to be charged with such waiver\n"
"      or consent.\n"
"\n"
"   e. This License constitutes the entire agreement between the\n"
"      parties with respect to the Work licensed here. There are no\n"
"      understandings, agreements or representations with respect to\n"
"      the Work not specified here. Licensor shall not be bound by any\n"
"      additional provisions that may appear in any communication from\n"
"      You. This License may not be modified without the mutual written\n"
"      agreement of the Licensor and You.\n"
"\n"
"Creative Commons is not a party to this License, and makes no warranty\n"
"whatsoever in connection with the Work. Creative Commons will not be\n"
"liable to You or any party on any legal theory for any damages\n"
"whatsoever, including without limitation any general, special,\n"
"incidental or consequential damages arising in connection to this\n"
"license. Notwithstanding the foregoing two (2) sentences, if Creative\n"
"Commons has expressly identified itself as the Licensor hereunder, it\n"
"shall have all rights and obligations of Licensor.\n"
"\n"
"Except for the limited purpose of indicating to the public that the\n"
"Work is licensed under the CCPL, neither party will use the trademark\n"
"\"Creative Commons\" or any related trademark or logo of Creative\n"
"Commons without the prior written consent of Creative Commons. Any\n"
"permitted use will be in compliance with Creative Commons'\n"
"then-current trademark usage guidelines, as may be published on its\n"
"website or otherwise made available upon request from time to time.\n"
"\n"
"Creative Commons may be contacted at http://creativecommons.org/.\n"
"\n"
"====================================================================\n"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: build/en/book.xml:0(None)
msgid "translator-credits"
msgstr ""
"Dongsheng Song <dongsheng.song@gmail.com>\n"
"Xun Leasun <leasun@gmail.com>\n"
"Daijun Sun <daijun@gmail.com>"
